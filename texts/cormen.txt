 Кормен (Renee Connen).

Предисловие
Как компьютеры решают задачи? Как ваш маленький GPS в считанные секунды на­
ходит самый быстрый пуrь из несметного множества возможных маршруrов? Когда вы
покупаете что-то в Интернете, как обеспечивается защита номера вашей кредитной карты
от перехвата злоумышленником? Оrветом на эти и массу других вопросов являются алго­
ритмы. Я написал эту книгу, чтобы раскрыть вам тайны алгоритмов.
Я - соавтор учебника Алгоритмы: построение и анализ. Это замечательная книга
(конечно, я небеспристрастен), но местами она представляет собой практически научный
труд.
Книга, которую вы держите в своих руках, - совершенно иная. Это даже не учеб­
ник. Она не погружается в алгоритмы достаточно rnубоко, не охватывает их разнообразие
сколь-нибудь широко, не учит методам проектирования компьютерных алгоритмов, и в
ней даже нет задач и упражнений, которые должен решать читатель! Так что же представ­
ляет собой эта книга? Это отправная точка для вас, если вы
• интересуетесь тем, как компьютеры решают поставленные перед ними задачи;
• хотите знать, как оценить качество этих решений;
• хотите понимать, как задачи, решаемые компьютерами, и используемые для этого ме­
тоды связаны с реальным, некомпьютерным миром;
• не очень сильны в математике;
• не написали ни одной программы (впрочем, умение программировать нисколько не
мешает чтению данной книги, даже наоборот).
Некоторые книги о компьютерных алгоритмах концептуальны, с небольшим количе­
ством технических деталей. Некоторые из них переполнены технически точными описа­
ниями. Ряд книг находится между этими крайностями. Для каждого типа книг есть свое
место и свой читатель. Я бы поместил эту книгу в промежуrочную категорию. Да, в ней
есть немного математики, и иногда она довольно глубоко погружается в детали, но я ста­
рался избегать таких мест (за исключением, возможно, конца книги, где я уже просто не
мог контролировать себя).
Я представляю эту книгу своеобразной закуской. Представьте, что вы зашли в ресто­
ран и для начала заказали закуски, решив подождать с основным заказом до тех пор, пока
не справитесь с этой мелочью. Ваш заказ принесен, вы пробуете его. Возможно, еда вам не
понравится, и вы решите уйти из этого ресторана. Возможно, вы уrолите голод одними са­
латиками. А может быть, вам так понравится, что вы закажете официанту обильный обед и
с нетерпением будете его ждать. Рассматривая эту книгу как закуску, я надеюсь, что либо
вы полностью насытитесь ею и сочтете, что достаточно погрузились в мир алгоритмов,
либо прочитанное заинтересует вас настолько, что вы захотите узнать побольше. Каждая
глава заканчивается разделом "Дальнейшее чтение", который подскажет вам, что прочесть
для уrnубленного понимания вопросов.

Предисловие

ff

Чему научит вас эта книга
Я не знаю, чему научит вас эта книга. Я могу только сказать, что именно я постарался
вложить в эту книгу, надеясь, что после ее прочтения вы будете знать следующее.
• Что такое компьютерные алгоритмы, как их описать и оценить.
• Простые способы поиска информации в компьютере.
• Методы переупорядочения информации в компьютере некоторым предопределенным
способом (мы называем эту задачу "сортировка").
• Как решаются базовые задачи, которые можно смоделировать в компьютере с помощью
математической структуры, известной как "граф". Среди множества приложений
графы прекрасно подходят для моделирования дорожных сетей (между какими пере­
крестками есть непосредственно связывающие их дороги и какой они длины?), взаи­
мосвязей между заданиями (какое задание должно предшествовать другим?), финан­
совых отношений (каковы курсы обмена между разными валютами?) или взаимоотно­
шений между людьми (кто с кем знаком? кто кого ненавидит? какой актер снимался
в фильме с некоторым другим актером?).
• Как решаются задачи, в которых участвуют строки текстовых символов. Некоторые из
этих задач находят применение в таких областях, как биология, где символы представ­
ляют собой базовые аминокислоты, а строки символов - структуры ДНК.
• Основные принципы, лежащие в основе криптографии. Даже если вы никогда не шиф­
ровали сообщений сами, ваш компьютер, вероятно, не раз это делал, например при
покупке товаров через Интернет.
• Фундаментальные идеи сжатия данных, выходящие далеко за рамки сокращений, на­
пример, в столь любимых недалекой молодежью смсках.
• Что некоторые задачи слишком трудны, чтобы решить их на компьютере за любое
разумное время (или как минимум никто пока что не нашел способа их решения за
приемлемое время).

Что следует знать для понимания материала книги
Как я говорил ранее, в книге есть немного математики. Если это пугает вас до дрожи
в коленках, можете попробовать пропускать ее или поискать менее техническую книгу.
Но я сделал все возможное, чтобы сделать те крохи математики, которые есть в книге,
доступными для всех.
Я не думаю, что вы никогда не писали и не читали ни одной компьютерной программы.
Если вы в состоянии следовать инструкциям, написанным обычным языком, то должны
быть в состоянии понять, как я выражаю в книге составляющие алгоритм шаги. Если вы
засмеетесь над следующей шуткой, вы на верном пути.

12

Предисловие

Вы слышали о программисте. который застрял в душе? Он' мыл голову и стро­
го следовал инструкции на бутылке шампуня, в которой было написа110 "Намы­
лить. Вспе11ить. Прополоскать. Повторить. "1
В книге я использовал довольно неформальный стиль написания, надеясь, что индиви­
дуальный подход поможет сделать материал более доступным. Некоторые главы зависят
от материала предьщущих глав, но такая зависимость характерна только для некоторых из
них. Ряд глав начинается совершенно не технически, но постепенно принимает все более
технический характер. Если вы обнаружите, что материал одной главы спокойно уклады­
вается в вашей голове, значит, очень велики шансы на то, что вы поймете по крайней мере
начало следующей главы.

Если вы нашли ошибку
Если вы нашли ошибку в книге, сообщите мне о ней электронной почтой по адресу
unlocked@mi t. edu.

Благодарности
Большая часть материала данной книги взята из книги Алгоритмы: построение и ана­
лиз, так что моя первая и самая горячая благодарность - моим соавторам по этой книге
Чарльзу Лейзерсону (Charles Leiserson), Рону Ривесту (Ron Rivest) и Клиффу Штайну (Cliff
Stein). Я так часто ссылаюсь на эту книrу3, что использую в тексте сокращение CLRS - по
первым буквам фамилий авторов. Работа над книгой, которую вы сейчас держите в ру­
ках, ясно показала мне, как мне недостает сотрудничества с Чарльзом, Роном и Клиффом.
Транзитивно я тахже благодарю всех, кого мы благодарили в предисловии к CLRS.
Я также воспользовался мэ:rериалом, который преподавал в Дартмуте, в особенности
на курсах информатики \, 5 и 25. Я благодарен своим студентам, вопросы которых по­
могли мне выработать педагогический подход, понять, что им интересно, и по каменному
молчанию вычислить не заинтересовавшие их темы.
Эта книга написана по предложению Ады Бранштейн (Ada Brunstein), нашеrо редакто­
ра в МIТ Press при подготовке третьего издания CLRS. В настоящее время ее место зани­
мает Джим Де Вольф (Jim DeWolf). Первоначально книга задумывалась как одна из книг
серии МIТ Press "Essential Клowledge" ("Базовые знания"), но, как оказалось, МIТ Press слишком научное издательство для выпуска такой серии. Джим справился с этой неловкой
ситуацией, позволив мне написать то, что хотел бы написэ:rь я сам, а не то, что задумы1 Или она. Политкорректность заставляет написать "она", но соотношение полов в этой об­
ласти деятельности (и опасения, что книгу будут читать феминистки) заставляет написать "он".
1 Бывают ситуации и похуже -один такой программист так и не смог помыть голову, nomawy

что на бутылке была надпись "для сухих волос", а всухую шампунь никак не хотел пениться ... Примеч. пер.

1 Имеется ее перевод 110 русский язык: Т. Кормен, Ч. Лейзерсон. Р Ривест, К. Штайн.
Алгоритмы: построение и анализ, 3-е изд. - М: Издательский дам "Вw,ьямс ", 2013.

Предисловие

13

валось МIТ Press первоначально. Я также высоко ценю поддержку Эллен Фаран (Ellen
Faran) и Гита Деви Манактала (Gita Devi Manaktala) из МIТ Press.
Техническим редактором 2- и 3-ro изданий CLRS была Джули Суссман (Julie Sussman),
и я очень хотел, чтобы она взялась и за эту книгу. Это наилучший технический редактор,
обладающий к тому же наилучшим чувством юмора . Посмотрите сами, какое письмо, по­
священное черновому варианту главы 5, прислала мне Джули.
Власти объявили о розыске сбежавшей главы, которая, как оказалось, скрыв а­
ется в вашей книге. Мы не можем выяснить, из к акой книги она совершила по­
бег, но и не можем представить себе, как она могла бы прятаться в вашей
книге многие месяцы без вашего ведома. Поэтому у нас нет выбора. кроме как
привлечь вас к ответственности. Надеемся. что вы возьмете на себя задачу
перевоспитания данной главы. что даст ей возможность стать продуктивным
гражданином вашей книги. Доклад сотрудника, произведшего арест. - Джули
Суссман - прилагается.

Гуrол спасибо тебе, Джули !
По профессии я далек от криптографии, и в mаве о принципах криптографии ис­
пользовалось множество комментариев и предложений Рона Ривеста (Ron Rivest), Шона
Смита (Sean Smith), Рейчел Миллер (Rachel Miller) и Хиджи Рэйчел Линь (Huijia Rachel
Lin). В этой главе имеется примечание о бейсбольных знаках, и я благодарю Боба Уолена
(ВоЬ Whalen), тренера по бейсболу в Дартмуте, за терпеливое пояснение мне некоторых
систем знаков в бейсболе. Илана Арбиссер (llana ArЬisser) проверила, что вычислитель­
ная биология выравнивает последовательности ДНК именно так, как я пояснил в mаве 7,
"Алгоритмы на строках". Мы с Джимом Де Вольфом (Jim DeWolf) перепробовали множе­
ство названий для нашей книги, но окончательный вариант был предложен дартмутским
студентом Чандером Рамешем (Chander Ramesh).
Факультет информатики колледжа в Дартмуте - удивительное место работы! Мои
коллеги составляют настолько блестящий профессиональный коллектив, что равного ему
не найти. Если вы ищете место для учебы в этой области, я всерьез предлагаю вам поду­
мать о Дартмуте.
Наконец я выражаю благодарности своей жене Николь (Nicole), а также мои родителям
Рени (Renee) и Перри (Perry) Корменам (Cormen) и родителям Николь - Колетт (Colett) и
Полю (Paul) Сейдж (Sage) за их любовь и поддержку. Кстати, мой отец уверен, что рису­
нок на с. 16 изображает цифру 5, а не букву S.

Том КоРмЕн

Ганновер, Ныо-Гзмпшир
Ноябрь2012

1 •..Что такое алrоритмы
и зачем они нужны
Начну с часто задаваемого вопроса "Что такое алгоритм?"
Обобщенный ответ - "набор шагов для выполнения задачи". У вас есть алгоритмы,
которые выполняются в вашей повседневной жизни. Например, алгоритм чистки зубов:
открыть тюбик зубной пасты, взять зубную щетку, выдавливать зубную пасту на щетку до
тех пор, пока не будет достаточно для покрытия щетки, закрыть тюбик, поместить щетку
в один из квадрантов вашего рта, перемещать щетку вверх и вниз N секунд и т.д. Если
вам приходится ездить на работу, у вас, конечно же, имеется алгоритм выбора транспорта
и мест пересадКи. У вас наверняка имеются и многие другие алгоритмы...
Однако данная книга посвящена алгоритмам, выполняемым на компьютерах, или, бо­
лее обобщенно, на вычислительных устройствах. Эти алгоритмы так же влияют на вашу
повседневную жизнь, как и алгоритмы, которые выполняете вы сами. Вы используете GPS
для поиска маршруrа поездки? Работает алгоритм поиска кратчайшего пути. Покупаете
что-то в Интернете? Значит, вы используете (или по крайней мере должны использовать)
защищенный веб-сайт, на котором работает алгоритм шифрования. Когда вы делаете по­
купки в Интернете, они доставляются службой доставки? Она использует алгоритм рас­
пределения заказов по машинам, а затем определяет порядок, в котором КаждЫЙ водитель
должен доставить пакеты. Алгоритмы работают на компьютерах везде - на вашем ноут­
буке, на серверах, на вашем смартфоне, во встроенных системах (таких, как автомобиль,
микроволновая печь или системы климат-контроля)- абсолютно везде!
В чем же отличие алгоритма, который работает на компьютере, от алгоритма, который
выполняете вы сами? Вы можете стерпеть, если алгоритм описан неточно, но вот ком­
пьютер не столь терпелив. Например, если вы едете на работу, работающий у вас в голове
алгоритм может сказать "если дорога перегружена, выбирай другой маршрут". Вы можете
понять, что значит перегруженная дорога, но компьютеру такие тонкости неизвестны ...
Таким образом, компьютерный алгоритм представляет собой набор шагов для выпол­
нения задачи, описанных достаточно точно для того, чтобы компьютер мог их выполнить.
Если вам приходилось немного программировать на Java, С, С++, Python, Fortran, Mat\ab
или тому подобных языках программирования, то у вас есть некоторое представление о
требуемом уровне точности описания. Если же вы никогда не писали компьютерных про­
грамм, то, возможно, вы прочувствуете этот уровень точности, глядя на то, как я описы­
ва19 алгоритмы в этой книге.
Давайте перейдем к следующему вопросу: ''Чего мы хотим от компьютерного алго­
ритма?" Компьютерные алгоритмы решают вычислительные задачи. С учетом этого от
компьютерного алгоритма требуются две вещи: он должен всегда давать правильное
решение поставленной задачи и при этом эффективно использовать вычислительные
ресурсы. Рассмотрим по очереди оба эти пожелания.

16

Глава/. Что такое алгоритмы и заче.w они нуж-ны

Корректность

Что это означает - "получение правильного решения задачи"? Обычно мы можем
точно определить, что повлечет за собой правильное решение. Например, если ваш GPS
выдает правильное решение задачи поиска наилучшего маршрута для путешествия, то это
будет маршрут, по которому вы доберетесь в желаемый пункт назначения быстрее, чем
при поездке по любому другому маршруту. Возможен поиск маршрута, который имеет
наименьшую возможную длину, или маршрута, который позволит добраться побыстрее и
при этом избежать дорожных сборов. Конечно, информация, которую ваш GPS использу­
ет для определения маршрута, может не соответствовать действительности. Так, с одной
стороны, можно считать, что время прохождения маршрута равно расстоянию, деленному
на максимально разрешенную скорость на данной дороге. Но когда дорога перегруже­
на, а вам надо добраться побыстрее, GPS может дать вам плохой совет. Таким образом,
алгоритм может быть правильным даже при неверных входных данных. Ведь если бы в
описанном случае GPS получил корректные входные данные, предложенный им маршрут
был бы и в самом деле самым быстрым.
Для некоторых задач достаточно сложно - а то и попросту невозможно - сказать,
дает ли алгоритм верное решение задачи. Например, в случае оптического распознавания
показанного на рисунке символа из 11 хб точек какой ответ считать верным - 5 или S?

s

Одни люди видят здесь цифру 5, в то время как другие уверенно утверждают, что это
буква S. И как после этого решить, корректно или некорректно то или иное решение ком­
пьютера? К счастью, в этой книге мы ограничимся компьютерными алгоритмами, которые
имеют распознаваемые решения.
Бывает, однако, что можно считать решением алгоритм, который иногда дает некор­
ректные результаты, если только мы в состоянии контролировать, как часто это проис­
ходит. Хорошим примером является шифрование. Распространенная криптосистема RSA
основана на определении того, что большое число - действительно большое, сотни де­
сятичных знаков - является простым. Если вы писали программы, то, наверное, сумеете
написать и программу проверки, является ли некоторое число п простым. Такая програм­
ма может проверять все числа от 2 до п -1, и если хоть одно из этих чисел является дели­
телем п, то п - составное число. Если между 2 и п -1 нет ни одного делителя п, то число
п - простое. Но если п - длиной в несколько сотен десятичных знаков, то кандидатов в
делители гораздо, гораздо больше, чем самый быстрый компьютер в состоянии проверить
за реальное время. Конечно, можно выполнить определенную оптимизацию, например
не проверять четных кандидатов или ограничиться кандидатами, меньшими, чем J;, (по­
скольку, если d больше J;, и d является делителем п, то п/d меньше J;, и также является
делителем п; следовательно, если п имеет делитель, то он будет найден до достижения
проверкой J;,). Если п имеет сотни десятичных знаков, то хотя J;, и имеет всего лишь
около половины десятичных знаков п, это все равно очень большое число. Хорошая но-

Глава 1. Что такое алгоритмы и зачем они нужны

17

вость зак лючается в том, что имеется алгоритм, который в состоянии быстро определить,
является ли заданное число простым. Плохая новость в том, что этот алгоритм может
делать ошибки. Конкретно - если алгоритм говорит, что некоторое число составное, то
оно, определенно, составное. Но если он говорит, что число простое, то есть небольшой
шанс, что это число на самом деле составное. Но плохая новость плоха не совсем: мы мо­
жем управлять частотой ошибок алгоритма, делая их действительно редкими, например
одна ошибка из 2 so случаев. Это достаточно редко - одна ошибка на миллион миллиардов
случаев, - чтобы данный алгоритм можно было применять в RSA для определения, про­
стое ли данное число.
Корректность - достаточно сложный вопрос в случае другого к ласса алгоритмов, на­
зываемого приближенными алгоритмами. Приближенные алгоритмы применяются к за­
дачам оптимизации, в которых мы хотим найти наилучшее решение в смысле некоторой
количественной меры. Одним из примеров является поиск наиболее быстрого маршрута,
для которого количественная мера представляет собой время поездки. Для некоторых за­
дач нет алгоритма, который мог бы найти оптимальное решение за любое разумное ко­
личество времени, но при этом известен приближенный алгоритм, который за разумное
количество времени может найти решение, которое является почти оптимальным. "Почти
оптимальный" обычно означает, что отличие количественной меры найденного алгорит­
мом приближения от таковой для оптимального решения находится в некоторых извест­
ных пределах. Если мы в состоянии указать эти пределы отличия от оптимального ре­
шения, то можем говорить о том, что корректным решением приближенного алгоритма
является любое решение, которое находится в указанных пределах.

Использование ресурсов
Что означает, что алгоритм эффективно использует вычислительные ресурсы? Об
одном из показателей эффективности мы уже упомянули при обсуждении приближенных
алгоритмов - это время работы алгоритма. Алгоритм, который дает правильное решение,
но требует большого времени для его получения, не имеет практической ценности. Если
бы вашему GPS требовался час, чтобы определить маршрут движения, стали бы вы тра­
тить силы, чтобы его включить? Время является основным показателем эффективности,
который мы используем для оценки алгоритма - конечно, после тоrо, как мы показа­
ли, что алгоритм дает правильное решение. Но это не единственная мера эффективности.
Следует также учитывать, какое количество памяти компьютера требуется алгоритму для
работы, так как иначе может оказаться, что он просто не станет работать из-за недостатка
памяти в вашем компьютере или ином устройстве. Другие возможные ресурсы, которые
мо>i<ет использовать алгоритм, - это сетевые соединения, дисковые операции и пр.
В этой книге, как и в большинстве других, посвященных алгоритмам работ, мы со­
средоточиваемся только на одном ресурсе, а именно - на времени работы алгоритма. Как
же судить о времени работы алгоритма? В отличие от корректности алгоритма, которая не
зависит от конкретного компьютера, выполняющего алгоритм, фактическое время работы
алгоритма зависит от нескольких факторов, внешних по отношению к самому алгоритму:

1В

Глава /. Что такое аqгоритмы и заче:и он/1 нужны

от скорости работы компьютера, языка программирования, на котором реализован алго­
ритм, компилятора или интерпретатора, который переводит программу в выполнимый
код, опыта разрабатывающего программу программиста да и просто от того, чем именно
параллельно выполнению вашей программы занят компьютер. Кроме того, обычно пред­
полагается, что алгоритм выполняется на одном компьютере и все необходимые данные
при этом находятся в оперативной памяти.
Если бы мы оценивали скорость работы алгоритма путем его реализации на конкрет­
ном языке программирования и измерения времени его работы на конкретном компьютере
с конкретными входными данными, то это ничего не говорило бы нам о том, как быстро
алгоритм выполнялся бы с входными данными другого размера (или даже просто с дру­
гими входными данными того же размера). И если бы мы хотели таким образом сравнить
скорости нескольких алгоритмов, нам бы пришлось реализовывать их оба и выполнять
с различными входными данными разных размеров. Так как же все-таки можно оценивать
скорость алгоритма?
Ответ заключается в том, чтобы делать это с помощью объединения двух идей. Во­
первых, мы определяем, как зависит время работы алгоритма от размера его входных дан­
ных. В нашем набившем оскомину примере поиска маршрута имеется некоторое пред­
ставление карты дорог, размер которого зависит от количества перекрестков и количе­
ства дорог, соединяющих эти перекрестки. (Физический размер дорожной сети не имеет
значения, поскольку мы можем охарактеризовать все расстояния числами, а все числа
в компьютере имеют один и тот же размер; так что длина дороги не имеет никакого отно­
шения к размеру входных данных.) В более простом примере поиска заданного элемента
в списке, чтобы определить, есть он там или нет, размером входных данных является ко­
личество элементов в списке.
Во-вторых, нас интересует, как быстро с ростом размера входных данных растет время
работы алгоритма - скорость роста времени работы. В главе 2, "Описание и оценка
компьютерных алгоритмов", мы познакомимся с обозначениями, применяемыми для того,
чтобы охарактеризовать время работы алгоритма. Самое интересное в нашем подходе то,
что нас интересует только доминирующий член функции времени работы алгоритма, и
при этом мы не учитываем коэффициенты. То есть нас интересует только порядок роста
времени работы. Например, предположим, что мы выяснили, что конкретная реализация
конкретного алгоритма поиска в списке из п элементов выполняется за 50n + 125 тактов
процессора. Член 50n доминирует над членом 125 при достаточно больших значениях п начиная с п;?: 3, и это доминирование растет с ростом списка размеров. Таким образом,
при описании времени работы данного алгоритма мы не учитываем член более низкого
порядка 125. Но что может удивить вас по-настоящему. так это то, что мы отбрасыва­
ем и коэффициент 50, таким образом, характеризуя время работы алгоритма просто как
линейно растущее с увеличением размера входных данных. В качестве другого примера
представим, что алгоритму требуется 20п3 + 100п2 + ЗООп + 200 тактов процессора. В этом
случае мы говорим, что его время работы растет с ростом размера входных данных как n3•
Члены меньшего порядка -100п2, ЗООп и 200 - становятся все менее и менее значимыми
с увеличением размера входных данных п.

Глава/. Что такое а�горит.мы и зачем они нужны

19

На практике игнорируемые нами коэффициенты имеют значение. Но они так сильно
зависят от внешних факторов, что вполне возможно, что при сравнении двух алгоритмов,
А и Б, которые имеют один и тот же тот же порядок роста и работают с одинаковыми
входными данными, алгоритм А может выполняться быстрее, чем Б, при некотором кон­
кретном сочетании компьютера, языка программирования, компилятора и программиста,
в то время как при некотором другом сочетании указанных фактором алгоритм Б работает
быстрее, чем алгоритм А. Конечно, если оба алгоритма дают верные решения и алгоритм
А всегда работает вдвое быстрее, чем алгоритм Б, то при прочих равных условиях мы
будем предпочитать работать с алгоритмом А. Но с точки зрения абстрактного сравнения
алгоритмов мы ориентируемся по порядку роста времени работы - безо всяких украше­
ний в виде коэффициентов или членов более низкого порядка.
Последний вопрос, который мы рассмотрим в данной главе, - "Зачем нужны алгорит­
мы? Почему нас, вообще говоря, должна волновать эта тема?" Ответ зависит от того, кем
вы, собственно, являетесь.

Компьютерные алгоритмы для людей, не связанных
с компьютерами
Даже если вы не считаете, что ваша деятельность и повседневная жизнь каким-либо
образом связаны с компьютерами, все равно компьютерные алгоритмы вторгаются в вашу
жизнь. Вы используете GPS? Вы что-то искали в Интернете сегодня? Любая поисковая
система - будь то Google, Bing или Яндекс - использует сложные алгоритмы как для по­
иска в Интернете, так и для решения, в каком порядке представить результаты поиска. Вы
водите современный автомобиль? Его бортовые компьютеры принимают за время поездки
миллионы решений - и все на основе алгоритмов. Я мог бы продолжать, но стоит ли?
Как конечный пользователь алгоритмов вы просто обязаны узнать немного о том, как
мы их проектируем, характеризуем и оцениваем. Я предполагаю, что у вас есть опреде­
ленный интерес к этой теме, иначе вы бы не выбрали эту книгу и не дочитали ее до этой
страницы. Тем лучше! По крайней мере, вам будет о чем поговорить на вечеринке.•

Компьютерные алгоритмы для компьютерщиков
Если же вы - представитель славного племени компьютерщиков, то вам и флаг в
руки! Алгоритмы - столь же важная начинка вашего компьютера, как и все его железки.
Вы можете купить супернавороченный компьютер и попросту выбросить деньги, если на
нем.не будут работать хорошие алгоритмы.
Вот пример, который иллюстрирует важность хороших алгоритмов. В rnaвe 3, "Алго­
ритмы сортировки и поиска", мы встретимся с несколькими различными алгоритмами,
которые сортируют список из п значений в порядке возрастания. Одни из этих алгоритмов
1

Вы :wожете возразить. что апгоритмы - тема для разговоров только в Кремниевой Долине,

но мы, профессора информатики. не против получить приглашения на вечеринку. где не будет
недостатка в таких разговорах.

20

Глава /. Что такое алгоритмы и зачем они нужны
2

имеют время работы, раС'I)'щее как n , у друrих время работы составляет только nlgn.
Что такое lgn? Это логарифм числа п по основанию 2, или log2 n. Ученые в области ин­
форматики используют логарифмы по основанию 2 столь же часто, как математики - на­
туральные логарифмы log, п, для которых они даже придумали специальное обозначение
1n п. Далее, поскольку функция lgп является обратной к экспоненциальной функции, она
0
растет с ростом п очень медленно. Если п = 2', то х = lg n. Например, 2' = 1024, н поэтому
20
lg1024 равен всего лишь 10. Аналогично 2 =1 048 576, так что lg 1 048 576 равен всего
лишь 20, а то, что 230 = 1 073 741824, означает, что \g1 07374 1824 равен 30.
Чтобы пример был более конкретным, рассмотрим два компьютера -А и Б. Компьютер
А более быстрый, и на нем работает алгоритм сортировки, время работы которого с п
2
значениями растет с ростом п как n , а более медленный компьютер Б использует ал­
горитм сортировки, время работы которого с п значениями растет с ростом п как пlg n.
Оба компьютера должны выполнить сортировку множества, состоящего из 1О миллионов
чисел. (Хотя десять миллионов чисел и могут показаться огромным количеством, но если
эти числа представляют собой восьмибайтовые целые числа, то входные данные занима­
ют около 80 Мбайт памяти, что весьма немного даже для старых недорогих лэптопов.)
Предположим, что компьютер А выполняет 10 миллиардов команд в секунду (что быстрее
любого одного последовательного компьютера на момент написания книги), а компьютер
Б - только I О миллионов команд в секунду, так что компьютер А в I ООО раз быстрее ком­
пьютера Б. Чтобы различие стало еще большим, предположим, что код для компьютера
А написан самым лучшим в мире программистом на машинном языке, так что для сорти­
ровки п чисел надо выполнить 2п2 команд. Сортировка же на компьютере Б реализована
программистом-середнячком с помощью языка высокого уровня с неэффективным компи­
лятором, так что в результате получился код, требующий выполнения 50n lg п команд. Для
сортировки десяти миллионов чисел компьютеру А понадобится
7

'j

2 ·(10
команд
--'---'---= 20 ООО С,
10
10 команд/с
т.е. более 5.5 часов, в то время как компьютеру Б потребуется

50 · 107 lg10 7 команд
7

10 команд/с

1163с,

т.е. менее 20 минут. Как видите, использование кода, время работы которого возрастает
медленнее, даже при плохом компиляторе на более медленном компьютере требует бо­
лее чем в 17 раз меньше процессорного времени! Если же нужно выполнить сортировку
100 миллионов чисел, то преимущество n2 -алгоритма перед пlgn-алгоритмом становится
еще более разительным: там, где для первого алгоритма потребуется более 23 дней, второй
алгоритм справится за четыре часа. Общее правило таково: чем больше размер задачи, тем
заметнее преимущество алгоритма со временем работы пlg п.
Несмотря на впечатляющие достижения компьютерной техники мы видим, что об­
щая производительность системы зависит от выбора эффективных алгоритмов ничуть не
меньше, чем от выбора быстрого оборудования или эффективной операционной системы.

Глава 1. Что такое алгоритмы и зачем они ну.жны

21

Такие же быстрые успехи, которые в настоящее время наблюдаются в других компьютер­
ных технологиях, осуществляются и в области алгоритмов.

Дальнейшее чтение
По моему очень предвзятому мнению, наиболее ясным и полезным источником инфор­
мации о компьютерных алгоритмах является книга Алгоритмы: построение и анализ [4).
Я взял из нее большую часть материала для данной книги. CLRS является гораздо более
полным учебником, чем эта книга, но он предполагает, что вы хотя бы немного разбирае­
тесь в программировании и математике. Если вы обнаружите, что математика в этой книге
не вызывает у вас затруднений и вы готовы углубленно изучить ту или иную тему, то вы
не сможете сделать ничего лучшего, чем обратиться к CLRS. (Конечно, это мое личное
скромное мнение.)
Книга Джона Мак-Кормика (John MacConnick) Nine Algorithms That Changed the Future
(девять алгоритмов, изменивших будущее) [14) описывает несколько алгоритмов и свя­
занных с ними вычислительных аспектов, которые влияют на нашу повседневную жизнь.
Книга Мак-Кормика менее технична, чем данная. Если вы обнаружите, что мой подход
в этой книге слишком математичен для вас, я рекомендую вам попробовать почитать кни­
гу Мак-Кормика. Вы должны легко понимать изложенный в ней материал, даже если у вас
гуманитарное образование.
В том маловероятном случае, если CLRS покажется вам слишком разбавленной, вы
можете обратиться к мноrотомнику Дональда Кнута (Donald Кnuth) Искусство програм­
мирования [10-13). Хотя название может навести на мысль, что многотомник посвящен
деталям написания кода, на самом деле в нем содержится блестящий, углубленный анализ
алгоритмов. Но будьте осторожны: материал в Искусстве программирования очень сло­
жен и переполнен серьезнейшей математикой. Кстати, если вам интересно, откуда взя­
лось слово "алгоритм", то Кнут утверждает, что оно является производным от имени "аль
Ховаризми", персидского математика, жившего в IX веке.
Помимо CLRS, имеется масса других отличных книг, посвященных компьютерным ал­
горитмам. В примечаниях к главе 1 CLRS приведен целый их список - к которому, чтобы
сэкономить место здесь, я вас и отсылаю.

2 •.. Описание и оценка компьютерных
алгоритмов
В предыдущей главе вы познакомились со временем работы алгоритмов, в первую оче­
редь - с зависимостью времени работы алгоритма как функцией от размера входных
данных, и с тем, как время рабоrы алгоритма оценивается как порядок роста этой функ­
ции. В этой главе мы немного вернемся к описанию компьютерных алгоритмов. Затем вы
узнаете обозначения, которые используются при описании времени работы алгоритмов.
Завершится эта глава описанием некоторых методов, коrорые используются для проекти­
рования и понимания алгоритмов.

Описание компьютерных алгоритмов
У нас всегда есть возможность описания компьютерного алгоритма в виде выполни­
мой программы на одном из распространенных языков программирования, таком как Java,
С, С++, Python или Fortran. И действительно, некоторые учебники по алгоритмам посту­
пают именно так. Проблема при использовании реальных языков программирования для
описания алгоритмов заключается в том, что при этом можно увязнуrъ в языковых дета­
лях, за этими деревьями не увидев леса самого алгоритма. Другой подход, который мы
приняли в CLRS, использует так называемый "псевдокод", который выmядит мешаниной
из разных машинных языков программирования с естественным человеческим языком.
Если вы когда-либо пользовались реальным языком программирования, вы легко разбе­
ретесь в псевдокоде. Но если вам ни разу не доводилось программировать, то псевдокод с
самого начала может показаться какой-то тайнописью.
Подход, использованный мною в этой книге, заключается в том, что я пытаюсь описы­
вать алгоритмы не для программного или аппаратного обеспечения, а для "нейронного":
серого вещества, располагающегося между ушами. Я также вынужден предположить, что
вы никогда не опускались до написания реальных компьютерных программ, а потому я
не буду даже пытаться описывать алгоритмы с применением какого-либо реального языка
программирования или даже псевдокода. Вместо этого я описываю их обычным челове­
ческим языком, используя по возможности аналогии из реального мира. Если вдруг вы
захотите реализовать описанный мною алгоритм на реальном языке программирования, я
безоговорочно доверяю вам перевод моего описания в выполнимый код.
)5отя я обещал и буду по возможности стараться избегать при описании технических
деталей, все же эта книга об алгоритмах для ко.мпьютеров, так что я вынужден использо­
вать компьютерную терминологию. Например, компьютерные программы содержат про­
цедуры (известные также как функции или методы в реальных языках программирова­
ния), которые указывают, как сделать то или это. Для того чтобы процедура сделала то, для
чего она предназначена, ее нужно вызватr,. Когда мы вызываем процедуру, мы снабжаем
ее входными данными (как правило, по крайней мере одним, но некоторые процедуры

Глава 2. Описание и оценка компьютерных алгоритмов

24

обходятся и без них). Входные данные процедур мы определяем как ntlJНI.Мempw в кру­
глых скобках после имени процедуры. Например, чтобы вычислить квадратный корень
из числа, мы могли бы определить процедуру SQUARE-Rooт(x), на вход которой передается
параметр х. Вызов процедуры может сгенерировать некоторые выходные данные (а может
обойтись и без этого), в зависимости от того, как мы определили процедуру. Если проце­
дура генерирует выходные данные, мы обычно рассматриваем их как нечто, передаваемЬе
назад вызывающему процедуру коду. В компьютерных терминах это описывается как воз­
врат значения процедурой.
Многие программы и алгоритмы работают с массивами данных. Массив группирует
данные одного и того же типа в единую сущность. Вы можете думать о массиве как о
таблице, которая при наличии индекса некоторой записи позволяет получить элемент
массива с указанным индексом. Например, вот таблица первых пяти президентов США.
Индекс Президент
1

2
3
4

5

Джордж Ваwингrон
Джон Адамс
Томас Джефферсон
Джеймс Мэдисон
Джеймс Монро

Например, в этой таблице элемент с индексом 4 - Джеймс Мэдисон. Мы рассматрива­
ем эту таблицу не как пять отдельных объектов, а как единую таблицу с пятью записями.
Массив выглядит аналогично. Индексы в массиве представляют собой последовательные
числа, которые могут начинаться с любого числа, но обычно индексы начинаются с 1 1 •
Имея имя массива и индекс, мы можем объединить их с помощью квадратных скобок для
указания конкретного элемента массива. Например, i-й элемент массива А обозначается
как A[i].
Массивы в компьютере обладают одним важным свойством: обращение к любому эле­
менту массива выполняется за одно и то же время. Когда вы передаете компьютеру индекс
i в массиве, он обращается к i-му элементу так же быстро, как и к первому, независимо от
значения i.
Давайте рассмотрим наш первый алгоритм: поиск определенного значения в массиве.
То есть мы имеем массив и хотим узнать, какая запись в массиве (если таковая имеется)
имеет определенное значение. Чтобы понять, как можно организовать поиск в массиве,
давайте представим массив как длинную полку, полную книг, и предположим, что нам
надо узнать, где на полке находится книга Шолохова. Книги на полке могут быть каким-то
образом упорядочены, например в алфавитном порядке по фамилии автора или в алфа­
витном порядке по названию, или по некоторому внутреннему библиотечному номеру.
А может быть, они стоят так, как на моей полке у меня дома, где в силу моей неорганизо­
ванности книги стоят как попало.
Если вы программируете на Java, С или С++, то ваши массивы начинаются с нулевого
эле.wента. Такое начало индексов с нуля отлично подходит компьютера.w, но люди обычно
предпочитают считать что-то. начиная с единицы.
1

Глава 2. Описание и оценка компьютерных алгоритмов

25

Если вы не можете заранее быть уверены, что кииrи стоят на полке в некотором по­
рядке, как бы вы искали книrу Шолохова? Вот алгоритм, которому следовал бы я. Я бы
начал с левого конца полки и посмотрел на первую книrу. Если это Шолохов, я обнаружил
искомую книrу. В противном случае я бы посмотрел на следующую книrу справа, и если
эта книrа Шолохова, то я обнаружил искомую книrу. Если же нет, то я бы продолжил
идти вправо, просмаrривая книrу за книгой, пока не нашел бы книrу Шолохова или пока
не натолкнулся бы на правую стенку полки (и сделал бы вывод, что на этой полке книrи
Шолохова нет). (В rлаве 3, "Алгоритмы сортировки и поиска", мы узнаем, как искать кни­
ги, если они стоят на полке в определенном порядке.)
Вот как мы можем описать задачу поиска в вычислительной терминологии. Будем рас­
сматривать полку как массив книr. Крайняя слева книrа находится в позиции 1, следую­
щая книrа справа он нее находится в позиции 2, и т.д. Если на полке у нас есть п книr,
то крайняя справа книrа находится в позиции п. Мы хотим найти номер позиции любой
книrи Шолохова на полке.
В качестве обобщенной вычислительной задачи мы получаем массив А (вся книжная
полка, на которой мы ищем интересующую нас книrу) сп элементами (отдельными книга­
ми), и при этом надо выяснить, присутствует ли в массиве А значение х (книrа Шолохова)
Если да, то мы хотим знать индекс i, такой, что A[i] = х (т.е. в i-й позиции на полке стоит
книrа Шолохова). Мы также должны иметь возможность каким-то образом сообщить, что
массив А не содержит элемент х (на полке нет книr Шолохова). Мы не ограничиваем себя
предположением, что х содержится в массиве не более одного раза (возможно, на полке
несколько книr Шолохова), так что если элемент х присутствует в массиве А, он может
встретиться там несколько раз. Все, что мы хотим от алгоритма поиска, - произвольный
индекс, по которому мы найдем элемент х в массиве А. Мы предполагаем, что индексы
массива начинаются с l, так что ero элементами являются элементы с А [ l] по А [п].
Если мы ищем книrу Шолохова, начиная с левого конца полки и проверяя поочередно
все книrи слева направо, такой метод называетсялинейнwм поисклм. В терминах массива
в памяти компьютера мы начинаем с начала массива (первого ero элемента), поочередно
проверяя все ero элементы (A[l], затем А[2], затем А[З] и так далее до А[п]) и записывая
место, rде мы находим х (если мы вообще находим ero).
Приведенная далее процедура LrNEAR-SEлRcн получает три параметра, которые в спец­
ификации разделены запятыми.

Процедура LJNEAR-SEAR.cн(A,n�)
Вход:

• JA: массив.
• п: количество элементов массива А, среди которых выпОЛНJ1ется поиск.
х: искомое значение.

Выход: либо индекс;, дл,� котороrо A(i] = х. либо специальное значение NOT·FOUND, ко­
торое может предстаалять собой тобой некорректный индекс массива, такой как О или
произвольное отрицательное значение.

26

Глава 2. Описание и оценка компьютерных аJ12оритмов

1. Установить значение answer равным NOT-FOUND.
2. Для каждого индекса i, пробегающего поочередно значеНШI от 1 до п:
А. Если A[i] = х, установить значение answer равным i.
3. В качестве выходного вернуть значение answer.
В дополнение к параметрам А, пи х процедура LINEAR-SEAR.cн использует переменную
с именем answer. Процедура прис111и111е,п начальное значение NOT-FOUND переменной an­
swer на шаге 1. Шаг 2 проверяет каждую запись массива от А [1] до А [п]. не содержит ли
она значение х. Всякий раз, когда запись A[i] равна х, шаг 2А присваивает переменной
answer текущее значение индекса i. Если х присутствует в массиве, то выходное значение,
возвращаемое на шаге 3, представляет собой последний индекс, где встретился элемент
х. Если же элемент х в массиве отсутствует, то проверка равенства на шаге 2А никогда не
будет истинной, и процедура вернет значение NOT·FOUND, присвоенное переменной answer
на шаге 1.
Прежде чем мы продолжим обсуждение линейного поиска, скажем несколько слов о
том, как описать неоднократные действия, такие как на шаге 2. Такие повторяющиеся дей­
ствия довольно часто встречаются в алгоритмах, например, для выполнения некоторых
действий для переменной, принимающей значения из определенного диапазона. Когда мы
выполняем такие неоднократные действия, это называется циклом, а каждое однократное
выполнение действий - UltU!p11цueii цикла. Описывая цикл на шаге 2, я написал "для каж­
дого индекса ;, пробегающего поочередно значения от 1 доп". Далее вместо такого словес­
ного описания я буду использовать запись "Для i = 1 до п", которая короче, но передает 1У
же струк,уру. Обратите внимание, что, когда я записываю цикл таким образом, перемен­
на цикл11 (в данном случае - 1) получает начальное значение (в данном случае - 1}, и
в каждой итерации цикла значение переменной цикла сравнивается с пределом (в данном
случае- n). Если текущее значение переменной цикла не превышает предел, мы делаем
все, что указано в теле цикла (в данном случае это строка 2А). После выполнения ите­
рации тела цикла выполняется инкремент переменной цикла - т.е. прибавление к ней
1, - после чего выполняется возврат к заголовку цикла, где новое значение переменной
цикла сравнивается с пределом. Проверка значенИJ1 переменной цикла, выполнение его
тела и увеличение значения переменной выполняется многократно, до тех пор, пока зна­
чение переменной цикла не превысит предел. Затем выполнение продолжается с wara,
следующего после тела цикла (в данном случае с шага 3). Цикл вида "для i = 1 до п" вы­
полняет п итераций и п + 1 проверку на превышение значения предела (поскольку значение
переменной цикла превысит предел при ( п + 1�й проверке).
Я надеюсь, для вас очевидно, что процедура LINEAR-SEARCH всегда возвращает правиль­
ный ответ. Но вы могли заметить, что эта процедура неэффективна: она продолжает по­
иск в массиве даже после тоrо, как индекс i, для которого A[i] = х, уже найден. Вряд ли
вы продолжаете поиск книги на полке после того, как уже нашли ее. Так что мы можем
спроектировать нашу процедуру линейного поиска так, чтобы поиск прекращался, как

Глава 2. Описание и оценка компьютерных алгоритмов

27

только он находит в массиве значение х. Далее мы считаем, что команда возврата значения
немедленно прерывает выполнение процедуры и возвращает указанное значение вызы­
вающему коду.
Лрочедура BEТП.R·LINEAR.·SEAR.cн(A ,п,х)

Вход и sыход: те же, что и в LINl!AR·SEARCН.
J. Дrul i = 1 ДО n:

А. Если А [t) = х, вернуrь значение i в качестве выхода процедуры.
2. Вернуть в ачесnе выходного значение NOТ·FOOND.
Поверите ли вы в это или нет, но линейный поиск можно сделать еще более эффек­
тивным. Заметим, что при каждом выполнении итерации цикла из шага 1 процедура
BEТТER-LINEAR-SEARCH выполняет две проверки: проверка в первой строке для выяснения,
не вышло ли значение переменной цикла за допустимые рамки (т.е. выполняется ли не­
равенство i s; п), и если не вышло, то выполняются очередная итерация цикла и проверка
равенства во второй строке. В терминах поиска на книжной полке эти проверки выглядят
так, как будто бы для каждой книги вы проверяли две вещи - добрались ли вы до конца
полки и не является ли автором следующей книги Шолохов? В случае с полкой особых
неприятностей от того, что вы пройдете немного дальше полки, не будет (конечно, если
только вы не ударитесь о стену), но в случае компьютерной программы обращение к эле­
ментам массива за его концом обычно заканчивается очень плохо. Например, это может
привести к повреждению данных или аварийному завершению программы.
Можно исправить алгоритм так, что вам придется выполнять для каждой книги только
одну проверку. Что если бы вы точно знали, что на полке есть книга Шолохова? Тогда вы
были бы твердо уверены, что найдете ее, так что до конца полки вы никогда не добере­
тесь. Достаточно просто проверять все книги по очереди, пока нс встретитесь с книгой
Шолохова.
Но представим, что вы ищете книгу на чужой полке или на своей, но не помните, на
какую именно полку засунули книги Шолохова - словом, вы не уверены, что на полке
есть требуемая книга. Вот что вы можете сделать в этом случае. Возьмите пустую ко­
робку размером с книгу и на узкой ее стороне (имитирующей корешок книги) напишите
"Шолохов. Поднятая целина". Замените крайнюю справа книгу этой коробкой, после чего
при поиске вдоль полки слева направо вам нужно будет проверять только автора книги, но
не то, последняя ли эта книга на полке, потому что теперь вы точно знаете, что найдете
что1то, на чем написано "Шолохов". Единственный вопрос заключается в том, нашли ли
вы настоящую книгу или ее заменитель. Если это заменитель, значит, книги Шолохова
на полке нет. Но такую достаточно простую проверку надо выполнить только один раз, в
конце поиска, а не для каждой книги на полке.
Имеется еще одна деталь, о которой надо упомянуть: что если единственная книга
Шолохова на вашей полке была крайней справа? Если вы заменили ее пустой коробкой,

28

Глава 2. Описание и оценка компьютерных алгоритмов

поиск завершится, когда вы ее найдете, и вы можете ошибочно заключить, что искомой
книги на полке нет. Поэтому следует выполнить еще одну проверку - для выявления
такой возможности. Но :это тоже только одна проверка, не выполняемая для каждой книги
на полке.
В терминах компьютерного алгоритма мы помещаем искомое значение х в последнюю
позицию А [ п] после сохранения содержимого А [ п] в другой переменной. Когда мы наJiо­
днм х, мы выполняем проверку, действительно ли мы ero нашли. Значение, которое мы
помещаем в массив, называется �раничителем, но ero можно рассматривать как пустой
ящик.
Процедура SEN11NEL-LJNEAR-SEARcн(Aдr)

Вход и выход: те же, что и в L1NEAR-SEARcн.
1. Сохранить А[ п] в переменной last и поместип. х в А [п].
2. Установить i равным 1.
3. Пока A[i]"' х, вьmОJiнпь следующие дейсrвюr:

А. Увеличиrь i на 1.
4. В0сстан0ВИ1Ъ А[п) из переменной last.
5. Если i < п или А[п] = х, вернуrь зн811еНИе i в качестве выхода процедуры.
6. В противном случае вернуть в качестве возвращаемоrо значеНШ1 NOT-FOUND.
Шаг 3 представляет собой цикл, но цикл, в котором не происходит увеличения
переменной-счетчика. Вместо :этого итерации цикла выполняются до тех пор, пока вы­
полняется условие цикла; в данном случае это условие А [i] '# х. Цикл работает следую­
щим образом. Сначала выполняется проверка условия цикла (в данном случае-А[i] '# х),
и если оно истинно, то выполняется тело цикла (в данном случае - строка ЗА, которая
увеличивает переменную i на 1 ). Затем выполняется возврат в начало цикла, и, если усло­
вие цикла истинно, снова выполняется тело цикла. И так проверка условия с последую­
щим выполнением тела цикла продолжается до тех пор, пока при очередном выполнении
условие не окажется ложным. Тогда алгоритм продолжается с шага, следующего за телом
цикла (в данном случае - со строки 4).
Процедура SF.NТINEL-LINEAR-SEдRcн оказывается немного более сложной по сравнению
с первыми двумя процедурами линейного поиска. Поскольку она помещает х в А [ п} на
шаге 1, мы гарантируем, что A[i} будет равно х при некоторой проверке на шаге 3. Как
только это произойдет, мы прекращаем выполнение цикла на шаге 3, и индекс i больше
изменяться не будет. Прежде чем мы сделаем что-либо еще, на шаге 4 мы восстанавлива­
ем исходное значение А [п). (Моя мать всегда учила меня, попользовавшись чем-то, поло­
жить все назад, откуда взял.) Затем мы должны определить, действительно ли мы нашли в
массиве х. Поскольку мы поместили х в последний элемент, А [ п), мы знаем, что если мы

Глава 2. Описание и оценка компьютерных алгорит,wов

29

нашли х в A[i], где i < п, то мы действительно нашли х и можно смело возвращать индекс,
хранящийся в переменной i. Но что делать, если мы нашли х в А[ п}? Это означает, что мы
не нашли х до А [п]. так что нам надо проверить, действительно ли А [п] равен х. Если это
так, то мы возвращаем индекс п, который в этом случае равен i, но если А(п] =F х, то сле­
дует возвратить значение NOT-FOUND. Эти проверки выполняются на шаге 5, и, если х изна­
чально находился в массиве, на этом же шаге возвращается корректное значение индекса.
Если же х найден только потому, что это значение было помещено в массив на шаге 1, то
шаг 6 вернет значение NOT-FOUND. Хотя процедура SENTINEL-LINEAR-SEARCH и выполняет две
проверки по окончании цикла. на каждой итерации выполняется только одна проверка,
так что эта процедура оказывается более эффективной, чем процедуры LINEAR-SEлRcн и
BETTER-LINEЛR-SEARCH.

Описание времени работы алгоритма
Вернемся к процедуре L1NEAR-SEARCH на с. 25 и рассмотрим время ее работы. Вспомним,
что мы хотим выразить время работы алгоритма как функцию от размера его входных
данных. В этой процедуре входными данными являются массив А из п элементов, а также
значение п и искомое значение х. Значения п и х не играют никакой роли при достаточно
большом размере массива (в конце концов, п представляет собой всего лишь одно целое
число, ах имеет размер одного элемента массива), так что можно считать, что размер вход­
ных данных равен п, числу элементов в массиве А.
Мы должны сделать несколько простых предположений о том, сколько времени за­
нимают простые операции. Мы будем предполагать, что каждая отдельная операция арифметическая (например, сложения, вычитания, умножения или деления), сравнение,
присваивание значения переменной, индексация элемента массива, вызов процедуры или
возврат из нее - выполняется за некоторое фиксированное время, не зависящее от разме­
ра входных данных 2. Время выполнения может варьироваться от операции к операции, так
что деление может занять больше времени, чем сложение, но когда шаг алгоритма состоит
только из простых операций, каждое отдельное выполнение этого шага занимает некото­
рое постоянное количество времени. Поскольку выполняемые операции выполняются от
шага к шагу, а также по внешним причинам, перечисленным в подразделе "Использование
ресурсов" на с. 17, время выполнения также может отличаться от шага к шагу. Будем счи­
тать, что каждое выполнение шага i требует времени f;, где /1 - некоторые константы, не
зависящие от п.
Конечно, необходимо учитывать, что некоторые шаги выполняются несколько раз.
Например, шаги I и 3 выполняются только один раз, но что можно сказать о шаге 2?
1

1 Если вы не.wного знакаwы с архитектурой реальных компьютеров, то можете знать, что
вре.W11 обращения к. конкретной пере.wенной или эле.wенту массива не обязательно фиксированное,
поскольку может зависеть от того. где находится пере.wенная или эле.wент массива - в кeш­
naWJ1mu, основной оперативной паwяти или в виртуальной памяти на диске. Некоторые сложные
модели ка!\lnьютеров учитывают эти вопросы. но зачастую вполне достаточно считать, что
все пере.wенные и эле.wенты ,wассивов находятся в основной naWJ1mu компьютера и что вpe.wi
обращения к .1ю6аwу из них одинак06().

30

Глава 2. Описание и оценка компьютерных алгоритмов

Мы должны проверять i на равенство п в общей сложности п + 1 раз: п раз выполняется
условие i � п и один раз - i = п+ 1 , и мы выходим из цикла. Шаг 2 выполняется ровно п
раз, по одному разу для каждого из значений i от 1 до п. Мы не знаем заранее, сколько раз
будем присваивать переменной answer значение i; это количество может принимать лю­
бые значения от О (если х нет в массиве) доп раз (если каждый элемент массива равен х).
Если мы собираемся быть предельно точны в нашем подсчете - а обычно мы не буд�м
столь придирчивы, - то должны считать, что на шаге 2 выполняются два разных дей­
ствия, которые выполняются различное количество раз: сравнение i с п выполняется п + 1
раз, но увеличение i выполняется только п раз. Разделим время выполнения строки 2 на
r; для выполнения проверки и r; для увеличения значения i. Аналогично разделим время
выполнения строки 2А на r;м требующееся для проверки A[i] = х, и r;м необходимое для
присваивания переменной answer значения i. Тогда время выполнения процедуры LINEAR­
SEARCH находится где-то между
t1 +t; ·(n+l)+t;·n+t;л ·n+t;.._ ·O+t3
и
t1 +t; ·(n+l)+t;·n+t;л ·n+t;л ·n+t3•
Перепишем теперь эти границы иначе, собирая вместе члены с п, и отдельно - остальные
члены, и при этом сразу станет очевидно, что время выполнения находится между ниж­
ней �оницей
(t; +1;+t;л )·п+{11 +t; +13 )
и верхней границей
(1; + r; + t� +1;л ) ·п+(11 + 1; + t3 ).
Заметим, что обе границы имеют вид с·п + d, где с и d - константы, не зависящие от п.
Время работы процедуры LINEAR-SEARCH ограничено линейной функцией от п как снизу,
так и сверху.
Для обозначения того факта, что время работы ограничено как сверху, так и снизу не­
которыми (возможно, разными) линейными функциями от п, используются специальные
обозначения. Мы записываем, что время работы алгоритма равно 0( п ). Эго греческая бук­
ва тета, и мы произносим эту запись как "тета от п" или просто как "тета п". Как я и обе­
щал в главе 1, "Что такое алгоритмы и зачем они нужны", это обозначение отбрасывает
член меньшего порядка (11 + 1; +13 ) и коэффициенты при п ((1; + r; + r;л ) для нижней грани­
цы и (r; +1; +1;А +1;л ) для верхней границы). Хотя при записи времени работы алгоритма
как 0( п) мы теряем точность, зато получаем преимущество в том, что у нас остается ясно
выраженный порядок роста и отброшены все несущественные детали.
0-обозначения применимы к функциям в общем случае, а не только для описания
времени работы алгоритмов, и применимы не только к линейным функциям. Идея заклю­
чается в том, что если у нас имеются две функции, f ( п) и g ( п ). то мы говорим, что f ( п)
представляет собой 0( g ( п) ), если f ( п) при достаточно больших п отличается от g ( п) на
постоянный множитель. Так что мы можем сказать, что время работы процедуры LINEAR­
SEARCH при достаточно больших п отличается от п на постоянный множительИмеется
пуrающее техническое определение 0-обозначения, но, к счастью, нам редко требуется
обращаться к нему, чтобы использовать 0-обозначения. Мы просто сосредоточиваемся

J:qaвa 2. Описание и оценка каuпьютерных алгоритмов

31

на доминирующем члене, отбрасывая члены более низкого порядка и постоянные множи­
тели. Например, функция п 2 /4+100п+50 представляет собой 0(п2 }; здесь мы опускаем
члены более низкого порядка IOOn и 50, а также постоянный множитель 1/4. Хотя при не­
больших значениях п члены низкого порядка будут превышаrь п2 /4, как только п превысит
2
400, член п2 /4 превысит 100п+50. При п = 1000 доминирующий член п /4 равен 250 000,
в то время как члены более низкого порядка I ООп + 50 равны только 100050; для п = 2000
разница становится еще большей - 1 000000 против 200050. В мире алгоритмов мы не­
много злоупотребляем обозначениями и просто пишем равенство/(п) = 0( g ( п) ), так что
мы можем написаrь п2 4 + 1 ООп+ 50 = 0(п2
Давайте теперь рассмотрим время работы процедуры BEТТER-LINEAR-SEдRCH на с. 27.
от случай немного сложнее процедуры LINEAR-SEлRcн, потому что мы не знаем заранее,
сколько раз будет выполняться итерация цикла. Если A(l) = х, то она будет выполнена
только один раз. Если х в массиве отсутствует, то цикл будет выполняться все максималь­
но возможные п раз. Каждая итерация цикла выполняется за некоторое постоянное вре­
мя, так что мы можем сказать, что в наихудше.w случае процедура BEТТER-LINEAR-SEARCH
требует время 0(п) при поиске в массиве из п элементов. Почему "в наихудшем случае"?
Потому что, поскольку мы хотим, чтобы алгоритмы работали как можно быстрее, наихуд­
ший случай осуществляется, когда время работы алгоритма максимально среди времен
для всех возможных входных данных.
В наилучшем случае, А (1) = х, процедура BETTER-LINEAR-SEдRCH требует только по­
стоянного количества времени: она устанавливает значение переменной i равным 1, про­
веряет, что i � п, убеждается, что выполняется условие A(i] = х, и процедура возвращает
значение i, равное 1. Это количество времени не зависит от п. Мы говорим, что время
работы BETTER-LINEAR-SEлRcн в наилучше.w случае представляет собой 0(1), потому что
в этом случае время работы отличается от I на некоторый постоянный множитель.
Другими словами, время работы в наилучшем случае представляет собой константу, кото­
рая не зависит от п.
Итак, мы видим, что не можем использоваrь 0-обозначения для выражения, охваты­
вающего все варианты времени работы процедуры BEТТER-LINEAR-SEARCH. Мы не можем
сказать, что ее время работы всегда представляет собой 0(п), потому что в наилучшем
случае оно является 0(1). И мы не можем сказаrь, что время работы всегда является 0(1),
потому что в наихудшем случае оно представляет собой 0(п). Однако мы можем сказаrь,
что линейная функция от п - верхняя граница во всех случаях, и у нас есть обозначение
для этого факта - О( п) . Когда мы записываем это обозначение, мы говорим "О большое
от п" или даже просто "о от п". Функция /(п) является O(g(n)), если при достаrочно
боЛЬ!,ОИХ п функция/(п) ограничена сверху g (п ), умноженной на некоторую константу.
Мы вновь немного злоупотребляем обозначениями и используем знак равенства, записы­
вая /(п) = O(g(n)). Для процедуры BEТТER-LINEAR-SEдRcн можно записать, что ее вре­
менем работы во всех случаях является О{ п ); хотя время ее работы может быть лучше
линейной функции п, хуже нее оно никогда не будет.
Мы используем О-обозначения для указания того факта, что время работы никогда не
будет хуже, чем константа, умноженная на некоторую функцию от п. Но как указаrь, что

/

).

32

Глава 2. Описание и оценка компьютерных алгоритмов

время работы никогда не лучше, чем константа, умноженная на некоторую функцию от п?
Это нижняя граница, и мы используем П-обозначения, которые зеркальны О-обозначени­
ям: функция f ( п) представляет собой n(g(п) ), если, когда п становится достаточно боль­
шим, f ( п) ограничена снизу некоторой константой, умноженной на g ( п ). Мы говорим,
что f ( п) представляет собой "омега большое от g(п )" или даже просто "омега от g(п )",
и записываем это как f ( п ) = n(g ( п )). П оскольку О-обозначения дают верхнюю гра$ицу,
О-обозначение дает нижнюю границу, а 0 -обозначение дает и верхнюю, и нижнюю гра­
ницы, можно заключить, что функция f ( п) является 0(g ( п)) тогда и только тогда, когда
f(n) одновременно является и O(g(n)), и П(g(п)).
Мы можем высказать общее утверждение о нижней границе времени работы проце­
дуры BEПER-LINEAR-SEARcн: во всех случаях это П(l). Конечно, это трогательно слабое
утверждение, поскольку любой алгоритм при любых входных данных работает по край­
ней мере какое-то постоянное время. Мы небудем часто обращаться к О-обозначениям, но
иногда они мoryr и пригодиться.
Общим названием для 0-, О- и П-обозначений является 11симптотические о6озн11ченw,. Дело в том, что эти обозначения описывают рост функции при асимптотическом
приближении ее аргумента к бесконечности. Все эти асимптотические обозначения дают
возможность отбросить члены более низкого порядка и константные множители, так что
мы можем игнорировать утомительные детали и сосредоточиться на действительно важ­
ном вопросе - как функция растет с ростом п.
Теперь вернемся к процедуре SENТINEL-LINEAR-SEARCH на с. 28. Так же, как и в случае
процедуры BEПER-LINEAR-SEARCH, каждая итерация цикла выполняется за некоторое по­
стоянное время, и при этом может выполняться от 1 до п итераций. Ключевое различие
между процедурами SENТINEL-LINEAR-SEARcн и BEПER-LINEAR-SEARCH заключается в том,
что время выполнения одной итерации в SENТINEL-LINEAR-SEARCH меньше, чем время вы­
полнения одной итерации в BEТТER-LINEAR-SEARCH. Обе процедуры требуют линейного
времени в наихудшем случае, но постоянный множитель в SENTINEL-LINEAR-SEARCH ока­
зывается лучшим. Хотя мы и ожидаем, что на практике поиск с помощью процедуры
SENТINEL-LINEAR-SEARCH будет быстрее поиска с помощью BEТТER-LINEAR-SEARCH, он будет
быстрее всего лишь на постоянный множитель. Если выразить время работы этих проце­
дур с помощью асимптотических обозначений, мы получим один и тот же результат: 0(п)
в наихудшем случае, 0(1) в наилучшем случае и О(п) во всех случаях.

Инварианты циклов
Для всех трех вариантов линейного поиска легко увидеть, что каждый из них дает пра­
вильный ответ. Зачастую увидеть это немного сложнее. Для этого имеется гораздо больше
методов, чем я могу рассмотреть в этой книге.
Один из распространенных методов показа правильности алгоритма использует иш111ри11нт цикл11: утверждение, для которого мы демонстрируем истинность в начале каждой
итерации цикла. Чтобы инвариант цикла мог помочь доказать корректность алгоритма, мы
должны показать выполнение трех его свойств.

Глава 2. Описание и оценка компьютерных алгоритмов

33

Инициализации. Инвариант цикла истинен перед первой итерацией цикла.
Сохранение. Если инвариант цикла истинен перед итерацией цикла, он остается истин­
ным и после нее.
Завершение. Цикл завершается. а после его завершения инвариант цикла вместе с при­
чиной завершения цикла дают нам искомую цель работы алгоритма.
В качестве примера приведем инвариант цикла для процедуры BEТТER-LJNEAR-SEARCH.
В начале каждой итерации на шаге 1, еслих имеется в массиве А, то он находит­
ся в подмассии (непрерывной части массива) с элементами от A(i] до А[п).
Чтобы показать, что если процедура возвращает индекс, отличный от NOT-FOUND, то этот
индекс корректен, нам даже не нужен инвариант цикла: единственная причина возврата
индекса i на шаге IA- выполнение равенства A[i] = х. Вместо этого давайте воспользу­
емся инвариантом цикла, чтобы показать, что если процедура возвращает на шаге 2 значе­
ние NOT-FOUND, то х в массиве отсутствует.
Инициализации. Изначально i = 1, так что подмассив в инварианте цикла представляет
собой все элементы цикла от А [ 1] до А [ п ]. т.е. весь массив полностью.
Сохранение. Предположим, что в начале итерации для некоторого значения i, если х име­
ется в массиве А, то он присутствует в подмассиве от элемента A[i] до элемента А(п].
Если эта итерация выполняется без возврата значения, то мы знаем, что A[i] � х, и,
следовательно, можем утверждать, что если х присутствует в массиве А, то он нахо­
дится в подмассиве от элемента A[i + 1] до элемента А(п). Поскольку i перед следую­
щей итерацией увеличивается на единицу, инвариант цикла перед очередной итера­
цией будет выполняться.
Завершение. Цикл должен завершаться либо потому, что процедура вернет значение на
шаге I А, либо потому, что выполнится условие i > п. Мы уже рассмотрели случай,
когда цикл завершается из-за возврата значения на шаге I А.
Чтобы разобраться со случаем завершения цикла по условию i > п, рассмотрим обрат­
ную форму утверждения ( его контрапозицию). Контрапозициеи утверждения "если
А, то Б" является утверждение "если не Б, то не А". Контрапозиция истинна тогда
и только тогда, когда истинно исходное утверждение. Контрапозицией инварианта
цикла является утверждение "если х отсутствует в подмассиве от А [ i] до А (п ], то его
нет и в массиве А".
Теhерь, когда i>n, подмассив от A[i] до А(п] пуст, в нем нет ни одного элемента.
так что он никак не может содержать х. В силу контрапозиции инварианта цикла х
отсутствует в массиве А, так что возврат значения NOT-FOUND на шаге 2 является кор­
ректным.
Однако как много рассуждений требуется провести для такого в действительности
простого цикла! Неужели мы каждый раз при рассмотрении нового алгоритма должны

34

Глава 2. Описание и оценка комт,ютерных алгоритмов

проходить через все эти мучения? Я считаю, что нет, но есть ряд ученых в области ин­
форматики, которые настаивают на таких строгих рассуждениях для каждого <Лдельноrо
цикла. Когда я пишу реальную программу, я замечаю, что большую часть времени написа­
ния цикла его инвариант прячется где-то на задворках моей памяти. Он может прятаться в
голове так далеко, что я даже не уверен, есть ли он у меня, но если бы это потребовалось,
я бы тут же смог ero сформулировать. Хотя большинство из нас согласится, что инвари�т
цикла является излишеством для понимания раб<Лы простого цикла в процедуре BETTER­
LINEAR·SEARCH, в действительности инварианты цикла могут очень помочь, когда надо по­
нять, как более сложные циклы делают правильные вещи.

Рекурсия
С помощью рекурсии мы решаем задачу путем решения меньших экземпляров этой же
задачи. Вот мой любимый канонический пример рекурсии: вычисление п! ("п фактори­
ал"), который определен для неотрицательных значений п как п ! = 1 при п = О, и
п! = п·(п-1}·( п-2)·(п-3)·· ·3 · 2· 1

при п � 1. Например, 5! = 5 ·4·3·2·1 = 120. Заметим, что
(п-1)! = ( n- l}·(n-2}·(n-3)···3· 2 ·1,
так что
n!=n·(n-1}!
при п � 1. Мы определяем п ! через "меньшую" задачу, а именно ( п -1) !. Таким образом, мы
можем записать рекурсивную процедуру для вычисления п ! следующим образом.

Процедура FлcroRJAL(n)
Вход: целое число п � О.

Выход: значение п !.
1. Если п = О, вернуть I в качестве -возвращаемого значения.
2. В противном случае вернуть п, умноженное на значение, которое возвращает рекур­
сивно вызванная процедура FACТORtAL(n -1).
Я записал шаг 2 довольно громоздким способом. Вместо этого можно было бы про­
сто написать "в противном случае вернуть п · F ACТORIAL(n -1)", использовав возвращаемое
значение рекурсивноrо вызова в большем арифметическом выражении.
Чтобы рекурсия раб<Лала, должны выполняться два свойства. Во-первых, должен су­
ществовать один или несколько 6аз08wх случае•, когда вычисления проводятся непосред­
ственно, без рекурсии. Во-вторых, каждый рекурсивный вызов процедуры должен быть
меньшим экзеwпляром той же саwой задачи, так что в конечном итоге будет достигнут
один из базовых случаев. В случае процедуры FлстоR1дL базовый случай осуществляется
при п = О, и каждый рекурсивный вызов выполняется для значения п, уменьшенного на 1.
В случае, когда исходное значение п больше нуля, рекурсивные вызовы в конечном счете
придут к базовому случаю.

Глава 2. Описание и оценка компьютерных алгоритwов

35

Доказательство того, что рекурсивный алгоритм коррекrно работает, на первый взгляд,
может показаться очень простой задачей. Ключевой идеей является то, что мы прини­
маем в качестве гипотезы уrверждение о том, что каждый рекурсивный вызов дает пра­
вильный результат. Если же рекурсивные вызовы выполняют вычисления правильно, то
дока.зать коррекrность процедуры очень легко. Вот как мы могли бы доказать, что про­
цедура FACТORIAL возвращает правильное значение факrориала. Очевидно, что при п = О
она возвращает 1, которая является верным значением, так как О!= 1. Предположим, что
при п � 1 рекурсивный вызов FACТORIAL(n-1) возвращает корректное значение, т.е. (п-1)!.
Затем процедура умножает это значение на п, тем самым вычисляя значение п!, которое и
возвращается процедурой.
А вот пример, в котором рекурсивный вызов выполняется не для меньшего, а для боль­
шего экземпляра задачи, несмотря на коррекrность математической постановки задачи.
При п � О совершенно справедливо равенство п!= (п+ 1)!/(п+ 1). Но построенная по этой
формуле рекурсивная процедура не дает правильный ответ при п � 1.

Процедура BлD-fACTORIAL(n)
Вход и выход: те же, что и для FACТOJUAL.
1. Если п= О, вернуrь 1 в качестве возвращаемого значения.
2. В противном случае вернуть BAD-FACТORIAL(п + 1)/(п + 1).
Если бы мы вызвали Вло-FлcтoRtAL( 1 ), этот вызов сгенерировал бы вызов Bлo­
FACТORIAL(2), тот, в свою очередь, - вызов Вло-FлстоRiлt(З) и т.д. В результате процедура
никогда бы не добралась до базового случая, когда п = О. Если бы вы реализовали эту про­
цедуру на реальном языке программирования и запустили ее на реальном компьютере, то
быстро бы увидели что-то вроде сообщения "ошибка переполнения стека".
Зачастую можно переписать алгоритм с циклом в рекурсивном стиле. Например, вот
как выглядит линейный поиск без ограничителя в рекурсивном варианте.

Процедура REcuRs1vв-L1NEAR-SEARcн(A,n,i,x)
Вход: тот же, что и для LINEAR-SEARcн, но с дополнительным параметром i.

i

Выход: индекс элемента, равного х, в подмассиве от элемеmа А [i} до А [п или значение
NOT·FOUND, если х в этом под:массиве отсуrствует.
1. Если i > п, вернуть NOT·FOUND.
2 . .В противном случае (i � п), если A(i)= х, вернуrь i.
J
3. В противном случае (i �пи A[i]-:1- х), вернуть REcuRS1vE-L1NEA.R-SEARcн(A,n,i + J,x).
Здесь подзадача заключается в поиске элемента, равного х, в подмассиве от элемента
A[i] до элемента А[п]. Базовый случай осуществляется на шаге \, когда подмассив пуст,
т.е. когда i > п. Поскольку на каждом шаге значение i увеличивается на единицу при каж-

36

Глава 2. Описание и оценка комт,ютерных алгорит.�иов

дом рекурсивном вызове, если ни один из вызовов не вернет значение i на шаге 2, в конеч­
ном итоге i превысит п, и будет достигнут базовый случай рекурсии.

Дальнейшее чтение
Главы 2 и 3 CLRS (4] охватывают большую часть материала данной главы. Более ран­
ний учебник по алгоритмам Ахо (Aho), Хопкрофта (Hopcroft) и Ульмана (Ullman) [1] ока­
зал особое влияние на применение асимптотических обозначений для анализа алгорит­
мов. Что касается доказательств корректности работы программ, то, если вы хотите углу­
биться в эту область, познакомьтесь с книгами Гриза (Gries) [8] и Митчелла (Mitchell) [ 15].

3 •.. Алгоритмы сортировки и поиска
В главе 2 мы видели три варианта линейного поиска в массиве. Можно ли как-то улуч­
шить имеющиеся алгоритмы? Оrвет: это зависит от обстоятельств. Если мы ничего не зна­
ем о порядке элементов в массиве, то ничего лучшего мы не добьемся. В худшем случае
мы должны просмотреть все п элементов, потому что, если мы не смогли найти значение,
которое мы ищем, среди первых п - 1 элементов, оно может оказаться в последнем, п-м
элементе. Таким образом, мы не можем достичь времени работы в наихудшем случае луч­
шего, чем Е>( п ), если ничего неизвестно о порядке элементов в массиве.
Предположим, однако, что массив отсортирован в неубывающем порядке, т.е. каждый
элемент массива меньше или равен элементу, следующему в массиве за ним, согласно
некоторому определению отношения "меньше, чем". В этой главе мы увидим, что если
массив отсортирован, то мы можем использовать простой метод, известный как бинар­
ный поиск, чтобы найти нужный элемент в массиве из п элементов за время всего лишь
O(lgn). Как мы видели в главе 1, "Что такое алгоритмы и зачем они нужны", значение lgn
растет с ростом п очень медленно, и поэтому бинарный поиск превосходит линейный в
наихудшем случае. 1
Что это означает - что один элемент меньше другого? Если элементы являются чис­
лами, это очевидно. Если элементы являются строками символов текста, можно говорить
о лексu1<Оzрt1фическом порядке: один элемент меньше другого, если в словаре он дол­
жен располагаться первым. Когда элементы представляют собой другие виды данных, мы
должны определить, что означает понятие "меньше". При наличии некоторого точного
понятия "меньше, чем" можно определить, отсортирован ли массив.
Вспомним пример книжной полки из главы 2, "Описание и оценка компьютерных ал­
горитмов". Мы могли бы рассортировать книги в алфавитном порядке по фамилии автора,
в алфавитном порядке по названию или, если в библиотеке имеется каталог, по номерам
в каталоге. В этой главе мы будем считать, что книги на полке отсортированы в алфавит­
ном порядке по автору, слева направо. На полке может содержаться более одной книги
одного автора - возможно, у вас несколько книг Уильяма Шекспира. Если требуется ис­
кать не просто книгу Шекспира, а конкретную его книгу, то будем считать, что если на
полке стоят две книги одного и того же автора, то та из книг, название которой идет в ал­
фавитном порядке первым, должна находиться левее. Может оказаться и так, что все, что
нас интересует, - это имя автора, так что при поиске нас устроит любая книга Шекспира.
Информация, которую мы сопоставляем с книгой при поиске, называется ключом. В на­
шем примере с книжной полкой ключом является только имя автора, а не сочетание сна­
чала имени автора, а затем названия книги при наличии нескольких книг одного автора.

1
Если вы не кштьютерщик и nponycmw,u подраздел "Компьютерные алгоритмы для компь­
ютерщиков ·· главы /, ·· Что такое алгорum'>IЫ II зачем 011и 11уж11ы ", ,wожете вер11уться к с.19 и
прочесть. что такое .1о?ар11ф11ы.

38

Глава З. Алгоритмы сортиро6ки и поиска

Каким же образом нам получить отсортированный массив? В этой главе мы познако­
мимся с четырьмя алгоритмами - сортировка выбором, сортировка вставкой, сортировка
слиянием и быстрая сортировка, - предназначенными для сортировки массива, и приме­
нением каждого из этих алгоритмов к нашей книжной полке. Каждый алгоритм сортиров­
JСИ имеет свои достоинства и свои недостатJСи, и в JСонце этой главы мы сравним их. Все
алгоритмы сортировJСИ, JСОТОрые приведены в данной главе, имеют время работы в худшем
случае либо е( п2 либо е(п lgn ). Таким образом, если вы собираетесь выполнить лишь
нескольJСо поисков, то лучше остановиться на линейном поиске. Но если вы собираетесь
выполнять поиск много раз, то может иметь смысл сначала отсортировать массив, а затем
применять бинарный поиск.
Сортировка - важная задача сама по себе, а не только как шаг предварительной обра­
ботки данных для бинарного поиска. Подумайте обо всех данных, которые должны быть
отсортированы, - таких как записи в телефонной книге, чеки в ежемесячной выписке
банка да и просто результаты работы поисковой веб-системы, отсортированные по уров­
ню релевантности. Кроме того, сортировка часто является отдельным шагом в другом ал­
горитме. Например, в JСомпьютерной графиJСе объекты часто пере1Срывают один друтой.
Программа, которая отображает объекты на экране, должна отсортировать их в соответ­
ствии с отношением "находится выше", чтобы затем иметь возможность изображать их
один за другим снизу вверх.
Прежде чем идти дальше, пару слов о том, что такое сортировка. В дополнение к клю­
чу (который при сортировке мы будем называть ключом сортировки) сортируемые эле­
менты обычно содержат некоторую информацию, которую мы называем сопутствующи­
ми данными. Сопутствующие данные представляют собой информацию, которая связана
с ключом сортировки и перемещается при перемещении элементов вместе с ключом. В на­
шем примере с книжной полкой ключом сортировки является фамилия автора, а сопут­
ствующими данными - сама книга.
Своим студентам я поясняю концепцию сопутствующих данных следующим образом,
который заставляет их быстро понять эту тему. Я показываю им таблицу успеваемости,
отсортированную по столбцу фамилий студентов (ключом сортировки являются фамилии,
а сопутствующими данными - успеваемость). Если я теперь отсортирую таблицу так,
что ключом сортировки будет успеваемость (в порядке ее убывания), а фамилии студен­
тов - сопутствующими данными, и при этом я не буду перемещать фамилии, оставив
их в первом столбце и сортируя только столбец с данными об успеваемости... Думаю,
вы понимаете, какую реаJСцию это вызовет у аудитории. Обычно студенты с фамилиями
в начале списка оказываются очень довольными, особенно по сравнению со студентами
с фамилиями на последние буквы алфавита. Зато понимание, что такое сопутствующие
данные, гарантируется!
Вот некоторые другие примеры ключей сортировки и сопутствующих данных. В теле­
фонной книге ключом сортировки является фамилия и имя абонента, а сопутствующими
данными - адрес и номер телефона. В поисковой системе ключ сортировки представляет
собой меру релевантности, а сопутствующими данными является URL веб-страницы, а
также любая иная информация о странице, которую хранит поисковая система.

),

Глава 3. Алгоритмы сортировки и поиска

39

При работе с массивами в этой главе мы действуем так, как будто каждый элемент со­
держит только ключ сортировки. При реализации любого из приведенных здесь алгорит­
мов сортировки следует убедиться, что при перемещении ключа сортировки перемещают­
ся и сопутствующие данные, или по крайней мере указатель на них.
Чтобы аналогия с книжной полкой была применима к компьютерным алгоритмам, не­
обходимо, чтобы полка и книги обладали двумя не слишком реалистичными свойствами.
Во-первых, все книги на полке должны иметь один и тот же размер, потому что в массиве
в компьютере все элементы массива имеют одинаковый размер. Во-вторых, все позиции
книг на полке можно пронумеровать числами от l до п, и каждую такую позицию мы
будем называть слотам. Слот 1 - крайний слева, а слот п - крайний справа. Как вы, на­
верное, догадались, каждому слоту на полке соответствует запись массива.
Я также хочу разобраться со словом "сортировка". В обыденной речи сортировка мо­
жет означать нечто, существенно отличное от того, что это слово означает в вычислитель­
ной технике. Словарь на моем компьютере определяет термин "сортировка" как "система­
тическая организация в группах; разделение в соответствии с типом, классом и т.д.". Так
что этим термином, например, можно назвать раскладывание по полкам шкафа одежды:
рубашки - в одно место, галстуки - в другое и т.д. В мире компьютерных алгоритмов
сортировка означает размещение элементов в некотором строго определенном порядке, а
"систематическая организация в группах" называется "группировкой".

Бинарный поиск
Прежде чем перейти к некоторым алгоритмам сортировки, давайте рассмотрим бинар­
ный поиск, который требует, чтобы массив, в котором он выполняется, был отсортирован.
Бинарный поиск имеет то преимущество, что для поиска в массиве из п элементов требу­
ется время O(lgn ).
В нашем примере с книжной полкой мы работаем с книгами, уже отсортированными
по автору слева направо. Давайте, используя в качестве ключа фамилию автора книги,
поищем любую книгу Маяковского. Конечно, буква "М" находится примерно в средине
алфавита, но даже если бы мы искали книгу Шолохова, это еще не гарантировало бы, что
она будет близко к правому концу полки, - в конце концов, на полке может оказаться
большое количество книг Шукшина или Эренбурга.
Словом, не будем полагаться на удачу и будем искать книгу Маяковского следующим
образом. Перейдем к слоту, находящемуся на полке ровно посредине, возьмем находящую­
ся там книгу и посмотрим, кто ее автор. Предположим, что вы нашли книгу Ефремова. Это
не просто не та книга, которую мы ищем; поскольку книги отсортированы по автору, мы
точ110 знаем, что среди книг левее найденной книги Ефремова нужной нам быть не может.
Просмотрев только одну книгу, мы исключили из рассмотрения половину книг на полке!
Любая книга Маяковского должна быть на правой половине полки. Так что теперь мы най­
дем слот посредине правой половины полки и посмотрим, какая книга находится в этом
месте. Предположим, что это книга Льва Толстого. Далее найдем книгу в слоте посреди
третьей четверти полки, в которой только и может располагаться книга Маяковского. Если
это Маяковский, мы нашли то, что искали. Если нет, мы снова можем исключить половину

40

Глава 3. Алгоритмы сортировки и поиска

оставшихся книг. В конце концов мы либо найдем книгу Маяковского, либо доберемся до
такой мелкой части полки, в которой уже не будет ни одного слота, который мог бы со­
держать искомую книгу. В последнем случае можно заключить, что книги Маяковского на
полке нет.
В компьютере мы выполняем бинарный поиск в массиве. В любой момент мы рас­
сматриваем только подмассив, т.е. часть массива между двумя индексами (включительнd).
Назовем их р и r. Первоначально р = 1 и r = п, так что в начале работы подмассив совпа­
дает со всем массивом. Мы многократно делим подмассив пополам, до тех пор, пока не
произойдет одно из двух событий: либо мы найдем искомое значение, либо подмассив
окажется пустым (т.е. р станет больше, чем r). Именно это многократное деление подмас­
сива пополам и обеспечивает время работы алгоритма, равное O(lgn).
Рассмотрим работу бинарного поиска немного более подробно. Предположим, что мы
ищем значение х в массиве А. На каждом шаге мы рассматриваем только подмассив, на­
чинающийся с элемента А(р] и заканчивающийся элементом A[r]. Поскольку нам при­
дется немного поработать с подмассивами, введем для такого подмассива обозначение
A[p..r]. На каждом шаге мы вычисляем средину q рассматриваемого подмассива, вычис­
ляя среднеери r и отбрасывая дробную часть, если таковая имеется: q = l(p+r)/2J (здесь
мы используем функцию "пол" L J для удаления дробной части числа. При реализации
этой операции на языках программирования Java, С или С++ можно просто использовать
целочисленное деление, при котором дробная часть отбрасывается). Далее выполняется
проверка, не равно ли значение элемента А [q] величине х. Если равно, искомый элемент
найден, поэтому можно просто вернуть q как индекс элемента массива А, содержащего
значениех.
Если же вместо этого выясняется, что А [q] � х, то можно воспользоваться предполо­
жением, что массив А отсортирован. Поскольку А [ q] � х, имеются две возможности: либо
А [q] > х, либо А [q] < х. Сначала рассмотрим случай А [q] > х. Так как массив отсортиро­
ван, мы знаем, что больше х не только элемент А [q ], но и (рассматривая элементы масси­
ва как расположенные слева направо) все элементы, расположенные правее A[q ]. Таким
образом, можно исключить из рассмотрения все элементы в позиции q и справа от нее.
Поэтому на следующем шаге р не изменяется, а r устанавливается равным q - \.
А ···

р

1 1

r

q

l>x/>xl>xl>xj>xl>xj...

q -1

Новое значение r
Если же выясняется, что А [q] < х, то мы знаем, что каждый элемент массива слева от q
меньше, чем х, и поэтому можно эти элементы не рассматривать. Поэтому на следующем
шаге r не изменяется, ар устанавливается равным q + \.
р

r

q

А ··• l<x l<x l<x l<x l<xl<x1
q+\

JJ

Новое значение р

1 ···

Глава 3. Алгоритмы сортировки и поиска

41

Вот точное описание процедуры бинарного поиска.
Процедура BINARY-SEARCH(A,n,x)
Вход и вьаод: те :же, что и в LINEAR-SEARcн.
1. Установить р равным 1, а r равным n.
2. Пока р s; r, выполнить следующие действия.

J.

А. У становить q равным L(р + r)/2
В. Если A[q)=x, вернутьq.

С. В противном случае (A[q) � х), если A[q) > х, установить rравным q-1.
D. В противном случае ( А [q] < х) установить r равным q + 1.
3. Вернуrь значение NOT·FOUND.
Цикл на шаге 2 не обязательно завершается из-за того, что р становится больше, чем r.
Он может завершиться на шаге 28, если обнаружит, что А [q ) равно х, и вернет q как ин­
декс элемента массива А, равного х.
Для того чтобы показэ:rь, что процедура BINARY-SEARCH работает корректно, нам нужно
просто показать, что если процедура BrNARY-SEлRcн возвращает на шаге 3 значение NOT­
FOUND, то х отсутствует в массиве. Воспользуемся следующим инвариантом цикла.
В начале каждой итерации цикла в шаге 2, если х находится где-то в массиве
А, то это значение находится в одном из элементов подмассива A[p..r].
Вот краткое доказательство корректности с применением инварианта цикла.
Инициализации. Шаг I инициализирует индексы р и r значениями I и п соответственно,
и поэтому инвариант цикла при первом входе в цикл является истинным.
Сохранение. Выше мы доказали, что шаги 2С и 2D корректно обновляют либо р, либо r.
Завершение. Если х отсутствует в массиве, то в конечном итоге процедура доходит до
точки, где р и r равны. Когда это происходит, вычисленное на шаге 2А значение q
будет таким же, как р и r. Если шаг 2С устанавливает значение r равным q - 1, то в на­
чале следующей итерации , . оказывается равным р-1, так что р будет больше r. Если
же шаг 2D устанавливает значение р равным q + 1, то в начале следующей итерации р
оказывается
равным r + 1, и р снова будет больше r. В любом случае условие цикла на
1
шаге 2 будет ложным, и цикл завершится. Поскольку р > r, подмассив A[p..r) пуст, и,
таким образом, значение х не может в нем находиться. Рассматривая контрапозицию
инварианта цикла ( см. с. 33), находим, что если х отсутствует в подмассиве А[p. .r), то
его нет нигде в массиве А. Таким образом, процедура корректно возвращает значение
NOT-FOUNO на шаге 3.
Можно также записать бинарный поиск как рекурсивную процедуру.

42

Глава 3. Алгоритмы сортировки и поиска

Процедура REcURSIVE-BINARY-SEARCH(AJJ,r,х)

Вход и выход: входные параметры А их те же, что и у процедуры LINEAR-SEARCH, также,

как и выход. Входные параметрыр и rопредел.lUОТ обрабатываемый подмассив A(p..r].
1. Если р > r, вернуть NOT-FOUND.

2. В противном случае (р S r) выполнить следующие действия.
А. Усrановить q = L(р + r )/2

J.

В. Если A[q]= х, вернуть q.

С. В противном случае ( A[q)� х), если A[q) > х, вернуть REcuRstvE-BINARY·
SEARcн(AJJ,q -1,х).
D. В проmвном случае (А [q] <х) вернуть RвcuRsIVE-BINARY-SEARcн(A,q + l,r,х).
Первоначальный вызов имеет вид REcuRs1vE-B1NлRv-SEлRcн(A, \ ,п,х).
Теперь давайте рассмотрим, почему бинарный поиск выполняется в массиве с п эле­
ментами за время О ( lg п ). Ключевым ЯВЛJ1ется наблюдение, что размер r - р + 1 рассма­
триваемоrо подмассива уменьшается примерно вдвое на каждой итерации цикла (или при
каждом рекурсивном вызове в рекурсивной версии, но давайте пока сосредоточимся на
итерационной версии B1NлRv-SEARCH). Легко видеть, что если итерации начинаются с под­
массива из s элементов, то на следующей итерации размер подмассива будет равен либо
Ls/2 либо s/2-1, в зависимости от тоrо, является ли s четным или нечетным числом, и
больше или меньше элемент А[q] значениях. Мы уже видели, что, как только размер под­
массива опускается до 1, на следующей итерации процедура завершается. Таким образом,
вопрос в том, сколько итераций цикла, вдвое уменьшающих рассматриваемый подмассив,
нужно выполнить, чтобы его исходный размер п уменьшился до 1. Это то же количество
итераций, что и в случае, если бы мы начали с подмассива размером I и на каждой ите­
рации удваивали бы его, пока не будет достигнут размер п. Но это просто возведение
в степень путем многократного умножения на 2. Другими словами, при каком значении
х величина 2' достигает п? Если п представляет собой точную степень 2, то, как мы уже
видели на с. 20, ответом является число lg п. Конечно, п может не быть точной степенью 2,
и в этом случае ответ может отличаться от lg п не более чем на 1. Наконец заметим, что
каждая итерация цикла требует постоянноrо количества времени, т.е. время выполнения
отдельной итерации не зависит от размера исходного массива п или от размера рассма­
триваемого подмассива. Давайте воспользуемся асимптотическими обозначениями для
того, чтобы отбросить постоянные множители и члены более низкого порядка. (Равно ли
количество итераций lg п или L lg пJ + 1? Да какая разница!) В результате мы получаем, что
время работы бинарного поиска составляет O(lgn ).
Я использовал здесь О-обозначения, поскольку хотел получить выражение, охватыва­
ющее все случаи. В наихудшем случае, когда значение х в массиве отсутствует, мы много­
кратно делим подмассив пополам, пока рассматриваемый подмассив не окажется пустым,
и в этом случае время работы равно 0(lgn ). В лучшем случае, когда х обнаруживается

J,

Глава 3. Алгоритмы сортировки и поиска

43

в первой же итерации цикла, время работы равно 0(1). Нет 0-обозначения, которое охва­
тывало бы все случаи, но выражение O(lgn) для времени работы бинарного поиска кор­
ректно - конечно, если массив предварительно отсортирован.
Превзойти время 0(lgn) в наихудшем случае можно только при более сложной орга­
низации данных и определенных свойствах к лючей поиска.

Сортировка выбором
Обратим теперь наше внимание на задачу сорти�ки, в которой требуется та.к раз­
местить элементы массива - выполнить их

переспи,но.ку,

- чтобы каждый элемент

был меньше или равен следующему за ним. Первый алгоритм сортировки, с которым мы
познакомимся, - сортировка выбором , на мой взгляд, является самой простой, потому
именно она тут же пришла мне в голову, когда мне надо было разработать алгоритм со­
ртировки массива. Но этот способ сортировки далеко не самый быстрый.
Вот ка.к сортировка выбором будет работать в случае сортировки книг на книжной пол­
ке по авторам. Сначала мы проходим по всей полке и находим книгу, автор которой стоит
первым по алфавиту, - скажем, Алеся Адамовича ( если на полке две или более книг этого
автора, выбираем любую из них). Затем мы меняем эту книгу местами с книгой в первом
слоте. Теперь в первом слоте находится книга с автором, первым в алфавитном порядке
среди всех авторов, книги которых присутствуют на полке. Затем мы вновь проходим по
книжной полке слева направо, начиная с книги в слоте 2, и в слотах со второго по слот

п

ищем книгу, автор которой стоит первым по алфавиту среди просматриваемых книг.

Предположим, что это Борис Васильев. Поменяйте эту книгу с книгой в слоте 2, так что
теперь слоты l и 2 заняты книгами, авторы которых стоят первыми в алфавитном порядке.
Затем надо сделать то же самое для слота 3 и т.д. После того как мы поставим нужную
книгу в слот п -1 (возможно, это кинга Шолохова), сортировка выполнена, так как оста­
ется только одна книга (скажем, Шукшина), и она находится в том слоте, где и должна на­
ходиться, - в слоте п.Чтобы превратить этот рассказ в компьютерный алгоритм, заменим
книжную полку массивом, а книги - его элементами. Вот что получается.

Процедура SEtEcnoN-Soaт(A,n)
Вход:
•

А: сортируемый массив.

•

п: количество сортируемых элементов в массиве А.

Рd1ультат: элементы массива А отсортированы в неубывающем порядке.
1. Для i = 1 ДО n -1:
А. Присвоить переменной

А[i.л).
В. Обменять

smallest индекс наименьшего элемента в подмассиве

А (i] ++ А (sma/lest].

44

Глава 3. Алгоритwы сортировки II поиска

Поиск наименьшего элемента в А[i..п] представляет собой вариант линейного поиска.
Сначала объявим наименьшим элементом A[i), а затем просканируем остальную часть
подмассива, обновляя индекс наименьшего элемента каждый раз, когда находим элемент,
меньший, чем текущий наименьший. Вот какой вид имеет уточненная процедура сорти­
ровки.

Процедура Sш,L"ПON-Soю'(A,n)
Вход и результат: те же, что и ранее.
1. Дш1i=lдon-l:
А. Установить значение переменной smallest равным i.

в. Для j = i + 1 до п:
i. Если A[J] < A[smal/est ], присваиваем переменной smallest значение}.
С. Обменять A[i]� A[smallest ].
Эта процедура имеет так называемый "вложенный" цикл: цикл на шаге 1 В вложен в
цикл на шаге 1. Внутренний цикл выполняет все свои итерации для каждой отдельной
итерации внешнего цикла. Обратите внимание, что начальное значение j во внутреннем
цикле зависит от текущего значения i во внешнем цикле. Приведенная ниже иллюстрация
показывает, как сортировки выбором работает с массивом из шести элементов.
1

2

3

4

5

6

1

2

3

4

5

6

1

2

3

4

5

6

1

2

3

4

5

6

2

3

4

5

6

А J12J 9 J з J 1J14J11J-л89 JЩ 1 j14j11J-л &W12J 9 J14J11j

А�-А

�..:��- .. т: --;- -,1".:::_"4 ...
�J

<

-i'"'-"'·

• -

Исходный массив показан в верхнем левом углу, и каждое следующее изображение пред­
ставляет массив после очередной итерации внешнего цикла. Более темным цветом показаны элементы подмассива, о котором точно известно, что он отсортирован.
Если вы хотите воспользоваться инвариантом цикла для доказательства того, что про­
цедура SELEC'nON-SOR'Г правильно сортирует массив, вам потребуется по одному инвариан­
ту для каждого цикла. Процедура доказательства достаточно проста, так что здесь приве­
дены только инварианты цикла, доказательство остается читателю в качестве небольшого
упражнения.
В начале каждой итерации цикла на шаге I подмассив А [ l ..i -1) содержит i -1
наименьших элементов массива в отсортированном порядке.
В начале каждой итерации цикла на шаге I В элемент А [ smallest] представля­
ет собой наименьший элемент в подмассиве A[i ..j-1).

Гла(Jа 3. Алгоритмы сортиро6ки и поиска

45

Чему же равно время работы процедуры SELECTION-SoRт? Покажем, что оно равно
е( п� ). Ключевым моментом анализа является выяснение количества итераций, выпол­
няемых внутренним циклом, с учетом того, что каждая итерация выполняется за время
<Э(l}. (Константные множители для верхней и нижней границ в <Э-обозначениях могут
быть различны, поскольку в каждой конкретной итерации присваивание значения пере­
менной smal/est может как произойти, так и не произойти.) Давайте посчитаем количество
итераций с учетом значения переменной внешнего цикла. Когда i равно 1 , внутренний
цикл выполняет итерации для), изменяющегося от 2 до п, или п-1 итерацию. Когда i
равно 2, внутренний цикл выполняет итерации для j в диапазоне от 3 доп, или п - 2 итера­
ции. Каждый раз с увеличением переменной внешнего цикла на единицу внутренний цикл
выполняется на один раз меньше. В общем случае внутренний цикл выполняется п - i раз.
В последней итерации внешнего цикла, когда i равно п -1, внутренний цикл выполняется
только один раз. Таким образом, общее количество итераций внутреннего цикла равно

(n-l}+(n-2}+(n-3}+···+2+ 1.

Такая сумма известна под названием арифметическаJI npozpeccw,, и вот очень важ­
ный факт об арифметических прогрессиях: для любого неотрицательного целого k

k+(k-l)+(k-2)+···+2+1=

k(k+l)
.
2

Подставляя п -1 вместо k, мы видим, что общее количество итераций внутреннего цикла
2
равно (п - 1)п/2, или (п п)/2. Воспользуемся асимптотическими обозначениями, чтобы
избавиться от членов более низкого порядка (-п) и постоянного множителя (1/2). Теперь
можно утверждать, что общее количество итераций внутреннего цикла представляет
2
собой е( п 2 Следовательно, время работы сортировки выбором равное(п ). Обратите
внимание, что это выражение, охватывающее все случаи. Внутренний цикл выполняется
2
е( п ) раз независимо от фактических значений элементов массива.
Вот еще один способ увидеть без использования арифметических прогрессий, что вре­
2
мя работы равное( п ). Покажем отдельно, что время представляет собой как
п 2 так
2
2
и
п объединение асимптотических верхней и нижней границ даст нам е( п ). Чтобы
2
убедиться, что время работы представляет собой о( п ). заметим, что в каждой итерации
внешнего цикла внутренний цикл выполняется не более п-1 раза, что равно О(п), по­
скольку каждая итерация внутреннего цикла требует постоянного количества времени.
Поскольку внешний цикл выполняет итерацию п - 1 раз, что тоже ни что иное, как О(п ),
общее время, затраченное во внутреннем цикле, представляет собой О(п ), умноженное на
О( п ), или о( п2 ). Чтобы убедиться, что общее время работы представляет собой п2 ),
замуrим, что в каждой из первых п/2 итераций внешнего цикла внутренний цикл выпол­
няет по меньшей мере п/2 итераций, т.е. в общей сложности как минимум п/2 умножен­
2
ное на п/2 итераций, или п /4 итераций. Поскольку каждая итерация внутреннего цикла
выполняется за постоянное количество времени, можно сделать вывод, что общее время
выполнения процедуры представляет собой по меньшей мере константу, умноженную на
п2
п 2 /4, или

-

).

о( ).

n( );

n(

n( ).

46

Глава 3. Алгоритмы сортировки и поиска

2) Два последних замечания о сортировке выбором. Во-первых, время работы
наихудшее среди всех алгоритмов сортировки, которые мы будем рассматривать. Во­
вторых, если внимательно изучить работу сортировки выбором, мы увидим, что время
2
работы
п ) обусловлено сравнениями на шаге IBi. Однако количество перемещений
ЭЛеМеНТОВ массива раВНО ТОЛЬКО 0{ n ), ПОСКОЛЬку шаr ) С ВЫПОЛНяется ТОЛЬКО n - \ чаз.
Если перемещение элементов массива требует большого времени - например, если они
велики или располагаются на медленном устройстве типа диска, - то сортировка выбо­
ром может оказаться вполне разумным решением.

е(п

е(

Сортировка вставкой
Сортировка вставкой несколько отличается от сортировки выбором, хотя и многим на
нее похожа. В сортировке выбором при решении, какая книга должна быть положена
в слот i, книги в слотах, предшествующих слоту i, уже отсортированы в алфавитном
порядке по авторам, причем это первые по алфавиту книги из всего множества книг
на полке. В случае сортировки вставкой книги в первых i слотах - это те же книги,
которые были изначально в первых i слотах, но теперь отсортированные в алфавитном
порядке по авторам.
В качестве примера давайте предположим, что книги в первых четырех слотах уже от­
сортированы по автору и что это книги Адамовича, Островского, Шолохова и Шукшина.
Пусть книга в слоте 5 написана Шефнером. При сортировке вставкой мы сдвигаем книги
Шолохова и Шукшина на один слот вправо, перемещая их из слотов 3 и 4 в слоты 4 и 5,
а заrем ставим книгу Шефнера в освободившийся слот 3. Пока мы работаем с книгой
Шефнера, нас не интересуют книги, стоящие справа от нее (книги Казакевича и Васильева
на представленном ниже рисунке), - с ними мы разберемся позже.

2

_I .___I_-_-_-_-_-_----=----'t t

3

4

5

6

7

2

3

4

5

6

7

Чтобы переместить книги Шолохова и Шукшина, мы сначала сравниваем автора
Шукшина с Шефнером. Выяснив, что Шукшин идет после Шефнера, мы сдвигаем его
книгу на один слот вправо, из слота 4 в слот 5. Затем сравниваем с Шефнером Шолохова.
Выяснив, что Шолохов также идет после Шефнера, мы сдвигаем книгу Шолохова на
один слот вправо, из слота 3 в слот 4, который был освобожден при перемещении книги
Шукшина. Далее мы сравниваем авторов Шефнера и Островского. На этот раз мы нахо­
дим, что Островский должен идти перед Шефнером. На этом мы прекращаем сравнения,

Глава 3. Алгоритмы сортировки и поиска

47

так как обнаружили, что книга Шефнера должна быть справа от книги Островского и сле­
ва от книги Шолохова. Мы смело можем поставить книгу Шефнера в слот 3, который был
освобожден при переносе книги Шолохова.
Переведем описанную идею на язык компьютерного алгоритма для сортировки мас­
сива. Подмассив А [ \ .i -1] содержит только те элементы, которые изначально находились
в первых i -1 позициях массива, и все они находятся в отсортированном порядке. Чтобы
определить, куда надо вставить элемент, первоначально находившийся в A[i], сортиров­
ка вставкой проходит по подмассиву А [ l ..i -1] справа налево, начиная с элемента А [i -1 ],
и переносит каждый элемент, больший, чем A[i], на одну позицию вправо. Как только
мы найдем элемент, который не превышает элемент A[i], или доберемся до левого конца
массива, мы перенесем элемент, изначально находившийся в A[i], в его новую позицию в
массиве.
Процедура lNSERTION-Soю'(A,n)
Вход и результат: те же, чrо и в SEtEcnoN-SoRT.
\. Для i = 2 ДО n:

1

А. Усrаиовить переfdенную key равной А [i а переменнойj присвоить значение i -1.
В. Пока j > О и A(j] > key, выполнять следующее:
i. Присвоить A[j + 1] значение A[j).
ii. Уменьшитьj на единицу (присвоить переменнойj значение j-1).
С. Присвоить A(j + t] значение lcey.
Проверка на шаге \В использует оператор "и", считая его сокрt1щенно 11wчист,емwм:
если выражение слева, j > О, ложно, выражение справа, A[j] > key, не вычисляется, по­
скольку и так очевидно, что общее выражение истинным быть не может. Если этот опера­
тор вычисляет обе части, то при j � О обращение к А [j] может привести к сбою выполне­
ния программы.
Вот как сортировка вставками работает с массивом, который уже был использован на
с. 44 в качестве примера для сортировки выбором.
1

2

3

4

5

6

1

2

3

4

5

6

1

2

3

4

5

6

1

2

3

4

5

6

2

3

4

5

6

AIЩ9IЗ!7lt4jttl-л�-л�

л�-л

Здесь вновь первоначальный массив показан в верхнем левом углу, а каждый шаг по­
казывает, какой вид имеет массив после очередной итерации внешнего цикла на шаге 1.
Более темным цветом показаны элементы подмассива, о котором точно известно, чrо он
отсортирован. Инвариант внешнего цикла (который, как и в предыдущем случае, мы при­
водим без доказательства) имеет следующий вид.

48

ГлаtJа 3. Алгоритмы copmupotJкu и поиска

В начале каждой итерации цикла в шаге 1 подмассив А [1 ..i -1] состоит из
элементов, изначально находившихся в А [ l ..i -1], но теперь - в отсортиро­
ванном порядке.
На следующем рисунке показано, как внутренний цикл на шаге 1 В работает в lfРИ­
веденном выше примере, когда i равно 4. Мы считаем, что подмассив A[l ..3] содержит
элементы, первоначально располагавшиеся в первых трех позициях массива, но теперь
они находятся в отсортированном порядке. Чтобы определить, где следует разместить
элемент, первоначально находившийся в позиции А[4], мы сохраняем его в переменной
с именем key, а затем сдвигаем каждый из элементов A[l .. Зt больший key, на одну пози­
цию вправо.

l l

1

2

1

2

3

4

5

6

А з 9 l12l 7 lt4Jt1I- А

А

key = 7

3

4

5

6

/

1

2

3

4

5

6

1

2

3

4

5

6

l з J 9 J128t4IHI

I з 19 8121141111 ... А J з 8 9 J12j14!ttl

Выделение темным цветом показывает позиции, в которые перемещаются элементы мас­
сива. На последнем показанном шаге значение A[t] = 3 не превышает значение перемен­
ной key, равное 7, и внутренний цикл завершается. Как видно из последней части рисун­
ка, значение key помещается в позицию, находящуюся непосредственно справа от А ( l].
Конечно, первоначально требуется сохранить исходное значение А [i] в переменной key на
шаге lA, потому что первая итерация внуrреннеrо цикла перезаписывает A[i].
Возможно также, что внутренний цикл завершается из-за невыполнения условия j > О.
Эта ситуация возникает, когда значение key меньше значений всех элементов в A(l ..i-1).
Если j становится равным О, значит, каждый элемент в А ( l . .i -1] был сдвинут вправо, так
что шаг l С помещает значение key в элемент А (1], что и требуется для корректной сорти­
ровки элементов.
Анализ времени работы процедуры INSERTION-SORT немного сложнее, чем процеду­
ры SELECTION-Soкr. Количество выполнений итераций внутреннего цикла в процедуре
SELECTION-SORT зависит только от индекса i внешнего цикла, но не от самих сортируемых
элементов. В случае же процедуры INSERTION-SORT количество итераций внутреннего цикла
зависит как от индекса i внешнего цикла, так и от значений элементов массива.
Наилучший случай в процедуре INSERTION-SORT осуществляется тогда. когда внутрен­
ний цикл всякий раз выполняет нуль итераций. Чтобы это произошло, условие A[J] > key
должно быть ложным при первой же проверке для каждого значения i. Другими словами,
каждый раз, когда выполняется шаг lB, должно выполняться условие A[i-1]::; A[i]. Как
это может произойти? Только если массив А отсортирован до выполнения процедуры.
В этом случае итерации внешнего цикла выполняются п -1 раз, а поскольку каждая итера­
ция внешнего цикла при этом выполняется за постоянное время, процедура INSERTION-SoRт
занимает время е( п ).

Глава 3. Алгоритмы сортировки и поиска

49

Наихудший случай осуществляется, когда внуrренний цикл каждый раз делает макси­
мально возможное количество итераций. Теперь условие A[j] > key всегда должно быть
истинным, и цикл завершается по невыполнению условия j > О. Каждый элемент A[i]
должен проделать весь путь до левого конца массива. Как может возникнуть такая ситуа­
ция? Только если массив А в начале работы оказывается отсорти рованным в обратном,
невозрастающем порядке. В этом случае внешний цикл каждый раз выполНJ1ет итерации
внуrреннеrо цикла i - 1 раз. Поскольку переменная внешнего цикла i пробегает все значе­
ния от 2 до п, общее количество итераций внуrреннеrо цикла имеет вид арифметической
прогрессии

1 + 2 +3+···+(n-2)+(n-l),

которая, как мы видели при анализе процедуры SELECТION-SoRт, представляет собой е( n 2 ).
Поскольку каждая итерация внуrреннеrо цикла выполняется за константное время, время
работы процедуры SELEcтюN-SoRт в наихудшем случае равно 0 ( п2 Таким образом, время
работы сортировки вставкой в наихудшем случае такое же, как и при сортировке выбором.
Имеет ли смысл попытаться понять, что происходит с сортировкой вставками в сред­
нем? Это зависит от того, как выглядят "средние" входные данные. Если порядок элемен­
тов во входном массиве действительно случайный, следует ожидать, что каждый элемент
будет больше около половины предшествующих ему элементов и меньше тоже около по­
ловины этих элементов, так что каждый раз при выполнении внутреннего цикла послед­
ний будет делать примерно (i-1)/2 итераций. Это сократит время работы по сравнению
с наихудшим случаем в два раза. 1/2 - это всего лишь постоянный множитель, а потому
асимптотически время работы алгоритма остается тем же - е( n 2 ).
Сортировка вставками является отличным выбором, когда массив изначально "почти
отсортирован". Предположим, что каждый элемент массива в начале работы находит­
ся в позиции на расстоянии k от той, где оказывается в отсортированном массиве. Тогда
общее число перемещений данного элемента в результате всех итераций внуrреннеrо
цикла не превышает k. Таким образом, общее количество сдвигов всех элементов в ре­
зультате всех итераций внуrреннеrо цикла не превышает kn, что, в свою очередь, говорит
о том, что общее количество итераций внуrреннеrо цикла также не превышает kn (ведь
на каждой итерации внуrреннеrо цикла выполняется сдвиг ровно одного элемента ровно
на одну позицию). Если k - константа, то общее время работы сортировки вставками
будет составлять 0 ( п), поскольку 0-обозначение включает постоянный коэффициент k.
На самом деле мы даже можем мириться с перемещением некоторых элементов на боль­
шие расстояния в массиве, пока таких элементов не слишком много. В частности, если/
элемрнтов можно перемещать в массиве произвольным образом (так, что каждый из этих
элементов можно переместить на расстояние до п -1 позиции), а остальные п -/ элемен­
тов перемещаются не более чем на k позиций, то общее количество сдвигов не превышает
/( n-1)+( n-l)k = ( k +l)n-(k + 1)/, что в случае, когда и/, и k являются константами, со­
ставляет 0 ( п).

).

50

Глава 3. Алгоритмы сортировки и поиска

Если сравнить асимптотическое время сортировки вставкой и выбором, то мы видим,
что в наихудшем случае они одинаковы. Сортировка вставками оказывается лучше, если
массив почти отсортирован. Сортировка выбором, однако, имеет одно преимущество
перед сортировкой вставкой: сортировка выбором перемещает элементы 0( п) раз неза­
висимо ни от чего, а сортировка вставкой может перемещать элементы до е( п2 ) раз, по­
скольку каждое выполнение шага I Bi процедуры INSERTION-SoRт выполняет перемещJние
элемента. Как мы уже отмечали при рассмотрении сортировки выбором, если перемеще­
ние элемента занимает очень много времени и у вас нет оснований ожидать, что сортиров­
ка вставкой для конкретных входных данных будет работать лучше, то стоит рассмотреть
возможность применения сортировки выбором вместо сортировки вставкой.

Сортировка слиянием
Наш следующий алгоритм сортировки, сортировка слиянием, имеет во всех случаях
время работы, равное всего лишь 0(nlgn). Сравнивая его с наихудшим временем ра­
боты е( п2 ) у алгоритмов сортировки выбором и сортировки вставкой, мы видим, что
множитель п заменен множителем ln п - а такая замена, как мы уже говорили в разделе
"Компьютерные алгоритмы для компьютерщиков" на с. 19, однозначно выгодна.
Однако сортировка слиянием имеет и пару недостатков по сравнению с уже рас­
смотренными нами алгоритмами сортировки. Во-первых, постоянный множитель, пря­
чущийся в асимптотических обозначениях, оказывается большим, чем у других двух
алгоритмов. Конечно, когда размер массива п становится достаточно большим, это пере­
стает иметь значение. Во-вторых, сортировка слиянием не работает "на месте", без
примечения дополнительной памяти: она делает полные копии всего входного масси­
ва. Сравните эту функцию с сортировкой выбором и сортировкой вставкой, которые в
любой момент хранят дополнительные копии только одной записи массива, а не всего
массива целиком. Если вопрос использования памяти приоритетен, использовать сорти­
ровку слиянием нельзя.
В алгоритме используется распространенная алгоритмическая парадигма, известная
как "рllЗделяii и властвуй". В ней мы разделяем задачу на подзадачи, которые подобны
исходной, решаем подзадачи рекурсивно, а затем объединяем решения подзадач в решение
исходной задачи. Вспомним из главы 2, "Описание и оценка компьютерных алгоритмов",
что, чтобы рекурсия работала, каждый рекурсивный вызов должен работать с меньшим
экземпляром той же задачи, чтобы в конечном итоге достичь базового случая. Вот общая
схема работы алгоритма "разделяй и маствуй".
1. РllЗделение. Задача разбивается на несколько подзадач, которые предстамяют собой
меньшие экземпляры той же самой задачи.
2. Властвование. Рекурсивно решаются подзадачи. Если они достаточно малы, они ре­
шаются как базовый случай.
3. Объединение. Решения подзадач объединяются в решение исходной задачи.

Глава 3. Алгоритмы сортировки и поиска

51

При сортировке книг на книжной полке с помощью сортировки слиянием каждая под­
задача состоит из сортировки книг в последовательных слотах полки. Первоначально мы
хотим отсортировать все п книг в слотах от первого до n-ro, но подзадача в общем случае
состоит в упорядочении всех книг в слотах от p-ro до r-ro. Вот как применяется парадигма
"разделяй и властвуй" в этом случае.
1. Разделение. Разделяем сортируемый промежугок путем нахождения значения q посре­
дине между р и r. Мы делаем это так же, как и при бинарном поиске: q = L( р + r )/2

J.

2. Власmю•ание. Рекурсивно сортируем книги в каждой половине промежутка, создан­
ной на шаге разделения: рекурсивно сортируем промежуток слотов от р до q, и от q + 1
доr.

3. Объединение. Объединение отсортированных книг в промежутках слотов от р до q и
от q + 1 до r так, чтобы книги в промежутке от р-го до r-ro слотов были отсортированы.
Как это сделать, мы вскоре узнаем.

Базовый случай осуществ.ляется, когда надо сортировать менее двух книг (т.е. когда
р;::: r), поскольку множество книг, в котором книг нет или имеется единственная книга,
уже отсортировано тривиальным образом.
Чтобы превратить эту идею в алгоритм сортировки массива, книги в слотах от р до r рас­
сматриваются как подмассив A(p"r]. В алгоритме используется процедура MERGE(A,p,q,r),
которая сливает отсортированные подмассивы А (p..q] и А (q + l "r] в единый отсортиро­
ванный подмассив A(p"q).
Процедура MERGE-SoRт(A.p,r)
Вход:

• А: массив
• р, r: начальный и mнечный ющексы подмассива А

Pe:J)!'lьmam: элементы подмассива А[р. .r)отсортированы в неубывающем порядке.
l. Если р � r, подмассив A[p. .r) содер*ИТ не более одного элемента, так что он uто­
матически еляется отсортированным. Вьmолияем возвраr из процедуры без каких­
либо действий.

2. В противном случае вьmОЛНJ1ем следующие действия.
А. Установить q =l(p+r)/2

J.

,в. Рекурсивно вызвать MERGE·Soкr(A.p,q)

С. Рекурсивно вызвать MERGE-Soкr(A,q + l,r)

D. Вызвать MEROE(AJJ,q,r)

52

Глава З. Алгоритмы сортировки и поиска

Хотя мы пока что не видели, как работает процедура MERGE, уже можно посмотреть, как
работает процедура MERGE-SoRт. Начнем со следующего массива.
1

2

3

l l
4

5

6

7

l I
8

9

10

lt2j 9 j з 7 t41t I l 6 2 ioj s

!

Первоначальный вызов для сортировки всего массива - MERGE-SORT(A,\,10). На �раге
2А находим, что q равно 5, так что рекурсивными вызовами на шагах 2В и 2С являются
MERGE-SoRт(A,1,5) И MERGE-SORT(A,6,\0).
1

2

3

4

5

112191311114 1

6

7

8

9

10

1Щ 612 1'015 I

После возврата из этих двух рекурсивных вызовов подмассивы будут отсортированы.

1 2 3 4

5

lзl119\12114j

1215161101111
6

7

8

9

10

Наконец вызов MERGE(A,1,5,10) на шаге 20 сливает два отсортированных подмассива
в единый отсортированный подмассив, который в данном случае представляет собой весь
массив полностью.
1

2

3

4

5

6

7

8

9

10

121 з j s j 6 j 1 j 9 \10111j12114I
Если полностью раскрыть рекурсивные вызовы, мы получим приведенную далее схе­
му. Расходящиеся стрелки показывают шаги разделения, а сходящиеся - шаги слияния.
Переменные р, q и r, показанные над каждым подмассивом, располагаются над индексами,
которым они соответствуют в каждом рекурсивном вызове. Выделенные курсивом числа
указывают порядок, в котором осуществляются вызовы процедур после первоначального
вызова MERGE-SoRт(A,1, 10). Например, вызов MERGE(A, 1,3,5) является тринадцатым вы­
зовом после начального, а вызов MERGE-SoRт(A,6,7)- шестнадцатым.
Реальная работа происходит в процедуре MERGE. Таким образом, эта процедура долж­
на работать не только корректно, но еще и быстро. Если сливаются в общей сложности п
элементов, то лучшее, на что мы можем надеяться, - это время работы 0( п ), поскольку
каждый элемент должен быть поставлен в соответствующее место. И мы действительно
можем достичь слияния за линейное время.

Глава 3. Алгоритмы сортировки и поиска

р

r

q

1234S6789IO

I

/1219 з l 7 !J411ll 6 / 2 l10l 5

Разделение

/ /

6789 10

/1 11612 /10/sj

[12l9!з!1lt4j
Разделение

2/

,9

1

2

4

3

l l

/ 121 9 з
Разделение

p,r

p,q r
1

2

3

@Ш

�5

Разделение 4 f
p,r

101

"lJ

4

S

\ 20 п/

p,q r

p, r

6 1

p,r

p,r

8

9

\ 24
p,r
10

p,r

ш

6

@]

�19f

�бf

p,q r

2

6

7

[I]}J]

"8

/

p,q r

р q r
2

4S

3

1з 19р21
Слияние
р
1

Слияние

�

9 10

пf ,1а

IIJ

1

/tt / 6 / 2 j
16/

p,q r

Слияние

p,q r

Ш 0 �@ЕJШ�Ш

2

1

,22

р q r

678

p,r

p,r

p,r

1

Слияние

s

�

\7

з/

1 5/

p,q r

р q r

r

q

р

s

1234

I

'14

r

q

р

53

�

,1з/
2

q

3

р q r

p,q r

2 6

[П!.О]

1зl 7 l 9112/141

'27

9

1 1 1"1
6

7

r

4 S

2

\21

р
6

8

,26/
1

q
8

r

10

12 1s l 6l10111 j

/

r
q
1 2 34 S 6 1 89 10
/ 2 1 зIsl 6l 1 l 9 l10111112114
р

9

10

J

Возвращаясь к примеру с книжной полкой, рассмотрим часть полки со слотами с 9 по 14.
Предположим, что у нас имеются отсортированные книги в слотах 9-11 и в слотах 12-14.

54

Глава 3. Алгоритмы сортировки и поиска

-----------------------­
9

10

11

<т°""""'оано

12

13

14

(movn,pooaнo

Снимем с полки книги в слотах 9-11 и положим их стопкой, так что книга автора, идущего
первым по алфавиту, оказывается на вершине стопки. Точно так же сложим книги из сло­
тов 12-14, сделав вторую стопку.

9

10

11

12

13

14

Поскольку эти стопки уже отсортированы, книга в слоте 9 должна быть одной из верх­
них книг этих двух стопок: либо книга Васильева, либо книга Адамовича. Мы видим, что
книга Адамовича должна находиться до книги Васильева, так что мы ставим ее в слот 9.

9

10

11

12

13

14

После того как книга Адамовича помещена в слот 9, книга, которая должна быть постав­
лена в слот 1 О, должна быть верхней книгой одной из стопок - либо книгой Васильева,
либо книгой Казакевича. Поэтому в слот I О мы ставим книгу Васильева.

\1 JJI,, "'""'

,. .
9

10

11

12

13

14

�
i�

·�

l�1trl11 ,,111>1 Ц( 11{/1 I

,: ,,lt.i

Затем мы вновь сравниваем книги на вершинах стопок - теперь это книги Шолохова и
Казакевича - и ставим в слот 11 книгу Казакевича. В правой стопке остается одна книга

Г.1ава 3. Алгоритмы сортировки и поиска

55

Шефнера, и после сравнения с Шолоховым мы ставим ее в слот 12. В этот момент правая
стопка становится пустой.

9

10

11

12

13

14

Все, что нам осталось сделать, - это взять книги из левой стопки и поставить их в остав­
шиеся пустыми слоты в том порядке, в котором они лежат в стопке.

9

10

11

12

13

Orcopn,pouнo

Насколько эффективна эта процедура слияния? Каждую книгу мы перемещаем ров­
но два раза: снимая ее с книжной полки и вновь возвращая на полку. Кроме того, когда
мы решаем, какая из книг должна быть поставлена на полку, нам надо сравнивать только
две книги, находящиеся на вершинах стопок. Следовательно, чтобы выполнить слияние п
книг, нам надо переместить книги 2n раз и сравнить пары книг не более п раз.
Зачем мы снимаем книги с полки? Что произойдет, если мы оставим книги на полке
и просто будем отслеживать, какие книги мы уже поместили в их корректные места на
полке, а какие еще нет? Эrо может привести к намного большему количеству работы.
Предположим, например, что каждая книга в правой половине полки должна в конечном
итоге оказаться перед каждой из книг в левой половине. Прежде чем мы смогли бы пере­
местить первую книгу из правой половины в первый слот левой половины, нам бы потре­
бовалось перенести каждую из книг в левой половине вправо на один слот для того, чтобы
освободить место для переносимой книги. Затем нам пришлось бы делать то же самое,
чтобы поставить следующую книгу, и так далее для всех прочих книг, которые изначально
находились в правой половине полки. В результате при установке на место каждой книги
из п�авой половины полки нам пришлось бы перемещать половину всех книг на полке.
Эrи рассуждения поясняют нам, почему мы не можем выполнять слияние "на месте",
без привлечения дополнительной памяти.2 Возвращаясь к слиянию отсортированных под­
массивов A[p..q) и A[q+l ..r) в подмассив A[ p..ri мы начинаем с копирования сливае­
мых элементов из массива А во временные массивы, а затем возвращаем их в массив А.
1

На cawaw деле слияние на .wecme за линейное t1pewя t1ыполнить .wожно, но coomt1emcmtJyющaя
процедуро оказыtJаеmся неопроt1данно сложной.

56

Глава 3. Алгоритмы сортировки и поиска

Пусть п, = q - р + 1- количество элементов в А (p..q], а n2 = r- q - количество элементов
в А (q + l ..r]. Создадим временные массивы В с п, элементами и С с п2 элементами и скопи­
руем элементы нз А (р . .q]. не нарушая их порядок, в массив В, а элементы нз А (q + l ..r]­
точно так же в массив С. Теперь можно вернуть эти элементы назад в A( p.. r), не боясь
перезаписать имеющиеся там элементы копиями.
Мы сливаем элемеtrrы массива точно так же, как книги. Будем копировать элемJнты
массивов В и С обратно в подмасснв A[ p..r], поддерживая индексы в этих массивах для
того, чтобы отслеживать наименьшие элементы, все еще не скопированные нз массивов
В и С, и копировать обратно минимальный нз них. За константное время мы можем вы­
яснить, какой нз элементов меньше, скопировать его в корректную позицию в А (p..r] и
обновить индексы в массивах.
В конце концов один нз двух массивов будет полностью перенесен обратно в A( p..r].
Эта ситуация соответствует моменту, когда остается только одна стопка книг. Чтобы из­
бежать необходимости проверять каждый раз, не исчерпался ли полностью один из мас­
сивов, прибегнем к хитрости, разместив в правом конце каждого из массивов В и С допол­
нительный элемент, который заведомо больше любого другого элемента. Помните трюк с
ограничителем, который мы использовали в процедуре SENTTNEL-LINEAR-SEARCH в главе 2,
"Описание и оценка компьютерных алгоритмов''? Используемая при слиянии идея очень
похожа на трюк с ограничителем. Здесь мы используем в качестве ключа ограничителя
значение оо (бесконечность)3, так что, когда все элементы из обоих массивов, В и С, скопи­
рованы обратно в исходный массив, в обоих массивах в качестве наименьших элементов
остаются ограничители. Но сравнивать при этом ограничители между собой не потре­
буется, потому что к этому времени все "реальные" элементы уже скопированы обратно
в A(p..r]. Поскольку мы заранее знаем, что будем копировать назад элементы начиная с
А(р] и заканчивая A[r], мы можем прекратить копирование, как только скопируем эле­
мент A(r]. Таким образом, можно просто использовать цикл, в котором индекс в массиве
А пробегает значения от р до r.
Вот как выглядит процедура MERGE. Она кажется длинной, но она всего лишь строго
следует описанному выше методу.

Процедура MERGE(A,p,q,r)
Вход:

• А: массив.
• р, q, r: индексы в массиве А.
. Подмассивы
рrированными.

A( p..q)

и

A[q + l .. r]

считаются уже 01'СО-

Ре3}�1ьтат: подмассив A[p..r], содержащий все элемеНТЪI, изначально находившиеся в
подмассивах А [p..q] и А [q + l ..r]. но теперь nодмассив А (p. .r] отсорrирован.
1. Установить п1 равным q- р + 1, а п2 - равным r- q.
J На проктике представляется значение.w. заведтwо большиw лю6о?о ключа сортировки. На­
приwер. при сортировке по авторам это может быть "Яяяяяя" - конечно. в предположении. что
такого автора на cawo.w деле не существует.

Глава 3. Алгоритмы сортировки и поиска

2. В [ l ..n1

57

+ J] и С[ 1 ..п2 + 1] представляют собой новые массивы.

3. Скопиромrь A[p..q)в B[l ..n1 ], а A[q + J ••r]- вС[1.л2 ).

4. Установить

в[ nl + t) и с[п2 + 1] равными 00.

5. Установить i иj равными 1.

6. Дnя k = р до r
А. Если B[i]� C(j], установить A(k] равны.м B[i] и увеличить i на 1.
В. В против1юм случае(В{i] >С(j}) установить А(k)равным С(j)и увеличитьjна 1.
В результате шагов 1-4 выделяется память для массивов В и С, выполняется копиро­
вание А(p..q] в В и А[q + I .J] в С, а также вставка в эти массивы ограничителей. После
этого каждая итерация цикла на шаге 6 копирует наименьший из оставшихся в массивах В
иС элементов в очередную позицию A[p .J], и цикл завершается после того, как обратно
в A[ p..r] будут скопированы все элементы из массивов В и С. В этом цикле i индексиру­
ет наименьший остающийся элемент в В, а j - наименьший остающийся элемент в С.
Индекс k указывает позицию в А , куда будет помещен очередной копируемый элемент.
Если мы сливаем вместе п элементов(так что п = п1 + п2), этот процесс требует времени
Е>( п) для копирования элементов в массивы В и С и константного времени для копирова­
ния каждого элемента из массивов В и С обратно в А, так что суммарное время работы
алгоритма равно Е>( п ).
Ранее мы утверждали, что алгоритм сортировки слиянием имеет время работы
E>{nlgn). Мы сделаем упрощающее предположение о том, что размер массива п пред­
ставляет собой степень 2, так что каждый раз, когда мы делим массив пополам, размеры
подмассивов равны. (В общем случае п может не быть степенью 2, а потому размеры под­
массивов могут не быть равными в конкретном рекурсивном вызове. Справиться с этой
ситуацией может строгий математический анализ, но в этой книге мы не будем утруждать
себя его проведением.)
Вот как мы анализируем время работы сортировки слиянием. Пусть сортировка под­
массива из п элементов занимает время Т ( п ), которое представляет собой функцию, ра­
стущую с ростом п(очевидно, что чем больше элементов, тем больше требуется времени
для их сортировки). Время r(п) состоит из трех суммируемых воедино компонентов па­
радигмы "разделяй и властвуй".
1. Разделение занимает константное время, поскольку состоит только в вычислении ин­
деlfса q.
2. Властвование состоит из двух рекурсивных вызовов для подмассивов, каждый разме­
ром п/2 элементов. В соответствии с определением времени сортировки подмассива
каждый из этих двух рекурсивных вызовов занимает время Т ( п/2 ).
3. Объединение результатов двух рекурсивных вызовов с помощью слияния отсортиро­
ванных подмассивов выполняется за время Е>(п ).

58

Глава З. Алгоритмы сортировки и поиск.а

Поскольку константное время для разделения имеет более низкий по сравнению со
временем объединения Е>( п) порядок, оно поглощается временем слияния, и можно счи­
тать, что разделение и объединение вместе выполняются за время Е>( п ). Шаг властвова­
ния выполняется за время Т( п/2) + Т ( п/2 ), или 2Т ( п/2 ). Таким образом, мы можем запи­
сать уравнение для Т ( п) следующим образом:

Т(п) = 2Т(п/2)+ /(п),

где f (п) представляет время, необходимое для разделения и слияния, которое, как мы уже
упоминали, представляет собой Е>( п). В изучении алгоритмов распространенной прак­
тикой является помещение в правой части уравнения асимптотических обозначений для
представления некоторой функции, не заботясь о том, чтобы присвоить ей имя, так что
указанное уравнение можно переписать как

Т(п) = 2Т(п/2) +Е>(п).

Минутку! Похоже, здесь что-то не так. Мы определили функцию Т, которая описывает
время работы сортировки слиянием, через ту же самую функцию! Мы называем такую за­
пись рекуррентным уравнением, или просто рекуррентностью. Проблема заключается
в том, что мы хотим выразить Т ( п) нерекурсивным способом, т.е. не через саму эту функ­
цию. Такая задача может оказаться настоящей головной болью, но для широкого класса
рекуррентных уравнений можно применить метод, известный как "основной метод". Он
применим ко многим (хотя и не ко всем) рекуррентностям вида Т(п)=аТ(п/Ь)+ f(n),
где а и Ь - положительные целые константы. К счастью, он применим и к нашему рекур­
рентному соотношению для сортировки слиянием и дает результат, состоящий в том, что
Т ( п) имеет вид Е>(п lg п ).
Это время - Е>( п lg п)- относится ко всем случаям сортировки слиянием - наилуч­
шему случаю, наихудшему случаю и ко всем промежуточным. Каждый элемент копиру­
ется Е>(п lg п) раз. Как видно из рассмотрения метода MERGE, когда он вызывается с р = 1
и r = п, он делает копии всех п элементов, так что сортировка слиянием, определенно, не
работает "на месте".

Быстрая сортировка
Как и сортировка слиянием, быстрая сортировка использует парадигму "разделяй и
властвуй" (а следовательно, использует рекурсию). Однако применение принципа "раз­
деляй и властвуй" быстрой сортировкой несколько отличается от случая сортировки сли­
янием. Быстрая сортировка имеет и пару других существенных отличий от сортировки
слиянием.
•

Быстрая сортировка работает "на месте", без привлечения дополнительной памяти.

•

Асимптотическое время работы быстрой сортировки для среднего случая отличается
от времени работы для наихудшего случая.

У быстрой сортировки, кроме того, достаточно хороший постоянный множитель (луч­
ше, чем у сортировки слиянием), так что на практике чаще всего предпочтение отдается
быстрой сортировке.

Глава 3. Алгоритмы сортировки и поиска

59

Вот как быстрая сортировка применяет парадигму "разделяй и властвуй". Вновь вер­
немся к нашей книжной полке. Как и в случае сортировки слиянием, изначально мы хотим
отсортировать все п книr в слотах с первого до n-ro и при этом рассматриваем обобщен­
ную задачу сортировки книr в слотах с р по r.
l. Рtпделение. Сначала выберем одну книгу из слотов от р по r. Назовем Э1)' книгу опор­
ной. Переставим книги на полке так, чтобы все книги с авторами, идущими в алфавит­
ном порядке до автора опорной книги (или с автором, совпадающим с автором опор­
ной книги), находились слева от опорной, а книги с авторами, идущими по алфавиту
после автора опорной книги, - справа от последней.
В данном примере выберем крайнюю справа книгу - Казакевича - в качестве опор­
ной для перестановки книr в слотах с 9 по 15.

9

10

11

12

13

14

15

После перестановки - которая в быстрой сортировке носит название разбиения книги Васильева и Адамовича, идущих по алфавиту до Казакевича, оказываются слева
от книги Казакевича, а все остальные книги, авторы которых в алфавитном порядке
идут после Казакевича, оказываются справа. Заметим, что после разбиения книги как
слева от книги Казакевича, так и справа, не располагаются в каком-то конкретном
порядке.
2. Властвование. Осуществляется путем рекурсивной сортировки книr слева и справа
от опорного элемента. То есть если при разделении опорный элемент вносится в слот
q ( слот 11 в нашем примере), то рекурсивно сортируются книги в слотах с р по q- l и с
q+ l по r.
3. Объединение. На этом этапе мы ничего не делаем! После рекурсивной сортировки
мы получаем полностью отсортированный массив. Почему? Авторы всех книr слева
от опорной (в слотах с р по q-1) идут по алфавиту до автора опорной книги, и книги
отсортированы, а авторы всех книr справа от опорной (в слотах с q + 1 по r) идут по
алфавиту после автора опорной книги, и все эти книги также отсортированы. То есть
отсортированы все книги в слотах начиная со слота р и заканчивая слотом r!
При замене книжной полки массивом, а книr - элементами массива мы получим
компьютерный алгоритм быстрой сортировки. Подобно сортировке слиянием, базовый
случай осуществляется, когда сортируемый подмассив содержит менее двух элементов.
Процедура быстрой сортировки подразумевает вызов процедуры PлRТ1TtoN(A,p,r), ко­
торая разбивает подмассив A[p.. r] и возвращает индекс q позиции, в которую помещается
опорный элемент.

60

Глава 3. Алгоритмы сортировки и поиска

Процедура Quк:КSORТ(Ap,r)

Вход и результат: те же, что и у процедуры MEROE·Soп.

l. Если р � r, просто выйти из процедуры, нс вьmоnнu НИIС81СИХ действий.

2. 8 Противном случае ВЫПО/IНИТЬ следующее.
f
А. Вызвать PAR11110N(Ap,r) и установить значение q равным результаrу вызова.
В. Рекурсивно вызвать Qwcкs oRТ{A JJ.q-1).
С. Рекурсивно вызвать Qu1CКSORТ(A, q + l ,r).

Первоначальный вызов Qшскsокr(А,1,п) аналогичен вызову процедуры MERGE-SoRт.
Вот пример работы процедуры QшскsоRт с развернутой рекурсией. Для каждого подмас­
сива, в котором р 5 r, указаны индексы р, q и r.
р
1

2

3

4

S

r

6

7

8

9

10

6

7

8

9

10

q
8

9

r
10

! 9171 5 1•111212 \t41 з 110161
р
1

2

3

q

4

+

S

r

1 s 121 зl6l1211114l 9 lto/11j

+

+

р
5

6

7

11191101111141121
p,r

p,r

шш
1

3

р
5

+

6

1719

+

1@.J

р q,r
5 6

0IJ
+

q,r
7

+

p,q r
9 10

1121§

t

p,r
1О

�

p,r
5

Самое нижнее значение в каждой позиции массива показывает, какой элемент будет
находиться в этой позиции по завершении сортировки. При чтении массива слева направо
смотрите на самые нижние значения в каждой позиции, и вы убедитесь в том, что массив
отсортирован.
Ключом к быстрой сортировке является разбиение. Так же, как мы смогли слить п элемен­
rов за время е(п) в сортировке слиянием, мы можем разбить п элеменrов за время Е>(п).

Глава 3. Алгоритмы сортировки и noucl((l

61

Вот как мы будем разбивать книги, которые находятся на полке в слотах с р по r. В ка­
честве опорной выбираем крайнюю справа книгу - из слота r. В любой момент каждая
книга может находиться в одной из четырех групп, и эти группы располагаются в слотах
от р до r слева направо.
• Группа L (левая): книги с авторами, о которых известно, что они располагаются в алфа­
витном порядке до автора опорной книги или написаны автором опорной книги.
• Далее идет группа R (правая): книги с авторами, о которых известно, что они распола­
гаются в алфавитном порядке после автора опорной книги.
• Затем идет группа U (неизвестная): книги, которые мы еще не рассмотрели и не знаем,
как их авторы располагаются по отношению к автору опорной книги в алфавитном
порядке.
• Последней идет группа Р (опорная): в нее входит единственная опорная книга.
Мы проходим по книгам группы U слева направо, сравнивая каждую из них с опорной
и перемещая ее либо в группу L, либо в группу R, останавливаясь по достижении опорной
книги. Книга, которую мы сравниваем с опорной, - всегда крайняя слева в группе U.
• Если автор книги находится в алфавитном порядке после автора опорной книги, то
книга становится крайней справа в группе R. Поскольку до этого она была крайней
слева в группе U, а за группой U непосредственно следует группа R, мы должны про­
сто переместить разделительную линию между группами R и U на один слот вправо,
без перемещения каких-либо книг.

-�-----_,9

L

•

10

11

R

12

13
U

14

IS

Р

9

10

11

12

13

14

IS

_ ______,�,....,-,
U
Р
L

R

Если автор книги находится в алфавитном порядке до автора опорной книги или со­
впадает с автором опорной книги, то эта книга становится крайней справа в группе L.
Мы обмениваем ее с крайней слева книгой в группе R и перемещаем разделительную
линию между группами L и R и между группами R и U на один слот вправо.

9

10

11

12

13

14

15

U

Р

..____.., '- --........ _.-' � "-v-"
L

R

62

Глава 3. Алгоритмы сортировки и поиска

Добравшись до опорной книги, мы обмениваем ее с крайней слева книгой группы R.
В нашем примере разбиение завершается расстановкой книг, показанной на рис. на с. 59.
Мы сравниваем каждую книгу с опорной один раз, и с каждой книгой, автор которой
находится в алфавитном порядке до автора опорной книги или совпадает с автором опор­
ной книги, выполняется один обмен. Для разбиения п книг, таким образом, делается не
более п-1 сравнения (так как нам не нужно сравнить опорную книгу саму с собой) Jf не
более п обменов. Обратите внимание, что, в отличие от слияния, книги можно разбить без
снятия их всех с полки, т.е. разбиение выполняется на месте, без привлечения дополни­
тельной памяти.
Чтобы преобразовать разбиение книг на полке в разбиение подмассива А( p"r ], мы сна­
чала выбираем крайний справа элемент A(r] в качестве опорного. Затем мы проходим
через подмассив слева направо, сравнивая каждый элемент с опорным. Мы поддерживаем
в подмассиве индексыq и и, которые разделяют его следующим образом:
• подмассив А ( p"q -1] соответствует группе L: каждый его элемент не превышает
опорный;
• подмассив А [q. .u -1] соответствует группе R: каждый его элемент больше опорного;
• подмассив А[и"r-1] соответствует группе U: нам пока неизвестно, как его элементы
соотносятся с опорным;
• элемент А [ r] соответствует группе Р: это опорный элемент.
Это разделение, по сути, представляет собой инвариант цикла (но мы не будем его до­
казывать).
На каждом шаге мы сравниваем крайний слева элемент группы U А[и] с опорным эле­
ментом. Если А[и] больше опорного элемента, мы увеличиваеми, чтобы переместить раз­
делительную линию между группами R и U вправо. Если же А [и] не превышает опорный
элемент, мы обмениваем элементы A(q] (крайний слева элемент в группе R) и А[и], а
затем увеличиваем q и перемещаем разделительные линии между группами L и R и груп­
пами R и U вправо. Вот как выглядит процедура PARTITION.
Процедура РARTmON(A ,p,r)
Вход: тот же, что и для MERGE-SoRT.
Результат: перестановка элементов A(p. .r], такая, что каждый 'ЭЛемент в A(p..q-1]
не превышает А[q ), а каждый элемент в А[q + l . .r] больше А[q ). Возвращает значение
индексаq.
1. Установить q равным р.
2. Для и = р до r-1:
А. Если А[и]� A[r], обменять A[q] с А[и1 а затем увеличитьq на 1.
3. Обменять A[q] и A[r1 а затем вернутьq.

Глава 3. Алгоритмы сортировки и поиска

63

Поскольку изначально значения обоих индексов q и и равны р, группы L (А [p..q -1 р
и R (A[q . .u-1)) в начале работы алгоритма пустые, а группа U (A[u..r-1)) содержит при
этом все элементы, за исключением опорного. В некоторых случаях, например, при
А [ р) :s; А [r ), элемент может меняться местами с самим собой, что не влечет за собой ни­
каких изменений в массиве. Шаr 3 заканчивается обменом опорного элемента с крайним
слева элементом в группе R, тем самым опорный элемент перемещается в его правильное
место в разбитом массиве, после чего процедура возвращает новый индекс q опорного
элемента.
Вот как пошаrово работает процедура PдRТITION с подмассивом A[S .. 10), созданным
при первом разбиении в примере быстрой сортировки на с. 62. Группа U показана белым
цветом, группа L имеет легкое затенение, группа R окрашена в более темный цвет, и тем­
нее всех изображен опорный элемент, который представляет собой группу Р. В первой
части рисунка показаны исходные массив и индексы, следующие пять частей показывают
массив и индексы после каждой итерации цикла на шаге 2 (включая увеличение индекса и
в конце каждой итерации), а последняя часть показывает окончательный разбитый массив.
p,q,u

5 6 78 9

г

10

11211j14j9[101D
р

q

и

г

р

p, q

5

р

q

и

г

� �
�
q

и

г

р

q

u,r

5678910

���-.�
�

�

р
5

6 7
7 9 10
Возврат8

Как и при разбиении множества книг на книжной полке, мы по одному разу сравни­
ваем каждый элемент с опорным и выполняем не более одного обмена для каждого эле­
мента, который сравниваем с опорным. Поскольку и каждое сравнение, и каждый обмен
занимают константное время, общее время работы процедуры PдRТITION сп-элементным
подмассивом равно е ( п ).
Так каково же время работы процедуры Qu1cкs0Rт? Обозначим, как и в случае сорти­
ровки слиянием, время сортировки подмассива изп элементов как Т(п)- функцию, кото­
рая увеличивается с ростом п. Разбиение с помощью процедуры PдRТITION занимает время
е( п) . Но время работы быстрой сортировки зависит от того, как именно выполняется
разб'fние.
В наихудшем случае размеры разделов являются несбалансированными. Если каждый
элемент, отличный от опорного, оказывается меньше последнего, разбиение оставляет
опорный элемент в А [г) и возвращает индекс r процедуре QшскsоRт, которая сохраняет
это значение в переменной q. В этом случае подмассив А [q + l .. r) является пустым, а мас­
сив А [ р..q -1) только на один элемент меньше, чем массив А [ p..r) . Рекурсивный вызов для
пустого подмассива выполняется за время 0(1) (время, необходимое для осуществления

64

Глава 3. Алгоритмы сортировки и поиска

вызова и определения на шаге 1, что подмассив пуст). Этим временем можно пренебречь
и скрыть его �о времени Е>(п), необходимом для разбиения. Но если A( p..r) имеет п эле­
ментов, то А (p..q -1] содержит п -1 элемент, а потому рекурсивный вызов для подмассива
А ( p..q -1] занимает время Т ( п -1 ). Таким образом, мы получаем рекуррентное соотноше­
ние Т ( п) = Т (п -1) + 0 ( п ).
Хотя мы и не можем решить это рекуррентное соотношение с помощью основно�il ме­
2 Это не лучше, чем сортировка выбором! Но
тода, оказывается, что Т(п) имеет вид
как мы можем получить такое неравномерное разбиение? Только если каждый опорный
элемент больше всех прочих элементов, т.е. массив должен быть изначально отсортиро­
ван. Оказывается также, что мы получаем неравномерное разделение и тогда, когда массив
изначально отсортирован в обратном порядке.
С другой стороны, если всякий раз каждый из подмассивов будет иметь размер n/2, то
рекуррентное с�ношение для времени работы окажется таким же, как и рекуррентное
соотношение на с. 58 для сортировки слиянием, а именно

e(n ).

Т(п) = 2Т(п/2)+0(п),
и будет иметь то же самое решение - что Т(п) представляет собой 0(nlgn). Конечно,
надо быть удивительным везунчиком, чтобы всякий раз при разбиении подмассива он раз­
бивался на строго равные части.
Обычный случай лежит где-то посредине между наилучшим и наихудшим. Матема­
тический анализ этого вопроса достаточно сложен, и я не хочу мучить вас им, так что
изложу только выводы: если элементы входного массива располагаются в случайном по­
рядке, то в среднем мы получаем разделения, достаточно близкие к разбиениям пополам,
так что быстрая сортиР?вка имеет при этом время работы 0 (п lgп ).
Теперь давайте ненадолго станем параноиками. Предположим, что ваш злейший враг
дал вам массив для сортировки, зная, что вы всегда выбираете в качестве опорного по­
следний элемент в каждом подмассиве, и организовал массив так, что вы всегда будете по­
лучать наихудшие разбиения. Как помешать этому злокозненному врагу? Конечно, можно
начать с проверки, не отсортирован ли массив изначально, и поступать в таких случаях
особым образом. Но ведь ваш враг тоже не дурак и может придумать массив, в котором
разбиения всегда плохие, но не предельно плохие. Вы же не будете проверять все возмож­
ные плохие случаи?
К счастью, есть гораздо более простое решение: не всегда выбирать в качестве опорно­
го последний элемент. Но ведь тоrда тщательно выверенная процедура PARTIТION не будет
работать, потому что группы элементов окажутся не на своих местах? Это не проблема:
достаточно перед выполнением процедуры PARTJTION поменять А [ r] с некоторым произ­
вольно выбранным элементом из A( p..r). Теперь опорный элемент выбран случайным об­
разом, так что далее вы можете смел.о запускать обычную процедуру PARТITION.
В действительности ценой небольших усилий можно повысить шансы на получение
хороших разбиений. Вместо случайного выбора одного элемента из A( p..r) выберите три
случайных элемента и обменяйте с А (r) их медиану. Под медианой трех элементов подраз­
умевается тот элемент, значение которого находится между двумя другими (если два или

65

Глава 3. Алгоритмы сортировки и поиска

более из случайно выбранных элементов равны, выберите медиану произвольно). Я вновь
не хочу мучить вас анализом, но вам нужно быть действительно уникально невезучим,
чтобы процедура QutcкsoRт при этом имела время работы большее, чем 0{nlgn). Кроме
того, если только ваш враг не имеет доступа к вашему генератору случайных чисел, он
никоим образом не сможет устроить вам козни и затормозить работу сортировки путем
подбора соответствующих входных данных.
Сколько же раз процедура QutcкsoRТ обменивает элементы? Это зависит от того, счи­
тать ли "обменом" ситуацию, когда элемент должен обменяться местами с самим собой.
Естественно, всегда можно проверить, не пытаемся ли мы обменивать элемент сам с собой,
и, если это так, не выполнять никаких действий. Поэтому будем считать обменом только те
случаи, когда элементы действительно перемещаются в массиве, т.е. когда q и на шаге 2А
или когда q r на шаге 3 процедуры PлRTtTJON. Наилучший случай с точки зрения миними­
зации обменов является также одним из наихудших в смысле асимптотического времени
работы: когда массив изначально отсортирован. В этом случае обмены не выполняются.
Наибольшее количество обменов осуществляется, когда п четно и входной массив име­
ет вид п, п -2, п -4, ... , 4, 2, 1, 3, 5, ... , п -3, п -1. В этом случае выполняется п 2/4 обменов, и
асимптотическое время работы алгоритма соответствует наихудшему случаю 0(п2

*

*

).

Резюме
В этой и предыдущей главах вы познакомились с четырьмя алгоритмами поиска и
четырьмя алгоритмами сортировки. Давайте подытожим их свойства в двух таблицах.
Поскольку три алгоритма поиска в главе 2, "Описание и оценка компьютерных алгорит­
мов", были всего лишь вариациями, в качестве представительного алгоритма для линей­
ного поиска достаточно рассмотреть BETTER-LtNEAR-SEлRcн или SENTINEL-LJNEAR-SEARCH.

Алгоритмы поиска
Алгоритм

Врем11 работы
в наихудшем случае

Время работы
в наилучшем случае

Требует ли отсортированного
входного массива

Линейный поиск

0{п)

0(1)

Нет

Бинарный поиск

0(1gn)

0(1)

Да

Алгоритмы сортировки
Время работы в Обменов в наиВыполняется ли
Алгоритм
Время работы в
сортировки наихудшем случае наилучшем случае худшем случае сортировка на месте
Выбором
Вставкой
Слиянием
Быстрая

0( п 2 )
0(п

2

)

0(nlgn)
0(п

2

}

0(п 2 )
0(п)
0(nlgn)
0(nlgn)

0{п)
0(п

2

)

0(nlgn)
2

0(п )

Да
Да
Нет
Да

68

Глава

З. Алгоритмы сортировки и поиска

В таблицах не показано время работы в среднем случае, поскольку, за исключением
быстрой сортировки, оно соответствует времени работы в наихудшем случае. Как мы ви­
дели, в среднем случае (в предположении случайно упорядоченноrо массива) быстрая со­
ртировка работает за время, составляющее всеrо лишь Е>( п lgn ).
Как соотносятся эти алrорнтмы сортировки на практике? Я реализовал их на языке
программирования С++ и применил к массивам 4-байтовых целых чисел на двух разlrых
компьютерах: на моем МасВооk Pro (на котором я писал эту книгу) с процессором lпtel
Core 2 Duo 2.4 ГГц и 4 ГБайт ОЗУ под управлением Мае OS 10.6.8 и на Dell РС (сервер
моеrо веб-сайта) с процессором 3.2 ГГц Intel Pentium 4 и I ГБайт ОЗУ под управлени­
ем Linux версии 2.6.22.14. Код компилирован компилятором g++ и уровнем оптимиза
ции -03. Каждый алrоритм тестировался на массиве размером до 50000 элементов; каж­
дый массив изначально был отсортирован в обратном порядке. Я усреднял времена рабо­
ты по 20 запускам для каждоrо алrоритма и каждоrо размера массива.
Используя массивы, отсортированные в обратном порядке, я сознательно получал
наихудший случай для сортировки вставкой и быстрой сортировки. Быструю сортиров­
ку я реализовал в двух вариантах: детерминистическую (т.е. действия которой всегда
выполняются одинаково), которая всегда выбирает в качестве опорноrо последний эле­
мент подмассива А [ р. .r и рандомизированную, которая перед разбиением меняет А [ r] со
случайно выбранным элементом из A[ p"r] (метод медианы трех случайных элементов я
реализовывать не стал).
Рандомизированная быстрая сортировка оказалась чемпионкой для п � 64 на обоих
компьютерах. Вот отношение времени работы других алrорнтмов ко времени работы ран­
домизированной быстрой сортировки для входных данных разных размеров.

1

MacBookPro
Алгоритм сортировки
Выбором
Вставкой
Слиянием
Детерминистическая
быстрая

50

100

500

1.34
1.08
7.58
1.02

2.13
2.о2
7.64
1.63

8.04
6.15
6.93
6.09

50

100

500

0.76
1.01
3.21
1.12

1.60
1.66
3.38
1.37

5.46
7.68
3.57
6.52

п

1000

5000

10000

50000

13.31
11.35
6.87
11.51

59.07
51.86
6.35
52.02

114.24
100.38
6.20
100.57

537.42
474.29
6.27
475.34

1000

5000

10000

50000

12.23
13.90
3.33
9.30

52.03
68.34
3.36
47.60

100.79
136.20
3.37
97.45

496.94
626.44
3.15
466.83

De/1 РС
Алгоритм сортировки
Выбо ром
В ставкой
Слиянием
Детерминистическая
быстрая

п

Рандомизированная быстрая сортировка выглядит очень хорошо, но и ее можно превзойти. Вспомним, что сортировка вставкой очень хороша, когда элемент не должен

67

Глава 3. Алгоритмы сортировки и поиска

двигаться по массиву далеко. Но как только размер подзадачи в рекурсивном алгоритме
опускается до некоторого значения k, то никакой элемент не будет перемещаться более
чем на k -1 позиций. Поэтому вместо тоrо, чтобы продолжать рекурсивный вызов рандо­
мизированной быстрой сортировки для подзадач небольших размеров, можно восполь­
зоваться сортировкой вставкой. Действительно, такой гибридный метод позволяет пре­
взойти рандомизированную быструю сортировку. Я обнаружил, что на моем MacBook Pro
оптимальным для переключения алгоритмов был размер подзадачи, равный 22, а на
Dell РС оптимальным был размер 17 элементов. Ниже приведены отношения времен ра­
боты rибрндноrо и рандомизированноrо алгоритмов быстрой сортировки на обеих маши­
нах для задач разных размеров.
Машина
MacBook Pro
Dell РС

50

100

500

0.55

0.56
0.58

0.60
0.60

0.53

п

1000

5000

10000

50000

0.60
0.58

0.62
0.60

0.63
0.64

0.66
0.64

Можно ли превзойти время сортировки 0( п lg п )? Это зависит от тоrо, что и как сорти­
руется. Мы увидим в главе 4, "Нижняя граница времени сортировки и как ее превзойти",
что если единственным способом определения порядка размещения элементов является
их сравнение, то превзойти время 0( п lgn) невозможно. Но если имеется дополнительная
информация о сортируемых элементах, то моrут быть ситуации, когда это время сортиров­
ки можно превзойти.

Дальнейшее чтение
В CLRS [4] рассматриваются сортировка вставкой, сортировка слиянием, а также де­
терминистическая и рандомизированная быстрая сортировки. Но суперкниrой о сорти­
ровке и поиске остается том 3 Искусства програw.мирования Д. Кнута (Donald Кnuth) [12].
Здесь применим совет из главы 1 нашей книrи: если вы не боитесь трудностей и матема­
тических сложностей, обратитесь к Искусству программирования.

4 •.. Нижняя граница времени сортировки
и как ее превзойти
В предыдущей главе вы познакомились с четырьмя алгоритмами для сортировки п эле­
ментов в массиве. Два из них, сортировка выбором и сортировка вставкой, имеют время
работы в наихудшем случае, равное 0( п2 ) , что не очень-то хорошо. Один из алгорит­
мов, алгоритм быстрой сортировки, в наихудшем случае имеет время работы 0( п2 ) , но
в среднем случае выполняет сортировку только за время 0{ пlg п) . Сортировка слиянием
имеет время работы 0(nlgn) во всех случаях. На практике наиболее эффективной явля­
ется быстрая сортировка, но если вы хотите абсолютно гарантированно защититься от
наихудшего случая, следует использовать сортировку слиянием.
Но насколько хорошим является время 0( пlg п)? Нельзя ли разработать алгоритм со­
ртировки, который в наихудшем случае превзойдет время 0(nlgn)? Ответ зависит от
правил игры: как алгоритм сортировки может использовать ключи сортировки для опреде­
ления порядка сортировки?
В этой главе мы увидим, что при определенном наборе правил превзойти время работы
0{ пlg п) невозможно. Затем мы рассмотрим два алгоритма сортировки, сортировку под­
счетом и карманную сортировку, которые используют другие правила, а потому в состоя­
нии выполнять сортировку за время всего лишь 0( п).

Правила сортировки
Если рассмотреть, как четыре алгоритма из предыдущей главы используют ключи со­
ртировки, то можно увидеть, что они определяют порядок сортировки, основываясь толь­
ко на сравнении пары ключей. Все принимаемые ими решения имеют вид "если ключ
сортировки этого элемента меньше, чем ключ сортировки другого элемента, то то-то, а в
противном случае либо сделать что-то еще, либо ничего не делать". Вы можете подумать,
что алгоритм сортировки может принимать решения только такого вида. А какие еще
виды решений он в состоянии принимать?
Чтобы убедиться в том, что возможны и другие виды решений, давайте рассмотрим
очень простой пример. Предположим, что мы знаем две вещи о сортируемых элементах,
а именно - что каждый ключ сортировки является либо единицей, либо двойкой и что
элементы состоят только из ключей сортировки, не имея никаких сопутствующих данных.
В эlой простой ситуации можно сортировать п элементов за время 0( п), превзойдя ал­
горитмы со временем работы 0{nlgn) из предыдущей главы. Каким образом? Начнем с
того, что пройдем по всем элементам и подсчитаем, сколько среди них единиц, - скажем,
это k элементов. Тогда можно вновь пройти через массив, устанавливая значение I в пер­
вых k позициях, а затем устанавливая значение 2 в остальных п - k позициях. Вот как
выглядит соответствующая процедура.

70

Глава 4. Нижюu, граница времени сортировки и как ее превзойти

Процедура REAI..Lv·Sn.O'l.l!-SoRТ(A,n)
Вход:

• А: м ассив, все элементы котороrо имеют значе1tИJ1 1 или 2.
• n: J<ОЛИЧество сортируемых элементов А.
Результат: элементы А отсорrироваиы в неубывающем
порядке.
1. Установить

r

k равным нулk>.

2. Для i=l доп:
А. Если .А [ i] = 1 , увеличиn. k на е ,11ИНицу.
3. Для i = 1

ДО k:

А. Установить A[i] равным 1.
4. Для i=k+1 доп:
А. Установить A[i] равным 2.
Шаги I и 2 подсчитывают количество единиц, увеличивая счетчик k для каждого эле­
мента A[i], равного 1. Шаг 3 заполняет подмассив A[l ..k] единицами, а шаг4 заполняет
остальные позиции, A[k+l ..n], двойками. Легко видеть, что эта процедура выполняется
за время <Э(п): первый цикл выполняет п итераций, как и два последних цикла вместе;
каждая итерация каждого цикла выполняется за постоянное время.
Обратите внимание, что процедура REлLLY-StMPLE-SORT никогда не сравнивает два эле­
мента массива один с другим. Она сравнивает каждый элемент массива со значением 1,
но не с другим элементом массива. Так что, как видите, в такой ограниченной ситуации
возможна сортировка без сравнения пар ключей сортировки.

Нижняя граница сортировки сравнением
Теперь, когда у вас есть некоторое представление о том. как могут варьироваться пра­
вила игры, давайте рассмотрим, насколько быстрой может быть сортировка.
Определим сортuр08ку сравнением как любой алгоритм сортировки, который опреде­
ляет порядок сортировки только путем сравнения пар элементов. Сортировкой сравнени­
ем являются четыре алгоритма сортировки из предыдущей главы, но не алгоритм REALLY­
StMPLE-SORT.

Вот нижняя граница сортировки сравнением.
В наихудшем случае любой алгоритм сортировки сравнением требует для
сортировки п элементов О(п lgп) сравнений пар элементов.
Вспомним, что Q -обозначение дает нижнюю границу, так что мы, по сути, говорим
"для достаточно больших п любой алгоритм сортировки сравнением требует в наихуд­
шем случае выполнения по крайней мере сп lgn сравнений для некоторой константы с".
Поскольку каждое сравнение выполняется по меньшей мере за постоянное время, это дает

Глава 4. НижН1111 граница времени сортировки и как ее превзойти

11

нам нижнюю границу O{nlgn ) времени сортировки п элементов при условии, что ис­
пользуется алгоритм сортировки сравнением.
Важно иметь ясное представление о нижней rранице. Первое - она говорит что-то
только о наихудшем случае. Вы всегда можете сделать алгоритм сортировки работающим
за линейное время в наилучшем случае: просто заявить, что наилучший случай - это
когда массив уже отсортирован, и просто проверить, что каждый элемент (за исключени­
ем последнего) не превышает его преемника в массиве. Это легко сделать за время <Э(п).
Если вы обнаружите, что каждый элемент не превышает его преемника, то сортировка
выполнена. Однако в наихудшем случае O{ nlgn ) сравнений являются необходимыми.
Мы называем эту нижнюю rраницу 1кзистенци1111ьной нижней rраницей, потому что
она уrверждает, что существуют входные данные, которые требуют О( п lg п) сравнений.
Другой тип нижней rраницы - универсально нижняя rраница, которая применима ко
всем входным данным. В случае сортировки единственной универсальной нижней rра­
ницей является О( п� поскольку мы должны взrлянуrь на каждый элемент по крайней
мере один раз. Обратите внимание, что в предыдущем предложении я не сказал, к чему
относится О(п ). Имел ли я в виду О(п) сравнений или время работы О( п)? Я подразуме­
вал время, поскольку мы должны проверить каждый элемент, даже если не сравниваем
элементы попарно.
Вторая важная вещь, которую следует сказать о нижней rранице, действительно за­
мечательна: это то, что нижняя rраница не зависит от конкретного алгоритма, лишь бы
этот алгоритм являлся алгоритмом сортировки сравнением. Нижняя граница применяется
к любо.wу алгоритму сортировки сравнением, независимо от того, насколько простым или
сложным он является. Нижняя rраница применима ко всем алгоритмам сортировки срав­
нением, которые уже были изобретены или еще только будуr открыты в будущем. Она
справедлива даже для тех алгоритмов сортировки сравнением, которые никогда не будуr
обнаружены человечеством!

Сортировка подсчетом
Мы уже видели, как превзойти нижнюю rраницу при очень оrраниченных условиях,
когда имеется только два возможных значения ключа сортировки, а каждый элемент со­
стоит только из ключа сортировки, без сопутствующих данных. В этом оrраниченном слу­
чае п элементов можно отсортировать за время <Э( п). без сравнения пар элементов.
Метод REдLLY-StMPLE-SORT можно обобщить на случай т различных возможных значе­
ний ключей сортировки, которые являются целыми числами из диапазона, представляю­
щеrр собой т последовательных целых чисел (скажем, от О до т -1), а элементы при этом
мoryr иметь сопуrствующие данные.
Вот в чем заключается идея. Предположим, мы знаем, что ключами сортировки явля­
ются целые числа в диапазоне от О дот -1. Кроме того, предположим, мы знаем, что ров­
но у трех элементов ключ сортировки равен 5 и что у шести элементов ключи сортировки
меньше 5 (т.е. находятся в диапазоне от О до 4). Тогда мы знаем, что в отсортированном
массиве элементы с ключом сортировки, равным 5, должны занимать позиции 7, 8 и 9.

72

Глава 4. Ни:жняя граница времени сортировки и как ее превзойти

Обобщая, если мы знаем, что у k элементов ключи сортировки равны х, а у / элементов
ключи сортировки меньше х, то элементы с ключами сортировки, равными х, в отсорти­
рованном массиве должны занимать позиции от / + 1 до / + k. Таким образом, нам надо
для каждого возможного значения ключа сортировки вычислить, у какого количества эле­
ментов ключи сортировки ключей меньше этого значения и сколько имеется элементов
f
с данным значением ключа сортировки.
Мы можем вычислить, у скольких элементов ключи сортировки меньше каждого из
возможных значений ключа, если начнем с того, что вычислим, у какого количества эле­
ментов ключи сортировки равны заданному значению. Начнем нашу работу с решения
этой задачи.

Процедура CouN1-KEvs-EQUAL(A .n,m)

Вход:
• А: массив целых чисел в диапазоне от О дот-1.
•

п: количество элементов в массиве А.

• т: определяет диапазон значений в массиве А.

Выход: массив equal[O.m-11 такой, что equal(j] содержит )(()J1ИЧество элементов мас­
сива А, равныхj, для j =0, 1,2, ... ,m- l.

1. Пусть equal[ О.т -1] представляет собой новый массив.
2. Установить все значеиИJ1 массива equal равными нулю.
3. Дnя i = 1 доп:

А. Установить значение переменной key равным A [i].
В. Увеличить equal[ key] на единицу.

4. Вернуть массив equa/.
Обратите внимание, что процедура Coum-KEvs-EQUAL никогда не сравнивает ключи
сортировки один с другим. Она использует ключи сортировки только в качестве индекса в
массиве equal. Поскольку первый цикл (неявный цикл на шаге 2) делает т итераций, вто­
рой цикл (на шаге 3) делает п итераций, и каждая итерация каждого цикла выполняется за
константное время, процедура COUNТ-KEvs-EQUAL выполняется за время 0( п + т ). Если т
является константой, то время работы CouNТ-KEvs-EQUAL равно 0( п ).
Теперь мы можем использовать массив equal для выяснения, у какого количества эле­
ментов ключи сортировки меньше каждого возможного значения.

Процедура CoUNТ-Квvs-Lвss(equa/,m)

Вход:
•

equa/: массив, возвращаемый вызовом процедуры Cowr-КEvs-EQUAL.

• т: определяет диапазон индексов массива equal - or О дот - l.

Глава 4. Нижняя граница времени сортировки и как ее превзойти

73

Выход: массив /ess[O.m-1], такой, что дrIJI j=0,1,2, ... ,m-l элемент less[j] содержит
сумму equal[O]+ equal[l]+···+ equal(j-1].
l. Пусть /ess[O..m-1] представт�ет собой новый массив.

2. Установить less [О] равным нулю.
3. Дл,1 j =) ДО m-J:
А. Установкrь less[j] равным less[j-l]+equal(j- l].

4. Вернуть массив less.

В предположении, что equal[j] дает точное количество элементов, ключи сортировки
которых равныj, дпя j=O,l, ... ,m-1, можно использовать следующий инвариант цикла,
чтобы показать, что по завершении работы процедуры CoUNТ-KEYS-LEss значение less[j]
равно количеству ключей сортировки, меньших j.
В начале каждой итерации цикла на шаге 3 значение /ess (j -1] равно количе­
ству ключей сортировки, меньших j -1.
Расписать части инициализации, сохранения и завершения я предоставляю читателю.
Можно легко увидеть, что процедура CouNт-KEYS-LEss выполняется за время 0( т ). И она,
определенно, не выполняет ни одного сравнениJI ключей одного с другим.
Рассмотрим пример. Предположим, что т = 7, так что все ключи сортировки являются
целыми числами в диапазоне от О до 6, и у нас есть следующий массив А с п = 1 О элемента­
ми: А= (4,l,5,0,1,6,5,l,5,3). Тогда equa/ = (l,3,0,l,l,3,1) и less = (0,1,4,4,5,6,9). Поскольку
less[5] = 6, а equa1[5] = 3 (вспомните, что индексы массивов /ess и equal начинаются с О, а
не с 1 ), по окончании сортировки позиции с 1 по 6 должны содержать значения ключей,
меньшие, чем 5, а в позициях 7, 8 и 9 должно содержаться значение ключа, равное 5.
Когда у нас есть массив /ess, мы можем создать отсортированный массив, хотя и не на
месте.
Процедура REARRI\NGU(A,LESS,N,M)
Вход:
• А: массив целых чисел в диапазоне <rr О до т-l .

• less: массив, возвращаемый процедурой CoUNТ-1<.Evs-LESs.
• п: количество элементов в массиве А.
• Jm: определяет диапаюн значеняй элементов R массиве А.
Выход: массив В, содержащий элементы массива А в отсортированном порядке.
1 . Пусть В[ J • .п] и next[ О..т-1] - новые массивы.
2. Для j = 0

ДО

m-1 :

А. Установить next(j] равным /ess[j)+J.

Глава 4. HuжНRR граница времени сортировки и как ее превзойти
0

Jess

1

2

3

4

S

6

IOl1\4\4IS1б\9I

next / l l 2 1 S / S / б j 1 \ 1oj

next

1

2

S

3

S

4

7

7/

S

S

7

7

j

next / l j

j

3

4

S

6

7

8

9

10

1

2

3

4

5

6

7

8

9

10

4

5

l4ltjs\oltl6IS1tls\зl
1 в1 1 1 1 1 1 1 1 1 1 1
А

t

6

А

1

1

t

1

2

3

4

5

6

7

8

9

10

1

2

3

4

5

6

7

8

9

10

1

1

4

5

l4/Il5\0/Il6/S1I\S/3\
0 1 2 3 4 S 6
J i IsIs \ l itO! 1 в I о11 1 1 1 141 51 1 1 1
t 1 2 3 4 5 6 7 8 9 10
14111s10/ 1 l6ISl t /sjзl
О 1 2 3 4 S 6
41s \ s/ l IO! 1 В/0\1\1\ 1 l4IS\ 1 1 \
2

8

7

З

1

2

3

4

0

1

l I

2

3

4

l l

О

1

2

0

12141
4

t

5

6

7

5

6

9 IJ t

3

4

5

6

3

4

5

6

6

S/ S\7

S\ S

l81111

1

121s I s I s11191щ
2

1

2

S/5

0

1

2

next

J 1

next

! 2l5l5 / 6 / 7 /toj111

1 ! 1 It 1
5

7

IO

3

4

5

А

А

8/

7

0

next / 2

пехt

S

7/8

next / 2 /

nex t

2

/4j11s10\1l6ISl1ISl3\
1 • \ 21 I l j 101 1 в 1 1 1 1 1 l41 1 1 1 1
t 1 2 3 4 5 6 7 8 9 10
А l4l 1 /SI0\ 1\6IS111s1з1
О 1 2 3 4 S 6
з I I l l llOI
1 в 1 111 1 1 141 1 1 1 1
t 1 2 3 4 5 6 7 8 9 10
А 1411j5joltl6lsj1 /5/зl
О 1 2 3 4 S 6
з s s / l 101 в 1 1 1 1 1 1 1 1 1 1 1
О

next J I j

next

1

I

14111s101116\5JIIS1ЗI
1 в1°1 1 1 1 1 1 1 1 161
t 1 2 3 4 5 6 7 8 9 10
А l41 l5lol I l6lsl t lSIЗI
1 В1°11111 1 1415\ 1 161
t 1 2 3 4 5 6 7 8 9 10
А 14111s1011161s11 1s131
11 \4\sjsl /6\
I в1011111
t 1 2 3 4 5 6 7 8 9 10
A/4/11s1011161s111s1з1
1в101111111 /4IS1Sl5l6\
t 1 2 3 4 5 6 7 8 9 10
/41115\0I I 161s111s1з1
в1011\1jtl314l5/S15l6I
А

t

А

5

Глага 4. Нижняя граница гремени сортирОtJки и как ее npetJЗOйmu

3. Дл1 i = )

ДО

75

n:

А. Усrановить зJ{ачение key равRЫМ А [ i] .
В. Усrановить значение index равным next [ key] .

С. Установить B[index] равным A[i].
D. Увеличить значение next [ key] на единицу.
4. Вернуть массив В.
Приведенный далее рисунок показывает, как процедура REARRANGE перемещает эле­
менты из массива А в массив В так, чтобы они в конечном итоге оказались в массиве В
в отсортированном порядке. В верхней части рисунка показаны массивы less, next, А и В
перед первой итерацией цикла на шаге 3, а в последующих частях показаны массивы next,
А и В после каждой очередной итерации . Серым цветом показаны элементы, скопирован­
ные в массив В.
Идея заключается в том, что при проходе по массиву А от начала до конца next(j]
указывает индекс элемента в массиве В, в который должен быть помещен очередной эле­
мент массива А с ключом j. Вспомните, что если / элементов имеют ключи сортировки,
меньшие, чем х, то k элементов с ключом сортировки, равным х, должны занимать пози­
ции от / + 1 до / + k . Цикл на шаге 2 выполняет установку значений массива next так, что
изначально next (j] = / + 1 • где / = /ess (j] . Цикл на шаге З обходит массив А от начала до
конца. Для каждого элемента А[i] шаг ЗА сохраняет значение A[i] в переменной key, шаг
ЗВ вычисляет значение index, которое представляет собой индекс в массиве В, где долж­
но быть сохранено значение A(i], а шаг ЗС переносит A[i] в эту позицию в массиве В.
Поскольку следующий элемент в массиве А, который имеет тот же ключ сортировки, что и
A(i] (если таковой имеется), должен быть сохранен в следующей позиции массива В, шаг
ЗD увеличивает значение next [ key] на единицу.
Кахово время работы процедуры REARRANGE? Цикл на шаге 2 выполняется за время
Е>( т), а цикл на шаге З - за время Е>(п). Следовательно, процедура REARRANGE, как и
процедура Coum-КEvs-EQUAL, имеет время работы Е>(п + т), что равно Е>(п), если т
является константой.
Теперь мы можем собрать все три процедуры вместе для создания процедуры со рти­
рогки под счетом .
Процедура COUNТING-SORТ(A.n ,m)
В�:
• А: массив целых чисел в диапазоне от О до т -1 .
•

п: kОЛНЧество элементов в массиве А.

•

т: определяет диапазон значениn в массиве А.

Выход: массив В, содержащий элементы массива А в отсортированном порядке.

76

Глава 4. Нижняя граница вре.мени сортировки и как ее превзойти

1. Вызвать процедуру Coum-KEYs-EQuAL(A,n,m) и сохранить ее результат как массив
equal.
2. Вызваrъ процедуру CoVNТ-КEvs-LEss(equal,m) и сохранJПЬ ее результэ:r как массив
less.
3. Вызвать процедуру R.EARRANGE(A,/ess,n,m) и сохранить ее результэ:r как массив в. f

4. Вернуrь массив В.

Исходя из времени работы процедур CouNТ-КEvs-EQUAL (0( п +т )), CoUNТ-KEvs-LEss (0(т ))
и REлRRANGE (0{п + т )), можно сделать вывод, что процедура CouNТING-SORT выполняется
за время 0(п +т ), или просто 0( п ), если т представляет собой константу. Сортировка
подсчетом превосходит нижнюю границуО(пlgп) сортировки сравнением, потому что
она никогда не сравнивает ключи сортировки один с другим. Вместо этого она использует
ключи сортировки для индексирования массивов, что вполне реально, когда ключи сорти­
ровки являются небольшими целыми значениями. Если ключи сортировки представляют
собой действительные числа с дробной частью или, например, строки символов, то в та­
ком случае использовать сортировку подсчетом нельзя.
Вы можете заметить, что процедура предполагает наличие в элементах только клю­
чей сортировки без каких-либо сопутствующих данных. Да, я обещал, что в отличие от
REALLv-S1мPLE-SORT процедура CoUNТING-SORT допускает наличие сопутствующих данных.
Этого легко добиться, достаточно только модифицировать шаг ЗС процедуры REARRANGE
так, чтобы он копировал весь элемент, а не только ключ сортировки. Вы могли также об­
ратить внимание на то, что мои процедуры несколько неэффективно используют массивы.
Да, массивы equal, less и next можно объединить в один массив, но эту задачу я оставляю
в качестве задания читателю.
Я постоянно отмечал, что время работы равно 0{ п), если т является константой. Но
когда т является константой? Один из примеров - сортировка студентов по уровню
успеваемости. Например, уровень успеваемости может принимать значения от О до I О,
но количество студентов при этом варьируется. Я вполне мог бы использовать сортировку
подсчетом для п студентов за время 0(п), так как значение т = 11 (вспомните, что сорти­
руемый диапазон значений - от О дот -1) является константой.
На практике однако сортировка подсчетом оказывается полезной в качестве части дру­
гого алгоритма сортировки - поразрядной сортировки. В дополнение к линейному вре­
мени работы при константном значении т сортировка подсчетом имеет еще одно важное
свойство: она является устойчивой. В случае устойчивой сортировки элементы с одним
и тем же ключом сортировки оказываются в выходном массиве в том же порядке, что и
во входном. Другими словами, устойчивая сортировка, встречая два элемента с равными
ключами, разрешает неоднозначность, помещая в выходной массив первым тот элемент,
который появляется первым во входном массиве. Понять, почему сортировка подсчетом
является устойчивой, можно глядя на цикл на шаге 3 процедуры REARRANGE. Если два эле­
мента А имеют один и тот же ключ сортировки, скажем, key, то процедура увеличивает
next[key] сразу же после переноса в массив В элемента, который ранее был в А. Таким

Глава 4. Ни:жняя граница времени сортировки и как ее превзойти

77

образом, к моменту перемещения элемента, который появляется в А позже, этот элемент
будет помещаться в массив В в позицию с большим индексом.

Поразрядная сортировка
Предположим. что вам нужно отсортировать строки символов некоторой фиксирован­
ной длины. Например сейчас я пишу этот раздел, сидя в самолете, и когда я делал за­
каз билета, мой код подтверждения был Xl7FS6. Все коды подтверждения авиакомпании
имеют вид строк из шести символов, каждый из которых является буквой или цифрой.
Каждый символ может принимать 36 значений (26 букв плюс 10 цифр), так что всего име­
ется 366 = 2 176 782 336 возможных кодов подтверждения. Хотя это и константа, но она
слишком велика. чтобы авиакомпания использовала для сортировки кодов сортировку
подсчетом.Чтобы получить для каждого кода конкретное число, можно перевести кажд ы
. й
из 36 символов в числовой код, имеющий значение от О до 35. Код цифры является самой
этой цифрой (так, код цифры 5 представляет собой число 5), а коды для букв начинаются
с I О для А и заканчиваются 35 для Z.
Теперь давайте немного упростим задачу и предположим, что каждый код подтверж­
дения состоит только из двух символов (не беспокойтесь: мы вскоре вернемся к шести
2
символам). Хотя можно воспользоваться сортировкой подсчетом ст= 36 = 1296, мы вме­
сто этого используем ее дважды с т = 36. В первый раз в качестве ключа сортировки ис­
пользуем правый символ, а затем вновь отсортируем результат, но теперь в качестве ключа
используем левый символ. Мы выбираем сортировку подсчетом, потому что она хорошо
работает при относительно небольших т и потому что она устойчива.
Предположим, например, что у нас есть двухсимвольные коды <F6, Е5, R6, Х6, Х2,
Т5, F2, ТЗ>. После сортировки подсчетом по правому символу мы получаем коды в сле­
дующем порядке: <Х2, F2, ТЗ, Е5, Т5, F6, R6, Х6>. Обратите внимание, что, поскольку со­
ртировка подсчетом устойчива, а Х2 в исходном порядке идет до F2, после сортировки по
правому символу Х2 продолжает находиться перед F2. Теперь отсортируем результат по
левому символу, вновь используя сортировку подсчетом, и получим то, что хотели: <Е5,
F2, F6, R6, ТЗ. Т5, Х2. Х6>.
Что бы произошло, если бы мы сначала выполнили сортировку по левому символу?
После сортировки подсчетом по левому символу мы бы получили <Е5, F6, F2, R6, Т5, ТЗ,
Х6, Х2>, а затем после сортировки подсчетом по правому символу был бы получен невер­
ный окончательный результат <F2, Х2, ТЗ, Е5, Т5, F6, R6, Х6>.
Почему работа справа налево приводит к правильному результату? Важное значение
имеет использование устойчивой сортировки; это может быть сортировка подсчетом или
л!ОбЬ иная, но устойчивая сортировка. Предположим, что мы работаем с символами в i-й
позиции и что по всем i - 1 позициям справа массив был отсортирован. Рассмотрим две
любые сортировки к лючей. Если они отличаются в i-й позиции, то их i -1 позиций справа
значений не имеют: устойчивый алгоритм сортировки по i-й позиции разместит их в вер­
ном порядке. Если же, с другой стороны, они имеют один и тот же символ в i-й позиции,

78

Глава 4. Hu:жНIIJI граница времени сортировки и как ее превзойти

то первым должен быть код, символ которого идет первым в i -1 позиции. Но применение
метода устойчивой сортировки гарантирует получение именно этого результата.
Вернемся к нашим шестизначным кодам подТверждения и посмотрим, как будут от­
сортированы коды, которые изначально находились в порядке <Xl7FS6, PL4ZQ2, Jl8FR9,
XL8FQ6, PY2ZR5, KV7WS9, JL2ZV3, КJ4WR2>. Пронумеруем символы справа налево от
1 до 6. Тогда последовательность кодов после выполнения устойчивой сортировки по /..му
символу имеет следующий вид.
Последовательность после сортировки

1
2
З
4
5

6

<PL4ZQ2, КI4WR2, JL2ZVЗ, PY2ZR5, Xl7FS6, XL8FQ6, Jl8FR9, KV7WS9>
<PL4ZQ2, XL8FQ6, КI4WR2, PY2ZR5, Jl8FR9, Xl7FS6, KV7WS9, JL2ZVЗ>
<XL8FQ6, Jl8FR9, XJ7FS6, КI4WR2, KV7WS9, PL4ZQ2, PY2ZR5, JL2ZVЗ>
<PY2ZR5, JL2ZVЗ, Kl4WR2, PL4ZQ2, Xl7FS6, KV7WS9, XL8FQ6, JI8FR9>
<Кl4WR2, Xl7FS6, JI8FR9, JL2ZVЗ, PL4ZQ2, XL8FQ6, KV7WS9, PY2ZR5>
<Jl8FR9, JL2ZVЗ, КI4WR2, KV7WS9, PL4ZQ2, PY2ZR5, Xl7FS6, XL8FQ6>

Обобщая, в алгоритме поразрядной сортироt1ки мы предполагаем, что каждый ключ
сортировки можно рассматривать как d-значное число, каждая цифра которого находится
в диапазоне от О до т -1. Мы поочередно используем устойчивую сортировку для каждой
цифры справа налево. Если в качестве устойчивой применяется сортировка подсчетом,
то время сортировки по одной цифре составляете( т + п ), а время сортировки по всем d
цифрам -е( d ( т + п)). Если т является константой (как в примере с кодами подтверж­
дения т = 36), то время работы поразрядной сортировки становится равным 0( dn ). Если
d также представляет собой константу (например, 6 в случае кодов подтверждения), то
время работы поразрядной сортировки превращается в просто 0( п ).
Когда поразрядная сортировка использует сортировку подсчетом для упорядочения по
каждой цифре, она никогда не сравнивает два ключа сортировки один с другим. Она ис­
пользует отдельные цифры для индексирования массивов в сортировке подсчетом. Вот
почему поразрядная сортировка, как и сортировка подсчетом, преодолевает нижнюю гра­
ницу n(nlgn) сортировки сравнением.

Дальнейшее чтение
В главе 8 в CLRS [4] весь материал данной главы охвачен более подробно и широко.

5 •.. Ориентированные ациклические графы
Когда-то я был неплохим хоккеистом. Несколько лет я был вратарем, но потом мой
интерес к игре угас, и я забросил клюшку и щиток. Но однажды, после более чем семилет­
него перерыва, случилось так, что мне удалось поучаствовать в паре игр.
Самой большой моей проблемой оказалась даже не игра - хотя я и знал, что на поле
я буду выглядеть ужасно, - а то, что я напрочь позабыл, как одевается вся эта вратарская
сбруя (а ее немало - до 15-20кг). Готовясь к выходу на поле, все это надо нацепить
на себя в правильном порядке. Например, поскольку я правша, на левую руку я одеваю
огромную рукавицу для ловли шайбы; она называется ловушкой (catch glove). После того
как я одену эrу перчатку, я больше не смогу ничего одеть на верхнюю часть тела - на­
столько она велика.
Словом, когда я готовился к игре, мне пришлось нарисовать для себя диаграмму, по­
казывающую, что и в каком порядке мне следует одевать (эта диаграмма приведена ниже).
Стрелка от А к В указывает на то, что А надо одеть до В. Например, я должен надеть на­
грудник до свитера. Очевидно, что ограничение "следует одеть до" является транзиmи•­
ным: если А следует одеть до В, а В надо одеть до С, то А должен быть одет до С. Поэтому
нагрудник надо надеть до свитера, маски, ловушки и щитка.
( Трусы )
1

�
�

Щитки
для ног
Щиток
tJекоторые пары вещей можно одевать в любом порядке. Например, можно одеть но­
ски как до, так и после нагрудника.
Мне надо было определить порядок одевания. Нарисовав диаграмму, я составил спи­
сок из всех элементов экипировки, расположив их так, чтобы не нарушалось ни одно из
ограничений "следует одеть до". Я обнаружил, что таких списков может быть несколько;
под диаграммой представлены три из них.

80

Глава 5. Ориентированные ациклические графы

Порядок 1

Порядок 2

Порядок 3

Трусы

Трусы

Носки

Шорты

Фуrболка

Фуrболка

Паховая защита

Шорты

Трусы

Носки

Паховая защита

Нагрудник

Рейтузы

Нагрудник

Шорты

Штаны

Носки

Коньки
Щитки для ноr

Рейтузы
Штаны

Ре йтузы
Паховая защита

Фуrболка

Свитер

Коньки

Нагрудник

Маска

Щитки для ног

Свите р

Коньки

Свитер

Маска

Щитки для ног

Маска

Ловушка

Ловушка

Ловушка

Щиток

Щиток

Щиток

Штан ы

Как я получил эти списки? Вот как я получил вrорой из них. Я искал элемент, в кото­
рый нет входящих стрелок, потому что такой элемент не обязан следовать после другого.
Я выбрал в качестве первого элемента трусы, а затем, одев их (концептуально), я удалил
их из диаграммы, что дало мне следующую диаграмму.

(Фуrоолка)
1

Щитки
для ног

t

( Щиток )
Затем я вновь выбрал элемент без входящей стрелки, в этот раз - футболку. Добавив ее к
концу списка, я удалил ее из диаграммы, получив н овую диаграмму.

ые циклические графы
ие и
Глава 5. Ор нт рованн а

81

Щитки
для ноr

И вновь я выбираю элемент без входящих стрелок (шорты} и выполняю те же действия,
что и ранее.

Щитки
,I.UUI ноr
Щиток
После выбора паховой защиты диаrрамма принимает следующий вид.

Щитки
для ног
Щиток

82

Глава 5. Ориентированные ациклические графы

Таким образом я действовал до тех пор, пока не осталось ни одного элемента. Три
списка, показанные на с. 80, представляют собой результат различных вариантов выбора
элемента без входящих стрелок на исходной диаграмме.

Ориентированные ациклические rрафы
Приведенные диаrраммы являются примерами ориентированных графов, которые
составлены из вершин, соответствующих элементам экипировки вратаря, и ориентиро­
ванных ре6ер, показанных с помощью стрелок. Каждое ориентированное ребро представ­
ляет собой упорядоченную пару вида (и, v), где и и v - вершины. Например, крайним
слева ребром в ориентированном графе на с. 80 является ребро (носки, рейтузы). Если
ориентированный граф содержит ориентированное ребро (и, v) , мы говорим, что верши­
на v является смежной с вершиной и и что ребро (и, v) покидает и и входит в v, так
что вершина, помеченная как "рейтузы", является смежной с вершиной "носки", а ребро
(носки, рейтузы) покидает вершину "носки" и входит в вершину "рейтузы".
Ориентированные графы, которые мы видели в этой главе, обладают еще одним свой­
ством: из вершины такого графа нельзя попасть в нее же, пройдя по некоторой ненулевой
последовательности ребер. Такой ориентированный граф называется ориентированным
ациклическим графом. Он называется ациклическим, поскольку в нем отсутствуют "ци­
клы", т.е. пути из вершины обратно в нее же (более точное определение цикла мы дадим
в этой главе позже).
Ориентированные ациклические графы идеально подходят для моделирования зависи­
мостей, когда одна задача должна быть выполнена до другой. Другое использование для
ориентированных ациклических графов - при планировании проектов, таких как строи­
тельство дома, например стены должны быть на месте до крыши. Или в кулинарии, где
определенные шаги при приготовлении блюда должны происходить в установленном по­
рядке, а для некоторых шагов их взаимный порядок совершенно не важен (мы рассмотрим
пример такого ориентированного ациклического графа далее в этой mаве).

Топологическая сортировка
Когда мне нужно было определить линейный порядок, в котором следует одевать вра­
тарскую экипировку, мне нужно было выполнить "топологическую сортировку". Говоря
точнее, топологическая сортировка ориентированного ациклического графа выполняет
линейное упорядочение вершин, такое, что если (и, v) представляет собой ребро ориен­
тированного ациклического графа, то в этом линейном упорядочении и находится пе ред v.
Топологическая сортировка отличается от сортировок, рассматривавшихся нами в гла­
вах 3, "Алгоритмы сортировки и поиска", и 4, "Нижняя граница времени сортировки и
как ее превзойти".
Линейное упорядочение, производимое топологической сортировкой, не обязательно
единственное. Но вы уже знаете об этом, поскольку каждый из трех списков на с. 80 может
быть получен топологической сортировкой.

Глава 5. Ориентированные ациклические графы

83

Еще с одним применением топологической сортировки .я столкнулся в своей работе
программиста много лет назад. Мы создавали системы автоматизированного проектиро­
вания, которые среди прочего могли поддерживать библиотеки частей. Одни части могуr
содержать другие части, но циклические зависимости при этом не допускались: никакая
часть не может в конечном счете содержать себя же. Нам потребовалось записать часть
конструкции на ленту (я же сказал, что работа выполнялась много лет тому назад) так,
чтобы каждая часть предшествовали другим част.ям, которые ее содержат. Если каждая
часть является вершиной, а ребро ( и, v) указывает, что часть v содержит часть и, то нам
необходимо записывать части в порядке, сrенерированном топологической сортировкой.
Какая вершина .являете.я хорошим кандидатом для первого места в линейном упорядо­
чении? Любая без входящих в нее ребер. Число ребер, входящих в вершину, называется
сходRщей степенью вершины, так что мы можем начинать с любой вершины с нулевой
входящей степенью. К счастью, каждый ориентированный ациклический граф должен
иметь по крайней мере одну вершину с нулевой входящей степенью и по крайней мере
одну вершину с нулевой исходRщей степенью (у которой нет покидающих ее ребер), так
как в противном случае в графе будет иметься цикл.
Итак, предположим, что мы выбираем любую вершину с нулевой входящей степе­
нью - назовем ее вершиной и - и поместим ее в начале линейного упорядочения. По­
скольку мы выбрали вершину и первой, все другие вершины будут размещены в линейном
упорядочении после и. В частности, люба.я вершина v, смежна.я с и, должна находиться в
линейном упорядочении после и. Следовательно, можно безопасно удалить из ориенти­
рованного ациклического графа вершину и и все исходящие из нее ребра. так как нам из­
вестно, что мы позаботились обо всех зависимостях, определяемых этими ребрами. Когда
мы удалим вершину и исходящие из нее ребра из ориентированного ациклического графа,
то что у нас останется? Другой ориентированный ациклический граф! В конце концов, мы
не можем создать цикл, удаляя вершины и ребра. А раз так, мы можем повторять описан­
ный процесс над получившимся ориентированным ациклическим графом, находя в нем
вершину с нулевой входящей степенью, помещая ее в линейное упорядочение после нахо­
дящихся там вершин, удал.я.я эту вершину и исходящие из нее ребра из ориентированного
ациклического графа, и т.д.
Приведенная ниже процедура топологической сортировки использует эту идею, но
вместо реального удаления вершин и ребер из ориентированного ациклического графа
она просто отслеживает входящую степень каждой вершины, уменьшая ее на единицу
дл.я каждого концептуально удаляемого входящего ребра. Так как массив индексируете.я
целыми числами, предположим, что мы идентифицируем каждую вершину уникальным
цел \dм числом в диапазоне от 1 до п. Поскольку процедуре необходимо быстро находить
вершины с нулевой входящей степенью, она поддерживает входящие степени вершин в
массиве in-degree, индексируемом вершинами, и список next всех вершин с нулевой входя­
щей степенью. На шагах 1-3 выполняется инициализация массива in-degree, далее шаr4
инициализирует список next, а шаг 5 обновляет массив in-degree и список next при концеп­
туальном удалении вершин и ребер. Процедура может выбирать любую вершину в списке
next в качестве очередной вершины линейного упорядочения.

84

Глава 5. Ориентированные ациклические графы

Процедура TOPOLOGICAL-SORT(G)
В:wд: G: ориентированный ациклический rраф с вершина.ми. пронумерованными от 1

доп.

Выход: линейное упорядочение вершин, такое, что вершина и находится в нем ДО ве
r
шины v, если ( и, v) ЯВJU1ется ребром графа.
1. Пусть in-degree[t"n) представляет собой новый массив; кроме тоrо, создадим пу­
стое линейное упорядочение вершин.

2. Установить все значенИJt элементов массива in-degree равНЪ1ми О.
3. Дпя каждой вершины и:

А. Дпя каждой вершины v, смежной с вершиной и:
i. Увеличить in-degree[v) на единицу .

4. Создать список пехt, состоящий из всех вершин и, таких, что in-degree[u) =О.

5. Пока список next не пустой. выполнять следующее.

А. Удалить вершину из списка next, называя ее вершиной и.
В. Добавить вершину и в 1<0нец линейного упорядочения.

С. Для каждой вершины v, смежной с вершиной и:
i. Уменьшить in-degree( v] на единицу.
ii. Если in-degree[ v] =О, внести вершину v в список next.
6. Вернуть линейное упорядочение.
Рассмслрим, как несколько первых итераций на шаге 5 работают с ориентированным
ациклическим графом дпя одевания хоккейного вратаря. Чтобы выполнить процедуру
ToPOLOGICAL-SORT над этим ориентированным ациклическим графом. нам нужно перену­
меровать вершины, как показано на рисунке на с. 85. Нулевую входную степень имеют
только вершины 1, 2 и 9 и при входе в цикл на шаге 5 список next содержит только эти
три вершины. Чтобы получить первый из списков на с. 80, порядок вершин в списке next
должен быть следующим: 1, 2, 9. Затем в первой итерации цикла на шаге 5 мы выбира­
ем в качестве вершины и вершину 1 (трусы), удаляем ее из списка next, добавляем ее в
конец изначально пустоrо линейноrо упорядочения, после чего уменьшаем на единицу
элемент in-degree(3) (шорты). Так как эта операция обнуляет значение in-degree(3), мы
вносим вершину 3 в список next. Будем считать, что при вставке вершины в список next
мы вставляем ero первой вершиной в списке. Такой список, в котором все вставки и уда­
ления выполняются в одном конце, известен как стек и напоминает стопку тарелок, из
которой всегда берется верхняя тарелка и в которую тарелка кладется на вершину. (Мы на­
зываем этот порядок последним вошел, первым вышел, или LIFO - last in, first out.) При
таком предположении список next на следующей итерации приобретает вид 3, 2. 9, и на
следующей итерации цикла мы выбираем в качестве вершины и вершину 3. Мы удаляем
ее из списка next, добавляем в конец линейного упорядочения, которое теперь имеет вид

Глава 5. Ориентированные ациклические графы

85

"Трусы, шорты" и уменьшаем на единицу элементы in-degree(4] (с 2 до\) и in-degree(5]
(с I до О). Вершину 5 (паховая защита) мы вносим в список пехt, который после этого
имеет вид 5, 2, 9. На следующей итерации мы выбираем в качестве вершины и вершину 5,
удаляем ее из списка next, добавляем в линейное упорядочение (которое теперь имеет вид
"Трусы, шорты, паховая защита") и уменьшаем элемент in-degree(6] с 2 до 1. В этот раз
новые вершины в список next не внос.яте.я, так что на очередной итерации мы выбираем
в качестве вершины и вершину 2 и т.д.

Трусы

з

2

Футболка 9
10

7

8 Щитки
ДПЯНОГ
Щ иток

14

Чтобы проанализировать процедуру TOPOLOGICAL-SoRт, сначала надо понять, каким об­
разом в компьютере лредставимы ориентированные графы и списки, такие как ne:xt. При
представлении графов их цикличность или ацикличность не играет никакой роли.

Представление ориентированных rрафов
В компьютере ориентированный граф можно представить несколькими способами.
Наше соmашение будет заключаться в том, что граф имеет п вершин и т ребер. Мы про­
должаем считать, что каждая вершина имеет свой собственный номер от 1 до п, так что
мы можем использовать вершину как индекс в массиве или даже как номер строки или
столбца матрицы.
Пока что мы просто хотим знать, какие вершины и ребра имеются в наличии (в даль­
нейшем мы будем также с каждым ребром связывать некоторое числовое значение). Мы
могjи бы использовать матрицу смежности п х п, в которой каждая строка и каждый
столбец соответствует одной вершине, и запись в строке для вершины и и столбца для вер­
шины v .являете.я либо 1, если в графе имеете.я ребро (и, v ), либо О, если граф не содержит
такое ребро. Так как матрица смежности содержит п 2 записей, должно выполняться усло­
вие т :::; п 2 • В качестве альтернативы можно просто содержать список всех т ребер в гра­
фе в произвольном порядке. Гибридом между матрицей смежности и неупорядоченным
списком .являете.я предстагление в 11иде списков смежности, где п-элементный массив

Глава 5. Ориенmиf)Оflанные ациклические графы

Btl

индексируете.я вершинами, а запись массива дл.я каждой вершины и представляет собой
список всех вершин, смежных с ней. В сумме списки содержат т вершин, поскольку дл.я
каждого из т ребер имеете.я один элемент списка. Вот как выглядят матрица смежности и
список смежности дл.я ориентированного графа на с. 85.
2

2
3
4

5
6

7
8
9
10
11
12
13
14

о о
о

о
о
о
о
о
о
о
о
о
о
о
о

о

о
о
о
о
о
о
о
о
о
о
о
о

3

о

о
о
о
о
о
о
о
о
о
о
о
о

4

Матрица смежности
5
6
7
8
9

о о о о
о о о
о о
о
о о
о
о о
о о о
о о о о
о о о о
о о о о
о о о о
о о о о
о о о о
о о о о
о о о о

о
о
о
о
о
о

10

11

12

13

14

о о
о о
о о
о о
о о

о
о
о
о
о

о о
о о
о о
о о
о о

о
о
о
о
о

о

о
о о
о о
о о
о о
о о
о о
о о

о

о о
о о
о
о
о о
о о
о о
о о

о

о
о

о
о

о

о

о о

о
о

о

о
о о
о о

о
о
о

о
о
о

Списки смежно f'и
3

2

4

3

4,5

4

6

5

6

6

7, 11

7

8

8

13

9

10

10

11

11

12

12

13

13

14

14

Нет

Представления с помощью неупорядоченных списков ребер и списков смежности при­
водят к вопросу о выборе представления списка. Лучший способ представления списка
зависит от того, операции какого вида должны будут выполняться над списком. Дл.я не­
упорядоченных списков ребер и списков смежности мы знаем заранее количество ребер
в этих списках, причем это количество не меняете.я со временем, так что можно хранить
каждый список в массиве. Массив дл.я хранения списка можно также использовать даже
в случае, когда содержимое списка меняете.я с течением времени - до тех пор, пока из­
вестно максимальное количество элементов, которые мoryr находиться в списке в любой
момент времени. Если нам не нужно вставлять элемент в средину списка или удал.ять
элемент оттуда, представление списка массивом .является столь же эффективным, как и
любые иные средства.
Если нужны вставки в середину списка, можно воспользоваться сввзанным списком,
каждый элемент которого включает размещение его преемника в списке, что упрощает
вставку нового элемента в список после данного элемента. Если необходимо также уда­
ление из средины списка, то каждый элемент в связанном списке должен включать раз­
мещение его предшественника, что обеспечивает быстрое удаление элемента из списка.

Глава J. Ориентированные ациклические графы

81

Далее мы будем считать, что вставить элемент в связанный список или удалить его оnуда
можно за константное время. Связанный список, который хранит только местоположение
преемника, называется однос11язным списком. Добавление в элемент ссылки на предше­
ственника по списку делает список дt1усt111зным.

Время работы топологической сортировки
В предположении, что ориентированный ациклический граф использует представ­
ление в виде списков смежности, а список next - связанный список, можно показать,
что процедура ToPOLOGICAL-SORT выполняется за время 0( п + т) . Поскольку next - это
связанный список, вставлять в него элементы и удалять их оnуда можно за константное
время. Шаг 1 выполняется за константное время, а поскольку массив in-degree имеет п
элементов, шаг 2 инициализирует массив нулями за время 0(п). Шагу З требуется время
0(п+т). Член 0(п) на шаге З возникает из-за того, что внешний цикл просматривает
каждую из п вершин, а член 0(т) - потому что внутренний цикл на шаге ЗА посещает
каждое из т ребер ровно один раз за все итерации внешнего цикла. Шаг 4 выполняется за
время О( п ), так как список next изначально содержит не более п вершин. Большая часть
работы выполняется на шаге 5. Поскольку каждая вершина вносится в список next ровно
один раз, выполняется п итераций главного цикла. Шаги 5А и 58 в каждой итерации вы­
полняются за константное время. Подобно шагу ЗА, цикл на шаге 5С всего выполняется т
раз, по одному разу на ребро. Шаги 5Ci и 5Cii выполняются за константное время в каж­
дой итерации, так что вместе все итерации шага 5С выполняются за время 0(т ), а следо­
вательно, цикл на шаге 5 выполняется за время 0( п + т ). Конечно, шаг 6 выполняется за
константное время, так что когда мы просуммируем все полученные времена, то найдем,
что время работы топологической сортировки равно 0( п + т).

Критический путь в диаграмме PERT
После напряженного рабочего дня я хочу расслабиться на кухне и приготовить на ужин
курицу rунбао1 • Я должен подготовить курятину, нарезать овощи, смешать маринад, сва­
рить соус и приготовить блюдо. Так же, как и при одевании вратарской экипировки, одни
шаги готовки должны быть выполнены раньше других, так что я могу воспользоваться
ориентированным ациклическим графом для моделирования процедуры приготовления
rунбао. Этот ориентированный ациклический граф показан ниже.
Рядом с каждой вершиной ориентированного ациклического графа приведено чис­
ло, указывающее, сколько минут требуется на выполнение указанной в вершине задачи.
Нап�имер, чтобы нарезать чеснок, мне надо четыре минуты (потому что сначала его надо
почистить, а я всегда использую действительно много чеснока). Если вы просуммируете
времена выполнения всех подзадач, то увидите, что при их последовательном выполнении
я буду готовить rунбао целый час.
1 Или ··кунг пао" - встречаются о6а варианта этого названия китайского блюда на русскаw
языке. - Примеч. пер.

88

Глава 5. Ориентированные ациклические графы

6

2

Смешать
маринад

4

Нарезать
чеснок

4

Нарезать
морковь

4

2

3

Закончить готовку
курятины

2

4

3

Смешать соус

Тушить, пока соус
не загустеет

3

Подать готовое блюдо
Но если мне будут помогать, то некоторые действия можно будет выполнять одно­
временно. Например, один человек может смешивать маринад, пока другой будет резать
курятину. Имея достаточное количество помощников, большую кухню, много ножей, раз­
делочных досок и тарелок, можно умудриться испортить гунбао за четыре часа. (Конечно,
это шутка, но в каждой шутхе есть доля истины ... ) Конечно же, я хотел сказать, что при
этих условиях можно выполнять множество задач одновременно. Если на диаграмме меж­
ду двумя задачами нет соединяющего их пути из стрелок, эти задачи можно выполнять
одновременно, поручив их разным людям.
Как быстро можно приготовить гунбао при наличии неограниченных людских и кухон­
ных ресурсов для одновременного выполнения нескольких задач? Наш ориентированный
ациклический граф является примером диаzраммы PERT (Project Eva\uation and Review
Technique - метод планирования и оценки затрат времени на проект с использованием
сетевого графика). Время, требуемое для завершения всей работы, даже при максималь­
но возможном распараллеливании задач определяется "критическим путем" диаграммы
PERT. Чтобы понять, что такое критический путь, сначала надо понять, что такое путь
вообще, после чего мы можем определить, что такое критический путь.

Гла6й 5. Ориентированные ациклические графы

89

Путь в графе представляет собой последовательность вершин и ребер, которые по­
зволят нам перейти от одной вершины к другой (или обратно). Мы говорим, что путь
содержит вершины, лежащие на пути, и ребра, по которым он проходит. Например, один
из путей в ориентированном ациклическом графе содержит вершины "Нарезать чеснок",
"Добавить чеснок и имбирь", "Закончить готовку курятины" и "Убрать курятину" вместе
ребрами, соединяющими эти вершины. Путь из вершины в нее же саму представляет со­
бой цикл, но, конечно же, ориентированные ациклические графы циклов не имеют.
Критический путь в диаграмме PERT - это путь, сумма времен выполнения задач
которого максимальна среди всех возможных путей. Сумма времен выполнения задач на
критическом пути дает минимальное время выполнения всего задания, независимо от сте­
пени распараллеливания. Критический путь на диаграмме PERT для приготовления гун­
бао заштрихован. Если вы просуммируете времена выполнения задач вдоль критического
пути, то увидите, что независимо от того, сколько у меня будет помощников, на приготов­
ление блюда уйдет по крайней мере 39 минут2.
В предположении, что времена выполнения всех задач являются положительными чис­
лами, критический путь диаграммы PERT должен начинаться с некоторой вершины с ну­
левой входящей степенью и заканчиваться в некоторой вершине с нулевой исходящей сте­
пенью. Вместо проверки путей между всеми парами вершин, в которых одна из них имеет
нулевую входящую степень, а вторая - нулевую исходящую, можно просто добавить две
фиктивные вершины - "старт" и "финиш", как показано на рисунке ниже. Поскольку это
вершины фиктивные, мы назначаем каждой из них нулевое время выполнения. Добавим
по ребру от вершины "старт" к каждой вершине с нулевой входящей степенью в диаграм­
ме PERT, и ребро от каждой вершины нулевой исходящей степенью к вершине "финиш".
Теперь нулевую входящую степень имеет только вершина "старт", и только вершина "фи­
ниш" имеет нулевую исходящую степень. Путь от старта до финиша с максимальной сум­
мой времен выполнения задач (на рисунке он заштрихован) и является критическим путем
в диаграмме PERT - конечно, после удаления фиктивных вершин "старт" и "финиш".
После того как мы добавили фиктивные вершины, мы находим критический путь как
кратчайший путь от старта до финиша на основе указанных времен выполнения задач.
Вы, наверное, думаете, что в предыдущем предложении я сделал ошибку, и критическому
пути должен соответствовать самый длинный путь, а не кратчайший. Действительно, это
так, но поскольку диаграмма PERT не содержит циклов, можно изменить времена выпол­
нения задач так, чтобы критический путь соответствовал кратчайшему пути. В частности,
можно изменить знак времени выполнения каждой задачи и найти путь от старта до фи­
ниша с .wинимальны.w суммарным временем выполнения задач.

1 Вас интересует. поче.wу в китайских ресторанах вы обычно ждете гораздо меньшее вре.wя?
Де.10 в mo,w. что они .wогут ряд ингредиентов подготавливать заранее, в расчете на возможных
посетите.1ей; может быть. их печи в состоянии готовить быстрее моей домашней. А ,wожет, видя,
что перед ни.wи не особо искушенный гурман, они просто быстренько разогревают в микроволновке
б.1юдо. приготовленное еще вчера ...

Глава 5. Ориентированные ациклические графы

6

Закончить rоrовку
курятины

2

4

3
Смешать соус

Тушить, пока соус
не заrустеет

3

Подать готовое блюдо
Финиш О
Почему мы делаем это - меняем знак времени выполнения задач и ищем путь с ми­
нимальным суммарным временем? Потому что решение этой задачи является частным
случаем задачи поиска кратчайших путей, для решения которой разработана масса ал­
горитмов. Однако когда мы говорим о кратчайшем пути, значения, которые определяют
длину пути, связаны с его ребрами, а не вершинами. Такое значение, связанное с ребром,
называется его гесом. Ориентированный граф, в котором ребра имеют веса, называется
гзгешенным ориентироганным графом. "Вес" является обобщенным термином для
значений, связанных с ребрами. Если взвешенный ориентированный граф представляет
дорожную сеть, каждое ребро в нем представляет одно направление дороги между двух
перекрестков, а вес ребра может представлять длину дороги, время, необходимое для по­
ездки, или для платных дорог - сумму, которую следует заплатить, чтобы использовать
эту дорогу. Вес пути представляет собой сумму весов ребер, принадлежащих этому пути,

Глава 5. Ориентированные ациклические графы

01

так что если веса ребер указывают расстояние между перекрестками, то вес пути пред­
ставляет собой общую длину маршрута. Kpllm'4aiiшuii путь из вершины и в вершину v
представляет собой путь, сумма весов ребер которого минимальна среди всех возможных
путей из вершины и в вершину v. Кратчайшие пути не обязательно единственные, и ори­
ентированный граф может иметь несколько путей, вес которых достигает одного и того же
минимального значения.
Чтобы преобразовать диаграмму PERT с отрицательными временами решения задач
во взвешенный ориентированный граф, мы переносим время работы каждой задачи с об­
ратным знаком в каждое из входящих в соответствующую вершину ребер. То есть если
вершина v имеет (не отрицательное) время выполнения задачи 1, то мы устанавливаем
вес каждого входящего в нее ребра (и, v) равным -1. Вот ориентированный ациt<J1ический
граф, который получается при таком действии для диаграммы приготовления гунбао.

Закончить готовку
курятины
-1

Тушить морковь
с�ереА, арахис,
-1
Смещат ь соус

Тушить, пока соус
не загус теет
-\
Подать готовое блюдо
о
Финиш

92

Глава 5. Ориентированные ациклические графы

Теперь мы просто должны найти в этом ориентированном ациклическом графе крат­
чайший путь (на рисунке он заштрихован) от старта до финиша, основываясь на весах
ребер. Критический путь в исходной диаграмме PERT будет соответствовать вершинам
на найденном нами кратчайшем пути с удаленными вершинами "старт" и "финиш". Так
что давайте познакомимся с тем, как можно найти кратчайший путь в ориентированном
f
ациклическом графе.

Кратчайший путь в ориентированном ациклическом графе
В изучении поиска кратчайшего пути в ориентированном ациклическом графе имеется
еще одно преимущество: тем самым мы заложим основы для поиска кратчайшего пути в
произвольных ориентированных графах, которые могут содержать циклы. Эту более об­
щую задачу мы рассмотрим в mаве 6, "Кратчайшие пути". Как и в случае топологической
сортировки ориентированного ациклического графа, мы предполагаем, что он хранится в
виде списков смежности и что каждое ребро (и, v) имеет свой вес weight(u, v).
В ориентированном ациклическом графе, который получается из диаграммы PERT,
нам надо найти кратчайший путь от исходной вершины, которую мы называем "стартом",
к целевой вершине, "финишу". Здесь мы будем решать более общую задачу поиска крат­
чайших путей из одной вершины, в которой будем искать к ратчайшие пути из исходной
вершины ко всем другим вершинам. Примем соглашение, по которому будем именовать
исходную вершину s, и при этом нам нужно вычислить для каждой вершины v две харак­
теристики: во-первых, вес кратчайшего пути от s до v, который мы будем обозначать как
sp ( s, v ), а во-вторых - вершину, являющуюся предшественником v на кратчайшем пути
от s до v, т.е. вершину и, такую, что кратчайший путь от s до v является путем от s до и,
к которому добавлено одно ребро ( и, v ). Пронумеруем п вершин числами от 1 до п, так
что наши алгоритмы для поиска кратчайшего пути здесь и в mаве 6, "Кратчайшие пути",
могут хранить указанные результаты в массивах shortest [ 1"п] и pred [ 1"п ] соответственно.
В процессе выполнения алгоритмов промежуточные значения в массивах shortest [ 1 ..п] и
pred[l ..n] могут не быть верными конечными значениями, но по окончании работы они
становятся таковыми.
Нам нужно уметь обрабатывать несколько могущих возникнуть при решении постав­
ленной задачи случаев. Во-первых, что если пути от s к v вообще нет? Тогда мы определяем
sp ( s, v) = оо, так что элемент массива shortest [ v] должен получить значение оо. Поскольку
вершина v при этом не должна иметь предшественника на кратчайшем пути от s, элемент
pred [ v] также должен иметь специальное значение NULL. Кроме того, все кратчайшие пути
от s начинаются с s, а потому s также не имеет предшественника; таким образом, pred [ s)
также должен иметь значение NULL. Другой случай возникает только в графах, у которых
имеются циклы и отрицательные веса ребер: что делать, если суммарный вес цикла яв­
ляется отрицательным? В этом случае можно делать круги по циклу, с каждым кругом
получая все меньшее и меньшее значение пути. Получается, что если можно достичь от

Глава 5. Ориентированные ациклические графы

93

вершины s цикла с отрицательным весом, а от него достичь вершину v, то вес sp ( s, v) не
определен. Сейчас, однако, мы имеем дело только с ациклическими графами, в которых
нет циклов, и еще меньше циклов с отрицательным весом, так что беспокоиться об этом
случае еще рано.
Чтобы вычислить кратчайший путь от исходной вершины s, мы начинаем с shortest [s] = О
(так как нам не нужно никуда идти, чтобы досmчь из вершины ее же), и shortest[ v] = оо
для всех других вершин v (так как мы не знаем заранее, до кахих вершин можно добраться
от s). По той же причине для всех вершин v изначально pred[ v] = NULL. Затем мы выполня­
ем ряд шаг08 ослабления к ребрам графа.

Процедура RELAx(u ,v)
Вход: и, v: вершины, тахие, что в графе имеется ребро (и, v).
Результат: знЗ'lение shortest[ v] может уменьшиться, и в этом случае pred[ v] прини­
мает значение и.
1. Если .rhortest(u ]+ weight(u, v) < shortest( v], установить shortest[ v] равным
shortest[u ]+ weight(u, v), а pred(vJ равным и.
Вызов RELAX(u,v) определяет, можно ли улучшить текущей кратчайший путь от s к v,
используя в качестве последнего ребра (и, v ). Мы сравниваем вес текущего кратчайшего
пути к и плюс вес ребра ( и, v) с весом текущего кратчайший пути к v. Если лучшим ре­
шением оказывается использовать ребро (и, v), соответствующим образом обновляются
элементы массивов shortest ( v] и pred [ v ].
Если мы последовательно ослабляем ребра вдоль кратчайшего пути, то получим кор­
ректный результат. Вы можете спросить, как мы можем быть уверены в ослаблении ребер
вдоль кратчайшего пути, если мы даже не знаем, каков этот путь (в конце концов, именно
это мы и пытаемся выяснить)? Оказывается, что в случае ориентированного ациклическо­
го графа это очень легко. Мы собираемся ослабить все ребра ориентированного ацикли­
ческого графа, и ребра каждого кратчайшего пути при проходе и ослаблении всех ребер
окажутся размещенными среди них в верном порядке.
Вот более точное описание работы ослабления ребер вдоль кратчайших путей, которое
применимо к любому ориентированному графу, независимо от наличия в нем циклов.
Начнем с shortest (и] = оо и pred (и] = NULL для всех вершин, за исключением
исходной, для которой shortest [ s] = О.
Затем ослабляем ребра вдоль кратчайшего пути от s до любой вершины v по
порядку, начиная от ребра, исходящего из s, и заканчивая ребром. входящим
в v. Ослабления других ребер могут свободно перемежаться с ослаблениями
вдоль кратчайшего пути, но изменять какие-либо значения массивов shortest
и pred могут только ослабления.

94

Глава 5. Ориентированные ациклические графы
После ослабления ребер значения элементов массивов shortest и pred для
вершины v являются правильными: shortest( v] = sp(s,v� а pred[v] представ­
ляет собой вершину, предшествующую v на некотором кратчайшем пути

отs.
Легко понять, почему работает ослабление ребер по порядку вдоль кратчайшего rlути.
Предположим, что кратчайший путь от s к v проходит через вершины s, v1 , v2 , v3 , • • • , vt ,v
в указанном порядке. После ослабления ребра ( s, v1 ) значение shortest [ v1 ] должно пред­
ставлять собой корректный вес кратчайшего пути до v1, а элемент pred( v1 ] должен быть
равен s. После ослабления ребра ( v" v2 ) должны получить верные значения shortest [ v1 ]
и pred[v2 ]. И так далее до ослабления ребра ( vt ,v ), после которого правильные значения
получают shortest[v] и pred[v].
Эrо хорошая новость. В ориентированном ациклическом графе легко ослабить каж­
дое ребро ровно один раз по порядку вдоль каждого кратчайшего пути. Каким образом?
Сначала выполним топологическую сортировку ориентированного ациклического графа.
Затем рассмотрим каждую вершину в линейном порядке, полученном путем топологиче­
ской сортировки, и ослабим все ребра, покидающие вершины. Поскольку каждое ребро
должно покидать вершину, идущую в линейном порядке ранее, и входить в вершину, бо­
лее позднюю в этом порядке, каждый путь в ориентированном ациклическом графе дол­
жен посещать вершины в порядке, согласующемся с линейным порядком, получаемым
топологической сортировкой.

Процедура Dлo-SнoRП.sт-PAтнs(G,s)

Вход:
•

G: взвешенный ориентированный 1ЩИIU1ИЧеский граф, содержащий множество V из
п вершин и множество Е из т ориентированных ребер.

• s: исходная вершина из V.

Результат: дu каждой вершины v из V, не .1111.11АЮщейся исх.одной, значение shortest[ v]
равно весу sp(s,v) кpa:rчaiiwero пути от s к v, а элемент pred[v] представляет собой

вершину, предшествующую v на некотором кратчайшем пуrи. Дu исходной вершины s
shortest[s] = О и pred[s] =NUU... Если пуrи изs к v нет, тoshortest[v) = оо и pred[v] = NULL.
1. Вызвать процедуру TOPOLOOICAL-SoRт(G) и определить линейный порядок/ вершин
графа, возвращаемый топопоrичесkОй сортировкой.
2. Дл.11 каждо/:i вершины v, отличной от s, установить shortest[v)=oo; установить
shortest[s] = О и ДЛ.11 всех вершин v графа усrановить pred[v] = NULL.
3. Для каждой вершины и, ВЗJIТОЙ в линейном порядке l:
А. Для каждой вершины v, С!',fежной с и:
i. Вызвать RELAX(и,v).

Глава 5. ОриентированнЬlе ациклические графЬl

95

На приведенном далее рисунке показан ориентированный ациклический граф, ря­
дом с каждым ребром которого указан его вес. Значения кратчайших пуrей от верши­
ны s, вычисленные с помощью вызова DАG-SноRтЕsт-Рдтнs, указаны внутри вершин, а
заштрихованные ребра показывают значения pred. Вершины располагаются слева на­
право в линейном порядке, полученном с помощью топологической сортировки, так что
все ребра направлены слева направо. Если ребро (и,v) заштриховано, то pred(v] = и и
shortest[v] = shortest[u] + weight(u, v); например, поскольку ребро (х,у) заштриховано,
pred(y]=xpred(y]=x, а shortest[y] (которое равно 5) представляет собой shortest[x]
(равное 6) плюс weight(x,y) (равно-\). Пуrи из s к r нет, так что shortest[r]=oo и
pred[r] = NULL (нет заштрихованных ребер, входящих в r).
1

Первая итерация цикла на шаrе 3 ослабляет ребра ( r, s) и ( r, t ), покидающие r, но по­
скольку shortest[r] = оо, это ослабление ничего не меняет. На следующей итерации цикла
ослабляются ребра (s,t) и (s,x). покидающие s, что приводит к тому, что shortest[tJ ста­
новится равным 2, shortest[x]- равным 6, а оба элемента -pred[t] и рrеd[х)-уста­
навливаются равными s. Очередная итерация ослабляет ребра ( t, х ). ( t,у) и ( t,z ), поки­
дающие t. Значение shortest[xJ не изменяется, поскольку shortest[tJ+weight(t,x), равное
2 + 7 = 9, превышает значение shortest ( х]. равное 6. Однако shortest [у) становится рав­
ным 6, shortest[z] получает значение 4, а оба элемента -pred(y] и pred[z)-устанавли­
ваются равными t. Следующая итерация ослабляет ребра (х,у) и (x,z), покидающие вер­
шину х, после чеrо shortest[y] становится равным 5, а pred[y]- вершинех; shortest[z] и
pred(z] остаются неизменными. Последняя итерация ослабляет ребро (y,z ), в результате
чего shortest [ z) получает значение 3, а pred[ z] - у.
Можно леrко увидеть, что поиск кратчайшего пуrи в ориентированном ацикличе­
ском графе выполняется за время 0( п + т ). Как мы знаем, шаr I выполняется за время
0(n+m), а шаr 2, конечно же, инициализирует по два значения для каждой вершины за
время 0(п). Как мы уже видели ранее, внешний цикл на шаrе 3 рассматривает каждую
вершину только один раз, а внуrренний цикл на шаrе ЗА делает то же с каждым ребромрассматривает его ровно один раз за все итерации. Поскольку каждый вызов процедуры
RELAX на шаrе ЗАi выполняется за константное время, время работы шаrа 3 составляет
0( п + т ). Суммирование времен работы для всех шагов дает нам общее время работы
проредуры, равное 0( п + т ).
Возвращаясь к диаграмме PERT с п вершинами и т ребрами, леrко увидеть, что поиск
критического пуrи выполняется за время 0( п + т ). Мы добавили к диаграмме две верши­
ны (старт и финиш), а также не болеет ребер, покидающих старт, и т ребер, входящих
в финиш, т.е. в общей сложности в получившемся ориентированном ациклическом графе
имеется не более Зm ребер. Изменение знака весов и перенос их из вершин в ребра

96

Глава 5. Ориентированные ациклические графы

выполняется за время е ( т ), а следующий за этим поиск кратчайшего пуrи в получившем­
ся ориентированном ациклическом графе выполняется за время е ( п + т ).

Дальнейшее чтение
Глава 22 CLRS [4] содержит другой алгоритм топологической сортировки ориен"4Иро­
ванного ациклического графа, отличный от представленного в данной главе (этот алго­
ритм взят из тома I Искусства программирования Кнуrа (Donald Knuth) [ 1 О)). Метод
в CLRS немного проще, но менее интуитивно понятный, чем приведенный в этой главе, и
опирается на методику обхода вершин графа, известную как "поиск в rnубину". Алгоритм
поиска кратчайших nyreй из одной вершины приведен в главе 24 CLRS.
О диаграммах PERT, используемых с 1950-х годов, можно прочесть в любой из множе­
ства книг об управлении проектами.

6 •.. Кратчайшие пути
В главе 5, "Ориентированные ациклические графы", вы познакомились с одним из
способов поиска кратчайших nyreй из одной вершины в ориентированном ациклическом
графе.
Однако большинство графов, моделирующих явления реальной жизни, содержат ци­
клы. Например, в графе, моделирующем дорожную сеть, каждая вершина представляет
перекресток, а каждое ориентированное ребро - дорогу, по которой вы можете двигаться
в одном направлении между перекрестками (дороге с двусторонним движением соответ­
ствуют два отдельных ребра, идущие в противоположных направлениях). Такие графы
должны содержать циклы, иначе после того, как вы проехали перекресток, вы уже никогда
не могли бы к нему вернуться. Таким образом, когда ваш GPS вычисляет кратчайший или
скорейший маршруr к месту назначения, граф, с которым он работает, содержит множе­
ство циклов.
Когда ваш GPS ищет самый быстрый маршрут от вашего текущего местоположения
в указанное место назначения, он решает задачу поиска кратчайшего пути между па­
рой вершин. Чтобы ее решить, он, вероятно, использует алгоритм, который находит все
кратчайшие пути от одной вершины, но затем GPS уделяет внимание только тому из крат­
чайших nyreй, который приводит к требуемому месту назначения.
Ваш GPS работает со взвешенным ориентированным графом, веса ребер которого
представляют собой либо расстояние, либо время в пуrи. Поскольку нельзя ни проехать
отрицательное расстояние, ни прибыть в место назначения до того, как вы отправились в
дорогу, все веса ребер в графе, с которым работает ваш GPS, являются положительными.
Я допускаю, что некоторые из них могуr оказаться равными нулю по каким-то непонят­
ным причинам, так что давайте просто говорить о неотрицательных весах ребер. Когда все
веса ребер неотрицательные, нам незачем беспокоиться о циклах с отрицательным весом,
так что все кратчайшие пуrи являются точно определенными.
Имеется масса других примеров из жизни, в которых ситуацию можно описать ориен­
тированными графами с неотрицательными весами ребер. А есть ли явления реального
мира, при описании которых получается граф с отрицательными весами ребер? Да, напри­
мер, в случае обмена валют возможны ситуации, описываемые графами, в которых есть
ребра с отрицательным весом, и даже циклы с отрицательным весом.
Переходя к алгоритмам, мы сначала изучим алгоритм Дейкстры поиска кратчайших
пуrей от одной вершины до всех остальных вершин графа. Алгоритм Дейкстры работает
с грt.фами, которые имеют два важных отличия от графов, с которыми мы встречались в
главе 5, "Ориентированные ациклические графы": все веса ребер должны быть неотри­
цательными, и граф может содержать циклы. Это ключевой момент в поиске маршруrов
вашим GPS. Мы также рассмотрим несколько вариантов реализации алгоритма Дейкстры.
Затем мы познакомимся с алгоритмом Беллмана-Форда, удивительно простым методом
поиска кратчайших nyreй из одной вершины даже при наличии ребер с отрицательным ве-

98

Глава 6. Кратчайшие пути

сом. Алгоритм Беллмана-Форда можно использовать для определения, содержит ли граф
цикл с отрицательным весом, и если содержит, то он позволяет указать вершины и ребра,
входящие в такой цикл. И алгоритм Дейкстры, и алгоритм Беллмана-Форда датируются
концом 1950-х годов, так что они выдержали испытание временем. Рассмотрение темы
мы завершим алгоритмом Флойда-Уоршелла для поиска кратчайших путей между всеми
f
парами вершин графа.
Так же, как мы делали в главе 5, ..Ориентированные ациклические графы", для поиска
кратчайшего пути в ориентированном ациклическом графе, мы предполагаем, что у нас
заданы исходная вершинаs (источник) и вес weight(u, v) каждого ребра (и, v), и хотим вы­
числить для каждой вершины v вес кратчайшего пути sp(s, v) от s к v, а также вершину,
предшествующую v на некотором кратчайшем пути от s. Мы будем хранить результаты в
элементах массивов shortest [ v] и pred [ v] соответственно.

Алгоритм Дейкстры

I

Мне нравится представлять алгоритм Дейкстры как имитацию действий бегунов, бе­
гущих по графу.
В идеале такая модель работает так, как показано далее, хотя вы увидите некоторые ее
отличия от алгоритма Дейкстры. Она начинается с отправки бегунов из исходной верши­
ны во все соседние. Как только бегун впервые достигает любой вершины, из нее тут же
выбегают бегуны во все соседние вершины. Взгляните на часть (а) рисунка.
На ней показан ориентированный граф с исходной вершиной s и весами всех ребер.
Рассматривайте вес ребра как количество минут, требующееся бегуну для того, чтобы
преодолеть это ребро.
В части (6) показано начало процесса моделирования - нулевой момент времени.
В этот момент, показанный внутри вершины s, бегуны покидают s и направляются к
двум смежным с ней вершинам, t и у. Затенение вершины s означает, что мы знаем, что
shortest [s] = О.
Четыре минуты спустя, в момент времени 4, бегун прибывает в вершину у (что по­
казано в части (в)). Поскольку этот бегун первый прибывший в вершину у, мы знаем, что
shortest[y] = 4, и вершина у на рисунке затенена. Заштрихованное ребро ( s,y) указывает,
что первый бегун прибыл в вершину у из вершины s, так что pred[y] = s. В момент 4 бегун
из вершин s к вершине t все еще находится в пути, и в этот же момент времени 4 вершину
у покидают бегуны, направляющиеся к вершинам t, х и z.
Следующее событие, отображенное в части (г), происходит одну минуту спустя, в мо­
мент времени 5, когда бегун из вершины у прибывает в вершину t. Бегун из s в t пока что
не успевает. Поскольку первый бегун прибыл в вершину t из вершины у в момент времени 5,
мы устанавливаем shortest[t] = 5 и pred[t] = у (что указывается штриховкой ребра (y,t)).
Из вершины t выбегают бегуны, которые теперь направляются к вершинам х и у.
Наконец в момент времени 6, бегун из вершины s добегает до вершины t, но так как бе­
гун из вершины у уже побывал там минутой ранее, усилия бегуна из s к t были напрасны.
1

Назван по имени ЭдсгераДейкстры (Edsger Dijkstra). предлож11ви.1его этот аq;,орипщ в 1959 году.

Глава 6. Кратчайшие пути

х

у
( а)
х

х

s

х

s

у
(д)
(е)
В момент времени 7, показанный в части (д), два бегуна прибывают в пункт назначе­
ния. Бегун из вершины t прибегает в вершину у, но там уже побывал бегун из s в момент
времени 4, так что о бегуне из t в у можно просто забыть. В этот же момент времени бегун
из у прибывает в вершину z. Мы устанавливаем shortest(z] = 7 и pred(z] = у, и бегуны вы­
бегают из вершины z, направляясь к вершинам s их.
Следующее событие происходит в момент времени 8, показанный в части (е), когда бе­
гун из вершины t прибывает в вершину х. Мы устанавливаем shortest(x] = 8 и pred(x] = t,
и бегун покидает вершину х, направляясь в вершину z.
Теперь, когда бегуны побывали в каждой вершине, моделирование можно остановить.
Конечно, некоторые бегуны еще в пути, но их прибытие будет в любом случае позже
nер чых бегунов, посетивших эти вершины первыми. Как только в вершину прибывает
nерdый бегун, момент его прибытия определяет кратчайший путь от вершины s, а значе­
ние элемента массива pred определяет предшественника данной вершины на кратчайшем
пути изs.
Выше описано, как моделирование должно выполняться в идеале. Оно основано на
времени прохода бегуна по ребру, равному весу ребра. Алгоритм Дейкстры работает не­
много иначе. Он рассматривает все ребра как одинаковые, так что, когда он рассматривает
у

Глава 6. Кратчайшие пути

100

ребра, покидающие вершину, он обрабатывает все смежные вершины одновременно, в
произвольном порядке. Например, когда алгоритм Дейкстры обрабатывает ребра, поки­
дающие вершину s на рисунке на с. 99, он объявляет, что shortest[y] = 4, shortest[t] = 6, а
pred[y] и pred[t] оба равны s - пока что. Когда алгоритм Дейкстры позже рассмотрит
ребро (y,t), это приведет к снижению веса кратчайшего пути к вершине t, найденного до
этого момента, так что shortest [t] станет равным 5 вместо 6, а pred [ t] вместо s пр.Аtет
значение у.
Алгоритм Дейкстры работает путем вызова процедуры RELAX (см. с. 93) по одному разу
для каждого ребра. Ослабление ребра ( и, v) соответствует бегуну, бегущему из вершины и
в вершину v. Алгоритм поддерживает множество Q вершин, для которых окончательные
значения shortest и pred пока неизвестны; все вершины, не входящие в Q, уже получили
окончательные значения shortest и pred. После инициализации shortest [ s] = О, а для всех
остальных вершин shortest[v]=oo; значение pred[v]=NULL для всех вершин. Алгоритм
многократно выполняет следующие действия - находит в множестве Q вершину и с наи­
меньшим значением shortest, удаляет ее из Q и ослабляет все ребра, выходящие из и.
Процедура DнкsтRA(G,s)

Вход:

• G: ориентированный граф, содержащий м}южество V из п вершин и множество Е из
т ориентированных ребер с неотрицательными весами.
• s: исходная вершина из множества V.
Результат: для каждой вершины v из V, не являющейся исходной, shortest [ v] содержит
вес .�p(s,v) кратчайшего пути из s в v, а p1·ed(v] представляет собой вершину, предше­
ствующую v на некотором .кратчайшем пути. Для исходной вершины s shortest [ s] = О и
pred(s]=NULL. Если пути изs в v нет, то shortest[v] =оои pred[v] =NULL. (Результат тот
же, что и у процедуры DлG-SноRТЕsт-Рлтнs на с. 94.)

1. Установить shortest[v]=ooдля всех вершин v, за исключением s; slrortest{s]=O, и
для всех вершин v - pred [ v] = NULL.
2. Внести все верши.ны в множество Q.
3. Пока множество Q не пустое, выполнять следующие действия.
А. Найти в множестве Q вершину и с наименьшим значением slюrtest и удалить ее
изQ.
В. Для каждой вершины v, смежной с и:
i. Вызвать RELAX(u,v).
В каждой части следующего рисунка показаны значения shortest (приведены в вер­
шинах графа), значения pred (обозначены заштрихованными ребрами) и множество Q (не
затененные вершины) перед каждой итерацией цикла на шаге 3 алгоритма.

Глава 6. Кратчайшие пути

101

х

х

5

s
у

у

(а)

(б)

х

s

s

у

(в)

(r)

х

х

5

s
у

(д)

s

у

(е)

Затеняемая на каждой итерации вершина - это и есть выбранная вершина и на шаге
ЗА. В модели с бегунами после того, как вершина получает значения shortest и pred, они не
могут быть впоследствии изменены, но в данном случае вершина может получить новые
значения shortest и pred в результате ослабления некоторых других ребер. Например, по­
сле ослабления ребра (у,х) в части (в) рисунка значение shortest(x) уменьшается от оо до
13, а pred(x] становится равным у. Очередная итерация цикла на шаге 3 (часть (r)) осла­
бляет ребро(t,х), и shоrtеst(х]уменьшается еще больше-до 8. При этом pred(x] стано­
вится равным t. На следующей итерации (часть (д)) ослабляется ребро(z,x), но в этот раз
значение shortest(x] не изменяется, поскольку его значение 8 оказывается меньшим, чем
shortest ( z] + weight ( z, х ). равное 12.
Алгоритм Дейкстры поддерживает следующий инвариант цикла.
В начале каждой итерации цикла на шаге 3 shortest [ v] = sp ( s, v) для каждой
вершины v, не входящей в Q. То есть для каждой вершины v, не входящей в
Q, значение shortest( v) представляет собой вес кратчайшего пути от s до v.
Вот упрощенная версия обоснования этого инварианта цикла (формальное доказатель­
ство немного сложнее). Изначально все вершины входят в множество Q, так что инва­
риант цикла не применяется к вершинам до входа в первую итерацию цикла на шаге 3.
Предположим, что при входе в этот цикл все вершины, не входящие в множество Q, имеют

102

Глава 6. Кратчайшие пути

в shortest корректные значения весов кратчайших nyreй . Тогда каждое ребро, покидающее
эти вершины, было ослаблено при некотором выполнении шага ЗВi. Рассмотрим вершину
и из Q с наименьшим значением shortest. Ее значение shortest никогда не сможет умень­
шиться. Почему? Потому что единственные ребра, которые мoryr быть ослаблены, - это
ребра, выходящие из вершин в Q, а каждая вершина в Q имеет значение shortest, не ме уь­
шее, чем shortest(и]. Так как все веса ребер неотрицательные, для каждой вершины v d Q
должно выполняться shortest(u] $ shortest[ v] + weight( v,u ). так что ни одно будущее осла­
бление не уменьшит значение shortest [и]. Таким образом, shortest [и] имеет наименьшее
возможное значение, и мы можем удалить и из Q и выполнить ослабление всех выходящих
из и ребер. По завершении цикла на шаге 3 множество Q становится пустым, так что у всех
вершин в их значениях shortest оказываются корректные веса кратчайших путей.
Мы можем начать анализ времени работы процедуры D1жsтRA, но, чтобы проанализи­
ровать ее в полном объеме, сначала необходимо согласовать некоторые детали ее реали­
зации. Вспомним, что в главе 5, "Ориентированные ациклические графы", мы обозначали
2
количество вершин п и количество ребер т, и при этом т $ п • Мы знаем, что шаг 1 вы­
полняется за время 0( п ). Мы также знаем, что цикл на шаге 3 выполняет итерации ровно
п раз, потому что множество Q изначально содержит все п вершин, а каждая итерация
цикла удаляет по одной вершине из Q, причем вершины обратно в Q никогда не добавля­
ются. Цикл на шаге ЗА обрабатывает каждую вершину и каждое ребро ровно один раз в
течение выполнения алгоритма (с такой же идеей мы сталкивались при работе с процеду­
рами ToPOLOGICAL-SORT и Dлo-SнoRТESт-Pлrns в главе 5, "Ориентированные ациклические
графы").
Что же осталось проанализировать? Нам нужно понять, сколько времени потребуется,
чтобы поместить все п вершин в множество Q (шаг 2), за какое время можно найти вер­
шину в Q с наименьшим значением shortest и удалить эту вершину из Q (шаг ЗА) и какие
действия надо выполнить при изменении значений shortest и pred вследствие вызова про­
цедуры RELAX. Дадим этим операциям имена.
•

INSERT(Q,v) вставляет вершину v в множество Q. (Алгоритм Дейкстры вызывает про­
цедуру INSERT п раз.)

•

ExТRAcт-MIN(Q) удаляет из Q вершину с минимальным значением shortest и возвра­
щает эту вершину вызывающей процедуре. (Алгоритм Дейкстры вызывает процедуру
ExТRACT-MIN п раз.)

•

DECREASE-КEv(Q,v) выполняет все необходимые действия над Q, чтобы записать, что
значение shortest[ v] уменьшилось при вызове процедуры RELAX. (Алгоритм Дейкстры
вызывает процедуру DECREASE-КEY дот раз.)

Взятые вместе, эти три операции определяют очередь с приоритетами.
Описания очереди с приоритетами говорят только о том, что делают ее операции, но
не как они это делают. В разработке программного обеспечения отделение того, что дела­
ют операции, от того, как они это делают, известно как абстракция. Мы называем набор
операций, определяемых тем, что, но не как они делают, абстрактным типом данных,
или АТД, очередь с приоритетами является АТД.

Глава 6. Кратчайшие пути

103

Реализовать очереди с приоритетами - то самое как - можно с помощью одной из
нескольких струК"Т)'J) данных. Струюпура дQннwх представляет собой конкретный способ
хранения и доступа к данным на компьютере, например массив. В случае очереди с при­
оритетами мы рассмотрим три различные стрУК"Т)'РЫ данных, позволяющие реализовать
указанные операции. Разработчики программного обеспечения должны быть способны
использовать любую стрУК"Т)'Ру данных, которая реализует операции АТД. Но это совсем
не так просто, когда мы говорим об алгоритмах. Дело в том, что для различных стрУК"Т)'Р
данных способ реализации одной и той же операции может привести к разному времени
работы. Три различные стрУК"Т)'Ры данных, о которых сказано выше, действительно дают
различные времена работы алгоритма Дейкстры.
Переписанная версия процедуры D11КSТRA, явно вызывающая операции очереди с
приоритетами, приведена ниже. Рассмотрим три стрУК"Т)'РЫ данных для реализации при­
оритетных операций очереди с приоритетами и их влияние на время работы алгоритма
Дейкстры.
Процедура DuкsrRA( G,s)
Вход и результат: Те же, что и ранее.
1. Установить shortest[v] = оо для всех вершин v, за исключением s, shortest[s] = О, и
для всех вершин v - pred [ v] = NULL.
2. Сдел�rrь Q пустой очередью с приоритетами.
3. Дл.11 каждой вершины v:
А. Вызвать INSERт(Q,v).
4. Пока очередь Q не пуста, выполнять следующие действия.
А. Вызвать ExтRAcт-MJN(Q) и присвоить и возвращенную вершину.
В. Для каждой вершины v, смежной с и:
i. Вызвать REtлx(u,v).
ii. Если вызов RELAX(и,v) уменьшает значение shortest[v], вызвать DECREЛSE·

КEY(Q,v).

Простая реализация с помощью массива
Самый простой способ реализации операций очереди с приоритетами - хранение
вершин в массиве с п элементами. Если в текущий момент очередь с приоритетами со­
дерiит k вершин, то они находЯтся в первых k позициях массива в произвольном порядке.
Наряду с массивом необходимо поддерживать счетчик, указывающий, сколько вершин в
настоящее время находится в массиве. Операция INSERT реализуется легко: надо просто до­
бавить вершину в первую неиспользуемую позицию в массиве и выполнить приращение
значения счетчика. Операция DECREASE-KEY еще проще: делать не надо вообще ничего!
Обе эти операции выполняются за константное время. Однако операция ЕхТRАст-М1N вы­
полняется за время О( п ). поскольку мы должны просмотреть все вершины, имеющиеся

104

Глава 6. Кратчайшие пути

в текущий момент в массиве, чтобы найти вершину с наименьшим значением shortest.
Как только мы обнаружим эту вершину, удалить ее будет достаточно легко: нужно про­
сто переместить вершину из последней позиции в позицию удаляемой и соответственно
уменьшить значение счетчика. Время выполнения п вызовов процедуры ЕхтRАст-М1N со­
ставляет п2 Хотя вызов процедуры RELAx выполняется за время О( m), вспомните, что
т � п2• При такой реализации очереди с приоритетами время работы алгоритма Дейкс�ры
составляет п 2 при этом в нем доминирует время работы процедуры ЕхтRАст-М1N.

о( ).

о( ),

Реализация с помощью бинарной пирамиды
Бинарная пирамида организует данные как бинарное дерево, хранящееся в массиве.
Бинарное дерево представляет собой разновидность графа, но мы называем его вершины
узлами, ребра его неориентированные, а каждый узел имеет О, 1 или 2 узла ниже, которые
являются его дочерними узлами. На левой стороне приведенного рисунка показан пример
бинарного дерева с пронумерованными узлами. Узлы без дочерних узлов, такие как узлы
2
с 6 по I О, называются листьями .
1

1s

1

2

3

4

5

6

7

8

9

!0

j 2 j 4 j14l1ol s ]1sltsl11lнl16!

БинарнШI пирамида представляет собой бинарное дерево с тремя дополнительными
свойствами. Во-первых, дерево полностью заполняется на всех уровнях, за исключением,
возможно, самого нижнего, который заполняется слева до некоторой точки. Во-вторых,
каждый узел содержит ключ, на рисунке показанный внутри каждого узла. В-третьих,
ключи подчиняются свойству пирамиды: ключ каждого узла не превышает ключи его до­
черних узлов. Бинарное дерево на рисунке одновременно является бинарной пирамидой.
Бинарную пирамиду можно хранить в массиве, как показано справа на рисунке. Из-за
свойства пирамиды узел с минимальным ключом всегда находится в позиции \ . У узла,
находящегося в позиции i, его дочерние узлы находятся в позициях 2i и 2i + \, а узел, на­
ходящийся в дереве над ним - родительский узел, - в позиции Li/2J. Таким образом,
когда бинарная пирамида хранится в массиве, перемещение по ее элементам выполняется
очень легко.
Бинарная пирамида обладает еще одной важной характеристикой: если она состоит из
п узлов, то ее высота - количество ребер от корня до самого дальнего листа - состав­
ляет всего лишь LlgnJ. Таким образом, путь от корня до листьев, или из листа в корень,
можно пройти за время O(lgn).
1 Кштьютер11ые специалисты предпочитают рисовать деревья с кор11е.11 tЖерху. 11аправляя ветви
вниз. - в отличие от настоящю: деревьев. ветви которою u�vm вверх от корня, на'(одящегося вниЗ){

Глав а 6. Кратчайшие пути

105

L J,

Поскольку бинарные пирамиды имеют высоту lg п три операции очереди с приори­
тетами выполняются в ней за время O(lgn) каждая. В слу чае INSERT добавляем новый лист
в первую доступную позицию. Затем до тех пор, пока ключ в узле больше, чем ключ в
родительском по отношению к нему узле, выполняем обмен содержимым3 узла с содер­
жимым его родителя и перемещаемся на один уровень вверх к корню. Другими словами,
содержимое узла "всплывает" к корню до тех пор, пока не будет выполняться свойство
пирамиды. Поскольку путь к корню состоит не более чем из ltgn ребер, выполняется не
более lg п J-1 обменов, так что время работы операции INSERT составляет О( lg п ). Чтобы
выполнить операцию DECREASE-KEY, используется та же идея: уменьшение ключа с после­
дующим всплытием содержимого к корню до тех пор, пока не будет выполнено свойство
пирамиды, - вновь за время О( lg п ). Чтобы выполнить операцию ЕхтRАст-М1N, сохраните
содержимое корня для возврата вызывающей процедуре. Затем возьмите последний лист
(узел с наибольшим номером) и поместите его содержимое в корень. Затем "утопите" со­
держимое корня, обменивая содержимое узла и дочернего узла с меньшим значением клю­
ча, пока не будет выполнено свойство пирамиды. После этого верните сохраненное значе­
ние корня. Поскольку путь от корня до листа не превышает ltgn ребер, выполняется не
более Llg пJ-1 обменов, так что время работы операции Ехтмст-МIN составляет О( lg п ).
Когда алгоритм Дейкстры использует реализацию очереди с приоритетами с помо­
щью бинарной пирамиды, на вставку вершин он затрачивает время O(nlgn), на операции
ЕхтRАст-М1N - то же время О( п lg п) и наконец на операции DECREASE-KEY тратится время
O(mlgn) (на самом деле вставка п вершин выполняется за время Е>(п), поскольку изна­
чально только у вершины s значение shortest равно нулю, а у всех остальных вершин зна­
чение shortest равно оо). Если граф разре3Кенный, т.е. число ребер т гораздо меньше, чем
n2 , реализация очереди с приоритетами с помощью бинарной пирамиды оказывается более
эффективной, чем при использовании простого массива. Графы, моделирующие сети до­
рог, являются разреженными, так как средний перекресток покидают около четырех дорог,
а потому т составляет около 4n. С другой стороны, когда граф оказывается плотным т.е.
когда т близко к п 2, так что в графе имеется много ребер - время О( т lg п ), которое алго­
ритм Дейкстры затрачивает на вызовы операций DECREASE-КEY, может сделать его медлен­
нее, чем при реализации очереди с приоритетами с помощью простого массива.
Вот еще одно применение бинарных пирамид: для выполнения сортировки за время
O(nlgn).

L

J

J

Процедура HEЛPSORТ(A,n)
Вход:
• JA: массив.
• п: 1\-Оличество сортируемых элементов в массиве А.

Выход: массив В, содержащий элементы массива А в отсортированном пор,щке.
1 Содерж-1шое узла включает ключ и любую прочую ищ/юр...,ацию. связа1111ую с ключом, 11апри:нер
какая вершина соответствует это.'lу у:1,1у.

106

Глава 6. Кратчайшие пути

1. Построить uинарную пирамиду Q из элементов массива А.
2. Пусть В(l.л] предСТUJJJ1ет собойиовый массив.
3. Дли i=l доп:
А. Вызывать Exтмcr-МIN(Q) и прнсвоиn. возвращаемое значение элемсmу В[i] .
f
4. Вернуrь массив В.
Шаг 1 преобразует входной массив в бинарную пирамиду, что можно сделать одним
из двух способов. Первый способ заключается в том, чтобы начать с пустой бинарной
пирамиды, а затем вставлять каждый элемент массива в сумме за время О ( п lgп) . Другой
способ состоит в построении бинарной пирамиды непосредственно в массиве, работая
снизу вверх, за время О(п). Можно также выполнить сортировку на месте без привлече­
ния дополнительного массива В.

Реалиэация с помощью фибоначчиевой пирамиды
Можно реализовать очередь с приоритетами и с помощью сложной структуры данных
под названием "фибоначчиева пирамида". При использовании фибоначчиевой пирамиды
п операций INSERT и ExтRAcт-MIN в сумме выполняются за время О( п lgп), ат операций
DECREASE-КEY занимают время Е>(т), так что общее время работы алгоритма Дейкстры
составляет О( п lg п +т). На практике фибоначчиевы пирамиды используются редко. Во­
первых, отдельные операции моrут выполняться гораздо дольше, чем в среднем, хотя об­
щее время остается приведенным выше. Во-вторых, фибоначчиевы пирамиды достаточно
сложны, так что скрытые в асимптотических обозначениях константные множители суще­
ственно большие, чем в случае бинарных пирамид.

Алгоритм Беллмана-Форда
Если некоторые ребра имеют отрицательные веса, алгоритм Дейкстры может вернуть
неверный результат. Алгоритм Беллмана-Форда4 в состоянии справиться с отрицательны­
ми весами ребер, и его можно использовать для обнаружения и помощи в идентификации
ЦИl(Jla с отрицательным весом.
Алгоритм Беллмана-Форда удивительно прост. После инициализации значений shortest
и pred он просто ослабляет все т ребер п -1 раз. Сама процедура показана ниже, а на ри­
сунке показано, как этот алгоритм работает с небольшим графом. Исходная вершина - s,
значения shortest приведены в вершинах графа, а заштрихованные ребра указывают зна­
чения pred: если ребро (и, v) заштриховано, то pred [ v] = и . В приведенном примере мы
предполагаем, что каждый проход по всем ребрам ослабляет их в фиксированном порядке
(t,x), (t,y), (t,z), (x,t), (у,х), (y,z), (z,x), (z,s), (s,t), (s,y). В части (а) показана
ситуация незадолго до первого прохода, а в частях (б)-{д) показано состояние дел после
каждого очередного прохода. Значения shortest и pred в части (д) являются конечными.
4 Основан на отдельных алгоритwах, разработанных Ричардаw Белл,wа11а\f (Richard Bellman) в
1958 году и Лестерам Фордом (Lester Ford) в 1962 году.

Глага 6. Кратчайшие пути

107

Процедура BELLМAN-FoRD(Grt)
Вход:
• G: ориентиро88ИНЫЙ rраф, содержащий множесrво У из п вершин lf множество Е из

т ориентироааинwх ребер с произвот,нымн весами.
• ,: исходнu вершина в JI.
Pe:JJ,Aьmam: тоr ае, чт о и в процедуре DuкsтRA (с.100).
1. Устаиовип. shol'tt;Jt(v]•ao м• всех вершин v, за исключением ,; установить
1hortut[1] • О и дu всех вершин v установить pred( v] • NULL.
2. Дu l • 1 ДО n -1:

А. Д.u JCDДOro ребра ( и, v} из Е:
i. Вызвать RJ!I.Ax(u,v).
х

у

у
(б)

(а)

у

у

(r)

(В)

у

t

(д)

Как может настолько простой алгоритм выдать правильный ответ? Рассмотрим крат­
чайший пуrь от источника s к любой вершине v. Вспомним (с. 93), что если мы ослабим
ребра по порядку вдоль кратчайшего пуrи от s к v, то значения shortest[ v] и pred[ v] ока­
жутся верными. Сейчас, если циклы с отрицательным весом запрещены, всегда имеется
кратчайший пуrь от s к v, не содержащий цикл. Почему? Предположим, что кратчайший
путь от s к v содержит цикл. Поскольку этот цикл должен иметь неотрицательный вес,

108

Глава 6. Кратчайшие пути

мы могли бы вырезать этот цикл из пути и в конечном итоге остаться с путем от s к v, вес
которого не выше веса пути, содержащего цикл. Каждый ациклический путь должен со­
держать не более п - \ ребер, так как если путь содержит п ребер, то некоторые вершины
он должен пройти дважды, что образует цикл. Таким образом, если в графе есть крат­
чайший путь от s к v, то есть такой кратчайший путь, который содержит не более п - \
ребер. При первом выполнении шага 2А ослабляются все ребра, а значит, и первое �ро
на кратчайшем пути. При втором выполнении шага 2А вновь ослабляются все ребра, а
значит, и второе ребро на кратчайшем пути и т.д. После ( п - \ )-го выполнения все ребра
на кратчайшем пути в соответствующем порядке гарантированно ослаблены, а значит,
значения shortest[ v] и pred[ v] оказываются верными.
Теперь предположим, что граф содержит цикл с отрицательным весом, но мы запусти­
ли для него процедуру BELLMAN-FORD. В результате можно ходить и ходить по этому циклу,
каждый раз получая все меньший и меньший вес кратчайшего пути. Это означает, что
имеется по крайней мере одно ребро (и, v) цикла, для которого shortest [ v] будет постоянно
уменьшаться при очередном ослаблении - несмотря даже на то, что это ребро уже было
ослаблено п - \ раз.
Так что вот как можно найти цикл с отрицательным весом, если таковой существу­
ет, после запуска процедуры BELLMAN-FORD. Пройдем по ребрам еще один раз. Если мы
найдем ребро ( и, v), для которого shortest[u]+ weight(u, v) < shortest[ v], то мы знаем, что
вершина v либо входит в цикл с отрицательным весом, либо достижима из него. Найти
вершину в цикле с отрицательным весом можно путем отслеживания значений pred на
обратном пути от v, отслеживая все посещенные вершины до тех пор, пока не обнаружим
ранее посещенную вершину х. Затем мы можем проследить значения pred, ведущие об­
ратно из х, до тех пор, пока вновь не достигнем х. Все вершины на этом пути вместе с х
образуют цикл с отрицательным весом. Приведенная далее процедура поиска цикла с от­
рицательным весом показывает, как определить, имеет ли граф такой цикл, и если имеет,
то как его построить.
Процедура FlND-NEGATIVE-WEJGHT-CYCLE( G)
Вход: G: ориентиро.ванныJi граф, содержащий множество Vиз 11 вершин и множество Е

из т ориентированных ребер с произвольными весами, для которого уже была выпол­
нена процедура BELLMAN-FORD.
Выход: либо список вершин, в указанном порядке образующих цикл с отрицательным
весом, либо пустой список, если таких циклов в графе нет.
1. Пройти по всем ребрам в поисках такого ребра (и, v), что sl1ortest[u ]+ weight(и, v) <
< sliortest [ v).
2. Если таких ребер нет, вернуть пустой список.
3. В противном случае ( имеется некоторое ребро (и, v), такое, что shortest [и]+
+ weight(u, v) < s/10,·test[ v]) выполнить следующее.
А. Пусть visited- новый массив с одним элементом для каждой вершины. Уста­
новить все элементы массива visited равным11 FALS!i.

Глава 6. Кратчайшие пути

109

В. Установить х равным v.
С. Пока visited(x] равно FALSE, выполнять следующее.
i. Установить visited[x]=TRUE.
ii. Установить х равным pred[х) .
D. Теперь мы знаем, что х nредстамяет собой вершину в цикле с отрицательным
весом. Установить vравным pred(x].
Е. Создать список вершин сус/е, изначально содержащий только вершину х.
F. Пока vне равно х, вылолЮ1Ть следующее.
i. Вставить вершину v в начало цикла.
ii. Установить vравным pred(v].
G. Вернуть список сус/е.
Проанализировать время работы алгоритма Беллмана-Форда достаточно легко. Цикл
на шаге 2 выполняет свои итерации п-1 раз, и каждый раз при таком выполнении цикл
на шаге 2А выполняет т итераций, по одной для каждого ребра. Общее время работы,
таким образом, оказывается равным 0(пт). Чтобы выяснить, существует ли цикл с от­
рицательным весом, каждое ребро ослабляется еще раз либо до тех пор, пока ослабление
не изменит значение shortest, либо пока не будут ослаблены все ребра, что выполняется за
время О( т). При наличии цикла с отрицательным весом он не может состоять более чем
из п ребер, так что время его трассировки составляет О{ п ).
В начале этой главы говорилось о том, что циклы с отрицательным весом могут возни­
кать в области обмена валют. Обменные курсы валют меняются быстро. Представьте себе,
что в некоторый момент времени действуют следующие курсы валют.
За I доллар США можно купить О.7292 евро.
За I евро можно купить 105.374 японской иены.
За I японскую иену можно купить 0.3931 российского рубля.
За I российский рубль можно купить 0.0341 доллара США.
Тогда вы могли бы взять I доллар США, купить за него О.7292 евро, взять О.7292
евро и купить 76.8387 иены (поскольку 0.7292 · 105.374 = 76.8387 с точностью до че­
тырех знаков после запятой), взять 76.8387 иены и купить 30.2053 рубля (поскольку
76.8387 ·0.3931 = 30.2053 с точностью до четырех знаков после запятой) и наконец взять
30.2053 рубля и купить 1.03 доллара (поскольку 30.2053 · 0.0341 = 1.0300 с точностью до
четырех знаков после запятой). Если все четыре операции можно выполнить до изменения
обмtнных курсов, то можно получить 3% прибыли. Начните с одного миллиона долларов,
и вы получите прибыль в 30 тысяч долларов, не пошевелив пальцем!
Такой сценарий называется возможностью арбитража. Вот как найти ее путем поиска
цикла с отрицательным весом. Предположим, что имеются п валют с"с2> с 3 , • • • ,с" и из­
вестны все обменные курсы между парами валют. Предположим, что за единицу валюты
с; можно купить rif единиц валюты cj, так что rif представляет собой обменный курс валют
с; и ci. И i, иj находятся в диапазоне от I доп (считаем, что r;; = 1 для всех валют с).

Глава 6. Кратчайшие пути

110

Возможность арбитража соответствовать такой последовательности k валют
(ci, , ci1 ,ci, , ...,ci, ). что когда вы перемножаете их обменные курсы, то получаете произ­
ведение, строго большее 1:
ri, ,i, · tj, .;, .. · '1,-, ,i, · ri, ,i, > 1.

Прологарифмируем обе части неравенства. Основание логарифмов значения не имеет,
так что поступим, как настоящие компьютерщики, и будем логарифмировать по оtно­
ванию 2. Так как логарифм произведения равен сумме логарифмов сомножителей, т.е.
lg(x· у)= lgx+ lgy, нас инте ресует ситуация, когда
lgr..+ lgr .. + ..·+ lgr. , + lgr.. > О.
)1,)2

lt ·1)

J, ••• JJ.

1, ·11

MeНJIJI знаки с обеих сторон неравенства, получаем
(-lgr.. )+(-lgr.. )+ .. ·+(-lgr. . )+(-lgr.. )<О ,
Jr ·12

)2 ,))

1, ....1.

1, ,)1

что соответствует циклу с весами ребер, равными взятым с обратными знаками логарифмам обменных курсов.
Чтобы найти возможность арбитража, если таковая существует, надо построить ори­
ентированный граф с вершиной v1 для каждой валюты с1 • Для каждой пары валют с1 и ci
создаются ориентированные ребра ( v1 , vi ) и ( vi , v1 ) с весами -lg rif и - lgri1 соответственно.
Добавим новую вершину s с ребрами ( s, v1 ) с нулевым весом, идущими к каждой вершине
от v1 до v•. Затем выполним алгоритм Беллмана-Форда над этим графом с s в качестве ис­
ходной вершины, а результатом воспользуемся для выяснения, не содержит ли он цикл с
отрицательным весом. Если содержит, то вершины этого цикла соответствуют валютам
2
возможности арбитража. Общее количество ребер т равно п + п ( п -1) = п , так что алго­
2
3
кроме того, время
п ) требуется
ритм Беллмана-Форда выполняется за время
п
для выяснения наличия цикла с отрицательным весом и О( п) - для его идентификации
3
(если он существует). Хотя время О(п ) кажется слишком большим, на практике все не
так плохо, потому что константные множители, скрывающиеся в асимптотических обо­
значениях, достаточно малы. Я написал и скомпилировал соответствующую программу и
выполнил ее на моем MacBook Pro 2,4 ГГц для 182 валют - по количеству валют всего
мира. После загрузки обменных курсов (я воспользовался генератором случайных чисел)
программа завершилась примерно за 0.02 секунды.

о( );

о(

Алгоритм Флойда-Уоршелла
Теперь предположим, что вы хотите найти кратчайший путь от каждой вершины графа
к каждой другой вершине. Эrо задача поиска кратчайших путей между всеми пара.ми

верши н.

Классический пример кратчайших путей между всеми парами вершин, на который
ссылается множество авторов, - это таблица в дорожном атласе, указывающая расстоя­
ния между городами. Найдите строку для одного города, столбец для другого, и на пере­
сечении этих строки и столбца вы найдете расстояние между указанными городами.
У этого примера имеется только одна небольшая проблема - это не все пары. Если бы
это были кратчайшие расстояния между всеми парами, таблица содержала бы по одной
строке и одному столбцу для каждого перекрестка, а не только для каждого города. Число

Глава 6. Кратчайшие пути

111

строк и столбцов в этом случае оказалось бы равным миллионам, так что единственный
способ сделать эту таблицу удобочитаемой - сократить ее и указывать кратчайшие пути
только между городами.
Но вот пример применения поиска кратчайших путей между всеми парами вершин без
сучка и задоринки: поиск диаметра сети, который представляет собой самый длинный из
всех кратчайших путей. Например, предположим, что ориентированный граф представля­
ет собой коммуникационную сеть, а вес ребра определяет время, необходимое сообщению
для прохода по каналу связи. Тогда диаметр дает наибольшее время прохода сообщения
через сеть.
Конечно, можно вычислить кратчайшие пути между всеми парами вершин путем вы­
числения кратчайших путей от одного источника поочередно для каждой вершины. Если
все ребра имеют неотрицательные веса, можно воспользоваться алгоритмом Дейкстры
для каждой из п вершин, и каждый такой вызов выполняется за время O(mlgn) при ис­
пользовании бинарных пирамид, и O(nlgn+m) при использовании фибоначчиевых пи­
рамид. Так что общее время работы программы будет составлять либо O(nmlgn), либо
О ( п 2 lg п + пт ). Если граф разреженный, такой подход вполне работоспособен. Но если
3 lgn). Даже приме­
2
граф плотный, так что т близко к п , то O(nmlgn) превращается в
нение фибоначчиевых пирамид дает для плотного графа время работы
п 3 ), и при этом
скрытый постоянный множитель в асимптотической записи может быть значительным из­
за сложности реализации фибоначчиевых пирамид. Конечно, если граф может содержать
ребра с отрицательным весом, то говорить о применении алгоритма Дейкстры не прихо­
дится, и для каждой из п вершин следует использовать алгоритм Беллмана-Форда, время
4
2
работы которого 0(n m) ДЛЯ ПЛОТНОГО графа превращается В 0(n
Если же вместо этого воспользоваться алгоритмом Флойда-Уоршелла\ то задачу по­
3
иска кратчайших путей между всеми парами вершин можно решить за время 0 ( п ), неза­
висимо от того, плотный ли граф, разреженный или представляет собой некоторый сред­
ний случай. Алгоритм допускает наличие в графе ребер (но не циклов) с отрицательным
весом. При этом скрытая в 0 -обозначении константа достаточно мала. Кроме прочего,
алгоритм Флойда-Уоршелла демонстрирует применение алгоритмического метода, име­
нуемого "динамическим программированием".
Алгоритм Флойда-Уоршелла основан на очевидном свойстве кратчайших путей. Пред­
положим, что вы ведете машину от Киева до Запорожья по кратчайшему маршруту и что
этот кратчайший маршрут проходит через Переяслав-Хмельницкий и Кременчуг. Тогда
часть кратчайшего пути из Киева в Запорожье, идущая из Переяслава-Хмельницкоrо в
Кременчуг, должна быть кратчайшим путем из Переяслава-Хмельницкоrо в Кременчуг.
Почему? Потому что, если бы был более короткий маршрут из Переяслава-Хмельницкоrо
в �менчуr, мы использовали бы его в кратчайшем пути из Киева в Запорожье! Как я
и говорил, это совершенно очевидное свойство. Применим этот принцип к ориентирован­
ным графам.

о(п

о(

).

J Наз6йн по uweнaw его разработчиков. Роберта Флойда (Robert Floyd) и Стивена Уоршелла
(Stephen Warshall).

112

Глава 6. Кратчайшие пути

Если кратчайший путь (назовем его р) из вершины и в вершину v идет из
вершины и через вершину х, затем в вершину у, а потом в вершину v, то часть
пути р между вершинами х и у сама является кратчайшим путем из х в у. То
есть любой подпуть кратчайшегопути является кратчайшим nyme.w.
Алгоритм Флойда-Уоршелла отслеживает веса путей и предшественников верш�;fн в
массивах, индексируемых в трех измерениях. Одномерный массив можно представить
в виде таблицы (такой, как, например, на с. 24). Двумерный массив можно представить в
виде матрицы (как, например, матрица смежности на с. 86). Для идентификации записи
в этом случае необходимы два индекса - строка и столбец. Двумерный массив можно
представить также как одномерный массив, в котором каждая запись сама по себе явля­
ется одномерным массивом. Трехмерный массив можно рассматривать как одномерный
массив двумерных массивов; для идентификации записи необходимы значения индексов
в каждом из трех измерений. Для разделения размерностей при индексации многомерных
массивов мы будем использовать запятые.
В алгоритме Флойда-Уоршелла мы предполагаем, что вершины пронумерованы от l
доп. Номера вершин в данном случае важны, потому что алгоритм Флойда-Уоршелла ис­
пользует следующее определение.
shortest[u,v,x] представляет собой вес кратчайшего пути от вершины и к
вершине v, в котором все промежуточные вершины - вершины на пути, от­
личные от и и v- пронумерованы от I дох.
(Так что и, v их можно рассматривать как целые числа в диапазоне от l до п, которые
представляют вершины.) Это определение не требует, чтобы промежуточные вершины
включали всех вершин с номерами от I дох; оно просто требует, чтобы каждая промежу­
точная вершина - сколько их ни есть - имела номер не вышех. Поскольку все вершины
имеют номер не выше п, значение shortest[u,v,п] должно быть равно sp(u, v), весу крат­
чайшего пути от и к v.
Рассмотрим две вершины, и и v, и выберем число х в диапазоне от I доп. Рассмотрим
также все пути от и к v, в которых все промежуточные вершины имеют номера, не пре­
вышающие х. Пусть среди всех этих путей путь р имеет наименьший вес. Путь р либо
включает вершину х, либо нет, и мы знаем, что, за исключением, возможно. и или v, он не
содержит ни одну вершину с номером больше х. Существуют две возможности.
• Первая возможность: х не является промежуточной вершиной пути р. Тогда все про­
межуточные вершины пути р имеют номера не более х - 1. Что это значит? Это значит,
что вес кратчайшего пути от и к v со всеми промежуточными вершинами с номерами
не более х, такой же, как и вес кратчайшего пути от и к v, в котором все промежу­
точные вершины имеют номера не выше х-1. Иными словами, .shortest[u,v,x] равно
shortest[u,v,x - 1].
• Вторая возможность: х появляется в качестве промежуточной вершины пути р.
Поскольку любой подnуть кратчайшего пути сам по себе является кратчайшим путем,

Глава б. Кратчайшие пути

113

часть пути р, которая идет от и к х, является кратчайшим путем от и к х. Аналогично
часть р, которая идет от х к v, является кратчайшим путем от х к v. Поскольку вершина
х является конечной точкой каждого из этих подпутей, она не может быть промежу­
точной вершиной в любом из них, а значит, промежуточные вершины в каждом из
рассмотренных подпутей имеют номера, не превышающие х -1. Таким образом, вес
кратчайшего пути от и к v, в котором все промежуточные вершины имеют номера,
не превышающие х, равен сумме весов двух кратчайших путей: одного - от и к х со
всеми промежуточными вершинами с номерами не выше х -1 и второго - от х к v, так­
же со всеми промежуточными вершинами с номерами не выше х -1. Иными словами,
shortest(u,v,x) равно сумме shortest(u,x,x- l)+shortest(x, v,x-1).
Поскольку х либо является промежуточной вершиной на кратчайшем пути от и к v,
либо нет, мы можем заключить, что shortest(u,v,x) является меньшим из значений
shortest(и,х,х -1) + shortest(x,v,x-1) и shortest(u, v,x-1).
Наилучший способ представления графа в алгоритме Флойда-Уоршелла - с по­
мощью варианта представления матрицей смежности. В такой матрице каждый элемент
уже не ограничен значениями О или t; запись для ребра (и, v) содержит вес ребра, где
значение оо означает, что данное ребро отсутствует. Поскольку shortest(u, v,O) означает
вес кратчайшего пути с промежуточными вершинами с номерами не более О, такой путь
не имеет промежуточных вершин, т.е. состоит только из одного ребра. Таким образом,
описанная нами матрица - именно то, что требуется для shortest ( и,v, О).
Исходя из имеющихся значений shortest(u, v,O) (которые представляют собой веса ре­
бер), алгоритм Флойда-Уоршелла вычисляет значения shortest(u,v,x) сначала для всех
пар вершин и и v с х, равным 1. После этого алгоритм вычисляет значения shortest(и,v,x]
сначала для всех пар вершин и и v с х, равным 2, а затем - с х, равным 3 и так далее вплоть

доп.

Как отслеживать предшественников вершин на кратчайших путях? Определим
pred(u,v,x) аналогично тому, как мы определили shortest(u,v,x) как предшественни­
ка вершины v на кратчайшем пути от вершины и, в котором номера всех промежуточ­
ных вершин не превышают х. Мы можем обновлять значения pred(u,v,x) так же, как
мы вычисляли значения shortest(u,v,x). Если shortest(u,v,x) имеет то же значение, что
и shortest(u, v,x-1) , то кратчайший путь от и к v, в котором номера всех промежуточных
вершин не превышают х, такой же, как и путь, в котором номера всех промежуточных
вершин не превышают х -1. Предшественники вершины v при этом должны быть оди­
наковы в обоих путях, так что pred(u,v,x] мы делаем таким же, как и pred(u, v,x-1). Но
что если shortest(u,v,x) меньше shortest(u,v,x-\)? Это происходит, когда мы находим
пут� от и к v, имеющий в качестве промежуточной вершину х и имеющий меньший вес,
чем кратчайший путь от и к v, в котором номера всех промежуточных вершин не превы­
шают х -1. Поскольку х должна быть промежуточной вершиной на этом вновь найден­
ном кратчайшем пути, предшественник вершины v на пути от и должен быть тем же, что
и предшественник v на пути от х. В этом случае мы устанавливаем pred[ и, v,x] равным
pred(x, v,x-1).

114

Глава 6. Кратчайшие пути

Теперь мы можем сложить все кусочки мозаики в единую картину алгоритма Флойда­
Уоршелла.
Процедура fLOYD-WARSНALL(G)
Вход: G: граф, представленный весовой матрицей смежности W с п строками и п столб­
цами (по одной строке и одному столбцу Д1U1 каждой вершины). Запись в строке • и
столбце v, записываемЗJI как w,.., представляет собой вес ребра (i,, ,,), если таковое при­
сутсrвует в G, и равна оо в противном случае.
Выход: для каждой пары вершин tt и v значеm1е shortest [и, v,n) содержит вес кратчай­
шего пути от и до v, а pred[u,v, п] - вершину, яв.1JJ1ющуюся предшественником верши­
ны V на 1Ср3ТЧ8ЙШСМ пути из и.
1. Пусть shortest и pred представляют собой новые массивы размером п х п х (п + 1 ).

2. Для всех и и v от I до 11:
А. Установить shortest [и, v, О] равным w...
В. Если (и, v) является ребром rрафа G, установить pred[и, v, О] равным и. В против­
ном случае установить pred[u, v,0] равным NULL.
3. Для Х = l ДО n:
А. Для и = 1 до п:
i. Для V = 1 ДО n:
а. Если shortest[u, v,x] < shortest[u,x,x-l]+shortest[x, v,x-1], то устаliовить
shortest[u, v,x) равным shortest[u,x,x-l)+shortest[x, v,x-1}, а pred[u, v.x]
равным pred[x,,,,x-1).
Ь. В противном случае установить shortest[и, v,x) равным shortest[u, v,x-1),
а pred[u, v,x) равным pred[u, v,x-1].
4. Вернуть массивы shortest и рrед
Для rрафа

матрица смежности W, содержащЗJ1 веса ребер, имеет вид

Глава 6. Кротчайшие пути

1 15

6

и дает значения shortest[u,v,0) (веса путей не более чем с одним ребром). Например,
shortest[2,4,0] равно 1, поскольку из вершины 2 можно попасть в вершину 4 непосред­
ственно, без промежуrочных вершин, по ребру (2,4), имеющему вес 1. Аналогично
shortest[4,3,0] равно -5. А вот как выглядит матрица pred[u,v,0):

�:1

[:; �u :�
4

4

NULL

NULL

Например, pred[2,4,0] равно 2, поскольку предшественником вершины 4 является вер­
шина 2, при использовании ребра (2, 4), имеющего вес 1. pred[2, 3, О] равно NU LL, посколь­
ку ребра ( 2,3) в графе нет.
После выполнения цикла на шаге 3 для х = 1 (рассматриваются пути, которые мoryr
включать вершину I в качестве промежуrочной) значения shortest[u,v,1] и pred[u,v,1]
имеют вид
LL

:
[
оо

2

�

�

4

0

:���
7
1 И [
00
NULL

5 -5 0

[=�

�LL

�LL

�

3

NULL

NULL

4

NULL

4

1

.

После выполнения цикла для х = 2 значения shortest[u, v,2] и pred[u, v,2] имеют вид
:
[

�

�

:

00 4 0 5
2 5 -5 0

1 И

NULL

N�LL

N�LL

�

3

NULL

2

4

NULL

4

1

.

После выполнения цикла для х = 3 значения shortest[u, v,3] и pred[u, v,3] имеют вид
00

0

�

00

4

0

[о2 -1з

�

:���
1 И [
5
NULL

-5 О

4

�LL

N�LL

3

NULL

3

4

jJ

Окончательные значения shortest[u,v,4] и pred[u,v,4] после выполнения цикла для
х = 4 имеют вид
4
NULL
4
3
NULL
3

4

Поскодьку трех.111ерный .111ассив npeдcmaВJ1J1em собой одномерный массив дtJумерных массивов,
д//Я фиксированного значения х мы рассматриваем shortest и, v, х] как двумерный массив.
6

[

116

Глава 6. Кратчайшие пути

Оrсюда видно, например, что кратчайший путь из вершины I в вершину 3 имеет вес -1 .
Этот путь начинается в вершине 1, проходит через вершины 2 и 4 и завершается в верши­
не 3, что можно отследить по значениям массива pred: pred[l,3,4) = 4 , pred[l,4,4) = 2 и
pred[l,2,4] = 1 .
Я говорил, что время работы алгоритма Флойда-Уоршелла равно е{ п3 ), и в этом легко
убедиться. У нас есть три вложенных один в другой цикла, и каждый из них выполнt�ет
по п итераций. В каждой итерации цикла на шаге 3 цикл на шаге ЗА выполняет п итераций.
Аналогично в каждой итерации цикла на шаге ЗА цикл на шаге ЗАi выполняет п итераций.
Поскольку внешний цикл на шаге 3 также выполняет п итераций, внутренний цикл (на шаге
ЗАi) выполняет всего п3 итераций. Каждая итерация самого mубоко вложенного цикла вы­
полняется за константное время, так что общее время работы алгоритма равно Е>(п3 ) •
Что касается используемой памяти, то дело выглядит так, будто этот алгоритм требует
Е>{п3 ) памяти. В конце концов, он ведь создает два массива размером пхпх(п+ 1). А
поскольку каждая запись массива занимает константное количество памяти, в сумме эти
массивы занимают Е>{п 3 ) памяти. Оказывается, однако, что можно ограничиться памя­
тью всего лишь размером е( п 2 ). Каким образом? Просто создав массивы shortest и pred
размером п х п и забыв о третьем индексе. Хотя на шагах ЗАiа и ЗАiЬ происходит обнов­
ление одних и тех же значений shortest[u,v) и pred[u,v], оказывается, что в конце эти
массивы содержат верные значения!
Ранее я упоминал, что алгоритм Флойда-Уоршелла иллюстрирует применение техно­
логии динамического программирования. Эта технология применима, когда
1. мы пытаемся найти оптимальное решение задачи,
2. мы можем разбить экземпляр задачи на экземпляры одной или нескольких подзадач,
3. мы используем решения подзадач (или подзадачи) для решения исходной задачи,
4. если мы используем решение подзадачи в оптимальном решении исходной задачи, то
решение используемой подзадачи должно быть оптимальным.
Мы можем подытожить эти условия единым лаконичным названием оптимальная
подструктура. Говоря кратко, оптимальное решение проблемы должно содержать в себе
оптимальные решения подзадач. В динамическом программировании у нас есть некоторое
понятие "размера" подзадачи, и мы часто решаем подзадачи в порядке увеличения разме­
ра, т.е. сначала решаем маленькие подзадачи, затем, как только у нас имеются оптималь­
ные решения меньших подзадач, можно пытаться решать большие подзадачи, используя
оптимальные решения меньших подзадач оптимальным же образом.
Такое описание динамического программирования выглядит довольно абстрактно, так
что давайте посмотрим, как его использует алгоритм Флойда-Уоршелла. Сформулируем
подзадачу как
вычислить значение shortest[u,v,x), которое представляет собой вес крат­
чайшего пути от вершины и до вершины v, в котором промежуточные вер­
шины имеют номера от I дох.

Глава 6. Кратчайшие пути

117

Здесь "размер" подзадачи - наибольший номер вершины, которая может быть про­
межуточной на кратчайшем пути; иными словами, это значение х. Оптимальная подструк­
rура осуществляется благодаря следующему свойству.
Рассмотрим кратчайший путь рот вершины и к вершине v, и пусть х - наи­
больший номер промежуточной вершины на этом пути. Тогда часть р, иду­
щая от и к х, представляет собой кратчайший путь от и к х, в котором все
промежуточные вершины имеют номера, не превышающие х -1 , а часть р,
идущая от х к v, представляет собой кратчайший путь от х к v, в котором все
промежуточные вершины имеют номера, не превышающие х -1 .
Мы
решаем
задачу
вычисления
shortest[u, v,x],
сначала
вычисляя
shortest[u,v,x-1], shortest[u,x,x-1] и shortest[x,v,x-\], а затем используя меньшее из
значений shortest[u,v,x-\] и shortest[u,x,x-\]+shortest[x,v,x-\]. Поскольку мы долж­
ны вычислить все значения, где третий индекс равен х -\, прежде чем вычислять значе­
ния с третьим индексом х, у нас имеется вся информация, необходимая для вычисления
shortest [и, v, х].
Обычной практикой динамического программирования является хранение оптималь­
ных решений подзадач (shortest[u, v,x-1], shortest[u,x,x-1] и shortest[x, v,x-1]) в табли­
це, а затем просмотр таблицы при вычислении оптимального решения исходной задачи
(shortest[u, v,x]). Такой подход называется восходящим, так как работает от меньших под­
задач к большим. Другой подход заключается в нисходящем решении подзадач, переходя
от больших подзадач к более мелким (сохраняя при этом результат решения каждой под­
задачи в таблице).
Динамическое программирование применимо к широкому спектру задач оптимиза­
ции, и лишь некоторые из них связаны с графами. Мы вновь встретимся с ним в главе 7,
"Алгоритмы на строках", когда будем искать наибольшую общую подпоследовательность
двух символьных строк.

Дальнейшее чтение

Алгоритмы Дейкстры и Беллмана-Форда подробно описаны в mаве 24 CLRS [4]. В
главе 25 CLRS рассматриваются алгоритмы поиска кратчайших путей между всеми па­
рами вершин, включая алгоритм Флойда-Уоршелла; все алгоритмы поиска кратчайших
путей между всеми парами вершин, основанные на умножении матриц, имеют время ра­
боты E>(n3 lgn); интеллекrуальный алгоритм Дональда Джонсона (Donald Johnson), раз­
работанный для поиска кратчайших путей между всеми парами вершин в разреженных
графах, имеет время работы О ( п2 lg п + пт ).
Когда веса ребер представляют собой небольшие неотрицательные целые числа, не
превышающие некоторую известную величину С, более сложная реализация очереди с
приоритетами в алгоритме Дейкстры дает асимптотическое время работы, превосходящее
использование фибоначчиевых пирамид. Например, Джа (Ahuja), Мельхорн (Mehlhom),
Орлин (Orlin) и Таржан (Tatjan) [2] включили в алгоритм Дейкстры "перераспределенные
пирамиды", что дало время работы алгоритма, равное о( т + п,jlg С).

7 ••• Алгоритмы на строках
CmpolUl предстаВЛJ1ет собой просто последовательность символов из некоторого их
набора. Например, эта книга включает в себя символы из множества букв, цифр, знаков
препинания и математических символов, которое является довольно большим, но конеч­
ным. Биологи кодируют ДНК как строки всего лишь из четырех символов - А, С, G, т, которые предстаВЛJ1ют базовые аминокислоты аденин, цитозин, гуанин и тимин.
Мы можем выяснять различную информацию о строках, но в этой главе мы остано­
вимся на алгоритмах для решения трех задач, для которых строки являются входными
данными:
1. найти наибольшую общую подпоследовательность символов двух строк;
2. для заданного множества операций, преобразующих строку, и стоимости каждой опера­
ции найти способ преобразования одной строки в другую с наименьшей стоимостью;
3. найти все вхождения заданной строки в другую строку или текст.
Первые две из этих задач находят применение в вычислительной биологии. Чем длин­
нее общая подпоследовательность аминокислот, которую мы можем найти у двух ДНК,
тем больше они похожи. Другой способ сравнения ДНК состоит в преобразовании одной
в другую; чем ниже стоимость такого преобразования, тем более они сходны. ПоследНJIJI
задача - поиск вхождения строки в текст (которая также часто называется сопост1U1Ле­
н11ем строк)- используется в программах всех видов, например где в меню есть команда
"Поиск". Она также находит применение в вычислительной биологии, где мы можем ис­
кать одну цепочку ДНК внутри другой.

Нандлиннейшая общая подпоследовательность
Начнем с того, что мы подразумеваем под терминами "последовательность" и "под­
последовательность". Последователъностъ представляет собой список элементов, в
которых играет роль их порядок. Определенный элемент может появляться в последо­
вательности несколько раз. Последовательности, с которыми мы будем работать в этой
главе, представляют собой строки символов, и мы будем использовать вместо термина
"последовательность" термин "строка". Аналогично мы предполагаем, что элементы, со­
стаВЛJ1ющие последовательность, являются символами. Например, строка GACA содержит
один и тот же символ (А) несколько раз и отличается от строки CMG, которая состоит из
тех8же символов, но в другом порядке.
Подпослеt>овательностъю Z строки Х является строка Х, возможно, с удаленными
элементами. Например, если Х является строкой GAC, то он имеет восемь подпоследова­
тельностей: GAC (без удаленных символов), GA (удален С), GC (удален А), АС (удален G),
G (удалены А и С), А (удалены G и С), С (удалены G и А) и пустую строку (удалены все
символы). Если Х и У являются строками, то Z является общей подпоследователъностъю

120

Глава 7. Алгоритщ,1 на строках

Х и У, если она является подпоследовательностью обеих строк. Например, если Х - это
строка CATCGA, а У является строкой GTACCGTCA, то ССА является общей подпоследова­
тельностью Х и У, состоящей из трех символов. Однако это не наидлиннейшая общая под­
последовательность, поскольку общая подпоследовательность СТСА состоит из четырех
символов. Подпоследовательность СТСА действительно является наидлиннейшей общей
подпоследовательностью, но не единственной, так как TCGA является еще одной об�hей
подпоследовательностью из четырех символов. Следует различать понятия подпоследо­
вательности и подстроки: подстрока представляет собой подпоследовательность строки,
в которой все символы выбираются из смежных позиций в строке. Для строки CATCGA
подпоследовательность ATCG является подстрокой, в то время как подпоследовательность
СТСА таковой не является.
Наша цель заключается в том, чтобы для двух заданных строк Х и У найти наидлин­
нейшую общую подпоследовательность Z строк Х и У. Для этого мы будем использовать
динамическое программирование, с которым мы уже встречались в главе 6, "Кратчайшие
пути".
Можно найти наидлиннейшую общую подпоследовательность, не прибегая к динами­
ческому программированию, но я не рекомендую поступать таким образом. Можно было
бы испытать все подпоследовательности Х и проверить, является ли каждая из них под­
последовательностью У, начиная с самых длинных подпоследовательностей Х. Так вы в
какой-то момент найдете искомую подпоследовательность (в конечном итоге она всегда
имеется, так как пустая строка является подпоследовательностью всех строк). Беда в том,
что если длина Х равна т, то она имеет 2 m подпоследовательностей, и поэтому даже если
игнорировать время проверки каждой из подпоследовательностей, входит ли она в У, вре­
мя поиска нандлнннейшей общей подпоследовательности в наихудшем случае будет по
меньшей мере экспоненциально зависеть от длины Х.
Вспомним нз главы 6, "Кратчайшие пути", что для применения динамического про­
граммирования требуется оптимальная подструктура: оптимальное решение задачи долж­
но состоять нз оптимальных решений ее подзадач. Чтобы найти наидлиннейшую общую
подпоследовательность двух строк с помощью динамического программирования, необ­
ходимо сначала выяснить, что представляет собой подзадача. Для этого можно восполь­
зоваться префиксами. Если Х является строкой х1 х 2х 3 • • • хт, то i-м префиксом Х является
строка х 1х2х 3 • • • Х; , которую мы будем обозначать как Х1 • Величина i должна быть в диа­
пазоне от О дот; Х0 является пустой строкой. Например, если строка Х - CATCGA, то
Х4 -САТС.
Можно увидеть, что нандлнннейшая общая подпоследовательность двух строк со­
держит наидлиннейшне общие подпоследовательности префиксов этих двух строк. Рас­
смотрим две строки: Х = х1х2 х3 • • • хт и У = у1у2 у3 ···У• . Они имеют некоторую наидлнн­
нейшую общую подпоследовательность, скажем, Z, где Z = z1 z2 z3 • • • z. для некоторой дли­
ны k, которая может иметь значение от О до меньшего нз значений т и п. Что мы можем
сказать о Z? Давайте посмотрим на последние символы строк Х и У: хт и У•. Они могут
быть одинаковыми или не совпадать.

Глава 7. Алгоритмы на строках

•

121

Если они совпадают, последний символ zt строки Z должен быть таким же, как и этот сим­
вол. Что мы знаем об остальной часrи строки Z, которой является Zн = z1 z2z3 ···z1< -.? Мы
знаем, что Zt -• должна быть наидлиннейшей общей подпоследовательностью того, что
ост алось от Х и У, а именно - Х.,_ 1 = х1 х2 х3 • • • х.,_ 1 и У,,_1 = у1 у2 у3 • • • у,,_1• В нашем более
раннем примере, где Х - это строка CATCGA, а У является строкой GTACCGTCA, наид­
линнейшая общая подпоследовательность Z =СТСА, и мы видим, что Z3 = стс должна
быть наидлиннейшей общей подпоследовательностью Х5 = CATCG и fs = GTACCGTC.

• Если они различны, то z. может быть таким же, как последний символ х,,, строки Х
или последний символ у" строки У, но не оба. Кроме того, z. может не совпадать ни с
последним символом Х, ни с последним символом У. Если z. не совпадает с х,,,, игно­
рируем последний символ Х: Z должна быть наидлиннейшей общей подпоследователь­
ностью Х,,,_ 1 и У. Аналогично, если zt не совпадает с у,,, игнорируем последний символ
У: Z должна быть наидлиннейшей общей подпоследовательностью Х и У,,_ 1• Продолжая
пример, рассмотрим Х = CATCG, У =GTACCGTC и Z = СТС. Здесь z3 совпадает с у8 ( С),
но не с х5 (G), а потому Z является наидлиннейшей общей подпоследовательностью
Х4 =САТС и У.
Следовательно, рассматриваемая задача имеет оптимальную подструктуру: наидлинней­
шая общая подпоследовательность двух строк содержит в себе наидлиннейшие общие
подпоследовательности префиксов этих двух строк.
Как же мы должны поступить? Нам необходимо решить одну или две подзадачи, в за­
висимости от того, совпадают ли последние символы Х и У. Если совпадают, то мы реша­
ем только одну подзадачу - поиска наидлиннейшей общей подпоследовательности Х,,,_,
и У,,_ 1, - а затем добавим к ней этот последний символ, чтобы получить наидлиннейшую
общую подпоследовательность Х и У. Если последние символы Х и У не совпадают, то нам
надо решить две подзадачи - найти наидлиннейшие общие подпоследовательности Х,,,_ 1
и У, а также Х и У,,_ 1 - и использовать большую из них в качестве наидлиннейшей общей
подпоследовательности Х и У. Если их длины одинаковы, можно использовать любую из
них - конкретный выбор не имеет значения.
Мы будем решать задачу поиска наидлиннейшей общей подпоследовательности Х и У
в два этапа. Во-первых, мы найдем длину наидлиннейшей общей подпоследовательности
Х и У, а также длины соответствующих подпоследовательностей для всех префиксов Х
и У. Вас может удивить, что мы ищем длины подпоследовательностей, не зная их самих.
Но после вычисления длин мы "реконструируем" эти вычисления, чтобы найти фактиче­
скую наидлиннейшую общую подпоследовательность Х и У.
�тобы быть несколько более точными, давайте обозначим длину наидлиннейшей об­
щей подпоследовательности префиксов Х; и Yj как l[i,j). Соответственно, длина наидлин­
нейшей общей подпоследовательности Х и У равна / [m, п). Индексы i и j начинаются с О,
так как если один из префиксов имеет длину О, то мы знаем наидлиннейшую общую под­
последовательность этих префиксов: это пустая строка. Иными словами, 1(0,j) = /[i,O) = О
для всех значений i иj. Когда i иj положительны, мы находим l[i,ji рассматривая мень­
шие значения i и/или j.

Глава

122

•

7. Алгоритмы

на строках

Еслиi иj положительны и х; совпадаете уi , то !(i,j]=l[i-1,j-1]+1 .

•

Если i иj положительны и х; отличается от yi, то !(i,j] равно наибольшему из значений !(i,j-1] и l(i-t,j].

Значения !(i,j] можно рассматривать как записи в таблицу. Нам необходимо вычислять
эти значения в возрастающем порядке индексовi иj. Вот как выглядит таблица !(i,j]tiля
нашеrо примера (что собой представляюr затененные клетки, вы узнаете немного позже).
j

о

yj

о

Х;

с

1
2

А

3
4

с

5
6

!(i,j]

т

G

А

G

о
о
о
о
о
о
о

т

3

4

5

6

А

с

с

G

о
о
о

о
о

о

о

о

2

о
о
о
о
о

1

1

т

8

9

с

А

о

о

о

7

1

2

2

2
2
2

2
2
2

2

2

3
3

3
3

2
3
3
3

2
2
3
3
4

Например, 1 [ 5, 8] = 3, что означает, что наидлиннейшая общая подпоследовательность
Xs = CATCG и Уа = GTACCGTC имеет длину 3, как мы уже видели на с. 121.
Для того чтобы вычислить значения таблицы в порядке возрастания индексов, перед
тем как вычислять определенное значение !(i,j], гдеi иj положительны, нам необходимо
вычислить записи l(i,j-1] (непосредственно слева от l(i,j]), l(i-1,j] (непосредственно
над !(i,jD и l(i-1,j-l] (вверху слева от !(i,jD 1• Записи таблицы легко вычислить, идя
построчно слева направо или постолбцово сверху вниз.
Приведенная далее процедура обрабатывает таблицу как двумерный массив
1(0..т,О..п]. После заполнения крайнего слева столбца и крайней сверху строки нулями
она заполняет оставшуюся часть массива построчно.
Процl!дура CoмPUТE-LCS-TлвtЕ(Х.У)
Вход: Х и У: две строки длиной т и п соответственно.

.nt

ВЬЩ}{): массJ,Ш /(0..m,O .
Значение l[m,n] npeдcт88J1Jleт собой длину наидлиннейшей
общей подпоследоваrельности Х и У.
1. Пусть l [ 0.т, О.. п] представляет собой новый массив.
2. Д11J1 i= 0 ДОm:
А. Установить l[i,O]=О.
3. Д11J1 j=О доп:
А. Установить 1( О, j) = О.
1 Упоминание l[i-1, j -1] избыточно, так как это значение мы должны буде'lf вычислить до

l[i,J-l]иl[i-1,j].

Глава 7. Алгоритмы на строках

123

4. Для i=l дот:
А. Для j = 1 до п:
i. Если х1 совпадает с у1 , то установить l[i,j) = /[i-1,j-l]+ 1 .
ii. В nротJrвном случае (х1 отличается от у1) установить l(i,j] равным боль­
шему из значений l(i,j-1) и l[i-1,J]. Если l(i,j-1] = l(i-1,j), конкретный
выбор не имеет значения.
5. Вернуrь массив /.
Поскольку заполнение каждой записи таблицы выполняется за константное время, а та­
блица содержит ( т + 1) · ( п + 1) записей, время работы процедуры CoмPUTE-LCS-TABLE
равно 0( тп).
Хорошая новость заключается в том, что, как только мы вычислим таблицу l(i,J],
ее элемент в правом нижнем уrлу / [т, п) даст нам длину наидлиннейшей общей подпо­
следовательности Х и У. Плохая новость заключается в том, что ни одна запись в таблице
не говорит нам о том, какие именно символы входят в LCS. Для построения наидлинней­
шей общей подпоследовательности за время О( т + п) можно воспользоваться таблицей
и строками Хи У. Каким образом было получено значение l[i,j), можно определить, ис­
ходя из самого значения t[i,J] и значений, от которых оно зависит: Х;, yi , l(i- J,j-1),
t[i,J-1) и t[i-1,J].
Я предпочитаю рекурсивный вариант этой процедуры, в котором мы собираем наид­
линнейшую общую подпоследовательность с конца к началу. Когда эта рекурсивная про­
цедура находит в Х и У одинаковые символы, она добавляет этот символ к концу строя­
щейся наидлиннейшей общей подпоследовательности. Первоначальный вызов данной
процедуры выглядит как ASSEMBLE-LCS(X,Y,/,m,n).
Процедура ASSEMBLE·LCS(X, Y,l,iJ}
Вход:
• Хн У: две строки.
• /: массив, заполненный процедурой CoмPmE-LCS-TABLE.
• i иj: индексы как в строках Хн У, так и в массиве /.
Выход: наидлиннейшая общая подпоследовательность Х1 и �.
1 . Если /[i,j]=О, вернуть пустую строку.
2. ,в противном случае (поскольку l(i,J] положительно и i иj положительны), если
х1 совпадает с у1, вернуть стр оку, о бразованную рекурсивным вызовом AssEМBLE·
LCS(X,Y,l, i -1 , j-1 ) с добавлением к ней символа х1 (или у1 ).
3. В противном случае (х1 :it у1 ), если l[i,j-1) больше, чем l[i-l,J), вернуть строку,
образованную ре�..-урсивным вызовом AssEМВLE-LCS(X,Y,/,i, j-1 ).
4. В пр отивном случае (х1 :1:у1 и l(i,j-1) не больше l(i-1,j}) вернуть строку, об­
разованную рекурсивным вызовом AssEMBLE-LCS(X,Y,/, i-1 J).

124

Глава

7. Алгоритмы на строках

В таблице на с. 122 заштрихованные записи /[i,j]- те, которые рекурсивно посеща­
ются начальным вызовом AssEMBLE-LCS(X,Y,/,6,9), а зашифрованные символы Х; - те, ко­
торые добавляются к строящейся наидлиннейшей общей подпоследовательности. Чтобы
понять, как работает процедура ASSEMBLE-LCS, начнем с i = 6 и j = 9. При этом мы нахо­
дим, что и х6, и у9 оба равны А. Таким образом, А является последним символом наидлин­
нейшей общей подпоследовательности Х6 и�. и переходим к рекурсии на шаге 2. В !том
рекурсивном вызове i = 5 и j = 8. В этот раз выясняется, что х5 и у8 являются различными
символами, а также, что /(5, 7] =1(4,8], и мы переходим к рекурсии на шаге 4. Теперь в ре­
курсивном вызове i = 4 и j = 8. И так далее, до конца построения. Если прочесть заштри­
хованные символы Х; сверху вниз, то вы получите строку СТСА, которая и представляет
собой наидлиннейшую общую подпоследовательность. Если бы в случаях, когда надо де­
лать выбор между l(i,j-1] и l[i-1,j ], мы предпочитали переход влево (шаг 3) переходу
вверх (шаr 4), то получили бы наидлиннейшую общую подпоследовательность TCGA.
Что касается времени работы процедуры AssEмBLE-LCS, равного О( т + п ), то заметим,
что в каждом рекурсивном вызове происходит уменьшение на единицу либо значения i,
либо значения j, либо обоих одновременно. После т + п рекурсивных вызовов один из
индексов гарантированно станет нулевым, и рекурсия исчерпается на шаге 1.

Преобразование одной строки в другую
Теперь давайте посмотрим, как преобразовать одну строку Х в другую строку У. Мы
начнем со строки Х и будем конвертировать ее в У символ за символом. Мы предполагаем,
что Х и У состоят из т и п символов соответственно. Как и прежде, будем обозначать i-й
символ каждой строки, используя строчное имя строки с индексом i, так что i-й символ
строки Х обозначается как Х;, аj-й символ строки У- как Уг
Чтобы преобразовать Х в У, мы будем строить строку (назовем ее Z) таким образом,
чтобы по окончании работы строки Z и Усовпадали. Мы поддерживаем индексы i в строке
Х иj в строке Мы допускаем выполнение последовательности определенных операций
преобразования, которые могут менять строку Z и указанные индексы. Мы начинаем с i
иj, равных 1, и в процессе работы мы должны исследовать каждый символ строки Х, что
означает, что мы остановимся только тогда, когда i достигнет значения т + 1.
Вот операции, которые мы рассматриваем.

z.

• Копирование символа Х; из Х в Z путем присвоения zi значения Х; с последующим
увеличением i иj на единицу.
• Замена символа Х; изХ другим символом а путем присвоения z значения а с после­
1
дующим увеличением i иj на единицу.
• Удаление символа Х; из Х путем увеличения i на единицу; значение j при этом не из­
меняется.
• Вставка символа а в Z путем присвоения z1 значения а с последующим увеличениемj
на единицу; значение i при этом не изменяется.

Глава 7. Алгоритмы на строках

125

Возможны и другие операции - например, обмен местами двух соседних символов
или удаление символов с х; по хт как единая операция, - но здесь мы рассматриваем
только операции копирования, замены, удш�ения и вставки.
В качестве примера вот последовательность операций, преобразующих строку
ATGATCGGCAT в строку CAATGTGAATC (заштрихованные символы предстаВЛJ1ют собой
Х; и zj после каждой операции).
Операция
Исходные строки
Удаление А
ЗаменаТнаС
ЗаменаG на А
Копирование А
Копирование Т
ЗаменаС наG
ЗаменаG на Т
КопированиеG
Замена С на А
Копирование А
КопированиеТ
ВставкаС

х

ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT
ATGATCGGCAT

z
с
СА
САА
СААТ

CAATG
CAATGT
CAATGTG
CAATGTGA
CAATGTGAA
CAATGTGAAT
CAATGTGAATC

Возможны и другие последовательности операций. Например, можно просто по очереди
удалять каждый символ из Х, а затем вставлять каждый символ из У в Z.
Каждая из операций преобразования имеет стоимость, которая предстаВЛJ1ет собой
константу, зависящую только от типа операции, но не от участвующих в ней символов.
Наша цель - найти последовательность операций, которая преобразует Х в У и имеет
минимальную стоимость. Давайте обозначают стоимость операции копирования как Се,
стоимость замены как cR , удаления как cD и вставки как с1 • Для последовательности опе­
раций в приведенном выше примере общая стоимость равна 5сс +5cR +cD +с1• Следует
считать, что каждая из стоимостей се и cR меньше, чем cD +с1, потому что в противном
случае вместо оплаты Се для копирования символа или cR для его замены было бы де­
шевле заплатить с0 +с1 для удаления символа и вставки его же (вместо копирования) или
любого другого (вместо замены).
Зачем вообще нужно преобразовывать одну строку в другую? Одно из приложений
связано с вычислительной биологией. Биологам часто надо выяснить, насколько схожи
две1последовательности ДНК. В одном из способов сравнения двух последовательностей
Х и У мы по возможности максимально выстраиваем идентичные символы, вставляя про­
белы в обе последовательности (включая пробелы на концах последовательностей) так,
чтобы результирующие последовательности, скажем, Х' и У', имели одинаковую длину,
но не имели пробелов в одних и тех же позициях. То есть и х; , и у; одновременно быть
пробелами не могут. После такого выравнивания каждой позиции назначается своя оценка:

126

Глава 7. Алгоритмы на строках

•

-1 , если и

•

+ 1 , если

• +2 , если

х;

х;,

и у; одинаковы и не являются пробелами;

и у; различны и ни один из них не является пробелом;

х; или у; представляет собой пробел.

Общая оценка вычисляется как сумма оценок отдельных позиций. Чем она ниже, тем
ближе друг к другу две строки. Строки из приведенного выше примера можно выровdять
следующим образом (здесь_ обозначает пробел).
Х':

У':

ATGATCG GCAT
СААТ GTGAATC
*++--*-*-+--*

Знак - под позицией символа указывает на ее оценку, равную -1, знак + - на оценку + \,
а * - +2. В данном конкретном примере общая оценка равна ( 6 · -1) + (3 · 1) + ( 4 · 2)= 5.
Имеется множество возможных способов вставки пробелов и выравнивания двух по­
следовательностей. Чтобы найти способ, дающий наилучшее соответствие - с мини­
мальной оценкой,- мы используем преобразование со стоимостями Се = -1, cR = + 1 и
с0 = с, = +2. Чем больше идентичных символов соответствуют друг другу, тем лучше вы­
равнивание, так что отрицательная стоимость операции копирования обеспечивает сти­
мул для увеличения количества таких символов. Пробелы в У' соответствуют удаленным
символам, поэтому в приведенном выше примере первый пробел в У' соответствует уда­
лению первого символа (А) из Х. Пробел в Х' соответствует вставке символа, и в приве­
денном выше примере первый пробел в Х' соответствует вставке символа т.
Давайте рассмотрим, как преобразуется строка Х в строку У. Мы будем использо­
вать динамическое программирование с подзадачей вида "преобразовать префиксную
строку Х; в префиксную строку У/', где i пробегает значения от О до m, а j - от О до
п. Назовем эту подзадачу "задачей Х1 -+ У/, так что исходная задача является задачей
Х,. -+ Уп. Обозначим стоимость оптимального решения задачи Х;-+ Yi как cost[i,j]. В ка­
честве примера возьмем Х = ACAAGC и У= CCGT; мы будем решать задачу Х6 -+ У.. и при
этом воспользуемся следующими стоимостями операций: Се = -1, cR = + 1 и с0 = с, = +2.
Мы решаем подзадачи вида Х1 -+ �· где i пробегает значения от О до 6, aj- от О до 4.
Например, задача Х3 -+ >; заключается в преобразовании префиксной строки Х3 = АСА в
префиксную строку У2 = се.
Легко определить cost[i,j), когда значение i или j равно нулю, потому что Х0 и У0
представляют собой пустые строки. Преобразовать пустую строку в У1 можно путемj опе­
раций вставки, так что cost[O,j]= j ·с,. Аналогично преобразовать Х1 в пустую стР,9ку
можно путем i операций удаления, так что cost[ i, О]= i · с0. Когда i = j= О, пустая строка
преобразуется сама в себя, так что очевидно, что cost [О, О)= О.
Когда и ;, и j положительны, нужно изучить применение оптимальной подструкrуры
к преоб разованию одной строки в другую. Предположим - на минутку- что мы знаем,
какой была последняя операция, использовавшаяся для преобразования Х, в У1 . Это одна
из четырех операций: копирования, замены, удаления или вставки.

r.�ава 7. Алгоритмы на строках

127

•

Если последняя операция была операцией копирования, то Х; и yi должны быть од­
ним и тем же символом. Остающаяся подзадача представляет собой преобразование
Хн в �-t• и оптимальное решение задачи Х; -+ Yi должно включать оптимальное реше­
ние задачи Х;_ 1 -+ Yi_ 1• Почему? Потому что если бы мы использовали решение задачи
Хн -+ Yi-• со стоимостью, отличной от минимальной, то могли бы использовать реше­
ние с минимальной стоимостью и получить лучшее решение Х; -+ �· чем имеющееся.
Таким образом, предполагая, что последняя операция была операцией копирования,
мы знаем, что cost[i,j] равно cost[i- l,j-1]+ Се-

•

В нашем примере обратимся к задаче Xs -+ fз. И Xs, и у3 представляют собой символ G,
так что если последняя операция была копированием G, то, поскольку Се = -1, должно
выполняться соотношение cost[5,3]=cost[4,2]-1. Если cost[4,2]= 4, то мы должны
иметь cost[5,3] = 3. Если бы мы могли найти решение задачи Х4 -+ r; со стоимостью,
меньшей 4, то мы могли бы использовать это решение для поиска решения задачи
X s -+ У3 со стоимостью, меньшей, чем 3.

•

Если последняя операция была замеиой, то с учетом разумного предположения, что
мы не заменяем символ им же, символы Х; и У; должны быть разными. Используя
те же рассуждения об оптимальной подструктуре, что и для операции копиро­
вания, мы видим, что в предположении, что последняя операция была заменой,
cost(i,j] = cost(i-1,j- l]+cR.

•

В нашем примере рассмотрим задачу Xs-+ У4 • На этот раз Xs и у4 представляют
собой различные символы (G и Т соответственно), так что если последняя опера­
ция была за\1еной G на Т, то, поскольку cR =+1, должно выполняться соотношение
cost[5,4] = cost[4,3]+ 1. Если cost[4,3] равно 3, то cost[5,4] должно быть равно 4.

•

Если последней была операция удалеиия, то у нас нет никаких ограничений на Х; и у;
. Думайте о операции удаления как о пропуске символа х1 и оставлении неизменным
префикса �· так что подзадача, которую нужно решить, - это задача Х;_ 1 -+ �· Если
предположить, что последняя операция -удаление, тоcost[i,j] =cost[i-1,j]+c0.

•

В нашем примере рассмотрим задачу Х 6 -+ fз. Если последняя операция - удаление
(удаленным должен быть символ х6 , представляющий собой символ С), то, поскольку
с0 = +2, мы должны иметь cost(6,3] = cost(5,3]+ 2. Если cost[5,3] = 3, то cost[6,3] дол­
жен быть равен 5.

•

Наконец, если последняя операция - вставка, она оставляет строку Х; нетро­
нvой, но добавляет символ yi , и решаемая подзадача представляет собой зада­
чу Х;-+ У;-•· В предположении, что последняя операция - вставка, мы получаем
cost[i,j] = cost(i,j-1]+ с1 •

•

В нашем примере рассмотрим задачу Х2 -+ >;. Если последней операцией была встав­
ка (вставленный символ у3, который представляет собой G), то, поскольку с1 = +2,
должно выполняться соотношение cost [ 2,3] =cost [ 2,2]+ 2. Если cost [ 2, 2] имеет ну­
левое значение, то стоимость cost [ 2,3] должна быть равна 2.

128

Глава 7. Алгоритмы на строках

Конечно, мы не знаем заранее, какая из четырех операций использовалась последней.
Мы х011tм использовать ту, которая дает наименьшее значение cost(i,j]. Для заданной
комбинации i и j применимы три из четырех операций. Операции удаления и вставки
применимы всегда при любых положительных i и j, а в зависимости от того, одинаковы
ли символы Х; и yi, применима только одна из операций - копирования и замены. Для
вычисления cost(i,j] из других значений стоимости мы определяем, какие три °'1ера­
ции возможны, и берем минимальное из значений cost(i,j], даваемых тремя возможными
операциями. Другими словами, cost(i,j] представляет собой наименьшее из следующих
четырех значений:

•
•
•
•

cost [ i -1, j -1]+ Се , но только если х; и уi совпадают;

cost [i -1, j -1] + с11 , но только если х; и уi различные;
cost(i-1,j]+c0 ;
cost(i,j-l]+c1 •

Так же, как при вычислении наидлиннейшей общей подпоследовательности, мы мо­
жем заполнять таблицу cost строка за строкой. Это возможно, поскольку, как и в таблице /,
каждое значение в ячейке cost(i, j] , где i иj - положительные, зависит от уже вычислен­
ных значений ячеек таблицы, непосредственно примыкающих к искомой слева, сверху и
по диагонали слева сверху.
В дополнение к таблице cost мы заполняем таблицу ор, где op(i,j] дает последнюю
операцию, использованную для преобразования Х; в Yi. Мы можем заполнить запись
op(i,j] при заполнении записи cost[i,j]. Процедура CoмPUTE-TRANSFORМ-TлвLES, приве­
денная ниже, построчно заполняет таблицы cost и ор, рассмаrривая их как двумерные
массивы.
Прочедура CoМPUТE-TRANSFORM-TAВLEs(X,Y,cc,c11 ,cD ,с,)
Вход:

• Х и У: две строки длиной т и п соответственно;
• Се, с 11 , с0 , с, : стоимости операций копирования, замены, уда1ения и вставки со­
ответственно.

Выход: массивы cost[O..m,0. .n) и ор[О..т,О..п). Значение cost(i,j) представляет собой
минимальную стоимость преобразования префикса Х1 в префикс �, так что cost (т, п]
является минимальной стоимостью преобразования Хв У. Операция в op[i,j] является
последней операцией, выполненной при преобразовании Х1 в � .
1. Пусть cost[O..m,0.л] и ор[О"т,О..п] -новые массивы.
2. Установить cost [О, О] равным О.
3. Для i=l дот:
А. Установить cost[i,0]=i·c0 и op[i,O]=del Х;·
4. Для j=l доп:
А. Усrановить cost(O,j]=j ·с1 и op(O,j)= ins у1.

Глава 7. Алгоритмы на строках

5. Для i = J до m:
А. Для j = 1

ДО

129

п:

(Onpeдeruieм, какм из операций - копирования или замены - применима,и уста­
навливаем cost[i,J] и op[i,J] в соответствии с тем, какая из трех применимых опе­
раций минимизирует значение cost[i,j) .)
i. Установить cost(i,j] и op[i,j] следующим образом:
а.Если х1 =у1 ,установить cost(i,j]=cosr[i-1,j-l]+cc и op[i,j]=copy x1 •
Ь. В противном случае (х1
op[i,J] = rep х1 Ьу у1 .

:;t;

у1 ) установить cost(i,j]= cost[i-1,j-l)+cR и

ii. Есл_и cost(i-1,J]+c0 <соst[i,j],установить cost[i,J]=cost[i-1,j]+c0 и
op[i,J] = del х1 •

iii. Если cost(i,J-l]+c1 <cost(i,J],установить cost[i,J]= cost[i,J-1]+c1 и
op[i,j) = ins у1

6. Вернуть массивы cost и ор.

Таблицы cost и ор,вычисленные с помощью процедуры CoмPuТE-TRANSFORМ-TABLES для
нашего примера преобразования строки Х = ACAAGC в строку У = CCGT со стоимостями
Се = -1, cR = +1 и с0 = с1 = +2, показаны ниже. В строке i и столбце} находятся значения
cost(i,J] и op[i,ji причем в последней записи de/ означает удаление символа, ins - его
вставку, сору - копирование,а repх Ьу у - замену символах символом у. Например,по­
следняя операция, использованная при преобразовании Xs = ACAAG в У2 = се, представля­
ет собой замену G на С, а оптимальная последоваrельность операций по преобразованию
ACAAG в се имеет общую стоимость, равную 6.
j

о
с

yj

2

3

4

с

G

т

Х1

о

о
А

2

с

3

А

4

А

2

4

6

8

ins С

ins С

insT

3

ins G
5

repAby C

repAby G

repAbyT

2
de/ А

repAbyC

о

7

4

1

de/C

сорус

сорус

6

3

2

de/ А

de/ А
5

repAby C

repAbyG

8

4

3

2

de/ А

de/ А

rep А Ьу с

rep Aby G

rep А ЬуТ

2

ins G

4

ins т
3

repAbyT

130

Глава 7. Алгоритмы на строках

5

G

6

с

10

7

6

3

4

de/G

de/G

rep G Ьу С

copyG

rep G ЬуТ

12

9

6

5

4

de!C

сорус

сорус

delC

repCbyT

Процедура CoМPUTE-TRANSFORМ-TABLES заполняет каждую запись таблицы за конс'!1ант­
ное время, так же, как и процедура CoмPUTE·Lcs-TABLE. Поскольку каждая из таблиц со­
держит ( т + 1) · (п + 1) записей, время работы процедуры CoмPUТE-TRANSFORМ-TABLES со­
ставляет 0( тп ).
Для построения последовательности операций, преобразующих строку Х в строку У,
мы обращаемся к таблице ор, начиная с последней записи, ор(т,п]. Мы рекурсивно, как
и в процедуре AssEMBLE-Lcs, добавляем каждую операцию, встречающуюся в таблице ор,
к концу последовательности операций. Выполняющая эти действия процедура AssEMBLE·
TRANSFORМATION приведена ниже. Первоначальный вызов процедуры имеет вид AssEMBLE·
TRANSFORМAТION(op,m,n). Последовательность операций для преобразования строки
Х = ACAAGC в строку Z, совпадающую со строкой У = CCGT, приведена после описания
процедуры ASSEMBLE-TRANSFORМATION.
Процедура AssEМВLE-TRANSFORМAПON(opJJ)

Вход:

•

ор: таблица операций, заполненная процедурой CoмPUТE-TRANsFORМ-TAВLES.

• i и}: индексы таблицы ор.

Выход: последовательность операций, трансформирующая строку Х.в строJ<У У, rде Х и
у представляют собой входные стрОkИ для процедуры COМPUТE-TRANSFORМ-TAВLES.
1. Если и i, и} равны нулю, вернуть пусrую последовательность.
2. В противном случае (хотя бы одно из значений i нj положительно) выполнить сле­
дующие действия.
А. Если op[i,J] является операцией копирования или .за:wены, вернуть последова­
тельность, образованную рекурсивным вызовом AsSEМВLE-TRANSFORМATION(op,
i-1, j-1 ), к которой добавлено значение op[i,J].
В. В противном случае ( ор [i,j) не является ни операцией копирования, ни операцией
зал1ены), если op[i,J] представляет собой операцию удаления, вернуть последо­
вательность, образованную рекурсивным вызовом AssEMBLE-TRANsFORMATtoN(op,
i-1 JJ, к которой добавлено значение op[i,J).
С. В противном случае ( ор [i,j] не является операцией копировани.я, операцией за­
.мены или операцией удаления, так что op[i,j) должно быть операцией вставки)
вернуть последовательность, образованную рекурсивным вызовом AssEMBLE·
TRANSFORМAnoN(op,i, j -1 ), к которой добавлено значение ор [ i, j] .

Глава 7. Алгоритмы на строках

ОперацИJ1

х

Исходные строки

'ACAAGC

Удаление А

A"CMGC

Копирование С

ACMGC

Удаление А

ACMGC

Замена А на С

ACMGC

Копирование G
Замена С на Т

ACMGC
ACMGC

131

у

...
с

с

се
CCG
CCGT

Так же, как и в случае процедуры AssEMBLE-Lcs, каждый рекурсивный вызов проце­
дуры AssEMBLE-TRANSFORМATTON уменьшает значение i илиj (или их оба), а потому рекур­
сия завершается не более чем за т + п рекурсивных вызовов. Поскольку каждый рекур­
сивный вызов требует константного времени до и после рекурсии, процедура AssEMBLE·
TRANsFORМATION выполняется за время О( т + п ).
В процедуре AssEMBLE-TRANSFORМATION имеется одна тонкость, требующая более при­
стального рассмотрения. Рекурсия завершается только по достижении нулевого значения
одновременно и i, и j. Предположим теперь, что нулю равно только одно из значений i
иj, но не оба одновременно. Каждый из трех случаев на шагах 2А, 2В и 2С приводит
к рекурсии с уменьшенным на единицу значением i илиj (или обоими значениями одно­
временно). Не может ли быть выполнен рекурсивный вызов, в котором i илиj имеет значе­
ние -1? К счастью, ответ на этот вопрос отрицательный. Предположим, что в вызове
AssEMBLE-TRANSFORМATTON j = О, а i является положительным. В соответствии со спо­
собом построения таблицы ор значение op[i,O] представляет собой операцию удале­
ния, так что выполняется шаг 2В. Рекурсивный вызов на шаге 2В вызывает AssEMBLE·
TRANSFORМATION(op,i-l,j), так что значениеj в рекурсивном вызове остается равным нулю.
Аналогично, если i = О, aj положительно, то op(O,j] является операцией вставки, а по­
этому выполняется шаг 2С, и в рекурсивном вызове AssEMBLE-TRANSFORМATION(op,i,j-1)
значение i остается нулевым.

Поиск подстрок
В задаче поиска подстрок у нас есть две строки: meкcmot1tvf cmpoкtl Т и ша6лоннtvf
строка Р. Мы хотим найти все вхождения Р в Т. Сократим названия строк до "текст" и
"шаблон" и предположим, что текст и шаблон состоят из п и т символов соответственно,
где т � п (так как не имеет смысла искать шаблон, больший по размеру, чем текст). Будем
обозначать символы в Р и Т соответственно как р1 р2 р3 ••• р,., и l1li3 ••• 1•.
гfоскольку мы хотим найти все вхождения шаблона Р в текст Т, решением будут все
величины сдвигов Р относительно начала Т, где шаблон располагается в тексте. Другими
словами, мы говорим, что шаблон Р t1стречается t1 тексте со сдtlшом s, если подстрока
Т, которая начинается с 1,.1, в точности такая же, как и шаблон Р: 1,. 1 = р1, 1,.2 = р2 и так
далее до 1,.,., = р,... Минимально возможный сдвиг - нулевой, а так как шаблон не должен
выходить за пределы текста, максимально возможный сдвиг равен п-т. Мы хотим найти

132

Глава 7. Алгоритмы на строках

все сдвиги, с которыми Р входит в Т. Например, если текст Т = GTAACAGTAAACG. а ша­
блон Р = ААС , то Р встречается в Т со сдвигами 2 и 9.
Если мы проверяем, не входит ли шаблон Р в текст Т с некоторым сдвигом s, нам сле­
дует сравнить все т символов Р с символами Т. Предполагая, что такое сравнение одного
символа выполняется за константное время, в наихудшем случае для сравнения всего ша­
блона потребуется время е ( т). Конечно, как только мы найдем несоответствие мJжду
символами Р и Т, нам больше не потребуется проверять остальные символы. Наихудший
случай осуществляется при каждой величине сдвига, при которой Р встречается в Т.
Было бы достаточно легко просто сравнивать шаблон с текстом для каждого возможного
сдвига от О до п -т. Вот как выполняется поиск шаблона ААС в тексте GTAACAGTAAACG
для каждого возможного сдвига (совпадающие при сравнении символы затенены).
Величина сдвига Текст и шаблон

о

2
3
4
5

GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС

Величина сдвига Текст и шаблон

8

10

GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС
GTAACAGTAAACG
ААС
GTAACAGTAAACG

мс

Увы, этот простой подход довольно неэффекrивен: при наличии п - т + 1 возможных
сдвигов, каждый из которых требует для проверки времени О( т ). полное время работы
алгоритма составляет О(( п -т )т). Нам придется проверять почти каждый символ текста
траз.
Можно поступить лучше, потому что простой способ сравнения шаблона с текстом
для каждого возможного сдвига выдает ценную информацию. В приведенном выше при­
мере, когда мы рассматривали сдвиг s = 2, мы просмотрели все символы в подстроке
t 3ti5 = ААС. Но при следующем сдвиге, s = 3, мы опять просматриваем символы 14 и ts.
Было бы более эффекrивно, если это возможно, избежать повторного просмотра этих сим­
волов. Рассмотрим более интеллектуальный подход к поиску подстрок, который позволяет
избежать пустой траты времени, вызванной повторным сканированием текста. Он прове­
ряет каждый символ текста ровно один раз вместо т-кратноrо их исследования.
Этот более эффекrивный подход основан на применении коне11ного 11t1томапю. Не­
смотря на вызывающее название, идея довольно проста. Имеется предостаточно различ­
ных приложений конечных автоматов, но здесь мы остановимся только на их примене­
нии для поиска подстрок. Конечный автомат, или, для краткости, КА, - это просто набор
состш,ний, а путь от состояния к состоянию основан на последовательности входных

Глава 7. Алгоритмtх на строках

133

символов. КА начинает раб01у с определенного состояния и по одному получает входные
символы. Основываясь на состоянии, в котором он находится, и полученном символе, ко­
нечный автомат переходит в новое состояние.
В нашем приложении поиска подстрок входная последовательность представляет со­
бой символы текста Т, и КА будет иметь т + 1 состояние (на одно больше, чем количе­
ство символов в шаблоне Р), пронумерованное от О до т. (Слово "конечный" в названии
''конечный автомат" означает конечное количество состояний автомата.) КА начинает ра­
боту из состояния О. Когда он находится в состоянии k, k последних считанных символов
текста соответствуют первым k символам шаблона. Таким образом, всякий раз, когда КА
входит в состояние т, он встретил в тексте весь шаблон.
Давайте рассмотрим пример, в котором используются только буквы А, С, G и Т.
Предположим, что шаблон представляет собой ACACAGA, в котором т = 7 символов. Вот
соответствующий КА с состояниями от О до 7.

А

Круги представляют состояния, а помеченные символами стрелки показывают, как КА
переходит из одного состояния в другое при получении входных символов. Например,
стрелки из состояния 5 помечены как А, С и G. Стрелка в состояние 1, помеченная как А,
указывает, что когда КА находится в состоянии 5 и получает символ текста А, он перехо­
дит в состояние 1. Аналогично стрелка в состояние 4, помеченная как С, говорит нам, что
когда КА находится в состоянии 5 и получает текстовый символ С, он переходит в состоя­
ние 4. Обратите внимание на выделенный толстыми стрелками "позвоночник", который
при прочтении слева направо дает шаблон ACACAGA. Всякий раз, когда в тексте встреча­
ется шаблон, КА перемещается вправо по одному состоянию для каждого символа, пока
не достигнет последнего состояния, где он объявляет, что найдено вхождение шаблона в
текст. Обратите также внимание на то, что некоторые стрелки отсутствуют - такие, как
стрелки, помеченные т. Если стрелка отсутствует, соответствующий переход ведет в со­
стояние О.
КА хранит таблицу next-state, которая индексируется всеми состояниями и всеми воз­
можными входными символами. Значение next-state[s,a) представляет собой номер со­
стояа�ия, в которое перейдет КА, если в настоящее время он находится в состоянии s и
получил из текста символ а. Вот как выглядит таблица next-state для шаблона ACACAGA.
Состояние А

о
1

2

1
3

Символ

т
о о о
2 о о
о о о

с

G

3
4
5

о о
о о о
4 6 о

4
5

6
7

7

1

о о о
2 о о

134

Глава

7.

Алгоритмы на строках

КА перемещается на одно состояние вправо для каждого символа, который соответ­
ствует шаблону, а для каждого символа, который ему не соответствует, он переходит влево
или остается в том же состоянии (next-state[l,A] равно 1). Позже мы узнаем, как строить
таблицу next-state, а пока что рассмотрим работу КА для шаблона ААС и входного текста
GTAACAGTAAACG. Вот как выmядит соответствующий КА.
А

Из приведенной схемы КА легко составить таблицу next-state, которая в данном случае
имеет следующий вид.
Символ
Состояние А с G т

о
1

2
3

1

2
2

о о о
о о о
3 о о
о о о

А вот как вытлядит перемещение КА по состояниям при считывании символов из вход­
ного текста.
2 2 3 О
Состояние О О О
2 3
О О
G Т А А С А G
Т А А А С G
Символ
Серой штриховкой выделены два случая, когда КА достигает состояния 3, поскольку до­
стижение этого состояния говорит о том, что в тексте обнаружено вхождение шаблона ААС.
Ниже приведена процедура FA-SТRJNG-MлтcHER, выполняющая поиск подстрок. Пред­
полагается, что таблица next-state к моменту вызова процедуры уже построена.
Процедура FA-SтIUNo-МлтcНER(T,next-state,m,n)
Вход:

• Т, п: строка текста и ее длина.
• next-state: таблица переходов между состояниями, построенная для заданного ша­
блона.
• m: длина шаблона. Сrроки таблицы next-state индексированы от О дот, а столбцы
индексированы симвоnами, которые мoryr встретиться в тексте.
Выход: выводит все величины сдвигов, при которых в тексте встречаете.я искомый ша­
блон.
1. Установить переменную state равной нулю.
2. Для i = J ДО n:
А. Установить значение state равным next-state[ state,t1 ].

В. Если state = т , вывести сообщение "Шаблон найден со сдвигом " i - т.

Г.?а(Jа 7. Алгорит.11Ь1 на строках

135

Если выполнить процедуру FA-SТRJNG-MATCHER для рассмотренного выше примера, в
котором т = 3, КА достигнет состояния 3 после обработки символов 15 и 112 • Следовательно,
процедура выведет сообщения "Шаблон найден со сдвигом 2" (2 = 5 - 3) и "Шаблон най­
ден со сдвигом 9" (9 = 12 - 3).
Поскольку каждая итерация цикла на шаге 2 выполняется за константное время и этот
цикл выполняет ровно п итераций, легко видеть, что время работы процедуры FA-SтRrNG­
MдтCHER равно 0 ( п ).
Это была леrкая часть данного материала. Трудная часть материала состоит в построении
таблицы next-state конечного автомата для заданного шаблона. Вспомним основную идею.
Когда конечный автомат находится в состоянии k, k последних считанных
символов текста соответствуют первым k символам шаблона.
Чтобы конкретизировать эту идею, вернемся к КА на с. 13 3 для шаблона ACACAGA и
подумаем о том, почему next-state[5,c] = 4. Если КА перешел в состояние 5, пять послед­
них считанных из текста символов - АСАСА, которые можно увидеть, если рассмотреть
"позвоночник" КА. Если следующий считанный символ - С, он не соответствует шабло­
ну и КА не попадет в состояние 6. Но КА при этом и не вернется в состояние О. Почему?
Потому что четыре последних считанных символа - АСАС, которые соответствуют пер­
вым четырем символам шаблона ACACAGA. Вот почему когда КА находится в состоянии 5
и получает на вход символ С, он переходит в состояние 4: последние четыре считанных
символа соответствуют первым четырем символам шаблона.
Мы почти готовы познакомиться с правилом построения таблицы next-state, но сна­
чала нам нужна пара определений. Вспомним, что i находится в диапазоне от О до т,
префикс Р; шаблона Р представляет собой подстроку, состоящую из первых i символов Р.
(Когда i = О, префикс является пустой строкой.) Определим суффикс шаблона как под­
строку символов с конца Р. Например, AGA - суффикс шаблона ACACAGA. Определим
также конкатенацию строки Х и символа а как новую строку, получающуюся путем до­
бавления а к концу Х, и будем обозначать ее как Ха. Например, конкатенацией строки СА
с символом Т является строка САТ.
Наконец, мы готовы к построению next-state[k,a], где k - номер состояния от О до
т, а а - любой символ, который может появиться в тексте. В состоянии k мы считали из
текста префикс Р., т.е. последние k считанных символов текста совпадают с первыми k
символами шаблона. Когда мы считываем следующий символ, скажем, а, мы считываем
из текста строку Р.а (конкатенация Р. с а). Какой длины префикс Р считан нами в этот
момент? Или, если переформулировать вопрос. какой длины префикс Р находится в конце
Р.а? Эта длина и является номером следующего состояния.

•

Более лаконично:
Возьмем префикс Р. (первые k символов шаблона Р), выполним его конкатенацию с
символом а. Обозначим полученную в результате строку как Р.а. Найдем наидлинней­
ший префикс Р, который одновременно является суффиксом Р.а. Тогда next-state [ k, а]
представляет собой длину этого наидлиннейшеrо префикса.

136

Глава 7. Алгоритмы на строках

Так как имеется несколько префиксов и суффиксов, давайте посмотрим, как мы опре­
деляем, что для шаблона Р = ACACAGA next-state[5,c] = 4. Поскольку в этом слу чае k = 5,
мы берем префикс f>s, который представляет собой АСАСА, и добавляем к нему символ С,
что дает нам строку АСАСАС. Мы хотим найти наидлиннейший префикс ACACAGA, кото­
рый одновременно является суффиксом АСАСАС. Поскольку строка АСАСАС имеет длину
6, а суффикс не может быть длиннее строки, можно начать с � и переходить ко все мtнь­
шим и меньшим префиксам. В нашем случае � = ACACAG, и это не суффикс АСАСАС.
Так что теперь мы переходим к префиксу f>s , который представляет собой строку АСАСА
и также не является суффиксом АСАСАС. Далее мы рассматриваем Р. = АСАС, но теперь
этот префикс является суффиксом АСАСАС, так что мы останавливаемся, определив, что
next-state[5,С] = 4.
Вы можете спросить, всегда ли мы можем найти префикс Р. который также является
суффиксом Р.а? Оrвет - да, поскольку пустая строка является префиксом и суффик­
сом любой строки. Когда наидлиннейший префикс Р, который одновременно является
суффиксом Р.а, оказывается пустой строкой, мы устанавливаем next-state(k.а]= О. По­
прежнему работая с шаблоном Р = ACACAGA, давайте посмотрим, как определяется зна­
чение next-state[3,G]. Конкатенация f>з с G дает строку ACAG. Мы работаем с префиксами
Р, начиная с Р. (так как длина ACAG равна 4), и движемся к меньшим префиксам. Ни один
из префиксов АСАС, АСА, АС и А не является суффиксом ACAG, так что мы выясняем, что
искомым наидлиннейшим префиксом является пустая строка, а так как она имеет нулевую
длину, мы устанавливаем значение next-state(3,G] равным нулю.
Сколько требуется времени для заполнения всей таблицы next-state? Мы знаем, что
она имеет по одной строке для каждого состояния КА, так что она имеет т + 1 строк, про­
нумерованных от О дот. Количество столбцов зависит от количества символов, которые
могут встретиться в тексте. Назовем это число q, так что таблица next-state содержит
q(m+ 1) записей. Для заполнения записи next-state[k,a] мы выполняем следующие дей­
ствия.
1. Образуем строку Р.а.
2. Устанавливаем i равным меньшему из значений k + 1 (длина Р.а) и т (длина Р).
3. Пока Р; не является суффиксом Р.а, выполняем следующее действие:
А. Устанавливаем i равным i -1 .
Заранее нам неизвестно, сколько итераций выполнит цикл на шаге 3, но мы знаем, что
он сделает их не более чем т + 1 . Мы также не знаем заранее, сколько символов Р; и Р.а
должно проверяться в ходе проверки на шаге 3, но мы знаем, что это число всегда не бо­
леет. Поскольку цикл выполняет не более т + 1 итераций и каждая итерация проверяет
2
не болеет символов, заполнение одной записи next-state[k,a] занимает время O(m ) .
Поскольку всего таблица next-state содержит q(т + 1) записей, общее время ее заполнения
составляет т 3q).
На практике заполнение таблицы next-state - не столь уж длительная работа. Я за­
кодировал алгоритм поиска подстрок на С++ на моем MacBook Pro с процессором 2.4 ГГц

о(

Глава 7. Алгоритмы 110 строках

137

и скомпилировал его с исполь.зованием оптимизации уровня -03. Я передал программе
в качестве шаблона строку а man, а plan, а canal, panama; алфавитом при этом
был набор символов ASCII размером 128. Программа построила таблицу next-state с 31
строкой и 127 столбцами (я пропустил столбец для нулевого символа) приблизительно за
1.35 мс. С более коротким шаблоном программа справляется еще быстрее: чтобы постро­
ить таблицу для шаблона panama, потребовалось около 0.07 мс.
Тем не менее некоторые приложения очень часто прибегают к поискам подстрок, так
что время построения таблицы переходов о(т3q) может создать проблему. Я не буду вда­
ваться в подробности, но есть способ сократить время до 0(mq). В действительности
можно сделать еще лучше. Алгоритм КМР (разработанный Кнутом (Кnuth), Моррисом
(Morris) и Пратrом (Pratt)) использует конечный автомат, но при этом вообще избегает
создания и заполнения таблицы next-state. Вместо этого он использует массив move-to
для т состояний, который позволяет КА эмулировать наличие таблицы next-state и при
этом требует для заполнения массива next-state время е( т ). Хотя это и было сложнее,
чем предыдущее задание, но я скомпилировал и протестировал алгоритм КМР на моем
MacBook Pro, и для шаблона а man, а plan, а canal, panama потребовалось около
одной микросекунды для создания массива move-to. Для более короткого шаблона panama
хватило около 600 нс (0.0000006 с). Совсем неплохо! Как и процедура FA-SТRING-MлтcHER,
алгоритм КМР при наличии построенного массива move-to выполняет поиск шаблона
в тексте за время 0( п) .

Дальнейшее чтение
В mаве 15 CLRS [4] подробно рассматривается динамическое программирование, вклю­
чая задачу поиска наидлиннейшей общей подпоследовательности. Приведенный в этой
главе алгоритм преобразования одной строки в другую представляет собой часть решения
задачи, предлагаемой в главе 15 в CLRS. (Задача в CLRS включает две операции, не рассмо­
тренные здесь, - обмен соседних символов местами и удаление суффикса Х. Вы же не ду­
маете, что я могу так подвести своих соавторов, что приведу здесь полное решение задачи?)
Алгоритмы поиска подстрок рассматриваются в главе 32 CLRS. В ней приведен ал­
горитм, основанный на применении конечных автоматов, а также детально рассмотрен
алгоритм КМР. В первом издании Алгоритмы. Построение и анализ [3] описан алгоритм
Бойера-Мура (Boyer-Moore), который особенно эффективен для длинных шаблонов и
большого количества символов в алфавите.

8 •.. Основы криптографии
Покупая что-либо через Интернет, вы обычно указываете номер кредитной карты
на веб-сайте продавца или на веб-сайте сторонней службы приема оплат. Чтобы сер­
вер получил номер вашей кредитной карты, его приходится отправлять через Интернет.
Интернет - открытая сеть, и нет никаких сложностей в перехвате идущей в ней инфор­
мации. Таким образом, если номер вашей кредитной карты передается через Интернет, не
будучи каким-то образом замаскированным, то его могут перехватить и использовать для
приобретения товаров и услуг за ваш счет.
Конечно, маловероятно, что кто-то сидит и ждет именно вашей отправки через
Интернет чего-то, что выmядит как номер кредитной карты. Куда более вероятно, что кто­
то ждет такого действия от кого угодно, а вы можете оказаться его невезучей жертвой. Для
вас было бы гораздо безопаснее с крывать номер кредитной карты всякий раз при отправке
его через Интернет. Что вы, вероятно, и делаете. Если вы используете защищенный веб­
сайт - URL-aдpec которого начинается с "https:" вместо обычного "http: ", - то
ваш браузер утаивает информацию от посторонних глаз, отправляя ее с помощью про­
цесса под названием шифрование. (Протокол https также предоставляет возможность ау­
тентификации, т.е. вы точно знаете, что подключаетесь именно к тому сайту, к которому
надо.) В этой главе мы познакомимся поближе с процессом шифрования, а также с об­
ратным к нему процессом расшифровки, в котором зашифрованная информация приво­
дится к первоначальному виду. Процессы шифрования и расшифровки образуют фунда­
мент криптографии.
Хотя я, конечно же, считаю номер моей кредитной карты очень важной информацией,
требующей защиты, я признаю также, что в мире имеются и более важные вещи. Если
кто-то украдет мой номер кредитной карты, национальная безопасность не подвергнется
риску. Но если кто-то узнает правду о том, как rосдеп инструктирует своих дипломатов,
национальной безопасности или по меньшей мере престижу страны может быть нанесен
урон. Таким образом, нужны не просто способы шифрования и расшифровки информа­
ции. но способы, которые должно быть очень трудно раскрыть.
В этой главе мы рассмотрим некоторые основные идеи, лежащие в основе шифрования
и расшифровки. Современная криптография выходит далеко за рамки представленного
здесь материала. Не пытайтесь разработать безопасную систему исключительно на основе
настоящей главы! Чтобы создать систему, безопасную в теории и на практике, вам нужно
rора,з до лучше разбираться в современной криптографии. Так, вам нужно следовать уста­
новленным стандартам, подобным опубликованным Национальным институтом стандар­
тов и технологий (NIST). Как писал мне Рон Ривест (Ron Rivest) (один из изобретателей
криптосистемы RSA, о которой мы поговорим далее в этой главе), " криптография сродни
боевым искусствам, и для ее применения на практике нужно знать последние ее дости­
жения". Здесь вы вкратце познакомитесь с некоторыми алгоритмами, продиктованными
необходимостью шифрования и расшифровки информации.

140

Глава 8. Ос11овы криптографии

В криптографии мы называем исходную информацию текстом (plaintext). а зашиф­
рованную его версию - шифровкой (ciphertext). Шифрование, таким образом. преобра­
зует текст в шифровку, а расшифровка преобразует шифровку обратно в исходный текст.
Информация, необходимая для выполнения преобразований, известна как криптографи­
ческий ключ.

Простые подстановочные шифры
В простом подспwно(l(}ЧНОМ шифре текст шифруется путем простой замены одной
буквы другой, а расшифровывается - путем обратной замены. Юлий Цезарь переписы­
вался со своими генералами, используя сдвиzовый шифр, в котором отправитель заменяет
каждую букву сообщения буквой, находящейся на три позиции далее в алфавите, с цикли­
ческим переходом в начало по достижении конца алфавита. В 26-буквенном английском
алфавите, например, А будет заменена буквой D, а У - буквой В (после У идет Z, затем А
и В). При использовании шифра Цезаря зашифрованное сообщение "пришлите мне еще
солдат" выглядит как "тулыолхи при иьи фсозгх''. По получении такого текста надо за­
менить каждую его букву той, которая стоит в алфавите на три позиции ранее, с цикличе­
ским переходом в конец по достижении начала алфавита. (Само собой разумеется, Цезарь
пользовался латинским алфавитом.)
Если вы перехватили зашифрованное таким образом сообщение, и знаете, что оно за­
шифровано сдвиговым шифром, расшифровать ero до смешного легко, даже если вы не
знаете ключ (который в этом случае представляет собой величину сдвига): просто про­
буйте все возможные значения сдвига до тех пор, пока расшифрованный текст не станет
иметь смысл, превратившись в обычный. В случае 26-символьного алфавита требуется
проверить не более 25 разных сдвигов.
Сделать шифр немного более безопасным можно путем некоторого взаимно одно­
значного преобразования каждого символа в некоторый другой, не обязательно располо­
женный в алфавите на фиксированном расстоянии. Иными словами, можно создать пе­
рестановку символов, которая будет использоваться в качестве ключа. Так мы получим
шифр, который по-прежнему представляет собой простой шифр, но он будет более слож­
ным, чем сдвиговый. Если в алфавите имеется п символов, то перехвативший сообще­
ние шпион должен выяснить, какую из п! (факториал п) перестановок вы использовали.
Факториал - очень быстро растущая с ростом п функция, которая растет быстрее, чем
даже экспоненциальная функция.
Так почему бы не ограничиться таким преобразованием каждого символа в другой?
Дело в том, что зачастую можно использовать частоты появления букв и их комбинаций
для того, чтобы сузить выбор ключа. Рассмотрим сообщение на обычном английском язы­
ке - "Send me а hundred more soldiers". Предположим, что при шифровании оно превра­
щается в "Кrcz sr h byczxrz sfxr kfjzgrxk". В зашифрованном тексте наиболее часто появля­
ется буква r, так что можно (вполне правильно) предположить, что соответствующий сим­
вол текста - е, наиболее часто встречающийся символ в английском тексте. Затем можно
обратить внимание на двухбуквенное слово sr в зашифрованном тексте и предположить,

Глава 8. Основt,1 криптографии

141

что исходный символ, соответствующий s, должен быть одним из Ь, h, т или w, так как в
английском языке есть только четыре двухбуквенных слова, оканчивающихся на е - Ье,
he, те и we. Можно также определить, что символу h соответствует исходный символ а,
потому это единственное однобуквенное слово в нижнем регистре в английском языке.
Конечно, если вы шифруете номера кредитных карт, то можно не слишком беспокоить­
ся о частотах букв или их комбинаций. Но десять цифр дают только 10! уникальных спо­
собов преобразования одной цифры в другую, т.е. всего 3 628 800 вариантов. Для компью­
тера это не слишком много, особенно по сравнению с l0 16 возможных номеров кредитных
карт ( 16 десятичных цифр), так что злоумышленник, в принципе, может автоматизировать
попытки произвести покупки для каждого из 10! способов.
Вы, возможно, обратили внимание на еще одну проблему простых подстановочных
шифров: отправитель и получатель должны согласовать ключ. Кроме того, если вы от­
правляете сообщения различным получателям и не хотите, чтобы каждый из них мог рас­
шифровывать сообщения, предназначенные другим, вы должны создавать отдельные клю­
чи для каждого из получателей.

Криптоrрафия с симметричным ключом
Криптография с симметричным ключом подразумевает, что отправитель и получатель
используют один и тот же ключ, о котором они должны каким-то образом заранее дого­
вориться.
Одноразовые блокноты
Если предположить, что использование симметричного ключа вас устраивает, но про­
стой подстановочный шифр не достаточно безопасен, можно воспользоваться еще одним
вариантом - одноразовым блокнотом. Одноразовый блокнот работает с битами. Как вы,
возможно, знаете, бит (Ьit) - это аббревиатура от "Ьinary digit'', двоичная цифра, и он
может принимать только два значения - нуль и единица. Цифровые компьютеры хранят
информацию в виде последовательности битов. Одни последовательности битов пред­
ставляют собой числа, другие - символы (с использованием стандартных кодировок типа
ASCII или Unicode), а третьи даже являются командами, выполняемыми компьютером.
Одноразовые блокноты применяют к битам операцию исключающеzо или (XOR), для
обозначения которой мы используем символ Е!Э .
ОЕ!ЭО

О,

ОЕ!ЭI

= 1,

1 Е!ЭО

1,

1 Е!Э l

=

о.

Самый простой способ представления операции XOR- если х является битом, то х Е!ЭО= х,
а х Е!Э l обращает значение х. Кроме того, если х и у являются битами, то ( х Е!Эу) Е!Э у= х:
применение исключающего или к х с одним и тем же значением дважды дает х.

142

Глава 8. Основы криптографии

Предположим, что я хочу отправить вам однобитовое сообщение. Я могу отправить в
качестве шифровки О или 1, и мы при этом договариваемся, отправляю ли я вам исходный
или инвертированный бит. Если взглянуть на происходящее через призму операции XOR,
мы договариваемся о том, с каким битом - нулевым или единичным - я буду выполнять
операцию исключающего или с исходным битом. Если вы после этого выполните ту же
операцию, что и я, то восстановите исходный текст.
,
Теперь предположим, что я хочу послать вам двухбитовое сообщение. Я мог оставить
оба бита неизменными, инвертировать оба бита или инвертировать только один из битов.
И вновь нам надо договориться о том, какие именно биты инвертируются. С точки зре­
ния операции XOR мы должны договориться о значении двухбитовоrо ключа - одного
из значений 00, О 1, 1О и 11, - с которым будет применена операция исключающего или
к исходному тексту. Для расшифровки вы вновь выполняете те же действия, что и я при
зашифровывании.
Если исходный текст состоит из Ь битов - вероятно, из символов ASCII или Unicode,
которые в сумме состоят из этих Ь битов, - то я мог бы сгенерировать случайную после­
довательность Ь битов в качестве ключа, а затем побитово применить операцию исклю­
чающего или для битов ключа и исходного текста. После получения Ь-битов шифровки вы
могли бы расшифровать ее, точно так же выполнив над ней операцию исключающего или
с битами ключа. Эта система называется одноразоt1wм 6локнотом 1•
Пока мы выбираем биты ключа случайным образом - этот вопрос будет рассмотрен
позже, - подобрать ключ для расшифровки невозможно. Даже если злоумышленник что­
то знает об исходном тексте - например, что это текст на английском языке, - для любой
шифровки и любого потенциального исходного текста существует ключ, преобразующий
этот потенциальный исходный текст в данную шифровку. (Это очевидно, поскольку в
случае потенциального исходного текста t, шифровки с и ключа k справедливо не только
соотношение t $ k =с, но и t $с= k ; операция $ применяется к t, k и с побитово, т.е.
применение исключающего или к i-му биту t и i-му биту k дает i-й бит с.) Таким образом,
шифрование с одноразовым блокнотом предотвращает получение злоумышленником лю­
бой дополнительной информации об исходном тексте.
Одноразовые блокноты обеспечивают высокую степень безопасности, но ключи долж­
ны иметь ту же длину, что и исходный текст, их биты должны выбираться случайным
образом, а сами ключи должны иметься у сторон заранее. Как предполагает название, вы
должны использовать одноразовый блокнот только один раз. Если вы используете один и

1 Это название пришло из докомпьютерной эры, ко,•да у каждой стороны был бу.�,ажный
блокнот. в которФ, на каждой странице и.иелись уникальные КJIIOЧU, приче.11 блокноты у сторон
совпадали, т.е. они пользовались одни.wи и те.ии же последовательносmя'llи ключей. К1юч
использовался только один раз, после чего соответствующий лист вырыва1ся из блокнота
и уничтожа1ся. Такая cucme.wa использов�а сдвиговый шифр. но сдвиги в не.1>1 обознача1ись
буквами - от О, обозначавшегося буквой а, до 25 (буква z). Например, поскольку z означает сдвиг
на 25 позиций, т - на 12, а п - на 13, КJIЮЧ zтп превращает слово dog в слово cat. В отличие
от системы, построенной на операции иск лючающего или, повторное при...,енение ключа не дает
исход11ый текст - расшифровку надо производить в обратна�, направлении.

Глаt1а 8. OcнotJЬl криптографии

143

=

тот же ключ k для двух текстов t, и /2 , то (t, $ k} (В (t2 $ k} t, $ t2 , что может показать, в
каких местах два исходных текста имеют одинаковые биты.

Блочные шифры и цепочки
Если исходный текст длинный, ключ в одноразовом блокноте должен иметь ту же дли­
ну, так что он может быть довольно громоздким и неудобным. Поэтому некоторые систе­
мы с симметричным ключом объединяют два метода: используют короткий ключ и разби­
вают текст на несколько блоков, применяя ключ поочередно к каждому блоку. То есть они
рассматривают исходный текст как состоящий из l блоков t"t2 ,t3 , ••• ,t1 , и шифруют эти
блоки текста в l блоков с"с2 ,с3 , • • • ,с1 зашифрованного текста. Такая система называется

блочным шифром.

На практике блочные шифры выполняют шифрование, несколько более сложное, чем
простое применение исключающего или с одноразовым блокнотом. Одна из часто исполь­
зуемых криптосистем с симметричным ключом, AES (Advanced Encryption Standard расширенный стандарт шифрования), включает в себя блочный шифр. Я не буду вдаваться
в подробности AES, скажу только, что она использует сложные методы для раз деления и
перемешивания блока текста для получения зашифрованного текста. AES использует раз­
мер ключа 128, 192 или 256 бит, и размер блока - 128 бит.
У блочных шифров имеются свои проблемы. Если в исходиом тексте дважды встре­
чается один и тот же блок, то в зашифрованном тексте дважды встретится один и тот же
блок зашифрованного текста. Одним из способов решения этой проблемы является метод
цепочек блоков шифра. Предположим, что вы хотите отправить мне зашифрованное со­
общение. Вы разбиваете исходный текст t на l блоков t"t2 ,t3, ••• ,t1 и создаете l блоков
с,,с2 ,с3, ••• , с1 зашифрованного текста следующим образом. Скажем, вы зашифровываете
блок, применяя к нему некоторую функцию Е, а расшифровка блока выполняется с помо­
щью некоторой функции D. Сначала вы создаете первый блок шифровки, с1 , как и ожида­
ется: с, = E(t, ). Но перед тем как приступить к зашифровке второго блока, вы выполняете
операцию исключающего или между шифруемым блоком и уже зашифрованным блоком
с,, так чтос2 = Е (с, $ 12 ). Перед зашифровкой третьего блока вы точно так же выполняете
операцию исключающего или: с3 Е( с2 $ 13 ). И так далее, так что в общем случае при за­
шифровке i-го блока сначала выполняется операция исключающего или с зашифрованным
( i -1)-м блоком, т.е. с, = Е (с;., $ t; ). Эта формула работает даже для вычисления с, из t1,
если принять, что фиктивный блок с0 состоит из одних нулей (поскольку 0$ х = х). При
расшифровке сначала вычисляем /1 D(с,). Зная с1 ис2, можно найти 12, сначала вычисляя
D(с2), которое равно с, $ 12, а затем применяя к полученному результату операцию исклю­
чающего или сс1• В общем случае мы расшифровываем С; и получаем 11 как 11 D(c, )$с;.,·
Как и при шифровании, эта схема работает даже для вычисления 11, если принять, что фик­
тивный блок с0 состоит из одних нулей.
Но это еще не конец. Даже при использовании цепочек шифрование одного и того
же исходного текста дает один и тот же результат. Поэтому злоумышленник в состоянии
отследить повторную отправку одного и того же сообщения, что может представлять цен-

=

=

=

144

Глава 8. Основы криптог рафии

ную ШU1 злоумышленника информацию. Одно из решений заключается в том, чтобы начи­
нать не с заполненного нулями фиктивного блока с0 • Вместо этого блок с0 генерируется
случайным образом. Затем он применяется как при шифровании, так и при расшифровке.
Такой блок называется иктором иницu11Лuзации.
Соrласование общей информации

Для того чтобы криптография с симметричным ключом была работоспособна, отпра­
витель и получатель должны договориться о ключе. Кроме того, если они используют
блочный шифр с цепочками, то им следует также договориться о векторе инициализации.
Как вы понимаете, на практике редко получается заранее договориться по этому поводу.
Так как же отправитель и получатель могут договориться о ключе и векторе инициализа­
ции? Далее в этой главе мы увидим, как использовать гибридную систему для их безопас­
ной передачи.

Криптография с открытым ключом
Очевидно, что ШU1 того, чтобы получатель зашифрованного сообщения мог его рас­
шифровать, и получатель, и отправитель должны знать ключ, использованный для зашиф­
ровки. Да?
Нет.
В криптографии с открытым ключом у каждой из сторон есть по два ключа: от­
крытый ключ и секретный ключ. Я буду описывать криптографию с открытым ключом
между двумя адресатами, между вами и мной, при этом мой открытый ключ я обозначу
как Р, а мой секретный ключ - как S. У вас имеются собственный открытый и секретный
ключи. У каждого из прочих участников (если их больше двух) также имеются собствен­
ные открьпые и секретные ключи.
Секретный ключ действительно секретен, но открытые ключи общедоступны и могут
быть известны кому угодно. Они могут даже находиться в некотором централизованном
хранилище, что позволит любому узнать открытый ключ любого другого человека. При
определенных условиях мы можем использовать любой из ключей для шифрования пере­
писки. Под "определенными условиями" я имею в виду наличие функций, которые ис­
пользуют открытый и секретный ключи либо для зашифровки исходного текста, либо
для расшифровки зашифрованного текста. Обозначим функцию, которую я использую
с моим открытым ключом, как Fp , а функцию, используемую с моим секретным клю­
чом, - как F5 •
Открытый и секретный ключи связаны соотношением
t=F5 (Fp (t)),
так что если вы используете для шифрования мой открытый ключ, а затем я использую
для расшифровки мой секретный ключ, то я получу искомый исходный текст. Некоторые
другие приложения криптографии с открытым ключом требуют выполнения соотношения
t =FP (F5 ( t)), так что если я зашифрую исходный текст с помощью моего секретного
ключа, эту шифровку сможет расшифровать с помощью моего открытого ключа любой.

Глава 8. Основы криптографии

145

Для работоспособности криптосистемы любой должен иметь возможность эффектив­
но вычислить мою функцию открытого ключа Fp , но только я должен быть способен
вычислить функцию секретного ключа Fs за разумное время. Время, необходимое посто­
ронним для успешного угадывания моей функции Fs без знания моего секретного клю­
ча, должно быть запретительно большим. (Да, здесь я достаточно расплывчато формули­
рую свои мысли, но скоро вы увидите реальную реализацию криптографии с открытым
ключом.) То же самое должно быть справедливо для всех открытых и секретных ключей:
функция открытого ключа Fp должна быть эффективно вычислима, но вычислить за раз­
умное время функцию секретного ключа Fs должен только хранитель секретного ключа.
Вот как вы можете послать мне сообщение с использованием криптосистемы с откры­
тым ключом.
Зашифрованный
я
Вы
текст c = Fp(t)
�
Исходный текст t
�-- Исходный текст
t = F5 (с)
Злоумышленн ик

Зашифрованный текст с

Вы начинаете с исходного текста 1, находите мой открытый ключ Р (возможно, получаете
его непосредственно от меня или находите в общедоступном хранилище). Как только вы
получаете Р, вы шифруете исходный текст с его помощью и получаете зашифрованный
текст с = FP ( t ), что можно сделать легко и эффективно. Вы отпраВЛJ1ете мне зашифрован­
ный текст, так что любой злоумышленник, который перехватывает ваше сообщение мне,
видит только зашифрованный текст. Я беру полученный зашифрованный текст с, расшифро­
вываю его, используя мой секретный ключ, и получаю исходный текст 1 = Fs (с). Кто угодно
может легко и быстро зашифровать исходный текст моим открытым ключом, но только я
могу расшифровать зашифрованное и воспроизвести исходный текст за разумное время.
На практике нужно убедиться, что функции Fp и F5 корректно работаюг вместе. Мы
хотим, чтобы Fp давала различные зашифрованные тексть1 для каждого возможного ис­
ходного текста. Если предположить, что функция Fp дает один и тот же результат для
двух различных исходных текстов 11 и 12 , т.е. что Fp (11 ) = Fp (t2 ), то при попытке рас­
шифровать зашифрованный текст FP (t1 ) с помощью функции F5 я не буду знать, был
ли мне передан текст 11 или 12 • С другой стороны, вполне нормально и даже предпо­
чтительно внесение в процесс шифрования элемента случайности, так что один и тот же
исходный текст при шифровании с помощью одного и того же открытого ключа дает вся­
кий раз разные шифровки. (Криптосистема RSA, которую мы рассмотрим немного позже,
оказывается гораздо более безопасной, когда исходный текст предстаВЛJlет собой лишь
небольшую часть шифруемого сообщения, а остальное тело сообщения является фиктивным случайным "заполнителем".) Конечно, функция расшифровки Fs должна быть раз­
работана соответствующим образом и давать корректный исходный текст при расшифров­
ке разных шифровок, получающихся при разном заполнении.Однако здесь возникает одна
проблема. Исходный текст t может принимать произвольное количество возможных значе­
ний - фактически быть произвольной длины, - и количество зашифрованных значений,

146

Глава 8. Осн08ЬI криптографии

в которые функция Fp превращает t, должно быть по крайней мере равно количеству зна­
чений, которые может принимать t. Как построить функции Fp и F5 при дополнительном
ограничении, что Fp должна быть легко вычислима любым, а F.� - только мною? Это
трудно, но выполнимо, если мы ограничим количество возможных исходных текстов, т.е.
если используем блочный шифр.

Криптосистема RSA
Криптография с открытым ключом - прекрасная концепция, но она опирается на
возможность найти функции Fp и F5, которые корректно работают вместе, и при этом Fp
может быть легко вычислена любым, а F5 - только владельцем секретного ключа. Мы
называем такую схему криптосистемой с открwтым ключом, а криптосистем11 RSA,
или просто RSA 1, является примером такой схемы.
RSA основана на применении ряда положений теории чисел, многие из которых от­
носятся к модульной арифметике. В модульной арифметике мы выбираем некоторое
положительное целое число п, и всякий раз, когда мы достигаем добавлением единиц
значения п, мы тут же возвращаемся к нулю. Арифметические действия в модульной
арифметике похожи на соответствующие действия в обычной арифметике, но все резуль­
таты получаются путем взятия остатка от деления на п. Например, если мы работаем по
модулю 5, то единственными возможными значениями являются О, l, 2, 3 и 4, и 3+4 = 2,
поскольку 7 при делении на 5 дает остаток 2. Определив оператор mod для вычисления
остатков, мы можем записать, что 7 mod 5 = 2. Еще одно представление модульной ариф­
метики - арифметика на часах, у которых на циферблате 12 заменено нулем. Если вы
идете спать в 11 и спите 8 часов, то вы проснетесь в 7 часов: ( l l+ 8) mod 12 = 7.
Самое приятное в модульной арифметике заключается в том, что мы можем применить
операцию mod посреди вычислений, и это не приведет к изменению результата3:

(а+Ь) mod п = ((а mod п)+(Ь mod п)) mod п,
аЬ mod п
аь mod п

= ((а mod п)(Ь mod п)) mod п,
ь

(а mod п) mod п.

1

Это название представ:�яет собой аббревиатуру от фаш11111й изобретате1ей систеwы - Ро­
нальда Ривеста (Ronald Rivest), Ади Шаwира (Adi Shamir) и Леонарда Аде1ь.wана (Leonard Adelman).

J В качестве прю1ера, чтобы увидеть. что аЬ mod п = ( ( а mod п)( Ь mod п)} mod п, предпо.10жиw, что а mod п = х и Ь mod п = у. Тогда существуют це1ые чис.1а i и j, такие, что а= ni + х 11
Ь = nj + у, и,обраЗQ.w,

аЬ mod п = ( ni + х)( nj +у) mod п

= ( n 2ij +xnj + yni + ху} mod п

= ((n 2ij mod п)+(хпj mod n)+(yni mod п)+(ху mod п)} mod п

=xymodn

= ((а mod п)(Ь mod п)} mod п.

Глава 8. ОсновЬl криптографии

147

Кроме того, для любого целого х справедливо соотношение хп mod п = О.
Чтобы выполнить условия, налагаемые на открытый ключ криптосистемы RSA, также
должны выполняться два теоретико-числовых свойства, относящиеся к простым числам.
Как вы, возможно, знаете, простое число - это целое число, большее 1, которое имеет
только два целочисленных делителя: единицу и само это число. Например, число 7 явля­
ется простым, но 6 таковым не является, так как его можно разложить на множители как
2 · 3. Первое свойство, от которого зависит работоспособность RSA, заключается в том,
что если у вас имеется произведение двух больших секретных простых чисел, то никто
не сможет определить эти числа за разумное время. Напомним, что в главе 1, "Что такое
алгоритмы и зачем они нужны", говорилось, что для проверки на простоту можно про­
тестировать все возможные нечетные делители, не превышающие квадратного корня ис­
ходного числа; однако если это число очень большое - скажем, состоит из сотен или ты­
сяч цифр, - то его квадратный корень, который состоит из половинного количества цифр,
тоже представляет собой очень большое число. Хотя теоретически так можно было бы
найти один из множителей, необходимые для этого ресурсы (время и/или вычислительные
мощности) делают поиск множителя невозможным на практике 4•
Второе свойство заключается в том, что, хогя разложить большое простое число на
множители очень трудно, совсем нетрудно определить, является ли большое число про­
стым. Вы можете думать, что невозможно определить, что число является составным и
при этом не найти хотя бы один его нетривиальный сомножитель (который не является
ни единицей, ни самим этим числом), но в действительности это можно сделать. Одним
из способов является проверка на простоту AKS5, первый алгоритм для проверки про­
стоты п-битовоrо числа за время о( п'" ) для некоторой константы с. Хотя теоретически
метод AKS считается эффективным, с практической точки зрения для больших чисел он
непригоден. Вместо него можно воспользоваться проверкой на простоту Миллера-Рабина
(Miller-Rabln primality test). Недостатком теста Миллера-Рабина является то, что он мо­
жет сделать ошибку, объявив простым составное число. (Если этот метод объявляет число
составным, то оно действительно составное.) Хорошей новостью является то, что ошибки
крайне редки - одна на 2' , где мы можем выбрать любое положительное значение s,
какое захотим. Так что если мы готовы мириться с одной ошибкой из, скажем, 2so про­
верок, то можно почти идеально точно выяснить, является ли число простым. Вспомните
из главы 1, "Что такое алгоритмы и зачем они нужны", что 250 - это примерно миллион
миллиардов, или около 1000000000000000. Если и это вас не устраивает, то ценой немно­
го больших усилий вы можете добиться одной ошибки из 2ro проверок, т.е. примерно еще
в I ООО раз реже. Время работы теста Миллера-Рабина линейно зависит от параметра s, так
что у�еличение s на I О, от 50 до 60, увеличивает время работы только на 20%, но при этом
снижает вероятность ошибки в i 0 раз (что равно 1024).
4 Например, если число имеет 1000 бит, то его квадраmнЬlй корень имеет 500 бит и :wожет
достигать значения 2500. Даже если кто-то сможет проверять триллион триллионов возi1tОЖНЬlХ
дел11те1ей в секунду, то задолго до достижения им значения 2500 Солнце погаснет ...
5 Аббревиатура от 11.иен первооткрЬ1вате.1ей метода - МаниндрЬl Агравала (Manindra Agra­
v.•al). Нираджа Кайя1а (Neeraj Кауа/) и Нитина СаксенЬl (Nitin Saxena).

148

Глава 8. Основы криптографии

Вот как вкратце работает криптосистема RSA. Позже мы рассмотрим некоторые во­
просы ее функционирования детальнее.
1. Выберем наугад два очень больших простых числа, р и q, которые не равны друг другу.
Что такое очень большое число? Состоящее по крайней мере из 1024 бит, или 309 де­
сятичных цифр. Если еще больше - тем лучше.

2. Вычислим п = pq. Это число имеет по меньшей мере 2048 бит, или 618 десятичных
цифр.
3. Вычислим r = (p-l)(q-1). Это значение почти такое же большое, как и значение п.
4. Выберем небольшое нечетное целое е, взаимно простое с r, т.е. единственный общий
делитель е и r должен быть равен 1. Нам подойдет любое такое небольшое целое число.

5. Вычислим d как мультипликатиttное обратное е по модулю r. То есть ed mod r
должно быть равно 1.
6. Объявим открытый ключ RSA как пару Р = ( е, п ).
7. Пара S = ( d,n) представляет собой секретный ключ RSA, и ее не должен знать никто.
8. Определим функции Fp и F5 как
Fp ( х) = х� mod п,
F5 (x)=xd modn.
Эти функции могуr работать как с блоком исходного текста, так и с блоком зашифро­
ванного текста, биты которых рассматриваются как представляющие большие целые
числа.
Давайте рассмотрим пример, но для лучшего понимания используем небольшие числа.

1. Выбираем простые числа р =17 и q= 29 .
2. Вычисляем п =pq= 493 .
3. Вычисляем r=(p-l){q-1)= 448 .
4. Выбираем е =5 , взаимно простое с 448.
5. Вычисляем d = 269. Проверяем: ed = 5 · 269 = 1345, так что ed mod r= 1345 mod 448 =
=(3·448+ 1) mod 448 =1.
6. Объявляем открытый ключ RSA Р =(5,493).
7. Сохраняем S=(269,493) как секретный ключ RSA.
8. В качестве примера вычисляем Fp (327):
5

Fp (327) =327 mod 493

=3 738 856 210 407 mod 493
=259.
269

Если мы вычислим F5 (259)= 259 mod 493, то должны получить 327. Мы сделаем
269
это, но у нас нет ни малейшего желания видеть все 650 цифр числа 259 • Их не так

Глава 8. Основы криптографии

149

сложно вычислить, например, найдя в Интернете калькулятор с произвольной точно­
стью вычислений. Но, поскольку мы работаем с модульной арифметикой, значение
259 269 вычислять не требуется. Мы можем выразить все промежуточные результаты по
модулю 493, поступив следующим образом. Начнем с единицы, и 269 раз выполним
следующие действия: вычислить произведение последнего полученного результата на
259 по модулю 493. Результат будет тем же, что и при явном вычислении 259 269, а имен­
но - 327. (Я для этого написал небольшую компьютерную программу.)
А вот те детали работы RSA, о которых я обещал поговорить подробнее.
• Как работать с числами, состоящими из сотен цифр?
• Хотя проверка того, является ли некоторое число простым, несложная, могу ли я быть
уверен в том, что найду большие простые числа за разумное время?
• Как мне найти е, взаимно простое с r?
• Как мне вычислить d, мультипликативно обратное е по модулю r?
• Как за разумное время вычислить xd mod п, если d велико?
• Как мне убедиться в том, что функции Fp и F.� обратны одна к другой?

Арифметика больших чисел
Очевидно, что настолько большие числа, которые требуются в реализации RSA, не
могут поместиться в регистрах большинства компьютеров (типичный размер которых 64 бита). К счастью, несколько пакетов программного обеспечения и даже некоторые
языки программирования - например, Python - позволяют работать с целыми числами,
которые не имеют никакого фиксированного предельного размера.
Кроме того, арифметика в RSA- модульная арифметика, которая позволяет нам огра­
ничить размеры целых чисел, с которыми нам приходится работать. Например, при вы­
числении xd mod п мы вычисляем промежуточные результаты, представляющие собой
значение х, возведенное в разные степени, но по модулю п, что означает, что они находятся
в диапазоне от О до п - 1. Кроме того, если вы фиксируете максимальные размеры р и q,
то вы фиксируете и максимальный размер п, что, в свою очередь, означает, что возможна
аппаратная реализация RSA.
Поиск больших простых чисел
Найти большое простое число можно путем неоднократной произвольной генерации
большого нечетного числа с последующим применением теста простоты Миллера-Рабина
для выяснения, является ли это число простым. Так, среди прочих можно натолкнугься на
простое число. Можно решить, что так придется искать большое простое число слишком
долго. Что если простые числа с их ростом становятся крайне редки? Придется потратить
огромное количество времени на поиск простой иголки в составном стоге сена.
Однако не нужно беспокоиться. Теорем11 о простых числllХ говорит нам о том, что при
стремлении т к бесконечности количество простых чисел, не превышающих m, стремит­
ся к m/ln т, где ln т - натуральный логарифм числа т. Если выбрать целое т случайным

150

Глава 8. Основы криптографии

образом,то шанс, что оно простое,- около I из ln т . Теория вероятностей говорит нам
о том, что в среднем придется испытать только около ln т чисел недалеко от т, прежде
чем найдется простое число. Если я ищу простые числа р и q размером 1024 бита, то т
024
равно i , а 1nm приблизительно равен 710. Компьютер может выполнить тест простоты Миллера-Рабина для 71О чисел очень быстро.
На практике можно использовать более простой тест, чем тест Миллера-Рабина. Малu
теорема Ферма утверждает, что если т является простым числом, то х"'- 1 mod т равно
единице для любого числа х в диапазоне от I до т -1 . Обратное - что если х "' - 1 mod т
равно единице для любого числах в диапазоне от I до т -1 , то т является простым - не
обязательно справедливо, но среди больших чисел исключения очень редки. Фактически
этого почти всегда достаточно,чтобы просто проверять нечетные целые числа т и объяв­
"' 1
"' 1
лять т простым, если 2 - mod т равно 1. Позже мы увидим, как вычислить 2 - mod т
с помощью всего лишь 0( lg т) умножений.

Как найти число, взаимно простое с друrим числом
Нам нужно найти небольшое нечетное целое число е, взаимно простое с числом r. Два
числа являются взаимно простыми, если их наибольший общий делитель равен 1. Будем
использовать алгоритм для вычисления наибольшего общего делителя двух целых чисел,
который описан еще древнегреческим математиком Евклидом. В теории чисел имеется
теорема, которая гласит, что если есть а и Ь - целые числа, не равные одновременно
нулю,то их наибольший общий делитель g равен ai + bj для некоторых чисел i иj. (Кроме
того,g - наименьшее число, которое может быть сформировано таким образом, но этот
факт сейчас не играет для нас никакой роли.) Один из коэффициентов i иj может быть от­
рицательным; например,наибольший общий делитель 30 и 18 равен 6,а 6 = 30i + 18j при
i=-1 и j=2 .
Ниже алгоритм Евклида приведен в форме,которая дает наибольший общий делитель
g чисел а и Ь, а также коэффициенты i и j. Эти коэффициенты пригодятся чуть позже,
когда будет нужно искать мультипликативное обратное к е по модулю р. Если у меня есть
значение-кандидат для е, я вызываю EucLю(r,e). Если первый элемент тройки,возвращен­
ной этим вызовом, равен 1, то проверяемое значение-кандидат для е является взаимно
простым с r. Если первый элемент представляет собой любое другое число, то r и про­
веряемое значение-кандидат для е имеют общий делитель, больший, чем 1,так что они не
являются взаимно простыми.

Процедура EuCLJD(a,b)
Вход: а и Ь: два целых числа.
Выход: тройка (g,i,j), такая, что g является наибольшим общим делителем а и Ь, и
g=ai+bj.
1. Если Ь=О,вернуть тройку (а,1,0).
2. В противном случае ( Ь =f:. О) выполнить следующие действия.

Глава 8. Основы криптографии

151

А. Рекурсивно вызвать EucLID(b, а mod Ь) и присвоить полученный результат тройке
(g,i',j') , т.е. присвоитъg значение первого элемента возвращенной тройки, i' значение второго элемеН7а возвращенной тройки, а j' - третьего элемента.
В. Присвоить i = j' .

С. Присвоить j = ;•

-Lа/Ьjj'.

D. Вернуть тройху (g,i,j).
Я не буду разбираться, почему эта процедура корректно работает\ не буду и анализиро­
вать ее время работы; просто сообщу, что при вызове EucLJD(r,e) количество рекурсивных
вызовов равно O{lge). Таким образом, я могу быстро проверить, равен ли наибольший
общий делитель чисел r и значения-кандидата для е единице (не забывайте, что е мало).
Если это не так, я могу испьпать другое значение-кандидат для е, и так далее, пока не
найду взаимно простое с r. Сколько в среднем кандидатов мне придется перепробовать?
Немного. Если я ограничу мой выбор для е нечетными простыми числами, меньшими,
чем r (что легко проверяется тестом Миллера-Рабина или тестом, основанным на малой
теорема Ферма), то весьма вероятно, что любой мой выбор будет взаимно простым с r.
Это связано с тем, что согласно теореме о простых числах имеется около r/ln r простых
чисел, меньших r, но еще одна теорема показывает, что r не может иметь более чем lg r
простых множителей. Поэтому я вряд ли столкнусь с простым сомножителем r.

Вычисление мультипликатнвноrо обратного в модульной арифметике
После того как я получил r и е, мне нужно вычислить d - обратное к е по модулю
= 1 . Мы уже знаем, что вызов Euctю(r,e) возвращает тройку вида
J)
(1,i, , т.е. наибольшим общим делителем е и r является единица (потому что эти числа
взаимно простые) и что 1 = ri + ej . Поэтому можно просто присвоить d = j mod r 7• Дело
в том, что мы работаем по модулю r, а потому можем рассматривать обе стороны равен­
ства по модулю r:
r, такое, что ed mod r

6 Вызов EVCLID(0,0) возвратит тройку (0,1.0). так что О рассматривается как наибольший
общий де11итель двух нулей. Однако для нас совершенно неважно, что возвращает вызов
EUCLID(0,0), так как параметр а в первом вызове будет положительным и останется таковым
в любом рекурсивном вызове.
7 Всп0,wни.м, что j может быть отрицательным. Один из способов трактовки j mod r
при отрицате1ьна,4 j и пооожительн0,и r - начать с j и прибавлять r до тех пор, пока не
nаqучится неотрицательное число, которое и будет равно j mod r . Например. чтобы иайти

-27 mod 10, мы работае-и с последовательностью -27,-17,-7,3. Получив последнее значение, мы

останав.швае.ися и говор,ш. что -21 mod 10 = 3.

152

Глава 8. Основы криптографии

1 mod r = (ri+ej) mod r

= ri mod r+ej mod r
=O+ej mod r
=ej mod r

= (е mod r) · (j mod r) mod r

=e(j mod r) mod r.

(Последняя строка следует из того, что е < r, откуда вытекает, что е mod r = е.) Так что мы
получаем l = e(j mod r) mod r, что означает, что можно присвоить d значение j из тройки,
возвращенной вызовом EucL1o(r,e), взятое по модулю r. Я использую j mod r вместо про­
стоj в случае, когдаj выходит за рамки диапазона от О до r - l.

Как быстро возвести число в целую степень

Хотя е и является небольшим числом, d может быть большим, а нам для вычисления
функции F5 требуется вычислять x d mod п. Несмотря на то что мы работаем по моду­
лю п, т.е. все промежуточные значения будут находиться в диапазоне от О до п - \, выпол­
нять умножение чисел d раз не хочется даже по модулю. К счастью, это и не надо делать.
Используя метод многократного возведения в квадрат, можно выполнить всего лишь
0(1gd) умножений. Этот же метод можно использовать и при проверке простоты, осно­
ванной на малой теорема Ферма.
Идея заключается в следующем. Мы знаем, что d - число неотрицательное. Сначала
2
предположим, 1то d четно. Тогда x d = { x dfZ } . Теперь предположим, что d нечетное - тог­
d
да x d = (x < -i)/2} . х. Эти наблюдения дают нам красивый рекурсивный способ вычисле­
d
ния x , базовый случай которого осуществляется, когда d = О: х0 = l. Описанная далее про­
цедура воплощает этот подход, выполняя все арифметические операции по модулю п.
Процедура MQDULAR-EXPONENТIATION(x,d,n)
В:wд: х, d, п: три целых чи:сла. х и d- неотрицательные, а п - положительное.

Выход: возвращает значение xd mod п .
1. Если d =О, вернуть 1.
2. В противном случае (d положительно), если d четно, выполнить рекурсивный вызов
MooULAR-ExPONENТIATION(x, d/2 ,п), установить z равным результату рекурсивного
вызова и вернуть z2 mod п .
3. В противном случае (d nоложятельно и нечетно) выполнить рекурсивный вызов
MODULAR-EXIONENTIATION(x,(d-1)/2 ,п), установить z равным результату рекурсив­
ного вызова и вернуть ( z2 • х) mod п .
Параметр d уменьшается по меньшей мере в два раза при каждом рекурсивном вызо­
ве. После не более чем lg d + 1 вызовов d уменьшается до О и рекурсия заканчивается.
Таким образом, эта процедура выполняет умножение чисел 0(1gd) раза.

L J

Глава 8. Основы криптографии

153

Демонстрация того, что функции F, и Fs обратны одна к другой
Предупре,кдение. Нас ждет масса вопросов теории чисел и модульной ариф,wетики.
Если вы готовы принять без доказательства тот факт, что функции Fp и F5 обратны
одна к другой, пропустите этот подраздел и переходите сразу к разделу "Гибридные
криптосистемы ".
Чтобы RSA была криптосистемой с открытым ключом, функции Fp и F5 должны

быть обратны одна к другой. Если взять блок текста t, рассматривать его как целое число,
меньшее, чем п, и передать его функции Fp, мы получим значение t' mod п; если теперь
d
передать этот результат функции Fs, мы получим (t' ) то� п, что равно t "' mod п. Если
выполнить действия в обратном порядке, мы получим ( t d ) mod п, что, опять же, равно
t"' mod п. Мы должны показать, что для любого блока текста t, рассматриваемого как
целое число, меньшее п, справедливо соотношение ted mod п = t .
Вот краткое изложение нашего подхода. Напомним, что п = pq . Покажем, что
t ю mod р = t mod р и t ..i mod q = t mod q . Тогда, используя другой факт теории чисел,
мы заключим, что t'd mod pq = t mod pq - другими словами, что t ed mod п = t mod п ,
что просто представляет собой t, так как t < п.
Нам нужно снова воспользоваться малой теоремой Ферма, и это помогает понять, по­
чему мы принимаем r равным произведению (р-1)(q-1). Так как р- простое число, то,
если t mod р :#: О, выполняется соотношение (t mod р
mod р = \.
Вспомним, что мы определили е и d как мультипликативно обратные по модулю r:
ed mod r = 1. Иными словами, ed = 1 + h(p-1)(q-1) для некоторого целого числа h. Если
t mod р О , то мы получаем

у-•

*

ed

t"' mod р = (t mod р ) mod р
d )l+ {p-l){q-1) d
= ( ( то
то
р

=

h

((t mod р)·{(t mod

р

р

у-• mod р

q
) { -i) )
h

mod р

=(t mod p)·{l h{ч -•) mod р}
=t mod р.
Конечно, если t mod р = О, то t"1 mod р = О.
Аналогичные рассуждения показывают, что если t mod q О , то t ю mod q = t mod q ,
а если t mod q = О, то t ed mod q = О.
Нам нужен еще один факт из теории чисел, чтобы завершить нашу работу: по­
скольку р и q взаимно простые (они оба - простые числа), если их mod р = у mod р,
их mod q = у mod q, то х mod pq = у mod pq (этот факт является следствием китайской
теоремы об остатках). Подставим r•d вместо х и t вместо у и, вспомнив, что п = pq и t < п,
получим t•d mod п = t mod п = t , а это именно то, что и требовалось показать.

*

154

Глава 8. Основы криптографии

Гибридные криптосистемы
Хотя мы можем выполнять арифметические операции с очень большими числами, на
практике мы платим за это снижением скорости вычислений. Шифрование и расшифров­
ка длинного сообщения, содержащего сотни или тысячи блоков исходного текста, могут
вызвать заметные задержки. RSA часто используется в гибридных системах, которые ча­
стично представляют собой системы с открытым ключом и частично - с симметричным
ключом.
Вот как вы могли бы прислать мне зашифрованное сообщение в случае применения
гибридной системы. Мы соmасуем, какие системы с открытым и симметричным ключами
будут использоваться; скажем, это RSA и AES. Выберите ключ k для AES и зашифруйте
его моим открытым ключом RSA, получив Fp ( k) . Затем с использованием ключа k вы за­
шифровываете последовательности блоков открытого текста с помощью AES и получаете
блоки зашифрованного текста. После этого вы присылаете мне Fp ( k) и зашифрованный
текст. Я расшифровываю Fp ( k) пуrем вычисления Fs ( Fp ( k)) и получаю ключ k AES, а
затем использую k для расшифровки зашифрованного текста с помощью AES, тем са­
мым восстанавливая исходный текст. Если применяется блочный шифр с цепочками и
нужен вектор инициализации, его можно зашифровать как с помощью RSA, так и по­
средством AES.

Вычисление случайных чисел
Как мы уже видели, некоторые криптосистемы требуют от нас генерации случайных
чисел, а точнее - случайных целых положительных чисел. Поскольку мы представляем
целое число как последовательность битов, нам нужен способ случайной генерации би­
тов, которые затем рассматриваются как представляющие целое число.
Случайные биты могут поступать только от действительно случайных процессов. Но
как может программа, выполняемая на компьютере, быть случайным процессом? В боль­
шинстве случаев компьютерная программа - это точно определенный набор детерми­
нированных инструкций, которые для одних и тех же входных данных всегда дают один
и тот же результат. Для поддержки криптографического программного обеспечения не­
которые современные процессоры снабжены командами, которые генерируют случайные
биты на основе случайных процессов, например на тепловом шуме в схеме. Дизайнеры
этих процессоров сталкиваются с тройной проблемой: генерировать биты надо доста­
точно быстро, при этом обеспечивая соответствие основным статистическим критериям
случайности, а кроме того, потреблять разумное количество энергии в процессе создания
и тестирования случайных битов.
Обычно криптографические программы получают биты от генератора псевдослу­
чайных чисел, или ГПСЧ. ГПСЧ - детерминированная программа, которая производит
последовательность значений, основанных на некО'Тором начальном значении, в соО'Твет­
ствии с детерминированным правилом, встроенным в программу, КО'Торая выдает очеред­
ное псевдослучайное значение на основании текущего. Если вы начинаете работу ГПСЧ
с одного и того же начального значения, вы всякий раз будете получать одну и ту же после-

Г.1ава 8. Основы криптографии

155

довательность значений. Такое повторяемое поведение хорошо для отладки, но не годится
криптографии. Последние стандарты генераторов случайных чисел для криптосистем
требуют определенных реализаций ГПСЧ.
Если вы используете ГПСЧ для генерации битов, выглядящих случайными, желатель­
но каждый раз начинать с нового начального значения, которое должно быть случайным.
В частности, оно должно основываться на битах несмещенных (равновероятных О и 1),
независимых (независимо от информации о предыдущих сгенерированных битах шанс
правильно угадать следующий бит равен 50%) и непредсказуемых для злоумышленни­
ка, который пытается разрушить вашу криптосистему. Если у вашего процессора есть
команда генерации случайных битов, это наилучший способ генерации исходного зна­
чения для ГПСЧ.

длJ1

Дальнейшее чтение
Криптография является лишь одним из компонентов безопасности компьютерных си­
стем. Книга Смита (Smith) и Марчесини (Marchesini) (20] охватывает вопросы компьютер­
ной безопасности весьма широко, включая криптографию и способы атак криптосистем.
Если вы хотите углубиться в вопросы криптографии, я рекомендую книги Каца (Katz)
и Линделла (Lindell) [9] и Менезеса (Menezes), ван Ооршота (van Oorschot) и Ванстоуна
(Vanstone) [ 16]. Глава 31 CLRS [4] содержит беглый обзор основ теории чисел, на которых
базируется криптография, а также описание RSA и тест на простоту Миллера-Рабина.
Диффи (Diffie) и Хеллман (Hellman) [5] предложили принцип криптографии с открытым
ключом в 1976 году, а исходная статья с описанием RSA, принадлежащая перу Ривеста
(Rivest), Шамира (Shamir) и Адельмана (Adelman) [ 17], появилась два года спустя.
Более подробную информацию об официально одобренных ГПСЧ можно найти в
приложении С к Федеральным стандартам обработки информации (Federal lnformation
Processing Standards PuЫication 140-2) [6]. Об одной аппаратной реализации генератора
случайных чисел на основе теплового шума можно прочесть в статье Тейлора (Taylor) и
Кокса (Сох) [22].

9 •.. Сжатие данных
В предыдущей главе мы рассмотрели, как преобразовать информацию, чтобы защи­
тить ее от злоумышленника. Но защита информации - не единственная причина ее пре­
образования. Иногда этой причиной является желание ее улучшить, например изменить
фотографию с помощью такого программного обеспечения, как АdоЬе Photoshop, чтобы
убрать "красноглазие" или изменить тон кожи. Иногда добавляется избыточность инфор­
мации, чтобы, если по каким-то причинам (например, при передаче по каналам связи) не­
которые ее биты станут неверными, можно было обнаружить и исправить ошибки. В этой
главе мы исследуем еще один способ преобразования информации - ее сжатие. Прежде
чем присrупить к изучению некоторых из методов, используемых для сжатия и распаков­
ки информации, мы должны ответить на три вопроса.

1. Заче.w надо сжимать информацию?
Обычно мы сжимаем информацию для того, чтобы сохранить время и/или простран­
ство (память).
Время: при передаче информации по сети чем меньше битов передается, тем быстрее
выполняется передача. Таким образом, отправитель часто сжимает данные перед от­
правкой и отправляет сжатые данные, а затем получатель распаковывает данные, кото­
рые он получает.
Пространство: если имеющаяся память ограничивает количество информации, кото­
рое вы можете сохранить, его можно увеличить, храня информацию в сжатом виде.
Например, в форматах МРЗ и JPEG сжатие звука и изображения выполняется таким
образом, что большинство людей не в состоянии заметить разницу (если таковая во­
обще существует) между первоначальными и сжатыми материалами.
2. Каково качество сжатой инфор.мации?
Методы сжатия могут быть с потерями или без потерь. Сжатие без потерь позволяет
после распаковки сжатых данных получить информацию, идентичную первоначаль­
ной. В случае сжатия с потерями распакованная информация отличается от ориги­
нала, но в идеале - крайне незначительно. Сжатие МРЗ и JPEG представляет собой
сжатие с потерями, но метод сжатия, используемый программой zip, является сжатием
без потерь.
Вообще говоря, при сжатии текста требуется сжатие без потерь. Даже разница в один
бит может быть значима. Например, следующие предложения различаются только од­
ним битом в ASCII-кoдax составляющих их букв':
Don't forget the рор.
Don't forget the pot.
1 АSС/1-коды букв ри t представляют собой 0///0000и01110100 соответственно.

158

Глава 9. С:жатие данных

3. Почему информацию можно сжимать?
На этот вопрос легче ответить в случае сжатия с потерями: мы просто миримся со сни­
жением точности передачи информации. Но что можно сказать о сжатии без потерь?
Цифровая информация часто содержит избыточные или бесполезные биты. В ASCII,
например, каждый символ занимает один 8-битовый байт, и все часто используемые
символы имеют значение О в старшем (крайнем слева) бите2, т.е. коды символов ASCII
находятся в диапазоне от О до 255, но используемые для записи английского текста
символы попадают в диапазон от О до 127. Поэтому зачастую старший бит в АSСII­
тексте бесполезен, так что такой текст легко сжать на 12.5%.
Еще более драматический пример использования избыточности при сжатии без по­
терь - передача черно-белых изображений, например, факсом. Факсы передают
изображение как серии черных или белых точек, вместе образующих изображение.
Многие факсы передают точки построчно сверху вниз. Если изображение состоит
главным образом из текста, большая часть такого изображения белая, так что каждая
строка, вероятно, содержит много участков из идущих подряд белых точек. Если стро­
ка содержит часть горизонтальной черной линии, в ней могут быть участки из идущих
подряд черных точек. Вместо указания цвета каждой точки отдельно факсы сжимают
информацию, указывая длину каждого одноцветного участка и его цвет. Например,
в одном из стандартов факсов участок из 140 белых точек сжимается в одиннадцать
битов 10010001000.
Сжатие данных хорошо изучено, так что я могу коснуться здесь лишь небольшой его
части. Я сосредоточусь на сжатии без потерь, но в разделе "Дальнейшее чтение" вы може­
те найти несколько ссылок, которые охватывают сжатие с потерями.
В этой главе, в отличие от предыдущих, нас не будет интересовать время работы ал­
горитмов. При необходимости я буду о нем упоминать, но в данном случае нас гораздо
больше интересует размер сжатой информации, чем время ее сжатия и распаковки.

Коды Хаффмана
Давайте ненадолго вернемся к строкам, представляющим ДНК. Из главы 7, "Алгоритмы
на строках", вы помните, что биологи представляют ДНК в виде строк из четырех симво­
лов А, С, G и Т. Предположим, что ДНК представлена п символами, 45% которых явля­
ются А, 5% - С, 5% - G и 45% - т, но расположены эти символы в произвольном по­
рядке. Если бы мы использовали для представления ДНК восьмибитовые АSСII-символы,
нам потребовалось бы Sn битов. Конечно, можно поступить разумнее. Поскольку для
представления ДНК нужны только четыре символа, нам хватит двух битов для представ­
ления каждого символа ( О О, О1, 1 О, 11), а потому мы можем уменьшить представление
до 2n бит.
1

Напом11и.и, что кодировка ASC/1 включает только буквы а11?лийско?о а.1фавита, 110 11е других

алфавитов, например русского, как в случае кодировок СР-125 /. СР-866 u.qu K0/8-r. - При.иеч. пер.

Глава 9. С:жатие данных

159

Но если воспользоваться относительными частотами появления разных символов,
можно добиться еще лучшего результата. Давайте кодировать символы следующими
последовательностями битов: А =О , С=100 , G =1О I и т=11 . Чаще встречающиеся
символы кодируются более короткими последовательностями битов. Мы можем за­
кодировать 20-символьную строку TAATTAGAAATTCTATTATA 33-битовой последо­
вательностью 110011110101000111110011011110110 (вскоре вы поймете, почему я вы­
брал эту конкретную кодировку, и какими свойствами она обладает). С учетом частот
появления наших четырех символов для кодирования п-символьной строки нам нужно
0.45 · п · 1 + 0.05 · п · 3 + 0.05 · п · 3 + 0.45 · п · 2 =1.65n бит ( обратите внимание, что в рассмо­
тренном примере 33 =1.65 · 20 ). Используя преимущества относительных частот появле­
ния символов, мы можем добиться результата, лучшего, чем 2n бит.
Использованный метод кодирования обладает не только тем свойством, что чем чаще
встречается символ, тем короче представляющая его последовательность битов. Есть и
друтая интересная особенность: ни один код символа не является префиксом любого дру­
гого кода. Код А равен О, и никакой другой код не начинается с О; код для Т - 11, и ника­
кой другой код не начинается с 11, и т.д. Мы называем такой код префиксно-сt1о6однwм
кодам 1.
Важное преимущество префиксно-свободных кодов проявляется в процессе распаков­
ки. Поскольку код не является префиксом любого другого кода, можно однозначно сопо­
ставить сжатые биты исходным символам при последовательной распаковке битов. В сжа­
той последовательности 11001111 О I О I ООО 111110011О 1111О11О, например, ни один символ
не имеет однобитовый код 1, и только код для Т начинается с 11. Так что мы знаем, что
первым символом несжатого текста должен быть Т. Убирая 11, мы получаем 001111 О I О I О
00111110011О 1111О 11О. С О начинается код одного символа - А, и поэтому первый символ
оставшейся строки - А. После удаления бита О, а затем битов О1111О, соответствующих
несжатой строке АТТА, у нас остаются биты I О I ООО 111110011О1111О11О. Так как только
код для G начинается с битов I О1, очередным символом исходного текста должен быть G.
И так далее.
Если измерять эффективность методов сжатия средней длиной сжатой информации, то
среди префиксно-свободных кодов код Хаффмана4 является наилучшим. Единственный не­
достаток традиционного кода Хаффмана в том, что он требует предварительного знания
частот всех символов, а потому часто требует два прохода по несжатому тексту: один - для
определения частот символов и второй - для сопоставления символам их кодов. Чуть поз­
же мы увидим, как можно избежать первого прохода ценой дополнительных вычислений.
После того как получена информация о частотах символов, метод Хаффмана строит
бинарное дерево (если вы уже забыли, что это такое, вернитесь к с. 104 главы 6, "Кратчай­
шие пути"). Это дерево помогает строить коды и очень помогает при распаковке. Вот как
выглядит дерево для нашего примера кодирования ДНК.
1 В CLRS такие коды называются просто "префиксны.wи ". Здесь я предпочитаю испа,1ыовать
бо.1ее точный тер.wин.
• Назван так по и.wени е�о первооткрывателя Дэвида Хаффwа11а (David Huffman).

160

Глава 9. С:жатие данных

Листья дерева, изображенные в виде прямоугольников, представляют символы (рядом с
символом в каждом прямоугольнике показана его относительная частота). Внутренние
узлы, не являющиеся листьями, изображены с закругленными углами, и в каждом вну­
треннем узле указана сумма частот в листьях ниже этого узла. Мы скоро увидим, зачем
нам хранить эти частоты во внутренних узлах.
Рядом с каждым ребром дерева показано значение О или 1. Чтобы определить код сим­
вола, надо следоваrь по пути от корня до листа символа и объединять биты, встречаю­
щиеся на этом пути. Например, чтобы определить код для символа G, надо начать с корня
и сначала идти вправо, по ребру, помеченному 1, и войти в правый дочерний узел корня.
Затем из неrо надо идти влево по ребру, помеченному О, в левый дочерний узел (внутрен­
ний узел с частотой 0.1), и наконец по ребру с меткой I мы попадаем в правый дочерний
узел, который представляет собой лист символа G. Объединение меток ребер дает для
символа G код l О1.
Хотя лично я всегда помечаю ребра к левым дочерним узлам символом О, а к пра­
вым - символом 1, значения меток не имеют большого значения. Можно было бы поме­
тить ребра, например, таким образом.

С случае такого дерева мы получаем коды А = О, С = l11, G = 11О и т = lО. Эrо по-прежнему
префиксно-свободной код, и число битов в каждом коде символа остается прежним. Эrо
связано с тем, что количество битов в коде символа равно глубине листа символа, иными
словами, количеству ребер в пути от корня до листа. Однако будет проще, если мы будем
всегда помечать ребра к левым дочерним узлам символом О, а к правым - символом l.
Когда нам известны частоты символов, мы можем начать строительство бинарного де­
рева снизу вверх. Мы начинаем сп листьев, соответствующих символам несжатого текста,
как с п индивидуальных деревьев, так что изначально каждый лист является корневым
узлом. Затем мы многократно ищем два корневых узла с наименьшими частотами и соз­
даем новый корень с этими узлами в качестве дочерних; при этом новый корень получает

Глава 9. Сжатие данных

161

значение частоты, равное сумме частот своих дочерних узлов. Процесс продолжается до
тех пор, пока все листья не окажутся под одним корнем. В процессе работы мы помечаем
каждое ребро к левому дочернему узлу символом О, а каждое ребро к правому дочернему
узлу символом 1 (хотя после выбора двух корней с минимальными частотами не важно,
какой из них будет левым дочерним узлом, а какой правым).
Распишем подробно процесс построения бинарного дерева для нашего примера с
ДНК. Мы начинаем работу с четырех узлов, каждый из которых яаляется листом, nред­
стааляющим один символ.

jo:o.os j

lc:o.os l

!А:0.451

! Т:0.45 !

Узлы С и G имеют наименьшие частоты, так что мы создаем новый узел, делаем эти два
узла его дочерними, и указываем частоту для нового узла, равную сумме частот исходных
узлов.

jл: О.45 !

1 Т:0.45

!

Теперь у нас есть узел с минимальной частотой 0.1 и два узла с частотами 0.45. Мы можем
выбрать любой из этих двух узлов для объединения с узлом с минимальной частотой; вы­
берем узел символа т и сделаем его и узел с частотой 0.1 дочерними узлами нового корня
с частотой 0.55 - суммой частот дочерних узлов.
1 А: 0.45 I

о

С: 0.05

Теперь у нас остались только два узла. Мы делаем их дочерними узлами вновь созданного,
частота у которого равна сумме частот дочерних узлов, т.е. 1.0.

Теперь все листья находятся в одном дереве с новым корнем, так что искомое дерево по­
строено.
Чтобы быть более точными, определим процедуру создания бинарного дерева. Про­
цедура Bu1LD-HUFFMAN-TREE принимает в качестве входных данных два п-элементных мас­
сива, char иfreq, где char[i] содержит i-й символ исходного алфавита, а freq[i]- частота

162

Глава 9. Сжатие данных

его появления в исходном тексте. Процедура также получает значение п. Чтобы найти два
корня с наименьшими частотами, процедура вызывает в качестве подпрограмм процедуры
INSERT и ExТRAcт-MIN, работающие с очередью с приоритетами (см. с. 102).

Процедура 8UJLD-HUFFMAN-TREE(cha,·/re.q,n)

Вход:
• char: п-элементный массив символов исходного алфавита.
• freq:п-элементный массив частот пояВ.11ени• символов в исходном тексте.
• п: размер массивов charиfreq.
Выход: 11t1рень бинарного дерева, построенного дл.я кода Хаффмана.
1. Пусть Q - пуста.я очередь с приоритетами.
2. ДШ1 i=l доп:
А. Строим новый узел z, содержащий символ char[i ); частота узла делаете.я равной

freq[i).
в. Вызываем INSERт(Q,z).
3. Дл.яi=lдоп-1:
А. Вызываем ExтRAcт-МIN(Q) и присваиваем извлеченное вызовом значение пере­
меннойх.
В. Вызываем ExТRAcr-MIN(Q) и присваиваем извлеченное вызовом значение переменной у.
С. Строим новый узел z, частота которого равна сумме частот х иу.
D. Делаем х левым дочерним узлом z, а у- его правым дочерним узлом.
Е. Вызываем INSERт(Q,z).
4. Вызываем ExТRAcт-M1N{Q) и возвращаем ювлеченный узел.
Когда процедура переходит к шагу 4, в очереди остается только один узел, который пред­
ставляет собой корень всего построенного бинарного дерева.
Вы можете проследить, каким образом эта процедура строит бинарное дерево, рассмо­
тренное выше. Корни, находящиеся в очереди с приоритетами в начале каждой итерации
цикла на шаге 3, показаны в верхней части каждого рисунка.
Давайте бerno проанализируем врем.я работы процедуры Bu1ш-HuFFMAN-TREE. В пред­
положении, что очередь с приоритетами реализована с помощью бинарной пирамиды,
каждая операция вставки и извлечения минимального элемента занимает врем.я O(lgn).
Процедура вызывает каждую из этих операций 2n - 1 раз, так что на это тратится в общей
сложности время О ( п lg п ). Все остальные действия выполняются в целом за врем.я 0 (п ),
так что окончательно врем.я работы процедуры Bшш-HuFFMAN-TREE составляет О( п lgn ).

Глава 9. С:жатие данных

163

Ранее я упоминал, что очень удобно иметь бинарное дерево, созданное процедурой
BшLD-HUFFMAN-TREE, при распаковке. Начиная с корня бинарного дерева, будем идти вниз
по дереву согласно битам сжатой информации. Будем брать очередной бит и идти в левый
дочерний узел, если этот бит нулевой, и в правый, если единичный. Добравшись до листа,
помещаем соответствующий ему символ в выходной поток и повторяем поиск от корня.
Возвращаясь к нашему примеру с ДНК, при разворачивании последовательности битов
11001111010100011111001101111011 мы извлекаем первый бит (l) и идем от корня вправо,
после чего следующий извлеченный бит I вновь отправляет нас вправо, прямо в лист сим­
вола т. Мы выводим т и возобновляем поиск от корня. Очередной бит -О, так что идем
от корня влево и сразу попадаем в лист символа А, который и выводим, после чего опять
возвращаемся в корень. Распаковка продолжается таким образом до тех пор, пока не будут
обработаны все биты сжатой информации.
Если у нас есть уже построенное бинарное дерево, то для обработки каждого бита
требуется константное время. Но как получить бинарное дерево для процесса распаков­
ки? Одна из возможностей заключается в том, чтобы включить представление бинарного
дерева в сжа,ую информацию. Другая возможность заключается в том, чтобы включить
в сжатую информацию таблицу декодирования. Каждая запись такой таблицы включает
символ, количество битов в его коде и сам код. Имея такую таблицу, можно построить
бинарное дерево за время, линейно зависящее от общего количества битов во всех кодах.
Процедура Bu1LD-HUFFМAN-TREE служит примером жадного алгоритма, в котором при­
нимается решение, выглядящее наилучшим в данный момент. Поскольку мы хотим, чтобы
редко встречающиеся символы находились от корня подальше, жадный подход всегда вы­
бирает для нового узла два корня с наиболее низкой частотой. Алгоритм Дейкстры ( с. 103)
является еще одним жадным алгоритмом, потому что всегда ослабляет ребра, выходящие
из вершины с наименьшим значением shortest нз остающихся в этот момент в очереди с
приоритетами.
Я реализовал алгоритм кодирования Хаффмана и применил его к онлайн-версии "Моби
Дик". Исходный текст имел размер 1 193 826 байтов, а сжатая версия -только 673 579 бай­
тов, или 56.42% от размера оригинала, не включая саму таблицу кодов. Другими словами,
при сжатии в среднем каждый символ можно представить с помощью только 4.51 бита.
Как и ожидалось, наиболее часто встречался пробел (15.96%), затем-символе (9.56%).
Наименее частыми символами (каждый из них встретился только по 2 раза) были $, &, [ и ] .
Адаптивные коды Хаффмана
Практики часто обнаруживают, что выполнять два прохода по входным данным
(один -для вычисления частот появления символов, а вrорой-для их кодирования)­
слиwком медленное решение. Вместо этого программы сжатия и распаковки могут ра­
ботать адаптивно, обновляя частоты символов и бинарное дерево в процессе сжатия или
распаковки за один проход.
Программа сжатия начинает работу с пустого бинарного дерева. Каждый символ, кото­
рый она считывает из входных данных, является либо новым, либо уже присутствующим
в бинарном дереве. Если символ уже находится в дереве, то программа сжатия выдает его

164

Глава 9. С:жатие да11ных

код в соответствии с текущим состоянием бинарного дерева, увеличивает частоту символа
и при необходимости обновляет бинарное дерево в соответствии с новой частотой. Если
символ в бинарном дереве отсутствует, программа сжатия вставляет символ в выходной
поток как есть, в незакодированном виде, затем добавляет этот символ в бинарное дерево
и соответствующим образом обновляет последнее.
Программа распаковки является зеркальным отображением программы сжатия. Она
также поддерживает бинарное дерево в процессе обработки сжатой информации. Коrда
программа встречает биты символа из бинарного дерева, она идет по дереву в соответ­
ствии с этими битами, находит, какому символу они соответствуют, выводит его, увеличи­
вает частоту символа и обновляет бинарное дерево. Если же программа распаковки встре­
чает символ, которого пока что нет в дереве, она просто выводит этот символ, а затем
добавляет его в бинарное дерево и обновляет последнее.
Но здесь есть один неприятный момент. Биты есть биты, представляют ли они сим­
волы ASCII или биты кода Хаффмана. Как же программа распаковки может определить,
являются ли просматриваемые ею биты закодированный или незакодированной символ?
Например, последовательность битов I О 1 - представляет ли она символ, в настоящее
время кодируемый как I О 1, или это первые три бита незакодированноrо символа? Решение
заключается в использовании предшествующего каждому незакодированному символу
упра8ЛRющего кода, который представляет собой специальный код, указывающий, что
следующий за ним набор битов является незакодированным символом. Если исходный
текст содержит k различных символов, то в сжатой информации встретятся только k управ­
ляющих символов, каждый из которых предваряет первое вхождение символа. Такие коды
обычно появляются очень редко, так что они не должны быть слишком короткими за счет
более часто встречающихся символов. Хороший способ обеспечить длинные управляю­
щие коды - включить их в бинарное дерево, но с фиксированной нулевой частотой. Тоrда
при любом обновлении бинарного дерева хотя управляющий код и будет изменяться, его
лист всегда будет располагаться далеко от корня.

Факсимильные аппараты
Ранее я уже упоминал, что факсы сжимают информацию, указывая длину и цвет по­
следовательности идентичных точек в строке. Эта схема сжатия известна как кодироt1а­
ние длин серий (run-length encoding, RLE). Факсимильные аппараты комбинируют коди­
рование длин серий с кодами Хаффмана. В стандарте для факсимильных аппаратов для
обычных телефонных линий 104 кода указывают серии разной длины из белых точек,
и 104 кода - серии разной длины из черных точек. Коды для белых точек префиксно­
свободные, как и коды для черных точек, хотя при этом некоторые коды для белых точек
являются префиксами кодов для черных точек и наоборот.
Чтобы определить, какие коды использованы для кодирования последовательностей,
комитет по стандартизации взял множество из восьми представительных документов и
подсчитал, как часто встречается каждая из последовательностей. Затем для этих после­
довательностей были построены коды Хаффмана. Наиболее частыми (а следовательно,

Глава 9. С:жатие данных

165

получившими наиболее короткие коды) оказались последовательности из двух, трех и че­
тырех черных точек (с кодами 11, 10 и 011 соответственно). Прочими часто встречающи­
мися последовательностями оказались одна черная точка (код 010), пять и шесть черных
точек (коды 0011 и 0010), от двух до семи белых точек (коды этих последовательностей
состоят из четырех битов каждый) и другие относительно короткие последовательности.
Довольно часто встречается последовательность из 1664 белых точек, представляющая пу­
стую строку. Прочие короткие коды принадлежат последовательностям белых точек, дли­
6
7
ны которых являются степенями 2 или суммами двух степеней 2 (например, 192 = 2 + 2 ).
Последовательности могут кодироваться как конкатенации кодов более коротких последо­
вательностей. Ранее в качестве примера кода для последовательности 140 белых точек я
привел код 1001ООО1ООО. На самом деле это конкатенация кодов для последовательности
из 128 белых точек (1001О) и последовательности из 12 белых точек (001ООО).
В дополнение к сжатию информации только в пределах каждой строки изображения
некоторые факсимильные аппараты выполняют сжатие изображения в обоих измерениях.
Последовательности точек одного цвета могут располагаться как в вертикальном, так и в
горизонтальном направлениях, так что вместо того, чтобы рассматривап. каждую строку
изолированно, строка кодируется в соответствии с тем, где она отличается от предыду­
щей. В большинстве случаев строка отличается от предыдущей всего несколькими точка­
ми. Такая схема влечет за собой риск распространения ошибок: ошибка кодирования или
передачи делает неверными несколько последовательных строк. По этой причине факсы,
которые используют эту схему и используют передачу по телефонным линиям, ограничи­
вают количество зависимых последовательных строк: после определенного количества
зависимых строк очередная строка изображения передается полностью, закодированной
с помощью схемы кодирования Хаффмана.

LZW-сжатне
Другой подход к сжатию без потерь, особенно для текста, использует информацию, ко­
торая повторяется в тексте, хотя и необязательно в последовательных местах. Рассмотрим,
например, знаменитую цитату из ннаугурацнонной речи Джона Кеннеди (John F. Kennedy).
s

Ask not what your country сап do for уои - ask what уои сап do for your country.
За исключением слова not, каждое слово в цитате повторяется дважды. Предположим,

мы создали таблицу слов.
Индекс

Слово
ask

2

not

3

what

4

your

5

country

5 Не спрашивай, что твоя страна может сделать для тебя; спроси, что ты можешь сделать
для своей страны. - При,wеч. пер.

166

Глава 9. С:жатие данных

6
7
8

can
do

for

you
9
Тогда мы можем закодировать цитату (игнорируя прописные буквы и знаки препинания)
как

1 2 3 4 5 6 7 8 9 1 3 9 6 7 8 4 5

Поскольку эта цитата состоит из небольшого количества слов, а байт может содержать
целые числа от О до 255, мы можем хранить каждый индекс в одном байте. Таким образом,
всю цитату можно хранить только в 17 байтах, по байту на слово, плюс память, необходи­
мая для хранения таблицы. Если использовать по байту на символ исходной цитаты, без
знаков препинания, но с пробелами между словами, нам потребуется 77 байт.
Конечно, память, требующаяся для хранения таблицы, имеет значение, так как в про­
тивном случае мы могли бы просто перенумеровать все возможные слова и сжимать файл,
сохраняя только индексы слов. Но для некоторых слов эта схема приводит не к сжатию, а
32
к расширению. Почему? Давайте предположим, что всего слов имеется меньше, чем 2 ,
так что мы можем хранить каждый индекс как одно 32-битовое слово. Итак, каждое слово
при сжатии заменяется четырьмя байтами, а потому схема не работает в случае слов из
трех букв или более коротких.
Препятствием для нумерации всех возможных слов является то, что реальный текст
может включать "слова", которые не являются словами, или, по крайней мере, не явля­
ются словами английского (или иного) языка. В качестве забавного примера можно при­
вести, например, первое четверостишие стихотворения Льюиса Кэрролла (Lewis Caпoll)
"Jabberwocky":
Twas brillig, and the slithy toves
Did gyre and gimЫe in the wаЬе:
All mimsy were the Ьorogoves,
And the mome raths outgraЬe. 6
Можно вспомнить также компьютерные программы, которые часто используют имена
переменных, не являющиеся английскими словами. Добавив прописные и строчные бук­
вы, символы пунктуации и очень длинные географические названия 7, увидим, что, если
сжимать текст с помощью нумерации всех слов, нам потребуется очень большое коли­
чество индексов. Конечно, это число куда больше 232 - оно просто неограниченное, по­
скольку в принципе в тексте .wожет встретиться любое сочетание символов.
6

Стихотворение "Бар.иаглот ":
Варкалось. Хливкие шорьки
Пырялись по наве,
И хрюкотали зелюки,
Как мюмзики в мове.
(Переtюд Д. Орловской)

7

Типа названия деревни L/anfairpv.1/lgwynю,/lgogerychv.yrndrobwl/llantysiliogogogoch в Уэльсе.

Глава 9. Сжатие данных

167

Однако еще не все потеряно, поскольку мы все же можем воспользоваться повторяю­
щейся информацией. Нам просто нужно не так зацикливаться на повторяющихся словах.
Может помочь любая повторяющаяся последовательность символов. Несколько схем сжа­
тия информации основаны на повторяющихся последовательностях символов. Та, которая
будет рассмотрена нами, известна как LZW' и является основой для многих программ
сжатия, используемых на практике.
Метод LZW выполняет один проход по входным данным для сжатия и распаковки.
В обоих случаях он строит словарь последовательностей просмотренных символов и
использует для представления последовательностей символов индексы в этом словаре.
Рассматривайте словарь как массив символьных строк. Мы можем индексировать этот
массив и говорить о его i-й записи. Ближе к началу входных данных последовательности,
как правило, короткие, и их представление с помощью индексов может привести к расши­
рению, а не сжатию. Но по мере работы LZW с входными данными последовательности
в словаре становятся все длиннее, и их представление с помощью индексов обеспечива­
ет существенное сжатие информации. Например, я пропустил текст "Моби Дик" через
программу сжатия LZW, и она 20 раз сгенерировал в качестве вывода индекс, представ­
ляющий !О-символьную последовательность_from_the_(символ_ указывает пробел).
Она также 33 раза вывела индекс, представляющий восемь символов последовательности
of the .
Как программа сжатия, так и программа распаковки заполняют словарь односимволь­
ными последовательностями для каждого символа из используемого набора символов.
Так, при использовании полного набора символов ASCII словарь начинается с 256 одно­
символьных последовательностей; i-я запись в словаре содержит символ, АSСП-код кото­
рого представляет собой i.
Перед тем как перейти к общему описанию работы программы сжатия, давайте
взглянем на пару возможных ситуаций. Программа сжатия создает строки, вставляет их
в словарь и в качестве вывода возвращает индексы в словаре. Предположим, что про­
грамма сжатия начинает построение строки с символа Т, считанного из входного потока.
Поскольку словарь содержит все односимвольные последовательности, программа сжа­
тия находит Т в словаре. Всякий раз, когда программа находит строку в словаре, она счи­
тывает следующий символ из входных данных и добавляет этот символ к построенной
строке. Предположим теперь, что следующий входной символ - А. Программа добавляет
А к строящейся строке и получает строку ТА. Предположим, что эта строка также имеется
в словаре. Затем программа считывает очередной входной символ, скажем, G. Добавление
G к строящейся строке дает строку TAG, и на этот раз предположим, что этой строки в
словаре нет. Программа делает три вещи: (1) выводит индекс строки ТА в словаре; (2)
вставляет строку TAG в словарь; и (3) начинает построение новой строки, первоначально
содержащей только один символ (G), который привел к отсутствию строки в словаре.
8 Как обычно, название увековечивает создателей. Терри Уэлч (Тerry We/ch) создал LZW на
основе схемы сжатия LZ78, предложенной Абрамам Ле.мпелем (Abraham Lempel) и Якобам Зивам
(Jacob Ziv).

168

Глава 9. Сжатие данных

Вот как программа сжатия работает в общем случае. Она генерирует последователь­
ность индексов в словарь. Конкатенация строк с этими индексами дает исходный несжа­
тый текст. Программа строит строки в словаре по одному символу за раз, так что вся­
кий раз, когда она вставляет строку в словарь, эта строка такая же, как уже имеющаяся
в словаре, но продленная на один символ. Программа сжатия управляет строкой s из по­
следовательных символов входных данных, поддерживая инвариант, заключающийся в
том, что словарь всегда содержит s в некоторой из своих записей. Даже если s состоит из
единственного символа, он имеется в словаре, поскольку словарь изначально заполнен
односимвольными последовательностями для каждого символа из используемого набо­
ра символов. Первоначально s представляет собой первый символ входного потока. При
чтении нового символа с программа сжатия проверяет, имеется ли в настоящее время в
словаре строка sc, образованная путем добавления с к концу s. Если есть, то программа
добавляет с в конец s и называет результат s; другими словами, она присваивает s значе­
ние sc. Программа сжатия строит все более длинную строку, которая в конечном итоге
будет вставлена в словарь. В противном случае (s присутствует в словаре, но sc - нет)
программа сжатия выводит индекс s в словаре, вставляет sc в свободную запись словаря
и устанавливает s равной одному входному символу с. Вставляя sc в словарь, программа
добавляет в него строку, которая расширяет s на один символ, а устанавливая строку s рав­
ной с, перезапускает процесс построения строки для поиска в словаре. Поскольку с пред­
ставляет собой односимвольную строку, имеющуюся в словаре, программа поддерживает
инвариант, заключающийся в том, что s имеется в словаре. После того как входной поток
исчерпан, программа выводит индекс оставшейся строки s.

Процедура

LZW-COMPRESSOR(text)

Вход: text - последовательность символов из набора ASCII.
Выход: последовательность индексов в словаре.
1. Для каждого символа с из набора символов АSСП:
А. Вставить символ с в словарь с индексом, равным числовому коду с в наборе сим­
волов ASCII.
2. Установить s равным первому символу text.
3. Пока text нс исчерпан, выполнять следующие действия.
А. Взять из tехt очередной символ Jt присвоить t:ro переменной с.
В. Если sc имеется в словаре, установить s = sc .
С. В противном случае (sc пока еще нет в словаре) выполнить следующие действия.
i. Вывести индекс s в словаре.
ii. Вставить sc в очередное свободное место в словаре.

iii. Присвоить s строку, состоящую из одного символа с.
4. Вывести индекс строки s в словаре.

Глава 9. Сжатие данных

169

Давайте рассмотримконкретный пример-скажем,сжатиетекстаТАТАGАТСТТААТАТА
(здесь мы встретимся с последовательностью TAG, которую уже видели выше). В приведенной далее таблице показано, что происходит после каждой итерации цикла на шаге 3.
Показаны значения строки s в начале итераций.
Новая строка словаря
Итерация s
Выход
с
1

т

2

А

84 (Т)

256: ТА

А

т

65 (А)

257: АТ

3

т

А

4

ТА

G

256 (ТА)

258: TAG

5

G

А

71 (G)

259: GA

6

А

т

7

АТ

260: АТС

67(С)

261: ст

10

с
т
т

с
т
т

257 (АТ)

8

А

11

ТА

А

12

А

т

13

АТ

А

14

А

т

15

АТ

А

Шаг4

АТА

9

84(Т)

262: тт

256 (ТА)

263: ТАА

257 (АТ)

264: АТА

264(АТА)

После шага 1 словарь содержит односимвольные строки для каждого из 256 символов
ASCII в записях с номерами от О до 255. Шаг 2 делает строку s состоящей из единствен­
ного входного символа т - первого входного символа. На первой итерации основного
цикла на шаге 3 с становится равным очередному входному символу - А. Конкатенация
sc представляет собой строку ТА, которой пока нет в словаре, так что выполняется шаг ЗС.
Поскольку строка s содержит только Т, а АSСП-код Т равен 84, шаг ЗСi выводит индекс
84. Шаг ЗCii вставляет строку ТА в очередную свободную запись в словаре (индекс кото­
рой - 256), а шаг ЗCiii начинает построение строки s заново, устанавливая ее значение
просто равным символу А. Во второй итерации цикла на шаге 3 с представляет собой
следующий входной символ - т. Строка sc = АТ отсутствует в словаре, и поэтому шаr
ЗС выводит индекс 65 (код ASCII для А), вносит строку АТ в запись 257 и устанавливает s
равной односимвольной строке Т.
Преимущество применения словаря мы видим во время двух следующих итераций цик­
ла на шаrе 3. В третьей итерации с присваивается следующий входной символ А. Теперь
строка sc = ТА присутствует в словаре, так что процедура ничего не выводит. Вместо
этого на шаге 38 к концу строки s добавляется считанный символ, и строка s принимает

170

Глава 9. С:жатие данных

вид ТА. В четвертой итерации символ с становится равным G. Строки sc = TAG в словаре
нет, а потому шаг 3Ci выводит индекс строки s в словаре, равный 256. Теперь одно число
на выходе указывает не на один, а на два символа -ТА.
За время работы процедуры LZW-CoмPRESSOR некоторые индексы могут не бьпь вы­
ведены в выходной поток ни разу, а некоторые - несколько раз. Если объединить все
символы в скобках в столбце "Выход" приведенной выше таблицы, мы получим исходный
текст TATAGATCTTAATATA.
Этот небольшой пример слишком мал, чтобы показать реальную эффективность сжа­
тия LZW. На вход подается 16 байт, а выход состоит из 1О индексов словаря. Каждый ин­
декс при этом требует более одного байта. Даже если мы используем на выходе два байта
на один индекс, то в результате получим 20 байт. Если же каждый индекс занимает четыре
байта, то общий размер "сжатой" информации равен 40 байтам.
Более длинные тексты, как правило, дают лучшие результаты. LZW-сжатие уменьшает
размер "МобиДика" с 1 193 826 до 919 012 байт. При этом в словаре 230 007 записей, так
что индексы должны иметь размер по меньшей мере четыре байта9• Вывод состоит из
229 753 индексов, или 919 012 байт. Этот результат уступает сжатию с помощью кодиро­
вания Хаффмана (673 579 байт), но чуть позже мы увидим некоторые идеи, каким образом
можно повысить степень сжатия.
LZW-сжатие имеет смысл только в том случае, если мы можем распаковать сжатую ин­
формацию. К счастью, хранить для этого словарь вместе со сжатой информацией не тре­
буется. (Если бы это требовалось, то сжатая информация вместе со словарем по размеру
не превышали бы исходный текст только в очень редких случаях.) Как упоминалось ранее,
распаковка LZW в состоянии построить словарь непосредственно из сжатой информации.
Вот как работает LZW-распаковка. Подобно программе сжатия, программа распаковки
начинает со словаря, состоящего из 256 односимвольных по следовательностей, соответ­
ствующих символам из набора символов ASCII. Она получает из входного потока после­
довательность индексов в словаре и зеркально отражает действия программы сжатия по
построению словаря. Всякий раз, когда распаковщик выполняет вывод, выводится строка,
добавленная им к словарю.
Чаще всего считанный из входного потока индекс указывает на строку, уже имеющую­
ся в словаре (вскоре мы увидим, что происходит в противном случае), так что распаков­
щик находит строку в словаре, соответствующую этому индексу, и выводит ее. Но как рас­
паковщик может построить словарь? Давайте на минутку задумаемся о том, как работает
программа сжатия. К моменту, когда программа выводит индекс на шаге 3С, она обнару­
жила, что, хотя строка s в словаре имеется, строки sc в нем нет. Программа выводит индекс
строки s в словаре, вставляет sc в словарь и начинает построение новой строки для со­
хранения, начиная с символа с. Распаковщик должен работать соответствующим образом.
Для каждого индекса, полученного из входного потока, он выводит строку s, находящуюся
в словаре в записи с этим индексом. Но он также знает, что в момент вывода программой
9 Я предполагаю. что целые числа имеют стандартное представление в виде одного. двух-,
четырех или восьми байт. Теоретически числа до 230 007 можно представить всего треwя
6aйma'llu, и в таком случае общий размер сжатой инфор.wации будет равен 689 259 байт.

Глава 9. Сжатие данных

171

упаковки индекса для s строки sc в словаре нет (здесь с - символ, следующий сразу по­
сле s). Распаковщик знает, что программа сжатия вставила строку sc в словарь, так что в
конечном итоге распаковщик должен поступить так же. Он пока что не в состоянии вста­
вить строку sc, потому что не видел символ с. Этот символ - первый символ очередной
выводимой распаковщиком строки. Однако пока что следующая строка ему неизвестна.
Следовательно, распаковщик должен отслеживать две последовательно выводимые стро­
ки. Если программа распаковки выводит строки Х и У в указанном порядке, то она должна
добавить первый символ У к Х, а затем вставить получившуюся строку в словарь.
Давайте рассмотрим конкретный пример, для чего обратимся к таблице на с. 169, кото­
рая показывает, как программа сжатия работает со входной строкой TATAGATCTTAATATA.
В итерации 11 программа сжатия выводит для строки ТА индекс 256 и вставляет в словарь
строку ТАА. Это связано с тем, что в указанный момент в словаре уже имелась строка
s =ТА, но не было строки sc = ТАА. Этот последний символ А является началом оче­
редной строки (АТ), которую программа сжатия выведет как индекс 257 в итерации 13.
Поэтому, когда программа распаковки встречает индексы 256 и 257, она должна вывести
строку ТА, а также запомнить ее, чтобы, когда следующей будет выводиться строка АТ,
символ А из нее мог быть добавлен к строке ТА и получившаяся в результате конкатенации
строка ТАА могла быть добавлена в словарь.
В редких случаях очередной индекс, поступающий в распаковщик из входного пото­
ка, еще не имеет соответствующей записи в словаре. Эта ситуация возникает настолько
редко, что при распаковке "Моби Дика" она произошла всего для 15 из 229 753 индексов.
Такое происходит, когда индекс, выводимый программой сжатия, соответствует послед­
ней вставленной в словарь строке. Эта ситуация возможна только тогда, когда строка, со­
ответствующая индексу, начинается и заканчивается одним и тем же символом. Почему?
Вспомним, что программа сжатия выводит индекс для строки s только тогда, когда s нахо­
дится в словаре, но sc в нем отсутствует. Затем она вставляет строку sc в словарь, скажем,
с индексом i и заново строит новую строку s, начинающуюся с с. Если следующий индекс,
выводимый программой сжатия, представляет собой i, то строка, соответствующая этому
индексу в словаре, должна начинаться с с, и при этом мы только что видели, что эта строка
представляет собой sc. Так что если очередной индекс словаря во входном потоке рас­
паковщика соответствует записи, которой еще нет в словаре, распаковщик может вывести
строку, вставленную последней, добавить к ней ее же первый символ и вставить получив­
шуюся строку в словарь.
Поскольку эти ситуации очень редки, приводимый пример несколько надуманный.
Итак, пусть мы имеем строку ТАТАТАТ. Программа сжатия делает следующее: выводит
индекс 84 (Т) и вставляет ТА в запись с индексом 256; выводит индекс 65 (А) и вставля­
ет строку АТ в запись с индексом 257; выводит индекс 256 (ТА) и вставляет ТАТ в за­
пись с индексом 258; и наконец выводит индекс 258 (только что вставленная строка ТАТ).
Распаковщик, считывая индекс 258, берет только что выведенную строку ТА, добавляет к
ней первый символ этой же строки т, выводит получившуюся строку ТАТ и вставляет ее
в словарь.

172

Глава 9. С:жатие данных

Хоrя эта редкая ситуация возникает только тогда, когда строка начинается и заканчи­
вается одним и тем же символом, обратное - что она возникает всякий раз, когда строка
начинается и заканчивается одним и тем же символом - неверно. Например, при сжатии
"Моби Дика" строки, начинавшиеся и заканчивавшиеся одним и тем же символом, для
которых в выходной поток выводился соответствующий индекс, встретились 11 376 раз
(около 5% от общего количества); при этом они не являлись последними вставленными в
словарь строками.
Процедура IZW-DECOМPRESSOR(indices)
Вход: indices: последовательность индексов в словаре, созданном процедурой LZW­

CoМPRESsoR.
Выход: исходный текст, переданный на вход процедуры LZW-CoмPRESSOR.
1. Для каждого символа сиз набора символов ASCII:

А. Вставить символ с в словарь с индексом, равным ч11словому ющу с в .Qаборе символов ASCII.
2. Установить значение переменной current равным первому индексу в indices.
З. Вывести строку из словаря, соответствующую индексу current.
4. Пока последовательность indices не исчерпана, выполнять следующие действия.
А. Установить значение переменной previous равным значению current.
В. Получить очередное число из nоследоваrельности indices и присвоить ero пере­
менной current.
С. Если словарь содержит запись с индексом current, выполнить следующие действия.
i. Установить s равной строке в словаре с индексом current.
ii. Вывести строку s.
iii. Вставить в очередную свободную запись словаря строку, индексированную
значением previous, к которой добавлен первый символ s.
О. В противном случае (словарь не содержит 1аnись с индексом current) выполнить
следующие действия.
i. Установить s равной строке в словаре с индексом previous, к которой добавлен
первый символ этой же записи в словаре.
ii. Вывести строку s.
iii. Вставить в очередную свободную запись словаря строку s.
В приведенной далее таблице показано, что происходит в каждой итерации цикла
на шаге 4 в случае, когда входными данными для распаковки служат индексы в столбце
"Выход" на с. 169. Строки, индексированные в словаре значениями переменных previous
и current, выводятся в последовательных итерациях, а значения переменных previous и
current приведены для каждой итерации после шага 48.

Глава 9. Сжатие данных

173

Итерация previou.r current Выход (s) Нова я строка словаря
т
84
Шаги 2,3
84

65

А

256: ТА

2

65

256

ТА

257: АТ

3

256

71

G

258: TAG

4

71

257

АТ

259: GA

5

257

67

с

260: АТС

6

67

84

т

261: ст
262:ТТ
263: Тдд

7

84

256

ТА

8

256

257

АТ

АТА
257
264: АТА
9
264
За исключением последней итерации входной индекс уже присутствует в словаре, так
что шаг 4D выполняется только в последней итерации. Обратите внимание, что словарь,
построенный процедурой LZW-DECOMPRESSOR, совпадает со словарем, построенным про­
цедурой LZW-CoмPREssoR.
Я не буду описывать, как искать информацию в словаре в процедурах LZW-CoмPRESSOR
и LZW-DECOMPRESSOR. В последнем случае это особенно легко: надо просто отслеживать
последний использованный индекс в словаре, и если индекс в current не превышает по­
следний использованный индекс, то искомая строка имеется в словаре. Что касается про­
цедуры LZW-CoмPRESSOR, то перед ней стоит более сложная задача: для заданной строки
определить, имеется ли она в словаре, и если да, то каков ее индекс. Конечно, можно вы­
полнить простой линейный поиск в словаре, но если там содержится п элементов, каждый
такой поиск будет требовать время О( п) . Эффективнее воспользоваться какой-либо из
специализированных структур данных. Одной такой структурой может быть луч (trie),
который напоминает бинарное дерево, которое мы строили для кодирования Хаффмана,
с тем отличием, что каждый узел может иметь много дочерних узлов, а каждое ребро
помечено символом ASCII. Еще одной эффективной структурой является хеш-m116лица,
которая обеспечивает простой и очень эффективный в среднем способ поиска строки в ка­
талоге.

Усовершенствование метода LZW
Как я уже говорил, меня не слишком впечатлило применение метода LZW для сжатия
текста "Моби Дика". Частично эта проблема связана с большим размером словаря. При
наличии 230 007 записей каждый индекс требует по крайней мере четырех байтов, так что
выходной поток из 229 753 индексов сжимает исходный текст до 919 О 12 байт. Далее, мож­
но заметить некоторые свойства индексов, генерируемых процедурой LZW-CoмPRESSOR.
Во-первых, многие из них представляют собой небольшие величины, а это означает, что в
32-битовом представлении большая часть их битов - нулевые. Во-вторых, одни индексы
будут использоваться гораздо чаще других.

174

Глава 9. Сжатие данных

Если выполняются оба эти свойства, к хорошим результатам может привести коди­
рование Хаффмана. Я модифицировал программу кодирования методом Хаффмана так,
чтобы она работала с четырехбайтовыми целыми числами, а не символами, и применил ее
к сжатому с помощью LZW-метода тексту "Моби Дика". Получившийся в результате файл
занимает только 460 971 байт, или 38.61% от размера исходного текста (1 193 826 байт),
что лучше, чем при использовании одного лишь метода кодирования Хаффмана. Конечно,
такой метод сжатия предполагает наличие двух этапов - сжатие исходного текста с помо­
щью LZW и затем сжатие полученной последовательности индексов методом Хаффмана.
Соответственно, распаковка также будет представлять собой двухэтапный процесс: сна­
чала сжатая информация распаковывается с помощью кодирования Хаффмана, а затем
выполняется распаковка LZW.
Другие подходы к LZW-сжатию стремятся уменьшить количество битов, необходимых
для хранения индексов, выводимых программой сжатия. Поскольку многие из индексов
представляют собой небольшие числа, один из подходов заключается в использовании
меньшего количества битов для меньших чисел, резервируя, скажем, первые два бита для
указания количества использованных для представления числа битов. Вот одна такая схема.
•

Если первые два бита - 00, то индекс находится в диапазоне от О до 63 (26 - 1), требуя
для своего представления шести битов (т.е. в сумме - один байт).

•

6
Если первые два бита - 01, то индекс находится в диапазоне от 64 (2 ) до 16 383
4
(i -1), требуя для своего представления 14 бит (т.е. в сумме - два байта).

•

Если первые два бита - 1О, то индекс находится в диапазоне от 16 384 (i ) до 4 194 303
(2 22 -1), требуя для своего представления 22 бит (т.е. в сумме - три байта).

•

Наконец, если первые два бита - 11, то индекс находится в диапазоне от 4 194 304
(2 22) до 1 073 741 823 (230 -1), требуя для своего представления 30 бит (т.е. в сумме -

4

четыре байта).
В двух других подходах индексы на выходе программы сжатия имеют один и тот же
размер в силу ограничения размера словаря. В одном варианте, когда словарь достигает
максимального размера, новые записи в него больше не вставляются. В другом варианте
после того, как словарь достигает максимального размера, он очищается (за исключением
первых 256 записей), после чего процесс заполнения словаря начинается заново с той точ­
ки текста, где словарь оказывается заполненным. Во всех случаях программа распаковки
должна зеркально отражать действия, выполняемые программой сжатия.

Дальнейшее чтение
Книга Саломона (Salomon) [18] при охвате широкого спектра методов сжатия выделя­
ется своей ясностью и краткостью. Книга Шторера (Storer) [21 ], опубликованная за 20 лет
до книги Саломона, представляет собой классический труд в данной области алгоритмов.
В разделе 16.3 CLRS [4] описаны коды Хаффмана, хотя и без доказательства того факта,
что они являются наилучшими среди префиксно-свободных кодов.

10 •..Трудная? Задача ...
Когда я покупаю что-то через Интернет, продавец должен доставить купленное мне
домой. В большинстве случаев продавец пользуется услугами компании, специализирую­
щейся на доставке товаров. Не буду говорить, какая именно компания чаще всего достав­
ляет мне купленное, скажу только, что перед моим домом очень часто можно увидеть
очередной коричневый грузовик.

Коричневые грузовики
Только в США компания по доставке товаров оперирует более чем 91 ООО таких ко­
ричневых грузовиков. По крайней мере пять дней в неделю каждый грузовик начинает и
заканчивает свой дневной маршрут в одном из гаражей и доставляет товары во множество
мест. Естественно, что компания весьма заинтересована минимизировать затраты, связан­
ные с грузовиками, делающими множество остановок каждый день. Например, один ис­
точник, с которым я консультировался, утверждал, что после тоrо, как компания наметила
новые маршруты для своих водителей, позволяющие уменьшить количество левых пово­
ротов, она сократила общий пробег своих транспортных средств на 464000 миль за 18-ме­
сячный период, сэкономив более 51 ООО галлонов топлива, с дополнительным преимуще­
ством, заключающимся в уменьшении выбросов углекислого газа на 506 тонн.
Но как компания может минимизировать ежедневную стоимость движения каждого
грузовика? Предположим, что некоторый грузовик в некоторый день должен доставить
товары в п мест. Добавление гаража в качестве одного из мест дает п + 1 точек, которые
должны быть посещены грузовиком. Для каждого из этих п + 1 мест компания может рас­
считать расходы на поездку грузовика из каждого из прочих п мест, так что компания имеет
таблицу расходов по проезду грузовика из одного места в другое размером ( п + 1) х ( п + 1);
диагональные записи в этой таблице смысла не имеют, так как i-я строка и i-й столбец
соответствуют одному и тому же месту. Компания хочет определить маршрут, который на­
чинается и заканчивается в гараже и посещает все п мест ровно один раз, такой, что общая
стоимость всего маршрута является минимальной.
Можно написать компьютерную программу, которая позволит решить эту задачу.
В конце концов, если мы рассмотрим конкретный маршрут с известным порядком оста­
новок, то надо просто просуммировать соответствующие маршруту элементы таблицы
расходов. Так что можно просто перечислить все возможные маршруты и найти среди них
тот, который имеет минимальную стоимость. Количество возможных маршрутов конечно,
так что в какой-то момент программа завершит работу и выдаст ответ. И похоже, такую
программу не так уж и трудно написать, не правда ли?
Да, ее действительно нетрудно написать.
Трудно дождаться, когда она завершит работу ...
Проблема в наличии огромного количества возможных маршрутов, которые посеща­
ют п мест: их п! (п факrориал). Почему? Грузовик выезжает из гаража. Перед ним выбор

176

Глава 10. Трудная? Задача ...

из п мест для первой остановки. После первой остановки он может выбрать любое из
оставшихся п -1 мест для второй остановки, так что имеется п · ( п -1) возможных ком­
бинаций первых двух остановок в определенном порядке. Как только мы сделаем эти
две остановки, у нас останется выбор из п - 2 мест для третьей остановки, а общее ко­
личество маршрутов из трех остановок составит п · ( п -1) · ( п - 2 ). Продолжая в том же
духе, мы находим, что общее количество возможных маршрутов по всем п местам равно
п ·( n-l)·(n-2)· · ·3· 2 · 1 = п!.
Вспомним, что п! растет быстрее, чем даже экспоненциальная функция. В главе 8,
"Основы криптографии", я писал, что 10! равно 3628 800. Для компьютера это не так уж
много. Но коричневые грузовики развозят гораздо больше 1О товаров в день. Предположим.
что грузовик доставляет товары по 20 адресам в день (в США в среднем в грузовике раз­
мещается около 170 товаров, так что даже с учетом того, что в одно место могут достав­
ляться несколько товаров одновременно, 20 адресов в день не кажутся завышенной оцен­
кой). В этом случае программа должна обработать 20! возможных маршрутов, а 20! - это
2432902 008176640000. Если компьютеры компании в состоянии обрабатывать триллион
маршрутов в секунду, то потребуется всего лишь 28 дней на поиск среди них оптимально­
го. И это только для одного из более чем 91 ООО грузовиков!
Так что при использовании такого подхода компании для приобретения и эксплуатации
вычислительной мощности, необходимой для поиска маршрутов для всех грузовиков на
каждый день, потребуются такие расходы, которые не покроешь никакой выгодой от бо­
лее эффективных маршрутов. Нет, эта идея - перечисление всех возможных маршрутов
и выбор наилучших - хотя и звучит математически разумно, совершенно непрактична.
Нет ли лучшего способа найти для каждого грузовика маршрут наименьшей стоимости?
Никто не знает (а если и знает, то не говорит). Никто не нашел способ получше, но
никто и не доказал, что такого способа не существует. Это вас не сильно разочаровало?
На самом деле это разочарование гораздо большее, чем вы можете себе представить.
Задача поиска маршрутов с минимальной стоимостью более известна как задача комми­
вояжера (она называется так потому, что в ее первоначальной формулировке коммивоя­
жер должен был посетить п городов, начиная и заканчивая путь в одном и том же городе, и
при этом его маршрут должен быть кратчайшим возможным). Пока что не найден ни один
алгоритм ее решения за время о( п') для какой бы то ни было константы с. Мы не знаем
алгоритма, который бы находил наилучший возможный маршрут по п городам ни за время
о( п100 ). ни за время о(п'000 ни даже за время о( п1000000 ).
На самом деле все еще хуже. Многие задачи - тысячи из них - имеют эту особен­
ность: для них неизвестен алгоритм, который бы решал их для входных данных размером
п за время о{ п') для какой-либо константы с, но и никто не доказал, что такой алгоритм
не может существовать. Эти задачи возникают в самых разных областях, среди которых логика, теория графов, арифметика и планирование.
Чтобы разочарование перешло на совершенно новый уровень, познакомьтесь с са­
мым удивительным фактом: если хотя бы для одной из этих задач существует алгоритw
со временем работы о( п' � где с - некоторая константа, то алгориm'И со вpe.we11e.i,
работы о( п') существует для каждой из них. Мы называем эти задачи NР-полны.,wи.

),

Глава 1 О. Трудная? Задача...

177

Алгоритм, который для входных данных размером п решает задачу за время о(п'· ). где с
является константой, представляет собой алгоритм с полиномиальным временем рабо­
ты. Он называется так потому, что п' с некоторым коэффициентом будет наиболее знача­
щим членом в формуле для его времени работы. Для каждой NР-полной задачи известен
алгоритм, решающий ее за время, не являющееся полиномиальным, но никто не доказал,
что некоторые из NР-полных задач за полиномиальное время не разрешимы.
Есть разочарование еще большее: многие NР-полные задачи практически такие же, как
и задачи, которые мы умеем решать за полиномиальное время. Оrличие в условии просто
мизерное. Например, вспомните из главы 6, "Кратчайшие пуrи", что алгоритм Беллмана­
Форда находит кратчайший путь из одной вершины в ориентированном графе, даже если
этот граф имеет ребра с отрицательным весом, за время Е>( пт) (п и т - соответственно
количество вершин и ребер графа). Если граф задан списками смежности, то его вход­
ной размер Е>( п + т ). Предположим, что т 2: п; тогда размер входных данных - 0( т ),
и пт � т2, так что время работы алгоритма Беллмана4орда полиномиально зависит от
размера входных данных (тот же результат получится и при п > т). Так что найти крат­
чайшие пути очень просто. Так что вас, наверное, удивит, что поиск длиннейшего ацикли­
ческого пути (т.е. самого длинного пути без циклов) между двумя вершинами является
NР-полной задачей. Более того, даже простое определение того, содержит ли граф путь
без циклов не менее чем с заданным количеством ребер, является NР-полной задачей.
В качестве еще одного примера близких задач, где одна решается легко, а вторая явля­
ется NР-полной, рассмотрим эйлеровы и гамильтоновы циклы. Обе эти задачи ищут пути
в связных неориентированных графах (в неориентированном zрафе ребра не имеют на­
правления, так что (и,v) и (v,u) представляют собой одно и то же ребро. Мы говорим,
что ребро (u,v) инцидентно вершинам и и v. Связный zраф имеет путь между каждой
парой вершин. Эйлеров 1 цикл начинается и заканчивается в одной и той же вершине и
проходит по каждому ребру ровно один раз, хотя при этом может посещать вершины более
одного раза. Гшнwrьтонов 2 цикл начинается и заканчивается в одной и той же вершине и
посещает каждую вершину ровно один раз (за исключением, конечно, вершины, в которой
цикл начинается и заканчивается). Если мы зададимся вопросом, имеет ли связанный не­
ориентированный граф эйлеров цикл, алгоритм удивительно прост: надо определить сте­
пень каждой вершины (т.е. количество инцидентных ей ребер). Граф имеет эйлеров цикл
тогда и только тогда, когда каждая его вершина имеет четную степень. Но если мы хотим
узнать, содержит ли связанный неориентированный граф гамильтонов цикл, то это - NР­
полная задача. Обратите внимание, что мы не ставим вопрос о порядке вершин гамильто­
нова цикла в графе и выясняем только, можно ли построить в этом графе гамильтонов цикл.
1 Назван так в связи с доказательством в 1736 году Леонардом Эйлераw (Leonard Еи/еr)
не8()зможности заwкнутого обхода города Кенигсберга с проходом по всем семи его моста,w ровно
по одному разу.
1 Назван так в честь Уильяма Гаwильтона (William Hami/ton). который в 1856 году описал

.wате.,wатическую игру на графе. представляюще.11,1 додекаэдр. в которой один игрок устанавливает
пять фишек в пяти последовательных вершинах. а второй игрок дол.жен завершить путь,
образующий цикл. содержащий все вершины графа.

178

Глава /0. Трудная? Задача ...

NР-полные задачи встречаются на удивление часто, и именно поэтому я включил в
книгу посвященный им материал. Если вы пытаетесь найти алгоритм с полиномиальным
временем для решения задачи, которая является NР-полной, вы, вероятно, не добьетесь
ничего, кроме усталости и разочарования. Концепция NР-полных задач возникла пример­
но в начале 1970-х годов, но попытки решения задач, оказавшихся NР-полными (таких,
как задача коммивояжера) были и задолго до этого. На сегодняшний день мы не знаем,
существует ли алгоритм с полиномиальным временем работы для любой из NР-полных
задач; но мы не можем и утверждать, что такой алгоритм не может существовать. Многие
блестящие ученые потратили годы на поиски ответа на этот вопрос - без малейшего ре­
зультата. Я не говорю, что вы не сможете найти полиномиальный алгоритм для решения
NР-полной задачи, но я очень удивлюсь, если это у вас получится...

Классы Р и NP и NР-полнота

В предыдущих главах меня волновало различие между временем работы о( п2 } и
O(nlgn). В этой же главе мы будем рады, если алгоритм имеет полиномиальное время
работы, так что отличия о( п2 ) и О( п lg п) в этом случае рассматриваются как незначи­
тельные. Ученые в области алгоритмов обычно рассматривают задачи, решаемые алго­
ритмами с полиномиальным временем работы, как "легко решаемые". Если для решения
задачи имеется алгоритм с полиномиальным временем работы, мы говорим, что эта задача
принадлежит классу Р.
Сейчас вас может удивить, что мы считаем "легко решаемой" задачу, для решения
которо й требуется время Е>(п 100 ). Для входных данных размером п = 10 не выглядит ли
число 10100 слишком угрожающе? Да, конечно, ведь это целый ryroл (googol, от которого
произошло название "Google"). Но, к счастью, алгоритмы со временем работы 0( п100 )
на практике не встречаются. Задачи из класса Р, с которыми приходится иметь дело на
практике, требуют для решения гораздо меньше времени. Я редко встречал алгоритмы
с полиномиальным временем работы, худшим, чем о( п5 Кроме того, опыт показывает,
что как только кrо-то находит первый алгоритм с полиномиальным временем работы для
некото рой задачи, тут же находятся другие, более эффекrивные алгоритмы. Так что, если
бы кrо-то разработал первый полиномиальный алгоритм со временем е( п100 ), имелись бы
неплохие шансы, что нашлись бы и более быстрые решения.
Теперь предположим, что у нас есть предложенное решение задачи и вы хотите убе­
диться, что это решение является правильным. Например, в задаче о гамильтоновом цикле
предлагаемое решение представляет собой последовательность вершин. Для того чтобы
убедиться, что это решение является правильным, нужно проверить, что каждая верши­
на появляется в последовательности ровно один раз (за исключением совпадения пер­
вой и последний вершин), и если предложенная последовательность представляет собой
(v1 , V2, V3 , • •• , Vn, V1 ), ТО граф ДОЛЖеН СОдерЖЗТЬ ребра ( V 1 , V2 ), ( V2, v3 ), ( V3, V4 ), •••, ( Vп-l • Vn) И
( vn, v1 ). Можно легко убедиться в правильности предложенного решения задачи о гамиль­
тоновом цикле за полиномиальное время. Если в общем случае можно проверить предло­
женное решение задачи за время, полиномиально зависящее от размера входных данных

).

Глава 1 О. Трудная? Задача...

179

задачи, то мы говорим, что эта задача принадлежит классу NP3. Такое предлагаемое ре­
шение мы называем сертификатом, и чтобы задача принадлежала классу NP, время про­
верки сертификата должно полиномиально зависеть от размера входных данных задачи и
размера сертификата.
Если вы можете решить задачу за полиномиальное время, вы, конечно же, сможете
проверить сертификат этой задачи за полиномиальное вреМJ1. Другими словами, каждая
задача из класса Р автоматически принадлежит классу NP. Обратное утверждение - что
все задачи из класса NP принадлежат также классу Р - представляет собой вопрос, кото­
рый многие годы ставит в тупик ученых. Его часто называют "проблема Р = NP?".
NР-полные задачи явл.яются "наитруднейшими" в классе NP. Неформально говоря, за­
дача является NР-полной, если она удовлетворяет двум условиям: ( 1) принадлежит классу
NP и (2) в случае, если для этой задачи существует алгоритм с полиномиальным временем
работы, имеется способ преобразования каждой задачи из класса NP в эту задачу таким
образом, чтобы все они решались за полиномиальное время. Если алгоритм с полиноми­
альным временем работы имеется дл.я любой NР-полной задачи - т.е. если любая NР­
полная задача принадлежит классу Р, - то тогда Р = NP. Поскольку NР-полные задачи
являются самыми сложными в классе NP, если окажется, что какая-то задача из класса NP
является неразрешимой за полиномиальное время, то не разрешима за полиномиальное
время ни одна из NР-полных задач. Задача называется NР-сложной, если она удовлетво­
ряет второму условию NР-полноты, но может как входить в класс NP, так и не входить в
него.
Вот для удобства список соответствующих определений.
• Р: задачи разрешимы за полиномиальное время, т.е. мы можем решить задачу за время,
полиномиально зависящее от размера входных данных.
• Сертификат: предлагаемое решение задачи.
• NP: задачи, проверяемые за полиномиальное время, т.е. если дл.я такой задачи имеется
сертификат, мы можем убедиться, что он представляет собой решение задачи, за время,
полиномиально зависящее от размера входных данных.
• NР-(J)ожнаи задача: задача, такая, что если существует алгоритм ее решения за поли­
номиальное время, то любая задача в NP может быть преобразована в данную задачу
таким образом, что все задачи из NP решаются за полиномиальное время.
• NР-полнаи 3адача: задача, явл.яющаяся NР-сложной и принадлежащая классу NP.

Задачи принятия решения и приведения
Говоря о классах Р и NP или о концепции NР-полноты, мы ограничиваемся задачами
npuНllmWI решенw,: их выход представляет собой один бит, указывающий ответ "да" или
1 Вы. вероятно, уже предположили, что название Р происходит от "полиномиальное
вре:wя ". Если вам интересно, откуда взялось название NP. то оно происходит от термина "неде­
тер.wинированное полино.\/uа�ьное вреw, ". Это эквива.�ентный. хотя и .\/енее интуитивный, способ
расо,отрения этого к.�асса задач.

180

Глава /0. Трудная? Задача ...

"нет". Я сформулировал задачи поиска эйлерова и гамильтонова циклов как "содержит ли
rраф эйлеров цикл?" и "содержит ли rраф гамильтонов цикл?"
Однако некоторые задачи являются задачами оптимизации, в которых мы хотим найти
наилучшие возможные решения. а не получить ответ "да" или "нет". К счастью. зачастую
достаточно легко перебросить мост через эту пропасть путем переформулирования задачи
оптимизации как задачи принятия решения. Например, рассмотрим задачу поиска крат­
чайшего пути. Для ее решения мы использовали алгоритм Беллмана-Форда. Каким об­
разом представить задачу поиска кратчайшего пути как задачу принятия решения? Можно
спросить "содержит ли rраф путь между двумя указанными вершинами, вес которого не
превышает заданное значение k?" Мы не просим указать вершины или ребра этого пути,
мы просто выясняем его наличие. Предполагая. что вес пути является целым числом, мы
можем найти фактический вес кратчайшего пути между двумя вершинами, задавая вопро­
сы с ответами "да/нет". Каким образом? Зададим вопрос о существовании пути для k 1.
Если ответ на него - "нет", то зададим вопрос с k = 2. Если ответ - "нет", попробуем
k = 4. Будем удваивать значение k до тех пор, пока не получим ответ "да". Если это по­
следнее проверенное значение k равно k', значит, ответ находится где-то между k'/2 и k'.
Точное значение можно найти методом бинарного поиска в интервале от k'/2 до k'. Такой
подход не скажет нам, какие вершины и ребра находятся на кратчайшем пути, но как ми­
нимум сообщит, есть ли такой путь.
Второе условие NР-полноты задачи требует, чтобы при наличии алгоритма ее решения
с полиномиальным временем работы существовал способ преобразовать каждую задачу
из NP в эту задачу таким образом, чтобы их все можно было решить за полиномиальное
время. Оrраничившись задачами принятия решения, давайте рассмотрим общую идею
преобразования одной задачи принятия решения Х в другую задачу принятия решения У
так, чтобы если существует алгоритм с полиномиальным временем работы для решения У.
то есть алгоритм с полиномиальным временем работы и для задачи Х. Мы называем такое
преобразование приведением. Вот основная идея приведения.

=

входные

данныех

для задачи

х

-

Алгоритм
Алгоритм
приведения Х Входные решения Ус по
д'!_
к Ус попино- даНJ-IЫе l
пиномиальным
миапьным для задачи
временем � �
временем
Нет Нет
у
работы
оаботы
Алrоритм решения Х с полиномиапьиым
временем работы

п"

-

У нас имеются некоторые входные данные х размером п для задачи Х. Мы преобразуем
эти входные данные во входные данные у для задачи У и делаем это за время, полиноми­
ально зависящее от п, скажем, за
п�) для некоторой константы с. Способ преобразова­
ния входных данных х во входные данные у обладает важным свойством: если алгоритм У
принимает решение "да" для входных данных у, то алгоритм Х должен принимать реше­
ние "да" для входных данных х; если же У решает "нет" для входных данных у, то Х выдает
"нет" для входных данных х. Это преобразование мы называем о.лгоритмом приведенш,
с полиномио.льным временем работы. Давайте посмотрим, сколько времени требуется

о{

Глава / О. Трудная? Задача...

181

о(

алrоритму для решения задачи Х. Алгоритм приведения требует времени
п' ), причем
ero вывод не может быть болъше, чем время работы, так что размер выходных данных ал­
rоритма приведения равен
п'· ). Но эти выходные данные являются входными данными
у для алrоритма решения задачи У. Поскольку алrоритм решения задачи У является алго­
ритмом с полиномиальным временем работы, для входных данных размером т он выпол­
d
п' ),
няется за время
m ) для некоторой константы d. Но здесь т представляет собой
< d
а потому алrоритм решения задачи У выполняется за время
п
=
п',1 ). Поскольку
и с, и d являются константами, константой является и cd, так что алrоритм для решения за­
дачи У является алrоритмом с полиномиальным временем работы. Общее время решения
«1
задачи Х составляет
п'· + п ), так что она также решается за полиномиальное время.
Этот подход показывает, что если задача У - "легкая" (разрешима за полиномиальное
время), то таковой же является и задача Х. Но мы будем использовать приведение за по­
линомиальное время, чтобы демонстрировать не легкость, а сложность задач.

о(

о(

о(

о(( ) ) о(

о(

Если задача Х является NР-сложной и мы можем привести ее к задаче У за полиноми­
альное время, то задача У также является NР-сложной.
Почему это утверждение должно выполняться? Давайте предположим, что задача Х яв­
ляется NР-сложной и что есть алrоритм приведения с полиномиальным временем работы,
преобразующий входные данные Х во входные данные У. Поскольку Х является NР-слож­
ной задачей, есть способ для преобразования любой задачи, скажем, Z, из класса NP в Х,
такой, что если Х имеет алrоритм для ее решения за полиномиальное время, то это спра­
ведливо и в отношении задачи Z. Теперь вы знаете, как выполняется такое преобразование.

входные

данныеz

- -

для задачи

z

--

Алrоритм
.Алrоритм
приведения Z Входные
а
Хс по Да_ Д-Э,,.
кХс полино- данныех решения
линомиальным
миальным для задачи
временем
временем
Нет
е;
Н
работы
р аботы
Алгоритм решения Z с полиномиаяъным
временем работы

х

Поскольку мы можем преобразовать входные данные задачи Х во входные данные задачи
У за полиномиальное время, можно воспользоваться ранее выполненным приведением Х.
Входные
данные�
для задачи

z

-

........

.. z
�
кХс�
�

Входные
данныех
ДЛЯ зцдаЧJI

х

" а

..

........
.......

.,,111•1 •Х

к Уе IJQIJIIIO-

.........

ВХОD.11ые
�
pauelltlll
Ye_!WO- Да
даш1ыеr
дlJЯзадаЧИ

у

..-...

llpClltllell

Нет

;:.

-

Да

�

Нет

Аnrоритм решения Хс полиномиальным

времс11ем работы
Алгоритм решения Z с 11шшном11альныУ временем работы

Вместо группирования в единое целое приведения задачи Х к задаче У за полиномиальное
время и решение задачи У, сгруппируем два приведения за полиномиальное время в одно.

182

Глава 10. Трудная? Задача ...

Входные
данные�
для задачи

z

Апrоритм решения Z с nОJtиномиальным временем работы
Заметим, что если немедленно после приведения за полиномиальное время задачи Z к за­
даче Х выполнить приведение за полиномиальное время задачи Х к задаче У, мы получим
приведение задачи Z к задаче У за полиномиальное время.
Входные
данныеz
для задачи

Ал ритм

rо
nриве.аения Z Входные

Алrоритм
данные pcweНИJJ У с по- Да
лино миальным
NIWIWlblМ дЛЯзадачи
временем
Нет
временем
у
рабаrы
Алrо рm:м решения Z с полиномиал.ьнЬI.М
временем работы

1С у с 11О11ННО-

Да

Просто для того, чтобы убедиться, что два приведения за полиномиальное время вме­
сте составляют одно такое приведение, выполним анализ, аналогичный приведенному ра­
нее. Предположим, что входные данные z для задачи Z имеют размер п, что приведение
Z к Х занимает время о(п< ) и что приведение Х к У для входных данных размером т вы­
полняется за время о( md ), rде с и d - константы. Выходные данные приведения Z к Хне
мoryr быть больше, чем затраченное время, так что эти выходные данные, которые одно­
временно являются входными данными х приведения Х к У, имеют размер о(п' Теперь
мы знаем, что размер т входных данных привед�ния Х к У равен т = о( п< ). а потому вре­
мя приведения Х к У представляет собой (п< ) ) = о( n<d ). Поскольку и с, и d являются
константами, это второе приведение выполняется за полиномиальное время от п.
Кроме того время, затраченное на последJJем этапе (полиномиальном алгоритме реше­
ния задачи У), также полиномиально зависит от п. Предположим что алгоритм решения
задачи У для входных данных размером р выполняется за время о(рь rде Ь - констан­
та. Как и ранее, выходные данные приведения не мoryr превышать время их генерации,
так что ,R = п:J, а это означает, что алгоритм решения задачи У выполняется за время
n<d ) ) = п ). Поскольку Ь, с и d являются константами, алгоритм решения задачи У
выполняется за время, полиномиально зависящее от размера исходных данных п. Так что
алгоритм решения задачи Z выполняется за время о( п< + n<d + пЬ<d являющееся полино­
миально зависящим от п.
Итак, что же мы только что видели? Мы показали, что если задача Х является NР­
сложной и существует приведение с полиномиальным временем работы, которое преоб­
разует входные данные х задачи Х во входные данные у задачи У, то задача У также яв­
ляется NР-сложной. То, что задача Х NР-сложная, означает, что все задачи из класса NP
приводятся к ней за полиномиальное время, позволяет выбрать произвольную задачу Z из

).

о(

),

о((

о(
о(

),

Глава 10. Трудная? Задача...

183

NP, которая приводится к Х за полиномиальное время, и тем самым показать, что она за
полиномиальное время приводится и к У.
Наша конечная цель заключается в демонстрации NР-полноты задач. Теперь для того,
чтобы показать, что задача У NР-полная, нам достаточно
•

показать, что она принадлежит классу NP (для чего достаточно показать, что имеется
способ проверки сертификата для Уза полиномиальное время),

•

взяв некоторую задачу Х, NР-сложность которой нам известна, показать, что она при­
водится к задаче У за полиномиальное время.

Есть еще одна небольшая деталь, о которой я пока ничего не сказал: первичная задача.
Нам нужно начать с некоторой NР-полной задачи М, к которой за полиномиальное время
приводится каждая задача из класса NP. После этого мы сможем приводить М к друтим
задачам за полиномиальное время, чтобы показать, что эти друтие задачи являются NР­
сложными, эти друтие задачи приводить за полиномиальное время к очередным задачам
для того, чтобы показать, что те также являются NР-сложными, и т.д. Имейте также в виду,
что нет никаких ограничений на количество других задач, которые могут быть приведены
к одной, так что генеалогическое дерево NР-полных задач начинается с первичной задачи,
а затем разветвляется.

Первичная задача
В разных книгах первичные задачи различны. Это нормально, поскольку после того,
как вы приведете одну первичную задачу к другой, эта другая задача также может высту­
пать в роли первичной. Одной из часто встречающихся первичных задач является задача
выполнимости булевой формулы. Я кратко опишу эту задачу, но не буду доказывать, что
за полиномиальное время к ней сводится любая задача из класса NP. Это доказательство
весьма длинное и, осмелюсь сказать, весьма утомительное.
Начну с того, что "булева" - это математический сленг для простой логики, в которой
переменные могут принимать только два значения - О и 1 (именуемые булевыми значе­
ниями), а операторы принимают одно или два булевых значения и выдают также булево
значение. Мы уже встречались с операцией исключающего или (XOR) в главе 8, "Основы
криптографии". Типичными булевыми операторами являются операции "и" (AND), "или"
(OR), "не" (NOT), "следует" (IMPLIES) и "эквивалентно" (IFF).
•

х AND у равно 1, только если и х, и у равны 1; в противном случае (когда хотя бы одно
из значений равно О) х AND у равно О.

•

х OR у равно О, только если их, и у равны О; в противном случае (когда хотя бы одно
из значений равно 1) х OR у равно 1.

•
•

NOT х представляет собой противоположное х значение: О, если х = 1 , и 1, если х = О.

х IMPLIES у равно О, только если х = 1 и у = О; в противном случае (либо х = О, либо и
х, и у равны 1) х IMPLIES у равно 1.

184

Глава / О. Трудная? Задача ...

• х IFF у означает "х тогда и только тогда, когда у", и это значение равно 1, только если
и х, и у одновременно равны О или одновременно равны 1. Если х у, то х IFF у= О.

*

Имеется 16 возможных булевых бинарных (получающих два операнда) операторов;
здесь показаны только наиболее распространенные из них4• Булева формула состоит из
булевых переменных, операторов и скобок для их группировки.
В задаче о выполнимости булевой формулы входные данные представляют собой бу­
леву формулу, а поставленный вопрос - существует ли такой набор значений перемен­
ных, чтобы выполненные по формуле вычисления давали значение 1. Если такой набор
существует, мы говорим, что формула выполнима. Например, булева формула
((wIMPLIESx)OR NOT{((NOTw)IFF y)OR z})AND(NOTх)
выполнима: пусть w =О, х =О, у= 1 и z = 1 . Тогда формула вычисляется следующим
образом:
((о IMPLIESO}OR Noт{((NOTО) IFF 1) OR 1))AND(NOTО)
= ( 1 OR NOT((1 IFF 1) OR 1))AND 1
= ( 1 OR NOT(1 OR 1))AND 1
= (1 OR О)AND 1
=IANDI
=1.

С другой стороны, следующая простая формула невыполнима: хAND(NOTх ).
Если х = О, эта формула вычисляется как ОAND 1, что равно О; если же х = 1, мы получаем
1ANDО, что, опять же, равно О.

Сборник NР-полных задач
Рассмотрим, с задачей выполнимости булевой формулы в качестве первичной, некото­
рые из задач, NР-полноту которых можно показать путем приведения за полиномиальное
время. Вот генеалогическое дерево приведений, которые я имею в виду.
Я не буду показывать все приведения в этом дереве, потому что некоторые из них до­
вольно громоздки и утомительны. Но мы рассмотрим пару из них, интересных тем, что
они показывают приведение задачи из одной предметной области к задаче из совершенно
другой, например логику (3-СNF-выполнимость) к графам (задача о клике).

3-СNF-выполнимость
Поскольку бул евы формулы могут содержать любой из 16 бинарных булевых опера­
торов, а также поскольку они могут быть размещены в скобках произвольным образом,
4 Некоторые из этих / 6 операmQJюв совершстю 11еи11терес11ы, как. 11апри111ер. оператор.
возвращающий з1юче11ие О 11езависимо от значе11ий опера11дов.

Глава / О. Трудная? Задача...

I 85

Первичная задача:
выполнимость булевой формулы:

----

---

3-CNF выполнимость

Клика
1

Сумма подмножества
1

Вершинное покрытие

Разбиение

Гамильтонов цикл

Рюкзак

1

/

�

1

Коммивояжер Гамильтонов путь
НаИдЛиннейший
ациклический путь
весьма трудно выполнить приведение непосредственно задачи выполнимости булевой
формулы, играющей роль первичной задачи. Вместо этого мы определим родственную
задачу, которая также состоит в определении выполнимости булевых формул, но при этом
имеет некоторые ограничения на структуру формулы, являющейся входными данными.
Выполнять приведение этой задачи будет гораздо проще. Итак, потребуем, чтобы фор­
мул а представляла собой набор операторов AND, примененных к выражениям в скобках,
где каждое такое выражение представляет собой применение операторов OR к трем чле­
нам, причем каждый член является литералом, т.е. либо переменной, либо ее отрицанием.
Булева формула в этом виде называется представленной в 3-коньюнктивноii нормальной
форме, или 3-CNF. Например, булева формула
(wOR (NOTw)OR {NOT х)) AND(yOR xOR z)
AND(( ANDw)OR (NOT y)OR (NOT z))
является 3-СNF-формулой. Ее первым выражением является( w OR (NOTw) OR(NOT х)).
Задача выяснения, имеет ли булева 3-СNF-формул а набор выполняющих ее перемен­
ных, - задача З-СNF-t1ыполнимости, - является NР-полной. Ее сертификат представ­
ляет собой предлагаемое назначение значений О и I переменным. Проверка сертификата
проста: надо просто присвоить назначенные значения переменным и, вычислив формулу,
убедиться, что в результате вычисления получилось значение 1. Чтобы показать, что зада­
ча 3-СNF-выполнимости является NР-сложной, мы приведем к ней задачу о выполнимо­
сти бул евой формулы (без каких-либо ограничений). Я вновь не буду вдаваться в (не столь
уж интересные) подробности. Гораздо интереснее будет посмотреть на приведение задачи
из одной предметной области к задаче из другой области, чем мы и собираемся заняться.
А вот и первое расстройство: хотя упомянутая задача 3-СNF-выполнимости NР­
полная, имеется алгоритм с полиномиальным временем работы, определяющий, является
ли выполнимой 2-СNF-формула (такая же, как и 3-СNF-формула, с тем отличием, что она
имеет по два, а не по три литерала в каждом выражении в скобках). Такое небольшое из­
менение - и такое усложнение решения!

186

Глава 10. Трудная? Задача ...

Клика
Теперь мы рассмотрим интересное приведение для задач из различных предметных
областей: задачи 3-СNF-выполнимости к неориентированным графам. Клика в неориен­
тированном графе G - это подмножество S вершин графа, такое, что в графе имеются
ребра, соединяющие каждую пару вершин в S. Размер клики равен количеству вершин,
которые она содержит.
Как вы догадываетесь, клики играют роль в теории социальных сетей. Если модели­
ровать каждого человека как вершину, а отношения между людьми - как неориентиро­
ванные ребра, то клики представляют собой группу лиц, в которой все имеют отношения
друг с другом. Клики также применяются в области биоинформатики, техники и химии.
Задача о клике получает на вход граф G и положительное целое число k, и в задаче
спрашивается, содержит ли граф G клику размером k. Например, приведенный ниже граф
имеет клику размером 4, вершины которой выделены темной штриховкой. В этом графе
нет других клик размером 4 или больше.

Проверить сертификат очень просто. Сертификат представляет собой список k вер­
шин, о которых утверждается, что они образуют клику, так что мы просто должны про­
верить, что каждая из k вершин имеет ребра к другим k - l вершинам. Эта проверка легко
выполнима за время, полиномиально зависящее от размера графа. Так что мы знаем, что
задача о клике принадлежит классу NP.
Но как же привести задачу о выполнимости булевой формулы к задаче, связанной
с графом? Начнем с булевой 3-СNF-формулы. Предположим, что формула имеет вид
cl AND с2 AND Сз AND • • • AND Ck, где каждое С, представляет собой ОДНО ИЗ k выра­
жений. На основе этой формулы мы за полиномиальное время построим граф, который бу­
дет иметь k клик тог.и.а и только тогда, когда 3-СNF-формула будет выполнимой. Мы должны
обеспечить три вещи: построение графа, доказательство, что это построение выполняется за
время, полиномиально зависящее от размера 3-СNF-формулы, и доказательство того, что граф
имеет k клик в том и только в том случае, если существует некоторый способ назначения зна­
чений переменным в 3-СNF-формуле таким образом, что ее значение оказывается равным l.
Для построения графа из 3-СNF-формулы сосредоточимся на r-м выражении С,. Оно
состоит из трех литералов; назовем их 1; 1; и 1; так что С, = 1; OR 1; OR 1; Каждый
литерал является либо переменной, либо ее отрицанием. Для каждого литерала мы созда­
ем одну вершину, так что для выражения С, мы создадим тройку вершин: v;, v; и v;. Мы
добавляем ребро между вершинами v; и v;, если выполняются два условия:

,

,

.

Глава / О. Трудная? Задача...

f 87

•

v; и v; находятся в разных тройках, т.е. r и s являются номерами разных выражений,

•

их литералы не являются отрицанием один другого.

Например, показанный ниже граф соответствует 3-СNF-формуле

(xOR(NOT y)OR (NOT z)) AND((NOT x)OR yOR z) AND(xOR yOR z)
С 1 = х OR (NOTy) OR (NOTz)

С2 = (NOTx) ORyORz

C 3=x0Ry0Rz

Достаточно лепсо показать, что это приведение может быть выполнено за полиноми­
альное время. Если 3-СNF-формула содержит k выражений, то в ней Зk литералов, так что
всего граф имеет Зk вершин. Каждая вершина имеет не более Зk -1 ребер ко всем осталь­
ным Зk-1 вершинам, так что общее количество ребер не превышает Зk(Зk-1) = 9k2 -3k.
Размер построенного графа полиномиально зависит от размера входной 3-СNF-формулы,
и очень лепсо определить, какие ребра имеются в графе.
Наконец нужно показать, что построенный граф имеет клику размером k тогда и толь­
ко тогда, когда 3-СNF-формула выполнима. Начнем с предположения, что формула вы­
полнима, и покажем, что граф имеет k-клику. Если существует удовлетворяющий набор
значений переменных, каждое выражение С, содержит по крайней мере один литерала z;,
имеющий значение 1, и каждый такой литерал соответствует вершине v; в графе. Если
мы выберем по одному такому литералу из каждого из k выражений, то получим соответ­
ствующее множество S из k вершин. Я утверждаю, что S является k-кликой. Рассмотрим
любые две вершины в S. Они соответствуют литералам в разных выражениях, которые
дают 1 при использовании выполняющего набора значений. Эти литералы не могут быть
отрицаниями один другого, поскольку в таком случае один из них был бы единицей, а дру­
гой - нулем. Но поскольку эти литералы не являются отрицанием один другого, между
соответствующими вершинами при построении графа было добавлено ребро. Поскольку
в качестве рассматриваемой пары мы можем выбрать любые две вершины в S, мы видим,
что между всеми парами вершин в S имеются ребра. Следовательно, множество S из k
вершин представляет собой k-клику.
Теперь следует рассмотреть ситуацию в обратном направлении: если граф имеет
k-клику S, то 3-СNF-формула выполнима. В графе нет ребер между вершинами из одной
тройки, а значит, S содержит ровно одну вершину из каждой тройки. Для каждой вершины
v; из S назначим соответствующему литералу
в 3-СNF-формуле единичное значение.
Мы не должны беспокоиться о присвоении единицы и литералу, и его отрицанию, так как

z;

188

Глава / О. Трудная? Задача ...

k-клика не может одновременно содержать вершины, соответствующие литералу и его
отрицанию. Поскольку каждое выражение имеет литерал, равный 1, каждое выражение
выполнимо, а потому выполнима и вся 3-СNF-формула. Значения переменным, не соот­
ветствующим вершинам клики, присваиваются произвольным образом; они не влияют на
выполнимость формулы.
В приведенном выше примере выполняющим набором являются у= О и z = 1 ; значе­
ние х не играет роли. Получающаяся 3-клика состоит из заштрихованных вершин, кото­
рые соответствуют NOT у из С1 и z из С2 и С3 •
Таким образом, мы показали, что существует приведение за полиномиальное время
NР-полной задачи 3-СNF-выполнимости проблемы к поиску k-клики. Если имеется булева
3-СNF-формула с k выражениями и вам надо найти для нее выполняющий набор значений
переменных, то можно использовать описанное выше построение для преобразования за
полиномиальное время формулы в неориентированный граф и определить, имеет ли этот
граф k-клику. Если бы можно было за полиномиальное время определить наличие k-клики
в графе, то тем самым за полиномиальное время можно было бы определить, имеет ли
3-СNF-формула выполняющий набор. Поскольку задача о 3-СNF-выполнимости является
NР-полной, таковой же является и задача определения, содержит ли граф k-клику. В ка­
честве бесплатного приложения, если бы вы моrnи определить не только наличие в графе
k-клики, но и составляющие ее вершины, вы моmи бы использовать эту информацию для
поиска выполняющего набора значений для 3-СNF-формулы.

Вершинное покрытие
Вершинное покрытие неориентированного графа G представляет собой подмножество
S его вершин, такое, что каждое ребро G инцидентно по крайней мере одной вершине нз S.
Мы говорим, что каждая вершина в S "покрывает" инцидентные ей ребра. Размер вершин­
н�о покрытw, равен количеству содержащихся в нем вершин. Как и задача о клике, зада­
ча о вершинном покрытии получает в качестве входных данных неориентированный граф
G и положительное целое число m. В задаче спрашивается, имеет ли граф G вершинное
покрьrrне размером m. Как и задача о клике. задача о вершинном покрьrrнн имеет прило­
жения в бионнформатике. Еще в одной задаче у вас есть здание с коридорами и камеры на
перекрестках этих коридоров, которые моrут полностью сканировать последние; требуется
определить, достаточно ли т камер для полного сканирования всех коридоров. Здесь ребра
моделируют коридоры, а вершины - их пересечения. В еще одном приложении эта задача
помогает в разработке стратегий по предотвращению атак компьютерных сетей червем.
Очевидно, что сертификатом для задачи вершинного покрытия является список пред­
лагаемых вершин. За полиномиальное время легко убедиться, что предлагаемое вершин­
ное покрытие имеет размер т и действительно охватывают все ребра; таким образом, мы
видим, что эта задача принадлежит классу NP.
Генеалогическое дерево NР-полноты на с. 185 говорит нам, что мы будем приводить
задачу о клике к задаче о вершинном покрытии. Предположим, что входными данными
для задачи о клике являются неориентированный граф G с п вершинами и положительное
целое число k. За полиномиальное время мы сгенерируем входной граф G для задачи о

Глава 10. Трудная? Задача...

189

вершинном покрытии, такой, что граф G имеет клику размером k тогда и только тогда,
когда граф G имеет вершинное покрытие размером п - k . Это очень простое приведение.
Граф G имеет те же вершины, что и граф G, и ребра, отсутствующие в G. Иными словами,
ребро (и, v) имеется в графе G тогда и только тогда, когда ребра (и, v) в графе G нет.
Возможно, вы решите, что вершинное покрытие размером п - k в G состоит из вершин,
которые не входят в клику из k вершин в графе G, - и вы будете совершенно правы! Ниже
приведены примеры графов G и G с восемью вершинами. Пять вершин, образующих

G

клику в G, и остальные три вершины, образующие вершинное покрытие в G, выделены на
рисунке темной штриховкой. Обратите внимание, что каждое ребро в G инцидеитно как
минимум одной заштрихованной вершине.
Нам нужно показать, что G имеет k-клику тогда и только тогда, когда G имеет вершин­
ное покрытие размером п - k. Для начала предположим, что G имеет k-клику С. Пусть S
состоит из п - k вершин, не входящих в С. Я утверждаю, что каждое ребро в G инцидентно
по крайней мере одной вершине из S. Пусть (и, v)- произвольное ребро в G. Оно принад­
лежит G, поскольку не принадлежит G. А так как (и, v) не принадлежит G, как минимум
одна из вершин и и v находится не в клике С графа G, поскольку ребро соединяет все пары
вершин в С. Так как по крайней мере одна из вершин и и v находится не в клике С, как
минимум одна из них находится в S, что означает, что ребро (и, v) инцидентно по меньшей
мере одной из вершин в S. Поскольку мы выбрали (и, v) как произвольное ребро из G, мы
видим, что S является вершинным покрытием графа G.
Теперь пойдем в обратном направлении. Предположим, что G имеет вершинное по­
крытие S, содержащее п - k вершин, и пусть С состоит из k вершин, не входящих в S.
Каждое ребро в G инцидентно некоторой вершине в S. Другими словами, если ( и, v) яв­
ляется ребром в G, то по крайней мере одна из вершин и и v находится в S. Если вы
вспомните определение контрапозиции на с. 33, то увидите, что контрапозицией данного
следствия является утверждение, что если ни и, ни v не находятся в S, то ( и, v) не входит
в G, а следовательно, ( и, v) принадлежит G. Другими словами, если и и, и v входят в С, то
ребро ( и, v) присутствует в G. Так как и и v- произвольная пара вершин из С, мы видим,
что в G имеются ребра между всеми парами вершин в С, т.е. С является k-кликой.
Таким образом, мы показали, что существует приведение за полиномиальное время
NР-полной задачи определения, содержит ли неориентированный граф k-клику, к задаче
выяснения, содержит ли неориентированный граф вершинное покрытие размером n-k.
Если у вас имеется неориентированный граф G и вы хотите знать, содержит ли он k-клику,

1SIO

Глава 10. Трудная? Задача...

можно воспользоваться только что описанным построением и преобразовать за полино­
миальное время граф G в граф G и вЫJ1снить, содержит ли граф G вершинное покрьпие
с п - k вершинами. Если за полиномиальное время можно определить, имеет ли G вер­
шинное покрытие размером п - k, то таким образом можно определить за полиномиальное
время, имеет ли граф G k-клнку. Поскольку задача о клике является NР-полной, таковой
же является и задача о вершинном покрытии. В качестве бесплатного приложения, если
бы вы могли определить не только наличие у графа G вершинного покрытия из п - k вер­
шин, но и сами эти вершины, эту информацию можно было бы использовать для поиска
вершин, составляющих k-клнку.

Гамильтонов цикл и гамильтонов путь
Мы уже встречались с задачей о гамильтоновом цикле: содержит ли связный неориен­
тированный граф гамильтонов цикла (путь, который начинается и заканчивается в одной
и той же вершине и посещает все прочие вершины ровно один раз)? Непосредственные
приложения этой задачи не совсем ясны, но из генеалогического дерева NР-полноты на
с. 185 можно увидеть, что эта задача используется для доказательства того, что задача ком­
мивояжера является NР-полной (а практичность этой задачи, как мы уже видели, сомне­
ний не вызывает).
С этой задачей тесно связана задача о гамильтоновом пути, в которой спрашива­
ется, содержит ли граф путь, который посещает все вершины ровно один раз, но не
требуется, чтобы этот путь был циклом. Эта задача также является NР-полной, и мы
воспользуемся ею, чтобы показать, что NР-полной является и задача о наидлиннейшем
ациклическом пути.
Сертификат ДЛJ1 обеих гамильтоновых задач тривиален: это упорядоченный список
вершин в гамильтоновом цикле или пути (для гамильтонова цикла повторять первую вер­
шину в конце не требуется). Для проверки сертификата нужно только проверить, что каж­
дая вершина появляется в списке ровно один раз и что граф содержит ребра между каждой
парой смежных вершин в списке. В случае задачи о гамильтоновом цикле надо тахже
убедиться в наличии ребра между первой и последней вершинами в списке.
Я не буду подробно останавливаться на приведении за полиномиальное время задачи
о вершинном покрытии к задаче о гамильтоновом цикле, которое показывает, что послед­
НЯJI является NР-сложной. Оно довольно сложное и опирается на так называемый виджет
(widget)- часть графа, которая обеспечивает определенные свойства. Виджет, используе­
мый в данном приведении, обладает тем свойством, что любой гамильтонов цикл в графе,
построенном приведением, может пройти через виджет только одним из трех способов.
Чтобы привести задачу о гамнльтоновом цикле к задаче о гамнльтоновом пути, мы на­
чинаем со связного неориентированного графа G с п вершинами и образуем нз него новый
связный неориентированный граф G' с п + 3 вершинами. Мы выбираем любую верши­
ну и в графе G. Пусть смежные с ней вершины - v" v2 ..... vk . Чтобы построить граф G',
мы добавляем три новые вершины х,у и z, а также ребра (и,х) и (y,z) наряду с ребрами
(v"y). (v2 ,y), ... , (vk ,у)между у и всеми вершинами, смежными с и. Вот пример такого
построения.

Глава 10. Трудная? Задача...

191

( v"y), (v2 ,y), ... , ( vt ,у)между у и всеми вершинами, смежными с и. Вот пример такого
построения.

G

G'

Заштрихованные ребра указывают rамильтонов цикл в графе G и соответствующий rа­
мильтонов путь в графе G' . Это приведение выполняется за полиномиальное время, так
как G' содержит только на три вершины больше, чем rраф G, и не более чем п + 1 до­
полнительное ребро.
Как обычно, следует показать, что приведение работает, т.е. что rраф G имеет rамиль­
тонов цикл тогда и только тогда, когда rраф G' имеет rамильтонов путь. Предположим,
что rраф G имеет rамильтонов цикл. Он должен содержатъ ребро (u,v;) для некоторой
вершины v;, смежной с вершиной и, а следовательно, смежной с у в графе G' . Чтобы
сформировать rамильтонов путь в графе G, перейдем от х к z, беря все ребра rамильтонова
цикла, кроме (u,v;), и добавляя ребра (и,х), (v;,Y) и (y,z). В приведенном выше при­
мере v1 представляет собой вершину v2 , так что из rамильтонова пути удаляется ребро
(v2 ,u) и добавляются ребра (и,х), (v2 ,y ) и (y,z).
Теперь предположим, что rраф G' имеет rамильтонов путь. Поскольку вершины х
и z имеют только по одному инцидентному ребру, rамильтонов путь должен идти or х к z
и должен содержать ребро ( v;, у) для некоторой смежной с у вершины, а следовательно,
смежной с и. Чтобы найти rамильтонов цикл в графе G, удалим х, у и z и все инцидент­
ные им ребра и воспользуемся всеми ребрами rамильтонова пути в графе G' вместе с
ребром (v ;,и) .
Завершение такое же, как и для всех рассмотренных ранее приведений. Существует
приведение за полиномиальное время NР-полной задачи определения, содержит ли связ­
ный неориентированный rраф rамильтонов цикл, к задаче определения, содержит ли
связный неориентированный rраф rамильтонов путь. Так как первая задача NР-полная,
таковой же является и последняя. Кроме тоrо, знание ребер rамильтонова пути дает ребра
rамильтонова цикла.

192

Глава /0. Трудная? Задача ...

Задача коммивояжера

В версии принятия решения задачи коммивояжера задан полный неориентирован­
ный граф с неотрицательными целыми весами ребер и неотрицательное целое число k.
Полный zраф имеет ребра между каждой парой вершин. так что если в нем имеется п
вершин, то он содержит п ( п -1) ребер. Требуется выяснить, имеет ли граф цикл, который
содержит все вершины и общий вес которого не превышает k.
Очень легко показать, что эта задача принадлежит классу NP. Сертификат представля­
ет собой упорядоченный список вершин цикла. Можно легко проверить за полиномиаль­
ное время, посещает ли цикл все вершины и имеет ли он общий вес, не превышающий k.
Чтобы показать, что задача коммивояжера является NР-сложной, мы выполним очень
простое приведение к ней задачи о rамильтоновом цикле. Для данного графа G, являюще­
гося входным для задачи о rамильтоновом цикле, мы строим полный граф G' с теми же
вершинами, что и у графа G. Вес ребра ( и, v) в графе G' устанамивается равным О, если
(и, v) ямяется ребром графа G, и равным 1, если (и, v) не входит в G. Устанавливаем k = О.
Такое приведение выполняется за время, полиномиально зависящее от размера графа G.
поскольку оно добамяет в граф не более п ( п -1) ребер.
Чтобы показать, что это приведение работает, нам нужно показать, что граф G имеет
rамильтонов цикл тогда и только тогда, когда граф G' имеет цикл с нулевым весом, вклю­
чающий все вершины. Это легко сделать. Предположим, что граф G имеет rамильтонов
цикл. Тогда каждое ребро цикла находится в G, так что каждое из этих ребер в графе G'
имеет нулевой вес. Таким образом, граф G' имеет цикл, содержащий все вершины, и
общий вес этого цикла нулевой. И обратно, предположим, что граф G' имеет цикл, содер­
жащий все вершины, и общий вес этого цикла нулевой. Тогда каждое ребро этого цикла
должно иметься и в графе G, так что граф G содержит rамильтонов цикл.
Надеюсь, мне не нужно повторять хорошо знакомое завершение доказательства?
Наидлиннейwий ациклический путь

В ве рсии принятия решения задачи о наидлиннейшем ациклическом пути нам даны
неориентированный граф G и целое число k и спрашивается, имеются ли в графе G две
вершины, между которыми имеется ациклический путь не менее чем из k ребер.
И вновь, сертификат для данной задачи проверить очень легко. Он состоит из упо­
рядоченного списка вершин в предлагаемом пути. Мы можем за полиномиальное время
проверить, что список содержит по крайней мере k + 1 вершину ( k + 1 , потому что путь
с k ребрами состоит из k + 1 вершины), при этом ни одна вершина в пуrи не повторяется,
и для каждой пары соседних вершин в списке имеется соединяющее их ребро.
Еще одно простое приведение показывает, что эта задача ямяется NР-сложной. Мы
выполняем привед ение к ней задачи о rамильтоновом пути. Если в качестве входного для
задачи о rамильтоновом пуrи дан граф G с п вершинами, то входными данными задачи о
наидлиннейшем ациклическом пути являются тот же граф G и целое число k = п -l . Если
это не приведение за полиномиальное время, то я уж и не знаю, что тогда можно назвать
таковым ...

Глава / О. Трудная? Задача...

193

Сумма подмножества
В задаче о сумме подмножества входными данными являются конечное неупо­
рядоченное множество S положительных целых чисел и целевое число t, которое

также является положительным целым числом. Мы хотим выяснить, су ществует ли
подмножество S' множества S, сумма элементов которого в точности равна t. Напри­
мер, если S представляет собой множество {1 , 2, 7, 1 4, 49, 98, 343, 686, 2409, 2793,
1 6 808, 17 206, 117 705, 117 993}, а t = 138 457, то решением является подмножество
S' = {1,2,7,98,343,686,2409,17 206,117705}. Сертификатом является, конечно же, под­
множество S, проверить которое можно простым сложением чисел подмножества и срав­
нением суммы с числом t.
Как можно увидеть из генеалогического дерева NР-полноты на с. 185, демонстриро­
вать NР-сложность задачи суммы подмножества мы будем путем приведения к ней задачи
о 3-СNF-выполнимости. Это еще один пример приведения задачи из одной предметной
области к задаче из другой, превращая логическую задачу в арифметическую. Это пре­
образование, несмотря на всю интеллектуальность, в конечном счете довольно простое.
Мы начинаем с булевой 3-СNF-формулы F, которая имеет п переменных и k выра­
жений. Назовем переменные v" v2, v3 , • • • , vn , а выражения - C"C2 ,Cp ···,Ck. Каждое
выражение содержит ровно три литерала (вспомните, что каждый литерал представ­
ляет собой v; или NOT v1), обьединенные операторами OR, а вся формула имеет вид
F = С1 AND С2 AND С3 AND ··· AND с•. Таким образом, каждое выражение выполняет­
ся, если любой из его литералов равен единице, а полная формула F выполняется, только
когда выполняются все входящие в нее выражения.
Прежде чем мы построим множество S для задачи суммы подмножества, сконструиру­
ем целевое число t из 3-СNF-формулы F. Будем строить его как десятичное число с п + k
цифрами. Младшие k цифр (k цифр справа) числа t соответствуют k выражениям форму­
лы F, и каждая из этих цифр равна 4. Старшие п цифр числа t соответствуют п перемен­
ным формулы F, и каждая из этих цифр равна 1. Если формула F имеет, скажем, три пере­
менные и четыре выражения, то t оказывается равным 1114444. Как мы увидим, если есть
подмножество S, сумма которого равна t, то цифры t, которые соответствуют переменным
(единицы), обеспечат присвоение значения каждой переменной в F, а цифры t, которые
соответствуют выражениям (четверки) гарантируют выполнение каждого выражения F.
Множество S будет состоять из 2n + 2k целых чисел. Оно содержит целые числа Х; и
х; для каждой из п переменных v1 в 3-СNF-формуле F и целые числа qj и q; для каждого
из k выражений Cj в формуле F. Мы строим каждое целое число в S цифра за цифрой в
десятичной системе счисления. Давайте рассмотрим пример с п = 3 переменными и k = 4
выражениями, так что 3-СNF-формула имеет вид F = С, AND С2 AND С3 AND С" и пусть
выражения представляют собой

194

Глава 10. Тру дная? Задача ...

с,= v, OR (NOT V2) OR (NOT VJ ),
С2 = (NOT v,) OR (NOT v2 ) OR (NOT v3
С3 = (NOT v1 ) OR (NOT vJ OR v3
С4 = v, oR v2 oR v3

),

,

•

Вот как выглядят соответствующее множество S и целевое число t.
VJ
v,
V2
Сз
с,
с2
х,

х:

Х2

х'2
Хз

,

Х3

q,
q;
Ч2

,

Ч1

Чз

q;
q4

q;

о
о
о
о
о
о
о
о
о
о
о

о
о
1

о
о
о
о
о
о
о
о
о
о

о
о
о
о

о
о
о
о
о
о
о
о

1

о
о
1

о

о

о

1

1

о
о
1

1

2

о
о
о
о
о
о
4

о
о
1

2

о
о
о
о
4

о
о
о
о
о
о
2

о
о
4

с.
о
1

о
1

о
о
о
о
о
о
о
1

2
4

Обратите внимание, что заштрихованные элементы S - 1ООО 11О, 1О 111О. 10011, 1ООО,
2000, 200, 1О, 1 и 2 - дают в сумме 1114444. Вскоре мы увидим, чему эти элементы соот­
ветствуют в 3-СNF-формуле F.
Мы строим целые числа в S цифра за цифрой так, чтобы каждый столбец в приведен­
ной таблице имел либо сумму 2 (п столбцов слева), либо 6 (k столбцов справа). Обратите
внимание, что при суммировании элементов в S необходимости переноса не возникает ни
в одной из позиций цифр, так что мы можем работать с числами цифра за цифрой.
Каждая строка в таблице помечена элементом из S. Первые 2n строк соответствуют
п переменным в 3-СNF-формуле, а последние 2k строк представляют собой "слабину",
цель которой мы увидим чуть позже. Строки, обозначенные элементами Х; и х; , отвеча­
ют соответственно литералам v1 и NOT v1 в формуле F. Мы будем говорить, что строки
"являются" литералами, понимая, что мы имеем в виду, что они соответствуют литералам.
Наша цель заключается в том, чтобы включить в подмножество S' ровно п из 2n первых
строк - ровно по одной строке из каждой пары Х; и х;
строки, которые будут со­
ответствовать выполняющему набору 3-СNF-формулы F. Поскольку мы требуем, чтобы
выбираемые строки добавляли по I в каждом из п левых столбцов, мы гарантируем, что

-

Глава / О. Трудная? Задача...

195

для каждой переменной v; в 3-СNF-формуле в подмножество S' из двух строк для каж­
дой пары Х; и х; будет включена только одна из них, но не обе одновременно. k столбцов
справа гарантируют, что строки, которые мы включаем в S' , представляют собой литера­
лы, которые удовлетворяют каждое из выражений в 3-СNF-формуле.
Давайте ненадолго сосредоточимся на п левых столбцах, которые помечены перемен­
ными v1 , v2 , •••, vn . Для каждой заданной переменной v1 в строках Х; и х; цифра, соответ­
ствующая v; , равна единице, а цифры в позициях, соответствующих другим переменным,
равны нулю. Например, три левые цифры для х2 и х; равны О 1 О. Цифры в последних 2k
строках в п левых столбцах нулевые. Поскольку целевое значение t содержит по единице
в каждой позиции переменных, чтобы внести свой вклад в сумму, в подмножество S' для
каждого i должно входить ровно одно значение - либо х, , либо х; (они не могут ни одно­
временно входить в S', ни одновременно отсутствовать в этом подмножестве). Наличие
х, в S' соответствует установке v; = 1 , а наличие х; соответствует v, = О .
Теперь обратим свое внимание на k правых столбцов, которые соответствуют выра­
жениям. Эти столбцы, как мы увидим ниже, гарантируют, что каждое выражение выпол­
няется. Если литерал v; встречается в выражении Ci , то в строке х1 в столбце для С1
находится значение 1; если же в выражении Ci имеется литерал NOT v; , то значение 1 в
столбце Ci находится в строке х;. Поскольку каждое выражение в 3-СNF-формуле содер­
жит ровно три разных литерала, столбец каждого выражения должен содержать ровно три
единицы среди всех строк х, и х; . Для данного выражения Ci среди первых 2n строк
строки, включенные в S', соответствуют выполнению О, l, 2 или 3 литералов в С1, так
что эти строки добавляют к общей сумме столбца С1 значения О, l, 2 или 3.
Однако целевой цифрой для каждого выражения является 4, и вот тут и ветупают в
игру "слабины" q i и q; для j = 1,2,3,...,k. Они гарантируют, что для каждого выражения
подмножество S' включает некоторый литерал из этого выражения (некоторое х, или х;,
которое имеет значение 1 в соответствующем столбце). Строка для q1 имеет единицу в
столбце для выражения С1 и нуль - во всех остальных; строка для q; такая же, за исклю­
чением того, что вместо значения 1 она содержит значение 2. Мы можем суммировать эти
строки для достижения целевой цифры 4, но только если подмножество S' включает по
крайней мере один литерал из Ci . Какие из этих строк "слабни" должны быть суммирова­
ны, зависит от количества литералов выражения Ci , включенных в S'. Если S' включает
только один литерал, то необходимы обе строки, поскольку сумма в столбце состоит из
единицы от литерала, плюс единица от qi и двойка от q; . Если S' включает два литерала,
то нужна лишь строка q;, так как два литерала дают в сумме двойку. Если же S' включает
три литерала, то нужна строка q1 , поскольку три литерала вносят в сумму вклад, равный
3, так что для получения значения 4 требуется одна единица - от строки qf . Но если в
S' не входит ни один литерал из Ci , то qi + q; = 3 недостаточно для получения целевого
значения 4. Следовательно, достичь целевого значения 4 можно, только если в подмноже­
ство S' входит некоторый литерал из выражения.
Теперь, когда мы познакомились с приведением, убедимся, что оно выполнимо за по­
линомиальное время. Мы создаем 2n + 2k + 1 целых чисел (включая целевое значение t),

Глава 10. Трудная? Задача...

196

каждое из которых состоит из п + k цифр. Из диаграммы видно, что все создаваемые це­
лые числа различны, так что S действительно представляет собой множество (определе­
ние множества не допускает наличия повторяющихся элементов).
Чтобы показать, что данное приведение работает, нужно показать, что 3-СNF-формула
F имеет выполняющий набор тогда и только тогда, когда существует подмножество S'
множества S, сумма элементов которого в точности равна t. Вы уже встречались с этой
идеей, но давайте повторимся. Во-первых, предположим, что F имеет выполняющий на­
бор. Если в этом наборе v; = l , включим Х; в S' ; в противном случае включим х; . По­
скольку в S входит только один из элементов Х; и х; столбец для v1 должен давать в
сумме значение l, равное соответствующей цифре числа t. Поскольку при наличии вы­
полняющего набора выполняется каждое выражение Cj , строки Х; и х; должны давать
в сумму в столбце Cj значение l, 2 или 3 (количество литералов Cj , равных 1 ). Включение
необходимых строк слабины qi и/или q; в S ' дает требуемую целевого цифру 4 .
И обратно, предположим, что S имеет подмножество S' , сумма элементов которого в
точности равна t. Чтобы число t имело единицы в плевых позициях, S' должно включать
ровно один из элементов х1 и х; для каждой переменной v; . Если оно включает х1 , уста­
навливаем v1 = 1 ; если же оно включает х; , устанавливаем v 1 = О . Поскольку строки сла­
бины qi и q; , просуммированные вместе, не могут дать целевую цифру 4 в столбце для
выражения С1 , подмножество S' должно включать по крайней мере одну из строк х 1 или
х; с единицей в столбце С1 . Если оно включает х, то в выражении Cj имеется литерал
v1 , и выражение выполняется. Если S' включает х;, то в выражении С1 имеется литерал
NOT v;, и выражение, опять же, выполняется. Таким образом, выполняется каждое из вы­
ражений, а значит, для 3-СNF-формулы F имеется выполняющий набор.
Таким образом, мы видим, что если можно за полиномиальное время решить задачу
о сумме подмножества, то тогда за полиномиальное время можно определить, является
ли 3-СNF-формула выполнимой. Поскольку задача о 3-СNF-выполнимости является NР­
полной, таковой же является и задача о сумме подмножества. Кроме того, если мы знаем,
какие целые числа множества S при суммировании дают целевое значение t, то мы можем
определить и выполняющий набор переменных для 3-СNF-формулы.
Еще одно замечание о рассмотренном приведении: цифры не обязаны быть десятич­
ными. Важно, чтобы при суммировании не происходили переносы из разряда в разряд,
а поскольку сумма столбца не может превышать 6, можно использовать любую систему
счисления, лишь бы ее основание было не менее 7.

,

,

Разбиение
Задача о разбиении тесно связана с задачей о сумме подмножества. Фактически это
частный случай последней: если z равно сумме всех целых чисел в множестве S, то целе­
вое значение t в точности равно z/2 . Другими словами, цель заключается в том, чтобы
определить, существует ли разбиение множества S на два непересекающихся множества
таким образом, чтобы каждое целое число из S находилось либо в S', либо в
S' и
но не в обоих подмножествах одновременно (что, собственно, и означает термин "разбие-

s·

s· ,

Г,qава 10. Трудная? Задача...

w

w

197

ние S на S' и S "), и чтобы сумма чисел в S' была равна сумме чисел в S . Как и в за­
даче о сумме подмножества, сертификат представляет собой подмножество множества S.
Чтобы показать, что задача о разбиении является NР-сложной, приведем к ней задачу
о сумме подмножества (вряд ли это решение показалось вам удивительным). Для входных
данных задачи, а именно - для заданного множества R положительных целых чисел и
целевого положительного целого числа 1, мы строим за полиномиальное время множе­
ство S, являющееся входными данными к задаче разбиения. Во-первых, вычислим сумму
z всех целых чисел в R. Мы предполагаем, что z 21 , потому что если это так, то задача
уже представляет собой задачу разбиения. (Если z = 21 , то I = z/2 , и мы пытаемся найти
подмножество R, сумма элементов которого та же, что и сумма элементов, не входящих в
него.) Затем выберем любое целое число у, большее, чем I + z и 2z. Определим множе­
ство S как содержащее все целые числа из R и два дополнительных целых числа у-1 и
у-z + t . Поскольку у больше, чем I + z и 2z , мы знаем, что и у-1 , и у - z + t больше z
(суммы всех чисел в R), так что таких чисел в R быть не может. (Вспомните, что поскольку
S представляет собой множество, все его элементы должны быть различными. Мы также
знаем, что, поскольку z 2t , должно выполняться неравенство у-t у-z + t , так что
два новых целых числа также уникальны.) Заметим, что сумма всех целых чисел в S равна
z+(y-t)+(y-z+t), т.е. просто 2у . Таким образом, если S разделить на два непере­
секающихся подмножества с равными суммами, сумма каждого из подмножеств должна
быть равна у.
Чтобы показать, что описанное приведение работает, нужно показать, что существует
подмножество R' множества R, целые числа которого дают в сумме I тогда и только тог­
да, когда существует разбиение множества S на подмножества S' и S w , такое, что сумма
чисел в S' совпадает с суммой чисел в
. Во-первых, давайте предположим, что не­
которое подмножество R' множества R имеет целые числа, сумма которых равна t. Тогда
сумма целых чисел из R, которые не входят в R' , должна быть равна z-t. Определим
w
множество S' как содержащее все целые числа из R' вместе с у-1 (так что s содер­
жит у- z + t вместе со всеми целыми числами из R, которые не входят в R' ). Нам просто
нужно показать, что целые числа в S' в сумме дают у. Но это легко: сумма целых чисел в
R' равна t, так что добавление у-1 дает сумму у.
И обратно, давайте предположим, что существует разбиение множества S на S' и
S w, суммы элементов которых равны у. Я утверждаю, что два целых числа, которые мы
добавили к множеству R при построении множества S (y-t и y-z+t) не могут одно­
временно находиться в одном подмножестве S' или
Почему? Если бы они оба были
в одном подмножестве, то сумма элементов этого подмножества была бы не менее чем
(y-t)+(y-z+t) = 2y-z. Но вспомним, что у больше z (на самом делеу больше 2z), а по­
тому 2у-z больше, чем у. Таким образом, если числа y-t и у-z + t находятся в одном
подмножестве, его сумма будет больше, чем у. Поэтому мы точно знаем, одно из чисел
у-1 и у - z + t находится в S' , а второе - в
. Не имеет значения, в каком именно под­
множестве находится у-1, так что пусть это будет подмножество S'. Мы знаем, что сумма
целых чисел, входящих в S', равна у, а это означает, что сумма целых чисел в S', отличных
от числа у-1, равна у-(у-1) = t. Поскольку число y-z+1 находиться в S' не может, все

*'

*'

*'

s•

s·.

s•

198

П1ава / О. Т рудная? Задача ...

числа в S', кроме y-t, входят в множество R. Следовательно, существует подмножество
R, сумма элементов которого равна t.
Рююак
В задаче о рююаке задано множество из п элементов, каждый из которых имеет свой
вес и цену, и требуется указать, существует ли такое подмножество элементов, что их
общий вес не превышает W, а их суммарная стоимость при этом не меньше V. Эта задача
представляет собой версию принятия решения задачи оптимизации, в которой требуется
загрузить рюкзак самым ценным подмножеством элементов, не превышающим предель­
ный вес. Эта задача оптимизации имеет очевидные приложения, такие как решение о том,
что следует взять с собой в поход или что должен выносить из обворованного дома гра­
битель.
Задача разбиения представляет собой частный случай задачи о рюкзаке, в котором цена
каждого элемента равна его весу, а W и V равны половине общего веса. Если бы мы могли
решить задачу о рюкзаке за полиномиальное время, то могли бы решить за полиномиаль­
ное время и задачу разбиения множества. Таким образом, задача о рюкзаке как минимум
так же сложна, как и задача о разбиении множества, и нам даже не нужно проходить через
полный процесс приведения, чтобы показать NР-полноту задачи о рюкзаке.

Общие стратегии
Как вы уже, вероятно, поняли к настоящему времени, не существует универсально­
го способа приведения одной задачи к другой с целью доказательства NР-сложности.
Некоторые приведения довольно просты, как приведение задачи о гамильтоновом цикле
к задаче коммивояжера, а некоторые чрезвычайно сложны. Вот несколько принципов и
стратегий, о которых следует помнить, так как они часто оказываются полезными.
Идти от общего к частному
При приведении задачи Х к задаче У вы всегда должны начинать с произвольных вход­
ных данных для задачи Х. Но входные данные задачи У вы можете ограничить так, как вам

нравится. Например, при приведении задачи 3-СNF-выполнимости к задаче о сумме под­
множества приведение в состоянии обработать любую 3-СNF-формулу в качестве входных
данных, но сгенерированные приведением входные данные для задачи о сумме подмно­
жества имеют определенную структуру, а именно - 2k + 2n целых чисел в множестве,
причем каждое целое число сформировано определенным образом. Приведение не в со­
стоянии сгенерировать каждые возможные входные данные для задачи о сумме подмно­
жества, но это и не нужно. Дело в том, что мы можем решить задачу 3-СNF-выполнимости
путем преобразования входных данных во входные данные для задачи о сумме подмно­
жества, а затем с помощью ответа на последнюю получить ответ и для задачи 3-СNF­
выполнимости.
Заметьте, однако, что каждое приведение должно иметь один и тот же вид: оно должно
преобразовывать любые входные данные задачи Х в некоторые входные данные задачи

Глава 10. ТруднОR? Задача...

199

У даже при объединении приведений в цепочку. Если вы хотите привести задачу Х к за­
даче У, а задачу У к задаче Z, то первое приведение должно превратить любые входные
данные задачи Х в некоторые входные данные У, а второе приведение должно превратить
любые входные данные задачи У в некоторые входные данные задачи Z. Если второе при­
ведение преобразует во входные данные для задачи Z только те входные данные, которые
генерируются первым приведением для задачи У из входных данных для задачи Х, этого
недостаточно.

Использовать преимущества ограничений приводимой задачи

В общем случае при приведении задачи Х к задаче У можно выбрать задачу Х так,
чтобы наложить дополнительные ограничения на входные данные. Например, почти всег­
да гораздо проще выполнить приведение задачи о 3-СNF-выполнимости, чем приводить
первичную задачу выполнимости булевых формул общего вида. Булевы формулы мoryr
быть произвольной сложности, но вы уже видели, как можно использовать при приведе­
нии стру ктуру 3-СNF-формул.
Кроме того, обычно более просто выполнять приведение задачи о гамильтоновом
цикле, чем приведение задачи о коммивояжере, даже несмотря на их сильную схожесть.
Дело в том, что в задаче коммивояжера веса ребер мoryr быть любыми положительными
числами, а не только нулем или единицей, как мы требуем при приведении к данной за­
даче. Задача о гамильтоновом цикле оказывается более ограниченной, потому что каждое
ребро может иметь только одно нз двух "значений": присутствует или отсутствует.

Рассмотрение частных случаев
Несколько NР-полных задач представляют собой всего лишь частные случаи других
NР-полных задач, как, например, задача разбиения является частным случаем задачи о
рюкзаке. Если вы знаете, что задача Х является NР-полной и что это частный случай за­
дачи У, то задача У также должна быть NР-полной. Дело в том, что, как мы видели в случае
задачи о рюкзаке, полиномиальное время решения задачи У автоматически даст решение
задачи Х за полиномиальное время. Интуитивно задача У, будучи более общей, чем задача
Х, не может быть проще последней.

Выбор подходящей задачи для приведения
Зачастую верной для доказательства NР-полноты оказывается стратегия выбора при­
водимой задачи из той же, или по крайней мере тесно связанной, предметной области.
Например, мы показали NР-полноту задачи вершинного покрытия (задачи, связанной с
графами) путем приведения к ней задачи о клике, также связанной с графами. Генеало­
гическое дерево NР-полных задач показывает, что далее выполняется приведение к за­
дачам о гамильтоновом цикле, гамильтоновом пути, о коммивояжере и о наидлнннейшем
ациклическом пути - все они представляют собой задачи на графах.
Однако иногда оказывается оправданным переход от одной предметной области к дру­
гой, например когда мы приводили задачу о 3-СNF-выполнимости к задаче о клике или

200

Глава /0. Трудная? Задача ...

к задаче о сумме подмножества. Когда приходится переходить от одной предметной обла­
сти к другой, задача о 3-СNF-выполнимости часто оказывается хорошим выбором.
Когда в задачах на графах требуется выбрать часть графа без учета упорядоченности,
хорошим стартом может оказаться задача о вершинном покрытии. Если важную роль
играет упорядочение, рассмотрите возможность воспользоваться задачами о гамильтоно­
вом цикле или гамильтоновом пути.

Увеличение мотивации
При преобразовании входного графа G задачи о rамильтоновом цикле во взвешен­
ный граф G' , выступающий в качестве входных данных для задачи коммивояжера, мы
в действительности хотели бы, чтобы при решении задачи коммивояжера выбор ребер
осуществлялся среди тех ребер, которые имеются в графе G. Чтобы мотивировать такой
выбор, мы придали этим ребрам очень низкий нулевой вес. Иными словами, использова­
ние этих ребер мы сделали выгодным.
Мы могли бы также дать ребрам из графа G некоторый конечный вес, а ребрам, в G
отсутствующим, - бесконечный, тем самым назначая "штраф" за использование ребер,
отсутствующих в G. Если бы мы приняли этот подход и назначили каждому ребру из G вес
W, то нам бы пришлось установить целевой вес k всего тура коммивояжера равным nW.
Разработка виджетов
Я не углубляюсь в эту тему, потому что виджеты могут быть очень сложными. Они
могут оказаться полезными для того, чтобы принудительного обеспечить определенные
свойства при построении приведения. Книги, приведенные в разделе "Дальнейшее чтение",
содержат множество примеров построения и использования виджетов в приведениях.

Перспективы
Я изобразил здесь довольно мрачную картину, не так ли? Представьте себе, как вы
тратите время, силы, нервы, пытаясь найти алгоритм с полиномиальным временем для
решения проблемы, но независимо от приложенных усилий, вы просто ничего не можете
сделать. Через некоторое время вы были бы счастливы, если бы могли найти алгоритм со
временем о( п5 ), несмотря на то что п5 - это ужасно быстрый рост. Может быть, эта
задача очень похожа на задачу, для которой вы знаете решение за полиномиальное время
(вспомните задачи о 2-CNF- и 3-СNF-выполнимости или эйлеров и гамильтонов циклы),
и вас ужасно расстраивает, что никак не получается адаптировать известный алгоритм с
полиномиальным временем работы для вашей задачи. В конце концов вы начинаете по­
дозревать, что, может быть - только может быть! - вы просто бьетесь головой о стену,
пытаясь решить NР-полную задачу? И вот, наконец, у вас получается привести к вашей
задаче какую-то из известных NР-полных задач, и теперь вы точно знаете, что ваша задача
NР-сложная.
Все, это конец? Нет никакой надежды, что вы сможете решить задачу за какое-то раз­
умное время?

Глава 10. Трудная? Задача...

201

Не совсем. Если задача NР-полная, это означает, что для некоторых входных данных
решать задачу очень трудно, но ведь это не значит, что плохими будут все входные данные.
Например, поиск наидлиннейшеrо ациклического пути в ориентированном графе является
NР-полной задачей, но если известно, что входной граф ацикличен, то найти наидлинней­
ший ациклический путь можно не просто за полиномиальное время, а за время О(п + т)
(если граф имеет п вершин и т ребер). Напомним, что мы решили именно эту задачу,
найдя критический путь в диаграмме PERT в mаве 5, "Ориентированные ациклические
графы". Еще один пример - если вы пытаетесь решить задачу разбиения множества це­
лых чисел, и при этом сумма всех чисел нечетна, то вы сразу можете сказать, что разбить
это множество на два с одинаковыми суммами элементов невозможно.
Хорошие новости выходят за рамки таких патологических частных случаев. Далее мы
сосредоточимся на задачах оптимизации, версии принятия решения которых являются
NР-полными задачами. таких как задача коммивояжера. Некоторые быстрые методы дают
хорошие, а часто и очень хорошие результаты. Метод итменw, с отсечением организу­
ет поиск оптимального решения в древовидной структуре и отсекает куски этого дерева,
убирая тем самым большие части пространства поиска. Метод основан на той простой
идее, что если можно определить, что все решения, исходящие из некоторого узла дерева
поиска, не могут оказаться лучше, чем наилучшее решение, найденное к настоящему мо­
менту, то этот узел со всеми исходящими из него ветвями можно просто отсечь.
Другой часто срабатывающий метод - поиск в окрестности, который получает не­
которое решение и пытается улучшить его с помощью некоторых локальных операций,
до тех пор, пока это возможно. Рассмотрим задачу коммивояжера, в которой все вершины
представляют собой точки на плоскости, а вес каждого ребра равен расстоянию между
соответствующими точками на плоскости. Даже с учетом этого ограничения задача оста­
ется NР-полной. Один из методов оптимизации решения состоит в том, чтобы всякий раз,
когда два ребра пересекаются, выполнять показанное ниже "переключение" путей, приво­
дящее к более короткому циклу.

Кроме того, множество приближенных алгоритмов дают результаты, которые бу­
дут отличаться от оптимального решения не более чем на гарантированный множитель.
Например, если входные данные для задачи коммивояжера подчиняются неравенству
треугольника (для всех вершин и, v и х вес ребра ( и, v) не превышает суммы весов ре­
бер (и,х) и (x,v)), то имеется простой приближенный алгоритм, который всегда нахо­
дит маршрут, общий вес которого не более чем в два раза превышает вес оптимального
маршрута, и при этом время его работы линейно зависит от размера входных данных.
Существует еще лучший приближенный ал.rоритм с полиномиальным временем работы
для описанной ситу ации, дающий маршрут, общий вес которого отличается от веса опти­
мального маршрута не более чем в 3/2 раза.

202

Глава /0. Трудная? Задача ...

Это может показаться странным, но если две NР-полные задачи достаточно тесно свя­
заны между собой, то решения, получаемые хорошим приближенным алгоритмом для
одной из них, для другой могут оказаться никуда не годными. То есть решение, которое
оказывается близким к оптимальному для одной из задач, необязательно отображается на
решение, сколь-нибудь близкое к оптимальному для другой задачи.
Тем не менее во многих реальных ситуациях близкое к оптимальному решение ока­
зывается достаточно хорошим. Возвращаясь к примеру с компанией по доставке товаров,
можно утверждать, что руководство этой компании будет радо найти почти оптимальные
маршруты для своих грузовиков, даже если эти маршруrы и не будут наилучшими. Ценен
каждый доллар, который они смогут сэкономить путем планирования маршрутов.

Неразрешимые задачи
Если вы решили, что NР-полные задачи - самые трудные в мире алгоритмов, вас ждет
очередное разочарование. Ученые-информатики определили большую иерархию классов
сложности, основанную на том, сколько времени и иных ресурсов необходимо для реше­
ния задачи. Некоторые задачи требуют для решения времени, доказуемо экспоненциально
зависящего от размера входных данных.
Но бывает и еще хуже. Для некоторых задач алгоритм решения существовать не может.
То есть имеются задачи, для которых доказательно невозможно создать алгоритм, который
всегда дает правильный ответ. Мы называем такие задачи нерtlЗрешимwми, и наиболее
известна среди них задача ocmaнOtla, неразрешимость которой доказана математиком
Аланом Тьюринrом (Alan Turing) в 1937 году. Входными данными задачи останова явля­
ется компьютерная программа А и ее входные данные х. Цель заключается в том, чтобы
определить, остановится ли когда-либо программа А при работе с входными данными х.
Другими словами, завершится ли когда-либо обработка программой А входных данных х?
Возможно, вы думаете, что могли бы написать программу - назовем ее программой
В, - которая считывает программу А, ее входные данные х и имитирует работу програм­
мы А с данными х. Да, это работает, если программа А при работе с входными данными
х в конечном итоге завершается. Но что делать, если это не так? Как программа В может
узнать, что следует объявить, что программа А никогда не остановится? Может ли про­
грамма В выяснить, не попала ли программа А в своего рода бесконечный цикл? Ответ
таков - хотя и можно написать программу В для проверки некоторых случаев, когда про­
грамма А не завершается, доказуемо невозможно написать программу В так, чтобы она
всегда останавливалась и верно сообщала о том, завершится ли программа А при входных
данныхх.
Поскольку невозможно написать программу, которая определяет, завершится ли другая
программа при работе с конкретными входными данными, невозможно также написать
программу, которая определяет, сооrветствует ли другая программа своей спецификации.
Как может программа сказать, даст ли другая программа верный ответ, если она не в со­
стоянии даже сказать, завершит ли та свою работу? Так что идеальное автоматизирован­
ное тестирование программного обеспечения, как видим, невозможно.

Глава 10. Трудная? Задача...

203

Чтобы вы не думали, что неразрешимые задачи связаны только со свойствами компью­
терных программ, задача coomt1emcmt1uя Поста (Post correspondence proЬ\em) связана со
строками. с которыми мы встречались в mаве 7, ''Алгоритмы на строках". Предположим,
что у нас есть по крайней мере два символа, и два списка из п строк. А и В, состоящих из
ЭТИХ символов. Пусть список А состоит из строк А,, А2 , Аз , ..., Ап, а список В - из строк
В,, В 2 , В3 , . . • , Вп. Задача заключается в выяснении, существует ли последовательность ин­
дексов i"i2 ,i3 , • • • ,i,,,, такая, что А;, А;, А;,···А;_ (то есть конкатенация строк А;,, А;,,А;,, ...,А1)
дает ту же строку, что и В;, В;,В;, ···В;_· Пусть, например, в роли символов выступают е, h,
m, n, о, r и у, что п = 5 и что
еу,

As

er,
то ,
on,
= h,

в,
В2
Вз

84

Bs

= ym,
= r,

oon,
е,
= hon.

Тогда одним из решений является последовательность индексов (5,4,1,3,4,2), поскольку
и AsA4 A1 A3A4 �, и В5 В4 В1 В3 В4 В2 образуют строку honeymooner. Конечно, если есть одно
решение, есть и бесконечное их количество, поскольку вы можете просто повторять по­
следовательность индексов (пОЛУ'fая honeymoonerhoneymooner и т.д.). Чтобы задача
соответствия Поста была неразрешимой, мы должны позволить использовать строки из
А и В несколько раз, так как в противном случае можно было бы просто перечислить все
возможные комбинации строк.
Хотя задача соответствия Поста может показаться не особенно интересной сама по
себе, ее можно привести к другим задачам, чтобы показать, что они тоже алгоритмически
неразрешимы. Это та же основная идея, которую мы использовали, чтобы показать, что
задача является NР-сложной: заданный экземпляр задачи соответствия Поста приводится
к экземпляру другой задачи Q, так что ответ на экземпляр задачи Q дает ответ на экзем­
пляр задачи соответствия Поста. Если мы могли бы решить задачу Q, то тем самым мы
могли бы решить и задачу соответствия Поста. Но поскольку мы знаем, что задача соот­
ветствия Поста неразрешима, то неразрешимой должна быть и задача Q.
Среди неразрешимых задач, к которым мы можем привести задачу соответствия
Поста, имеются несколько задач, связанных с контекстно-сt106однwми грамматика­
ми, которые описывают синтаксис большинства языков программирования. Контекстно­
свободная грамматика - это набор правил генерации формального Rзыка, который пред­
ставляет собой причудливый способ вывода "множества строк". Выполняя приведение
задачи соответствия Поста, можно доказать, что неразрешимыми являются такие задачи,
как выяснение, генерируют ли две контекстно-свободные грамматики один и тот же фор­
мальный язык или является ли данная контекстно-свободная неоднозначной, т.е. суще­
ствуют ли два различных способа генерации одной и той же строки с помощью правил
данной контекстно-свободной грамматики.

204

Глава / О. Трудная? Задача ...

Итоги
Мы встретили в книге широкий спектр алгоритмов из самых разных предметных об­
ластей. Мы видели алгоритм с сублинейным временем работы - бинарный поиск. Мы
видели алгоритмы с линейным временем работы - линейный поиск, сортировка под­
счетом, поразрядная сортировка, топологическая сортировка и поиск кратчайшего пути
в ориентированном ациклическом графе. Мы видели алгоритмы со временем работы
О( п lg п )- сортировка слиянием и быстрая сортировка (средний случай). Мы видели ал­
2
горитмы со временем работы
п ) - сортировка выбором, сортировка вставкой и бы­
страя сортировка (в наихудшем случае). Мы видели алгоритмы на графах, время работы
которых описывается некоторой нелинейной комбинацией числа п вершин и числа т ре­
бер, - алгоритм Дейкстры и алгоритм Беплмана-Форда. Мы видели алгоритм на графе
3
со временем работы
п )- алгоритм Флойда-Уоршелла. Наконец, теперь мы знаем, что
для некоторых задач неизвестно, имеется ли алгоритм их решения за полиномиальное
время работы. Более того, мы знаем, что для некоторых задач алгоритм решения просто не
существует, независимо от времени его работы.
Даже из этого относительно краткого введения в мир компьютерных алгоритмов 5 вид­
но, насколько широк охват этой предметной области. Эта книга охватывает лишь некото­
рые небольшие островки в безбрежном океане. Кроме того, я ограничил наш анализ кон­
кретной моделью вычислений, в которой операции выполняет только один процессор, а
время выполнения каждой операции является более или менее одинаковым независимо от
того, где в памяти компьютера располагаются данные. Имеется множество альтернатив­
ных вычислительных моделей -были предложены модели с несколькими процессорами;
модели, в которых время выполнения операции зависит от расположения данных; модели,
в которых данные поступают в виде однонаправленного неповторяющегося потока; моде­
ли, в которых компьютер представляет собой квантовое устройство.
Главное - вы теперь видите, что на карте этого безбрежного океана еще много белых
пятен, много вопросов без ответа, много вопросов, которые еще даже не заданы. Так что
у вас есть отличная возможность проявить себя, выбрав эту область знаний для изучения
и работы! Дерзайте!

о(

о(

Дальнейшее чтение
В первую очередь, это книга об NР-полноте Гари (Garey) и Джонсона (Johnson) [7].
Если вас интересует эта тема-прочтите ее. В CLRS [4] имеется посвященная NР-полноте
глава, в которой гораздо больше технических деталей, чем в этой книге; кроме того, в ней
также есть глава о приближенных алгоритмах. Более подробно о вычислимости и слож­
ности, а также (кратко и понятно) о задаче останова можно прочесть в книге Сипсера
(Sipser) [ 19].

' Сравните эту ю1игу с CLRS - более 1300 страниц в третьем издании.

Библиография
1.
2.
3.
4.

5.

Alfred У. Aho, John Е. Hopcroft, and Jeffrey D. Ullman. The Design and Ana/ysis of

Computer Algorithms. Addison-Wesley, 1974.

Ravindra К. Ahuja, Kurt Meh\hom, James В. Orlin, and Robert Е. Tarjan. Faster algorithms
for the shortest path proЫem. Journal ofthe АСМ, 37(2):213-223, 1990.
Thomas Н. Cormen, Charles Е. Leiserson, and Ronald L. Rivest. Introduction to

Algorithms. The МIТ Press, first edition, 1990.

Thomas Н. Cormen, Charles Е. Leiserson, Ronald L. Rivest, and Clifford Stein.
Introduction to Algorithms. The МIТ Press, third edition, 2009.
Имеется перевод на русский язык: Кормен Т., Лейзесон Ч., Ривест Р., Штайн К.
Алгоритмы: построение и анализ, 3-е издание. - М.: ООО "И.Д. Вильяме", 2013.
Whitfield Diffie and Martin Е. Hellman. New directions in cryptography. IEEE Transactions

оп lnformation Theory, IТ-22(6):644-654, 1976.

6.

Annex С: Approved random numЬer generators for FIPS PUB 140-2, Security
requirements for cryptographic modules. http://csrc.nist.gov/ puЫications/fips/fips140-2/
fips l 402annexc.pdf, July 2011. Draft.

7.

Michael R. Garey and David S. Johnson. Computers and Jntractahility: А Guide to the
TheoryofNP-Completeness. W. Н. Freeman, 1979.

8.

David Gries. The Science of Programming. Springer, 1981.

9.

Jonathan Katz and Yehuda Lindell. Introduction to Modern Cryptography. Chapman &
Ha\VCRC, 2008.

1О. Donald Е. Кnuth. The Art о/Computer Programming, Yolume 1: Fundamental Algorithms.
Addison-Wesley, third edition, 1997.
Имеется перевод на русский язык: Кнут Д. Искусство программирования, т. I.
Основные алгоритмы, 3-е изд. - М.: ООО "И.Д. Вильяме", 2000.
11. Donald Е. Кnuth. The Art о/Computer Programming, Yolume 2: Seminumeral Algorithms.
Addison-Wes\ey, third edition, 1998.
Имеется перевод на русский язык: Кнут Д. Искусство программирования, т. 2.
Получисленные алгоритмы. 3-е изд. - М.: ООО "И.Д. Вильяме", 2000.
12. Donald Е. Knuth. The Art o/Computer Programming, Yolume 3: Sorting and Searching.
Addison-Wesley, second edition, 1998.
Имеется перевод на русский язык: Кнут Д. Искусство программирования, т. 3.
Сортировка и поиск, 2-е изд. - М.: ООО "И.Д. Вильяме", 2000.
13. Donald Е. Knuth. The Art of Computer Programming, Yolume 4А: Combinatorial
Algorithms, Part 1. Addison-Wesley, 2011.
Имеется перевод на русский язык: Кнут Д. Искусство программирования, т. 4,А.
Комбинаторные алгоритмы, часть 1. - М.: ООО "И.Д. Вильяме", 2013.

206

Библиография

14. John MacConnick. Nine Algorithms That Changed the Future: The lngenious Jdeas That
Drive Today's Computers. Princeton University Press, 2012.
15. John С. Mitchell. Foundationsfor Programming Languages. TheMIТ Press, 1996.
16. Alfred Menezes, Paul van Oorschot, and Scott Vanstone. Handbook о/ Applied Cryp­
tography. CRC Press, 1996.
17. Ronald L. Rivest, Adi Shamir, and Leonard М. Adleman. А method for obtaining digital
signatures and puЫic-key cryptosystems. Communications о/ the АСМ, 21(2):120-126,
1978. See also U.S. Patent 4,405,829.
18. David Salomon. А Concise Introduction to Data Compression. Springer, 2008.
19. Michael Sipser. Introduction to the Theory о/ Computation. Course Technology, second
edition, 2006.
20. Sean Smith and John Marchesini. The Craft o/System Security. Addison-Wesley, 2008.
21. James А. Storer. Data Compression: Methods and Theory. Computer Science Press, 1988.
22. Greg Taylor and George Сох. Digital randomness. IEEE Spectrum, 48(9):32-58, 2011.

Предметный указатель
L

LIFO 84
р
PERT 88
А
АбстраКПlый тип данных 102
Абстракция 102
Алгоритм 15
беллмана-форда 106
времJ1 работы /09
время работы /7, 29
дейкстры 98
BpeМJI работы /02
детерминистический 66
eBКIIIWI /50
жадный 163
компьютерный 15
корректность 16
описание 23
приближенный /7, 201
псевдокод 23
рандомизнрованный 66
с полиномиальным временем
работы /77
флойда-уоршелла 11/
эффективность 17
Арифметическая проrрессня 45,
49
Асимптотические обозначения

30,32

Б
Бинарна,� пирамида. См. Пира­
мида бниарнu
Бинарное дерево. См. Дерево
бинарное
Бинарный поиск 39
Бит 141
Быстрая сортировка. См. Сорти­
ровка быстрu

в

Вершина 82
входщая степень 83
исходная nyrn 92
исход,1щая степень 83
целевая пути 92
Вершинное покрытие 188
Вычислительнаи задача 15

г

Генератор псевдослучайных
чисел 154

Граф
вершина 82
вершинное покрытие 188
клика 186
неориентированный 177
ориентированный 82
ациклический 82
взвешенный 90
представление 85
плотный 105
rюлный 192
путь 89
вес 90
кратчайший 91, 92
разреженный 105
ребро 82
ребровес 90
реброос11абление 93
связный /77
ЦИКЛ 89

д

Дерево
бинарное /04
Диаграмма PERT 88
Динамическое программирова­
ние 116, 126
оптимальная подструктура 116

з

Задача
3-СNF-выполнимости 185
NР-полная 176, 179
NР-сложная 179
коммивояжера /76, 192
неразрешимая 202
о вершинном покрытии 188
о выполнимости булевой форму­
лы 184
о клике /86
о наидлиннейшем ациклическом
пути 192
о разбиении 196
о рюкзаке 198
останова 202
о сумме подмножества /93
принятия решения 179
соответствия поста 203

и

Избыточность 158
ИнвариаliТ цикла 32
Индекс 14
ИнкремеliТ 26
Итерация 26

к

Класс
классNР /79
классР 178, 179
Клика 186
Ключ 37,38
открьrтый /44
секретный /44
Конечный автомат 132
состояние 132
таблица переходов /33
Конкатенация 135
Контекстно-свободна,� граммати­
ка 203
Контрапознция 33
КриnтОfl)афия 139
RSA /46
гибридные системы 154
ключ 140
с открытым ключом 144
текст 140
шифровка 140
Критический путь 89

л

Лексикографический порядок 37
Линейный поиск 25
рекурсивный 3 5
Лист /04
Луч 173

м

Массив 24
Матрица
смежности 85
Медиана 64
Модульнаи арифметика 146

н

Нижняя граница
универсальная 7/
экзистенциальная 71

о

Оfl)аничитель 28
Оптимальна,� подструк,ура 116
Ориентированное ребро 82
Ориентированный fl)aф. См. Граф
ориентированный
Открытый ключ /44
Очередь
с приоритетами /02

п

Параметр 24
Переменная 26

208

Предметный указатель

Перестановка 43
Пирамида
бниарн3JI /04
высота 104
свойство /04
фнбоиаччнева 106
Подпоследовательность 119
общu 119
Подстрока 120
Поиск
бинарный 39
КJJЮЧ 37
кратчайшего пути
между всеми парами вершин //О
между парой вершин 97
линейный 25
нанд11нннейшей общей подпосле­
довательности 122
подстрок /3 /
Пол 40
Последовательность 119
Префикс /20
Приведение задач /80
Присваивание 26
Простое число /47
взаимно простые числа /48
Процедура 23
AssemЬJe-LCS /23
AssemЫe-Transfonnation / 30
Вetter-Linear-Search 27
Binary-Search 41
Build-Huffinan-Tree / 62
Compute-LCS-TaЫe 122
Compute-Transfonn-TaЫes I 28
Counting-Son 75
Count-Keys-Equal 71
Count-Keys-Less 72
Dag-Shortest-Paths 94
Dijkstra /00. I 03
Euclid 150
Factorial 34
FA-String-Matcher 134
Find-Negative-Weight-Cycle /08
Floyd-Warshall /14
Heapsort /05
lnsertion-Sort 47
Linear-Search 25
LZW-Compressor 168
LZW-Decompressor 172
Merge 56
Merge-Sort 51
Modular-Exponentiation /52
Partition 62
Quicksort 60
Rearrange 73
Recursive-Binary-Search 42
Recursive-Linear-Search 35

Relax 93
Selection-Son 43, 44
Sentinel-Linear-Search 28
Topological-Sort 84
возврат эначенНJ1 24
вызов 23
параметры 24
Псевдокод 23

Путь 89

вес 90
кратчайший 91, 92
поиск 93
поиска вpet.U работы 95
критнческнii 89

р
Разделяй и властвуii 50
Рандомиэацня 64
Рекуррентность 58
Рекурсия 34
базовый случай 34

с

Связанный список 86
Сдвиг /3/
Секретный ключ 144
Сертификат 179
Сжатие / 5 7
LZW 167
RLE 164
без потерь /5 7
кодирование длин серий /64
код хаффмана 158
адаптивный 163
префнксно-<:вободный J<Dд 159
с потер11мн /57
Скорость роста 18
Слот 39
Сопутствующие данные 38
Сортировка 38
быстр3JI 58
вpet.U работы 63, 65
опорный ЭJ1емеит 59
разбиение 5 9
вставкоii 46
время работы 48, 65
инвариант цикла 48
выбором 43
время работы 45, 65
ннвариаит цикла 44
ключ 38
пирамидальная 105
подсчетом 7/, 75
время работы 76
поразр11ДНЗJ1 77, 78
время работы 78
СЛНJIНИем 50
врем• работы 57, 65
сравнением 70

тополоrнчесК3JI 82
врем11 работы 87
устоЙЧНВ3JI 76
Список
двусмзный 87
ОДНОС8113НЫЙ 87
С81133ННЫЙ 86
смежности 85
Стек 84
Строка 119
конкатенация 135
поиск подстрок 13 /
преобразование / 24
префикс 120
суффикс /35
Структура данных /03
Суффикс 135
Теорема
мал3JI ферма /50
о простых числах 149
ТополоrнчесКЗJ1 сортировка. См. Сортировка тополо­
rичесk3JI

т

Транзитивность 79

у
Узел /04
дочерннii 104
родительский /04
Уравнение
рекуррентное 58
УстойчИВЗJI сортировка. См. Со­
ртировка устойчивая
ф

С!>акторнал 34,140,175
С!>ормальный 11зык 203
Хеш-таблица /73

ц

Цикл 26
инвариант 32
итерацн11 26
переменная 26
тело 26

ш

Шифр /40
RSA 146
блочныii /43
одноразовый блокнот 141, /42
простой подстановочный 140
сдвиговый 140
с открытым КJJЮЧОМ 144
цепочки блоков 143

ема. (И кроме
того, оно обладает таким преимуществом, как краткость.)

1.3. Вход в систему
Имя пользователя
При входе в  систему UNIX мы вводим имя пользователя и  пароль. После этого система отыскивает введенное имя в  файле паролей; обычно это файл /etc/
passwd. Файл паролей содержит записи, состоящие из семи полей, разделенных
двоеточием: имя пользователя, зашифрованный пароль, числовой идентификатор
пользователя (205), числовой идентификатор группы (105), поле комментария,
домашний каталог (/home/sar) и командный интерпретатор (/bin/ksh).
sar:x:205:105:Stephen Rago:/home/sar:/bin/ksh

Все современные системы хранят пароли в отдельном файле. В главе 6 мы рассмотрим эти файлы и некоторые функции доступа к ним.

36    Глава 1. Обзор ОС UNIX

Командные оболочки
Обычно после входа в систему на экран выводится некоторая системная информация, после чего можно вводить команды, предназначенные для командной
оболочки. (В некоторых системах после ввода имени пользователя и пароля запускается графический интерфейс, но и в этом случае, как правило, можно получить доступ к командной оболочке, запустив командный интерпретатор в одном
из окон.) Командная оболочка — это интерпретатор командной строки, который
читает ввод пользователя и выполняет команды. Ввод пользователя обычно считывается из терминала (интерактивная командная оболочка) или из файла (который называется сценарием командной оболочки). В табл. 1.1 перечислены наиболее
распространенные командные оболочки.
Таблица 1.1. Наиболее распространенные командные оболочки, используемые в UNIX
Название

Путь

FreeBSD 8.0

Linux 3.2.0

Mac OS X 10.6.8

Solaris 10





копия bash



Bourne shell

/bin/sh

Bourne-again
shell

/bin/bash

необязательно







C shell

/bin/csh

ссылка
на tcsh

необязательно

ссылка
на tcsh



Korn shell

/bin/ksh

необязательно

необязательно

TENEX C shell

/bin/tcsh



необязательно






Информацию о том, какой командный интерпретатор следует запустить, система
извлекает из записи в файле паролей.
Командный интерпретатор Bourne shell был разработан в Bell Labs Стивом Борном (Steve Bourne). Он входит в состав практически всех существующих версий
UNIX, начиная с Version 7. Управляющие конструкции в Bourne shell чем-то напоминают язык программирования Algol 68.
Командный интерпретатор C shell был разработан в Беркли Биллом Джоем (Bill
Joy) и  входит в  состав всех версий BSD. Кроме того, C shell включен в  состав
System V/386 Release 3.2 от AT&T, а также в System V Release 4 (SVR4). (В следующей главе мы расскажем об этих версиях UNIX подробнее.) Командная оболочка C shell разработана на основе оболочки 6-й редакции UNIX, а не Bourne shell.
Управляющие конструкции этого интерпретатора напоминают язык программирования C, и  кроме того, он поддерживает дополнительные особенности, отсутствующие в Bourne shell: управление заданиями, историю команд и возможность
редактирования командной строки.
Командный интерпретатор Korn shell можно считать наследником Bourne shell.
Он впервые появился в составе SVR4. Разработанный в Bell Labs Дэвидом Корном (David Korn), он может работать в большинстве версий UNIX, но до выхода
SVR4 обычно распространялся как дополнение за отдельную плату и поэтому не
получил такого широкого распространения, как предыдущие два интерпретатора.

1.4. Файлы и каталоги   

37

Сохраняет обратную совместимость с Bourne shell и предоставляет те же возможности, благодаря которым C shell стал таким популярным: управление заданиями,
возможность редактирования командной строки и пр.
Bourne-again shell — командный интерпретатор GNU, входящий в состав всех версий ОС Linux. Был разработан в соответствии со стандартом POSIX и в то же время сохраняет совместимость с  Bourne shell, а  также поддерживает особенности,
присущие C shell и Korn shell.
Командный интерпретатор TENEX C shell — это расширенная версия C shell. Заимствовал некоторые особенности, такие как автодополнение команд, из ОС TENEX,
разработанной в 1972 году в компании Bolt Beranek and Newman. TENEX C shell
расширяет возможности C shell и часто используется в качестве его замены.
Стандарт POSIX 1003.2 определяет перечень возможностей, которыми должен
обладать командный интерпретатор. Эта спецификация была основана на особенностях Korn shell и Bourne shell.
В разных дистрибутивах Linux по умолчанию используются разные командные интерпретаторы. В одних по умолчанию используется командный интерпретатор Bourne-again,
в других — BSD-версия Bourne shell — dash (Debian Almquist shell, первоначально написан
Кеннетом Альмквистом (Kenneth Almquist) и затем перенесен в Linux). В системах FreeBSD
по умолчанию используется производная от Almquist shell. В Mac OS X — Bourne-again
shell. Операционная система Solaris унаследовала от BSD и System V все командные интерпретаторы, перечисленные в табл. 1.1. Свободно распространяемые версии большинства
командных интерпретаторов можно найти в Интернете.
На протяжении всей книги в подобных примечаниях мы будем приводить исторические
заметки и  сравнения различных реализаций UNIX. Зачастую обоснования отдельных
методов реализации становятся гораздо понятнее в историческом контексте.

В тексте книги приводятся многочисленные примеры взаимодействия с командным интерпретатором, демонстрирующие запуск разрабатываемых нами программ. В этих примерах используются возможности, общие для Bourne shell, Korn
shell и Bourne-again shell.

1.4. Файлы и каталоги
Файловая система
Файловая система UNIX имеет иерархическую древовидную структуру, состоящую из каталогов и файлов. Начинается она с корневого каталога, имеющего имя
из единственного символа /.
Каталог — это файл, содержащий каталожные записи. Логически каждую такую
запись можно представить в виде структуры, состоящей из имени файла и дополнительной информации, описывающей атрибуты файла. К атрибутам относятся
такие характеристики, как тип файла (обычный файл или каталог), размер, владелец, разрешения (доступность файла для других пользователей), время последнего изменения. Функции stat и  fstat возвращают структуру с  информацией
обо всех атрибутах файла. В главе 4 мы исследуем атрибуты файла более детально.

38    Глава 1. Обзор ОС UNIX
Мы различаем логическое представление каталожной записи и фактический способ хранения этой информации на диске. Большинство реализаций файловых систем для UNIX
не хранят атрибуты в каталожных записях из-за сложностей, связанных с их синхронизацией при наличии нескольких жестких ссылок на файл. Это станет понятным, когда
мы будем обсуждать жесткие ссылки в главе 4.

Имя файла
Имена элементов каталога называются именами файлов (filenames). Только два
символа не могут встречаться в именах файлов — прямой слеш (/) и нулевой символ (\0). Символ слеша разделяет компоненты, образующие строку пути к файлу
(описывается ниже), а нулевой символ обозначает конец этой строки. Однако на
практике, выбирая имена для файлов, лучше ограничиться подмножеством обычных печатных символов. (Мы ограничиваем набор допустимых символов, потому что некоторые специальные символы имеют особое значение для командного
интерпретатора и при их использовании в именах файлов нам пришлось бы применять экранирование, а это влечет дополнительные сложности.) В действительности для совместимости стандарт POSIX.1 рекомендует использовать в именах
файлов только следующие символы: буквы (a-z, A-Z), цифры (0-9), точку (.), дефис (-) и подчеркивание (_).
Всякий раз, когда создается новый каталог, в  нем автоматически создаются две
записи: . (точка) и .. (точка-точка). Записи «точка» соответствует текущий каталог, а записи «точка-точка» — родительский. В корневом каталоге запись «точка-точка» представляет тот же каталог, что и «точка».
В Research UNIX System и некоторых устаревших версиях UNIX System V длина имени
файла ограничена 14 символами. В версиях BSD этот предел увеличен до 255 символов.
Сегодня практически все файловые системы коммерческих версий UNIX поддерживают
имена файлов с длиной не менее 255 символов.

Путь к файлу
Последовательность из одного или более имен файлов, разделенных слешем, образует строку пути к файлу. Эта строка может также начинаться с символа слеша,
и тогда она называется строкой абсолютного пути, иначе — строкой относительного пути. Относительные пути начинаются от текущего каталога. Имя корня
файловой системы (/) — особый случай строки абсолютного пути, которая не содержит ни одного имени файла.

Пример
Вывести список всех файлов в каталоге достаточно просто. Вот пример упрощенной реализации команды ls(1).
Листинг 1.1. Вывод списка всех файлов в каталоге
#include "apue.h"
#include <dirent.h>
int

1.4. Файлы и каталоги   

39

main(int argc, char *argv[])
{
DIR
*dp;
struct dirent
*dirp;
if (argc != 2)
err_quit("Использование: ls имя_каталога");
if ((dp = opendir(argv[1])) == NULL)
err_sys("невозможно открыть %s", argv[1]);
while ((dirp = readdir(dp)) != NULL)
printf("%s\n", dirp->d_name);
closedir(dp);
exit(0);

}

Нотация ls(1) — обычный способ ссылки на определенную страницу справочного руководства UNIX. В данном случае она ссылается на страницу с описанием
коман­ды ls в первом разделе. Разделы справочного руководства обычно нумеруются цифрами от 1 до 8, а страницы в каждом разделе отсортированы по алфавиту.
Здесь и далее мы будем исходить из предположения, что у вас под рукой имеется
текст справочного руководства по вашей версии UNIX.
Исторически сложилось так, что все восемь разделов были объединены в документ, который называется «UNIX Programmer’s Manual» (Руководство программиста UNIX). Но
поскольку количество страниц в руководстве постоянно растет, появилась тенденция
к распределению разделов по отдельным руководствам: например, одно для пользователей,
одно для программистов и одно для системных администраторов.
В некоторых версиях UNIX разделы справочного руководства делятся на подразделы,
обозначенные заглавными буквами. Так, описания всех стандартных функций ввода/вывода в AT&T [1990e] находятся в разделе 3S, например fopen(3S). В некоторых системах
в обозначениях разделов цифры заменены алфавитными символами, например «C» — для
раздела с описаниями команд.

В наши дни большинство руководств распространяется в электронном виде. Если
вы располагаете такой версией справочного руководства, просмотреть справку по
команде ls можно так:
man 1 ls

или
man -sl ls

Программа в листинге 1.1 просто выводит список файлов в  указанном каталоге
и  ничего больше. Назовем файл с  исходным кодом myls.c и  скомпилируем его
в исполняемый файл с именем по умолчанию a.out:
cc myls.c

Исторически команда cc(1) запускает компилятор языка C. В системах, где используется компилятор GNU C, выполняемый файл компилятора носит имя gcc(1). В этих
системах команда cc часто является ссылкой на gcc.

40    Глава 1. Обзор ОС UNIX
Примерный результат работы нашей программы:
$ ./a.out /dev
.
..
cdrom
stderr
stdout
stdin
fd
sda4
sda3
sda2
sda1
sda
tty2
tty1
console
tty
zero
null

и еще много строк...
mem
$ ./a.out /etc/ssl/private
невозможно открыть /etc/ssl/private: Permission denied
$ ./a.out /dev/tty
невозможно открыть /dev/tty: Not a directory

Далее в книге запуск программ и результаты их работы демонстрируются именно так: символы, вводимые с клавиатуры, выделяются жирным моноширинным шрифтом, а результат выполнения — обычным моноширинным шрифтом. Комментарии среди
строк, выводимых в терминал, будут оформляться курсивом. Знак доллара, предшествующий вводимым с клавиатуры символам, — это приглашение командного
интерпретатора. Мы всегда будем отображать приглашение в виде символа доллара.
Обратите внимание, что полученный список файлов не отсортирован по алфавиту. Команда ls сортирует имена файлов перед выводом.
Рассмотрим детальнее эту программу из 20 строк.
 В первой строке подключается наш собственный заголовочный файл apue.h.
Мы будем использовать его почти во всех программах в этой книге. Этот заголовочный файл, в свою очередь, подключает некоторые стандартные заголовочные файлы и определяет множество констант и прототипов функций, которые будут встречаться в наших примерах. Листинг этого файла вы найдете
в приложении B.
 Далее подключается системный заголовочный файл dirent.h, чтобы добавить объявления прототипов функций opendir и readdir, а также определение
структуры dirent. В  некоторых системах определения разбиты на несколько
заголовочных файлов. Например, в  дистрибутиве Linux Ubuntu 12.04 файл
/usr/include/dirent.h объявляет прототипы функций и  подключает файл
bits/dirent.h с определением структуры dirent (и фактически хранится в каталоге /usr/include/x86_64-linux-gnu/bits).

1.4. Файлы и каталоги   

41

 Функция main объявлена в соответствии со стандартом ISO C. (Более подробно об этом стандарте рассказывается в следующей главе.)
 В ней мы принимаем аргумент командной строки argv[1] — имя каталога, для
которого требуется получить список файлов. В главе 7 мы увидим, как вызывается функция main и как программа получает доступ к аргументам командной
строки и переменным окружения.
 Поскольку на практике в разных системах используется разный формат запи­
сей в  каталогах, для получения информации мы использовали стандартные
функции opendir, readdir и closedir.
 Функция opendir возвращает указатель на структуру DIR, который затем передается функции readdir. (Нас пока не интересует содержимое структуры DIR.)
Затем в цикле вызывается функция readdir, которая читает очередную запись
и  возвращает указатель на структуру dirent или пустой указатель, если все
запи­си были прочитаны. Все, что нам сейчас нужно в структуре dirent, — это
имя файла (d_name). Это имя можно передать функции stat (раздел 4.2), чтобы
определить атрибуты файла.
 Для обработки ошибочных ситуаций вызываются наши собственные функции:
err_sys и err_quit. Функция err_sys в предыдущем примере выводит сообщение, описывающее возникшую ошибку («Permission denied» — «Доступ запрещен» или «Not a directory» — «Не является каталогом»). Исходный код этих
функций и их описание приводятся в приложении B. В разделе 1.7 мы еще поговорим об обработке ошибок.
 В конце программы вызывается функция exit с аргументом 0. Она завершает
выполнение программы. В соответствии с соглашениями 0 означает нормальное завершение программы, а значения в диапазоне от 1 до 255 свидетельствуют о наличии ошибки. В разделе 8.5 мы покажем, как любая программа, в том
числе и наша, может получить код завершения другой программы.

Рабочий каталог
У каждого процесса имеется свой рабочий каталог, который иногда называют текущим рабочим каталогом. Это каталог, от которого откладываются все относительные пути, используемые в программе. Процесс может изменить свой рабочий
каталог вызовом функции chdir.
Например, относительный путь к файлу doc/memo/joe означает, что файл или каталог joe находится в каталоге memo, который находится в каталоге doc, который
в свою очередь должен находиться в рабочем каталоге. Встретив такой путь, мы
можем точно сказать, что doc и memo — это каталоги, но не можем утверждать, является joe каталогом или файлом. Путь /usr/lib/lint  — это абсолютный путь
к файлу или каталогу lint в каталоге lib, находящемся в каталоге usr, который
в свою очередь находится в корневом каталоге.

Домашний каталог
Когда пользователь входит в  систему, рабочим каталогом становится его домашний каталог. Домашний каталог пользователя определяется в  соответствии
с записью в файле паролей (раздел 1.3).

42    Глава 1. Обзор ОС UNIX

1.5. Ввод и вывод
Дескрипторы файлов
Дескрипторы файлов — это, как правило, небольшие целые положительные числа, используемые ядром для идентификации файлов, к которым обращается конкретный процесс. Всякий раз, когда процесс открывает существующий или создает новый файл, ядро возвращает его дескриптор, который затем используется для
выполнения операций чтения/записи с файлом.

Стандартный ввод, стандартный вывод,
стандартный вывод ошибок
По соглашению, все командные оболочки при запуске новой программы открывают для нее три файловых дескриптора: стандартного ввода, стандартного вывода
и стандартного вывода ошибок. За исключением особых случаев, все три дескриптора по умолчанию связаны с терминалом, как в простой команде
ls

Большинство командных оболочек дает возможность перенаправить любой из
этих дескрипторов в любой файл. Например
ls > file.list

выполнит команду ls и перенаправит стандартный вывод в файл с именем file.
list.

Небуферизованный ввод/вывод
Небуферизованный ввод/вывод осуществляется функциями open, read, write,
lseek и close. Все эти функции работают с дескрипторами файлов.

Пример
В листинге 1.2 приводится пример программы, которая читает данные из стандартного ввода и копирует их в стандартный вывод. С ее помощью можно выполнять копирование любых обычных файлов.
Листинг 1.2. Копирование со стандартного ввода на стандартный вывод
#include "apue.h"
#define BUFFSIZE 4096
int
main(void)
{
int
n;
char buf[BUFFSIZE];
while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
if (write(STDOUT_FILENO, buf, n) != n)
err_sys("ошибка записи");
if (n < 0)

1.5. Ввод и вывод   

43

err_sys("ошибка чтения");
}

exit(0);

Заголовочный файл <unistd.h>, подключаемый в  apue.h, и  константы STDIN_
FILENO и  STDOUT_FILENO являются частью стандарта POSIX (о котором мы будем
много говорить в следующей главе). В этом файле объявлены прототипы функций
для доступа к системным службам UNIX, в том числе к функциям read и  write,
используемым в этом примере.
Константы STDIN_FILENO и  STDOUT_FILENO, объявленные в  файле <unistd.h>, соответствуют дескрипторам файлов стандартного ввода и  стандартного вывода.
Обычные значения этих констант — соответственно 0 и 1, как определено стандартом POSIX.1, но мы будем пользоваться именованными константами для большей удобочитаемости.
Константу BUFFSIZE мы детально исследуем в разделе 3.9, где увидим, как различные значения могут влиять на производительность программы. Однако независимо от значения этой константы наша программа будет в состоянии выполнять
копирование файла.
Функция read возвращает количество прочитанных байтов. Это число затем
передается функции write, чтобы сообщить ей, сколько байтов нужно записать.
Достигнув конца файла, функция read вернет 0 и  программа завершится. Если
в  процессе чтения возникнет ошибка, read вернет –1. Большинство системных
функций в случае ошибки возвращают –1.
Если скомпилировать программу в выполняемый файл с именем по умолчанию
(a.out) и запустить ее:
./a.out > data

стандартный вывод будет перенаправлен в  файл data, а  стандартным вводом
и стандартным выводом сообщений об ошибках будет терминал. Если выходной
файл не существует, командная оболочка создаст его. Программа будет копировать строки, вводимые с клавиатуры, в стандартный вывод до тех пор, пока мы не
введем символ «конец-файла» (обычно Control-D).
Если запустить программу так:
./a.out < infile > outfile

она скопирует файл infile в файл outfile.
Более подробно функции небуферизованного ввода/вывода будут описаны в главе 3.

Стандартные функции ввода/вывода
Стандартные функции ввода/вывода предоставляют буферизованный интерфейс
к функциям небуферизованного ввода/вывода. Использование стандартных функций ввода/вывода избавляет от необходимости задумываться о выборе оптимального размера буфера, например о значении константы BUFFSIZE в листинге 1.2. Другое
преимущество стандартных функций ввода/вывода — они значительно упрощают

44    Глава 1. Обзор ОС UNIX
обработку пользовательского ввода (что на каждом шагу встречается в прикладных
программах UNIX). Например, функция fgets читает из файла строку целиком,
в  то время как функция read считывает указанное количество байтов. Как будет
показано в разделе 5.4, стандартная библиотека ввода/вывода включает функции,
с помощью которых можно управлять типом буферизации.
Самой известной стандартной функцией ввода/вывода является printf. В  программах, вызывающих ее, обязательно должен быть подключен заголовочный
файл <stdio.h> (мы всегда делаем это через подключение файла apue.h), определяющий прототипы всех стандартных функций ввода/вывода.

Пример
Программа в листинге 1.3 (более детально исследуется в разделе 5.8) подобна программе из предыдущего примера, использующей функции read и write. Она также
копирует данные, полученные со стандартного ввода, в стандартный вывод и может выполнять копирование обычных файлов.
Листинг 1.3. Копирование стандартного ввода в стандартный вывод
с использованием стандартных функций ввода/вывода
#include "apue.h"
int
main(void)
{
int
c;
while ((c = getc(stdin)) != EOF)
if (putc(c, stdout) == EOF)
err_sys("ошибка вывода");
if (ferror(stdin))
err_sys("ошибка ввода");
}

exit(0);

Функция getc читает один символ, который затем записывается вызовом функции putc. Прочитав последний байт, getc вернет признак конца файла — константу EOF (определена в  <stdio.h>). Константы stdin и  stdout также определены
в <stdio.h> и обозначают стандартный ввод и стандартный вывод.

1.6. Программы и процессы
Программа
Программа — это выполняемый файл, хранящийся на диске. Программа загружается в память и передается ядру для выполнения вызовом одной из шести функций семейства exec. Мы рассмотрим эти функции в разделе 8.10.

Процессы и идентификаторы процессов
Выполняющая программа называется процессом. Этот термин будет встречаться
практически на каждой странице этой книги. В некоторых операционных систе-

1.6. Программы и процессы   

45

мах для обозначения выполняемой в  данный момент программы используется
термин задача.
UNIX присваивает каждому процессу уникальный числовой идентификатор, который называется идентификатором процесса (process ID, или PID). Идентификатор процесса — всегда целое неотрицательное число.

Пример
Программа в листинге 1.4 выводит собственный идентификатор процесса.
Листинг 1.4. Вывод идентификатора процесса
#include "apue.h"
int
main(void)
{
printf("привет от процесса с идентификатором %d\n", (long)getpid());
exit(0);
}

Если скомпилировать эту программу в файл a.out и запустить, она выведет примерно следующее:
$ ./a.out
привет от процесса с идентификатором 851
$ ./a.out
привет от процесса с идентификатором 854

После запуска эта программа вызовет getpid, чтобы получить идентификатор своего процесса. Как будет показано ниже, getpid возвращает значение типа pid_t. Его
размер нам неизвестен, зато известно, что в соответствии с требованиями стандартов оно должно умещаться в длинное целое. Поскольку мы должны сообщить функции printf размер каждого аргумента, мы выполняем приведение типа фактического значения к более широкому типу (в данном случае к длинному целому). Хотя
в большинстве систем значение идентификатора процесса укладывается в тип int,
использование типа long обеспечивает дополнительную переносимость.

Управление процессами
За управление процессами отвечают три основные функции: fork, exec и waitpid.
(Функция exec имеет шесть разновидностей, но мы часто будем ссылаться на них
просто как на функцию exec.)

Пример
Особенности управления процессами в UNIX демонстрирует простая программа
(листинг 1.5), которая читает команды со стандартного ввода и выполняет их. Это
похоже на примитивную реализацию командной оболочки.
Листинг 1.5. Чтение команд со стандартного ввода и их выполнение
#include "apue.h"
#include <sys/wait.h>
int

46    Глава 1. Обзор ОС UNIX
main(void)
{
char
buf[MAXLINE]; /* из apue.h */
pid_t pid;
int
status;
printf("%% "); /* вывести приглашение (printf требует использовать */
/* последовательность %%, чтобы вывести символ %) */
while (fgets(buf, MAXLINE, stdin) != NULL) {
if (buf[strlen(buf) - 1] == '\n')
buf[strlen(buf) - 1] = 0; /* заменить символ перевода строки */
if ((pid = fork()) < 0) {
err_sys("ошибка вызова fork");
} else if (pid == 0) { /* дочерний процесс */
execlp(buf, buf, (char *)0);
err_ret("невозможно выполнить: %s", buf);
exit(127);
}
/* родительский процесс */
if ((pid = waitpid(pid, &status, 0)) < 0)
err_sys("ошибка вызова waitpid");
printf("%% ");

}

}
exit(0);

Перечислим наиболее важные аспекты в этой 30-строчной программе.
 Для чтения строки из стандартного ввода используется функция fgets. Когда первым в строке вводится символ конца файла (обычно Control-D), fgets
возвращает пустой указатель, цикл прерывается и процесс завершает работу.
В главе 18 мы опишем все символы, имеющие специальное значение — признак конца файла, забой, удаление строки и  пр., и  покажем, как можно замещать.
 Каждая строка, возвращаемая функцией fgets, завершается символом перевода строки, за которым следует нулевой символ (\0), поэтому мы определили
ее длину с помощью стандартной функции strlen и заменили перевод строки
нулевым символом. Это необходимо, потому что функция execlp ожидает получить строку, завершающуюся нулевым символом, а  не символом перевода
строки.
 Вызов функции fork создает новый процесс — копию вызывающего процесса.
Мы называем вызывающий процесс родительским процессом, а вновь созданный — дочерним. В родительском процессе функция fork возвращает идентификатор дочернего процесса, в дочернем процессе — 0. Поскольку fork создает
новый процесс, можно сказать, что она вызывается один раз — родительским
процессом, а возвращает управление дважды — в родительском и в дочернем
процессах.
 Для запуска команды, прочитанной из стандартного ввода, в дочернем процессе вызывается функция execlp. Она замещает дочерний процесс новой программой из файла. Комбинация функций fork/exec  — это своего рода двухступенчатый системный вызов, порождающий новый процесс. В UNIX эти два

1.6. Программы и процессы   

47

этапа выделены в самостоятельные функции. Более подробно мы поговорим
о них в главе 8.
 Поскольку дочерний процесс запускает новую программу с помощью execlp,
родительский процесс должен дождаться его завершения, прежде чем продолжить работу. Делается это с помощью вызова функции waitpid, которой передается идентификатор дочернего процесса — аргумент pid. Функция waitpid
возвращает код завершения дочернего процесса (переменная status), но в нашей программе это значение не используется. Мы могли бы проверить его, чтобы узнать, как завершился дочерний процесс.
 Одно из основных ограничений этой программы заключается в невозможности передать аргументы выполняемой команде. Так, например, вы не сможете
указать имя каталога, чтобы получить список файлов, хранящихся в нем. Мы
можем выполнить команду ls только для рабочего каталога. Чтобы передать
аргументы, необходимо проанализировать введенную строку, выделить аргументы в  соответствии с  некоторыми признаками (например, по символам
пробела или табуляции) и  затем передать их в  виде отдельных аргументов
функции execlp. Тем не менее наша программа наглядно демонстрирует, как
работают функции управления процессами.
Ниже показан вывод программы, полученный в нашей системе. Обратите внимание, что она выводит символ % в качестве приглашения, чтобы как-то отличить его
от приглашения командной оболочки.
$ ./a.out
% date
Sat Jan 21 19:42:07 EST 2012
% who
sar
console Jan 1 14:59
sar
ttys000 Jan 1 14:59
sar
ttys001 Jan 15 15:28
% pwd
/home/sar/bk/apue/3e
% ls
Makefile
a.out
shell1.c
% ^D
ввод символа конца файла
$
приглашение командной оболочки

Последовательность ^D указывает на ввод управляющего символа. Управляющие символы — это специальные символы, которые формируются при нажатой и удерживаемой
клавише Control или Ctrl (в зависимости от модели клавиатуры) и одновременном нажатии на другую клавишу. Символ Control-D, или ^D, представляет признак конца файла.
Мы встретим еще много управляющих символов, когда будем обсуждать терминальный
ввод/вывод в главе 18.

Потоки выполнения и идентификаторы потоков
Обычно процесс имеет единственный поток выполнения — только одна последовательность машинных инструкций выполняется в одно и то же время. Со многими
проблемами легче справиться, если решать различные части задачи одновременно

48    Глава 1. Обзор ОС UNIX
в нескольких потоках. Кроме того, в многопроцессорных системах различные потоки одного процесса могут выполняться параллельно.
Все потоки в  процессе разделяют общее адресное пространство, файловые дескрипторы, стеки и  прочие атрибуты процесса. Поскольку потоки могут обращаться к одной и той же области памяти, они должны синхронизировать доступ
к разделяемым данным, чтобы избежать несогласованности.
Подобно процессам, каждый поток имеет свой числовой идентификатор. Однако
идентификаторы потоков являются локальными для процесса. Они не имеют никакого значения для других процессов и служат для ссылки на конкретные потоки
внутри процесса, когда требуется оказать управляющее воздействие.
Функции управления потоками отличны от функций управления процессами.
Однако поскольку потоки были добавлены в UNIX намного позже появления модели процессов, эти две модели находятся в достаточно сложной взаимосвязи, как
будет показано в главе 12.

1.7. Обработка ошибок
Часто при появлении ошибки функции системы UNIX возвращают отрицательное число, а  в  глобальную переменную errno записывают некоторое целое число, несущее дополнительную информацию об ошибке. Например, функция open
возвращает файловый дескриптор  — неотрицательное число  — или –1 в  случае
ошибки. Вообще через переменную errno функция open может вернуть 15 различных кодов ошибок, таких как отсутствие файла, недостаточность прав доступа
и т. п. Некоторые функции следуют иному соглашению. Например, большинство
функций, которые должны возвращать указатель на какой-либо объект, в случае
ошибки возвращают пустой указатель.
Определения переменной errno и констант всех возможных кодов ошибок находятся в заголовочном файле <errno.h>. Имена констант начинаются с символа E.
Кроме того, на первой странице второго раздела справочного руководства UNIX,
которая называется intro(2), обычно перечислены все константы кодов ошибок.
Например, если переменная errno содержит код, равный значению константы
EACCES, это означает, что возникли проблемы с  правами доступа, например, при
открытии файла.
В ОС Linux коды ошибок и соответствующие им имена констант перечислены на странице errno(3).

Стандарты POSIX и  ISO C определяют errno как символ, разворачивающийся
в изменяемое левостороннее выражение (то есть выражение, которое может стоять слева от оператора присваивания) целого типа. Это может быть целое число,
соответствующее коду ошибки, или функция, возвращающая указатель на код
ошибки. Изначально переменная errno определялась как
extern int errno;

Но в многопоточной среде адресное пространство процесса совместно используется несколькими потоками и  каждый поток должен обладать своей локальной

1.7. Обработка ошибок   

49

копией errno, чтобы исключить конфликты. ОС Linux, например, поддерживает
многопоточный доступ к переменной errno, определяя ее так:
extern int *__errno_location(void);
#define errno (*__errno_location())

Необходимо знать два правила, касающиеся errno. Во-первых, значение errno
никогда не очищается процедурой, если ошибка не происходит. Следовательно,
проверять это значение надо лишь в  тех случаях, когда значение, возвращаемое
функцией, указывает, что произошла ошибка. Во-вторых, ни одна функция никогда не устанавливает значение errno в 0 и ни одна константа из определяемых
в <errno.h> не имеет значения 0.
Для вывода сообщений об ошибках стандарт C предусматривает две функции.
#include <string.h>
char *strerror(int errnum);

Возвращает указатель на строку сообщения

Эта функция преобразует код ошибки errnum, обычно равный значению errno,
в строку сообщения об ошибке и возвращает указатель на нее.
Функция perror, основываясь на значении errno, выводит сообщение об ошибке
в стандартный вывод ошибок.
#include <stdio.h>
void perror(const char *msg);

Она выводит строку, на которую ссылается аргумент msg, двоеточие, пробел
и текст сообщения об ошибке, соответствующий значению errno. Вывод заканчивается символом перевода строки.

Пример
В листинге 1.6 приводится пример использования этих функций.
Листинг 1.6. Демонстрация функций strerror и perror
#include "apue.h"
#include <errno.h>
int
main(int argc, char *argv[])
{
fprintf(stderr, "EACCES: %s\n", strerror(EACCES));
errno = ENOENT;
perror(argv[0]);
exit(0);
}

Скомпилировав и запустив эту программу, мы получим
$ ./a.out
EACCES: Permission denied
./a.out: No such file or directory

50    Глава 1. Обзор ОС UNIX
Обратите внимание: мы передали функции perror имя выполняемого файла программы — a.out, находящееся в  argv[0]. Это стандартное соглашение, принятое
в UNIX. Если программа выполняется в составе конвейера, как показано ниже,
prog1 < inputfile | prog2 | prog3 > outputfile

следуя этому соглашению, мы сможем точно определить, в  какой из программ
произошла ошибка.
Во всех примерах в этой книге вместо strerror или perror мы будем использовать
собственные функции вывода сообщений об ошибках, которые можно найти в приложении B. Они принимают переменное количество аргументов, что позволяет легко обрабатывать ошибочные ситуации единственным выражением на языке C.

Восстановление после ошибок
Ошибки, определенные в  <errno.h>, можно разделить на две категории: фатальные и нефатальные. Восстановление нормальной работы после фатальных ошибок невозможно. Самое большее, что можно сделать,  — вывести сообщение об
ошибке на экран или в  файл журнала и  завершить приложение. Нефатальные
ошибки допускают нормальное продолжение работы. Большинство нефатальных
ошибок по своей природе носит временный характер (например, нехватка ресурсов), и их можно избежать при меньшей загруженности системы.
К нефатальным ошибкам, связанным с  нехваткой ресурсов, относятся: EAGAIN,
ENFILE, ENOBUFS, ENOLCK, ENOSPC, ENOSR, EWOULDBLOCK и иногда ENOMEM. Ошибку EBUSY
можно считать нефатальной, если она сообщает о занятости общего ресурса в настоящий момент времени. Иногда нефатальной может считаться ошибка EINTR,
если она возникает в результате прерывания медленно работающего системного
вызова (подробнее об этом рассказывается в разделе 10.5).
Для восстановления после вышеперечисленных ошибок обычно достаточно приостановить работу на короткое время и  повторить попытку. Этот прием можно
использовать в других ситуациях. Например, если ошибка свидетельствует о разрыве сетевого соединения, можно подождать некоторое время и затем попытаться
восстановить соединение. В некоторых приложениях используется алгоритм экспоненциального увеличения времени задержки, когда пауза увеличивается с каждой следующей попыткой.
В конечном счете сам разработчик приложения решает, после каких ошибок возможно продолжение работы. Применяя разумную стратегию восстановления после ошибок, можно существенно повысить отказоустойчивость приложения и избежать аварийного завершения его работы.

1.8. Идентификация пользователя
Идентификатор пользователя
Идентификатор пользователя (user ID, или UID) из записи в файле паролей — это
числовое значение, которое однозначно идентифицирует пользователя в системе.
Идентификатор пользователя назначается системным администратором при соз-

1.8. Идентификация пользователя   

51

дании учетной записи и не может изменяться пользователем. Как правило, каждому пользователю назначается уникальный идентификатор. Ниже мы узнаем, как
ядро использует идентификатор пользователя для проверки прав на выполнение
определенных операций.
Пользователь с  идентификатором 0 называется суперпользователем, или root.
В файле паролей этому пользователю обычно присвоено имя root. Этот пользователь обладает особыми суперпривилегиями. Как показано в главе 4, если процесс имеет привилегии суперпользователя, большинство проверок прав доступа
к файлам просто не выполняется. Некоторые системные операции доступны только суперпользователю. Суперпользователь обладает неограниченной свободой
действий в системе.
В клиентских версиях Mac OS X учетная запись суперпользователя заблокирована, в серверных версиях  — разблокирована. Инструкции по разблокированию учетной записи
суперпользователя можно найти на веб-сайте компании Apple: http://support. apple.com/
kb/HT1528.

Идентификатор группы
Кроме всего прочего, запись в файле паролей содержит числовой идентификатор
группы (group ID, или GID). Он также назначается системным администратором
при создании учетной записи. Как правило, в файле паролей имеется несколько
записей с одинаковым идентификатором группы. Обычно группы используются
для распределения пользователей по проектам или отделам. Это позволяет организовать совместное использование ресурсов, например файлов, членами определенной группы. В разделе 4.5 показано, как назначить файлу такие права доступа,
чтобы он был доступен всем членам группы и недоступен другим пользователям.
В системе существует файл групп, определяющий соответствия имен групп их
числовым идентификаторам. Обычно этот файл называется /etc/group.
Представление идентификаторов пользователя и  группы в  числовом виде сложилось исторически. Для каждого файла на диске файловая система хранит
идентификаторы пользователя и группы его владельца. Поскольку каждый идентификатор представлен двухбайтным целым числом, для хранения обоих идентификаторов требуется всего четыре байта. Если бы вместо идентификаторов
использовались полные имена пользователей и групп, потребовалось бы хранить
на диске значительно больший объем информации. Кроме того, сравнение строк
вместо сравнения целых чисел при проверках прав доступа выполнялось бы гораздо медленнее.
Однако человеку удобнее работать с осмысленными именами, чем с числовыми
идентификаторами, поэтому файл паролей хранит соответствия между именами
и  идентификаторами пользователей, а  файл групп  — между именами и  идентификаторами групп. Например, команда ls –l выведет имена владельцев файлов,
используя файл паролей для преобразования числовых идентификаторов в соответствующие им имена пользователей.
В ранних версиях UNIX для представления идентификаторов использовались 16-разрядные
целые числа, в современных версиях — 32-разрядные.

52    Глава 1. Обзор ОС UNIX

Пример
Программа в листинге 1.7 выводит идентификаторы пользователя и группы.
Листинг 1.7. Вывод идентификаторов пользователя и группы
#include "apue.h"
int
main(void)
{
printf("uid = %d, gid = %d\n", getuid(), getgid());
exit(0);
}

Для получения идентификаторов пользователя и группы используются функции
getuid и getgid. Запуск программы дает следующие результаты:
$ ./a.out
uid = 205, gid = 105

Идентификаторы дополнительных групп
В дополнение к  группе, идентификатор которой указан в  файле паролей, большинство версий UNIX позволяют пользователю быть членом других групп. Впервые такая возможность появилась в 4.2BSD, где можно было определить до 16 дополнительных групп, к которым мог принадлежать пользователь. Во время входа
в систему из файла /etc/group извлекаются первые 16 групп, в которых присутствует имя данного пользователя, и  их идентификаторы назначаются идентификаторами дополнительных групп. Как показано в  следующей главе, стандарт
POSIX требует, чтобы операционная система поддерживала не менее 8 дополнительных групп для каждого процесса, однако большинство систем поддерживает
не менее 16 таких групп.

1.9. Сигналы
Сигналы используются, чтобы известить процесс о  наступлении некоторого состояния. Например, если процесс попытается выполнить деление на ноль, он получит уведомление в виде сигнала SIGFPE (floating-point exception — ошибка выполнения операции с плавающей запятой). Процесс может реагировать на сигнал
тремя способами.
1.	 Игнорировать сигнал. Такая реакция не рекомендуется для сигналов, указывающих на аппаратную ошибку (такую, как деление на ноль или обращение
к памяти, находящейся вне адресного пространства процесса), поскольку результат в этом случае непредсказуем.
2.	 Разрешить выполнение действия по умолчанию. В случае деления на ноль по
умолчанию происходит аварийное завершение процесса.
3.	 Определить функцию, которая будет вызвана для обработки сигнала (такие
функции называют перехватчиками сигналов). Определив такую функцию,

1.9. Сигналы   

53

можно отслеживать получение сигнала и реагировать на него по своему усмотрению.
Сигналы порождаются во многих ситуациях. Две клавиши терминала, известные
как клавиша прерывания (Control-C или DELETE) и клавиша выхода (часто Control-\),
используются для прерывания работы текущего процесса. Сгенерировать сигнал
можно также вызовом функции kill. С ее помощью один процесс может послать
сигнал другому. Естественно, эта операция имеет свои ограничения: чтобы послать
сигнал процессу, мы должны быть его владельцем (или суперпользователем).

Пример
Вспомните пример простейшей командной оболочки в  листинге 1.5. Если запустить эту программу и нажать клавишу прерывания (Control-C), процесс завершит
работу, так как реакция по умолчанию на этот сигнал, называемый SIGINT, заключается в завершении процесса. Процесс не сообщил ядру, что реакция на сигнал
должна отличаться от действия по умолчанию, поэтому он завершается.
Чтобы перехватить сигнал, программа должна вызвать функцию signal, передав ей имя функции, которая должна вызываться при получении сигнала SIGINT.
В следующем примере эта функция называется sig_int. Она просто выводит на
экран сообщение и новое приглашение к вводу. Добавив 11 строк в программу из
листинга 1.5, мы получим версию в листинге 1.8 (добавленные строки обозначены
символами «+»).
Листинг 1.8. Чтение команд со стандартного ввода и их выполнение
#include "apue.h"
#include <sys/wait.h>
+ static void
+
int
main(void)
{
char
pid_t
int
+
+
+

sig_int(int); /* наша функция-перехватчик */

buf[MAXLINE]; /* из apue.h */
pid;
status;

if (signal(SIGINT, sig_int) == SIG_ERR)
err_sys("ошибка вызова signal");
printf("%% "); /* вывести приглашение (printf требует использовать */
/* последовательность %%, чтобы вывести символ %) */
while (fgets(buf, MAXLINE, stdin) != NULL) {
if (buf[strlen(buf) - 1] == '\n')
buf[strlen(buf) 1] = 0; /* заменить символ перевода строки */
if ((pid = fork()) < 0) {
err_sys("ошибка вызова fork");
} else if (pid == 0) { /* дочерний процесс */
execlp(buf, buf, (char *)0);
err_ret("невозможно выполнить: %s", buf);
exit(127);
}

54    Глава 1. Обзор ОС UNIX
/* родительский процесс */
if ((pid = waitpid(pid, &status, 0)) < 0)
err_sys("ошибка вызова waitpid");
printf("%% ");

}
+
+
+
+
+
+

}
exit(0);

void
sig_int(int signo)
{
printf("прервано\n%% ");
}

В главе 10 мы детально рассмотрим сигналы, поскольку с  ними работает большинство серьезных приложений.

1.10. Представление времени
Исторически в системе UNIX поддерживается два способа представления времени.
1.	 Календарное время. Значения в этом представлении хранят число секунд, прошедших с начала Эпохи — 00:00:00 1 января 1970 года по согласованному всемирному времени (Coordinated Universal Time, UTC). (Старые руководства
описывают UTC как Greenwich Mean Time — время по Гринвичу.) Эти значения используются, например, для представления времени последнего изменения файла.
Для хранения времени в этом представлении используется тип данных time_t.
2.	 Время работы процесса. Оно еще называется процессорным временем и измеряет ресурсы центрального процессора, использованные процессом. Эти значения измеряются в тактах (ticks). Исторически сложилось так, что в различных
системах в одной секунде может быть 50, 60 или 100 тактов.
Для хранения времени в этом представлении используется тип данных clock_t.
(В разделе 2.5.4 мы покажем, как узнать количество тактов в секунде вызовом
sysconf.)
В разделе 3.9 мы увидим, что при измерении времени выполнения процесса система UNIX хранит три значения:
 общее время (Clock time);
 пользовательское время (User CPU time);
 системное время (System CPU time).
Общее время (иногда называют временем настенных часов)  — отрезок времени,
затраченный процессом от момента запуска до завершения. Это значение зависит
от общего количества процессов, выполняемых в системе. Всякий раз, когда нас
интересует общее время, измерения должны делаться на незагруженной системе.
Пользовательское время — это время, затраченное на исполнение машинных инструкций самой программы. Системное время — это время, затраченное на вы-

1.11. Системные вызовы и библиотечные функции   

55

полнение машинных инструкций в ядре от имени процесса. Например, всякий
раз, когда процесс обращается к системному вызову, такому как read или write,
ему приписывается время, затраченное ядром на выполнение запроса. Сумму
пользовательского и системного времени часто называют процессорным временем (CPU time).
Измерить общее, пользовательское и системное время просто: выполните команду time(1), передав ей в качестве аргумента команду, время работы которой требуется измерить. Например:
$ cd /usr/include
$ time -p grep _POSIX_SOURCE */*.h > /dev/null
real
user
sys

0m0.81s
0m0.11s
0m0.07s

Формат вывода результатов зависит от командной оболочки, поскольку некоторые из них вместо утилиты /usr/bin/time используют встроенную функцию, измеряющую время выполнения заданной команды.
В разделе 8.17 мы увидим, как получить все три значения из запущенного процесса. Собственно тема даты и времени будет рассматриваться в разделе 6.10.

1.11. Системные вызовы
и библиотечные функции
Любая операционная система дает прикладным программам возможность обращаться к системным службам. Во всех реализациях UNIX имеется строго определенное число точек входа в  ядро, которые называются системными вызовами
(вспомните рис. 1.1). Седьмая версия Research UNIX System имела около 50 системных вызовов, 4.4BSD — около 110, а SVR4 — примерно 120. В Linux 3.2.0 имеется 380 системных вызовов, а в FreeBSD 8.0 их более 450.
Интерфейс системных вызовов всегда документируется во втором разделе «Руководства программиста UNIX». Он определяется на языке C независимо от конкретных реализаций, использующих системные вызовы в той или иной системе.
В этом отличие от многих старых систем, которые традиционно определяли точки
входа в ядро на языке ассемблера.
В системе UNIX для каждого системного вызова предусматривается одноименная функция в стандартной библиотеке языка C. Пользовательский процесс вызывает эту функцию как обычно, а она вызывает соответствующую службу ядра,
применяя способ обращения, принятый в  данной системе. Например, функция
может поместить один или более своих аргументов в  регистры общего назначения и затем выполнить некоторую машинную инструкцию, которая сгенерирует
программное прерывание. В  нашем случае мы можем рассматривать системные
вызовы как обычные функции языка C.
Раздел 3 «Руководства программиста UNIX» описывает функции общего назначения, доступные программисту. Эти функции не являются точками входа в ядро,

56    Глава 1. Обзор ОС UNIX
хотя могут обращаться к нему посредством системных вызовов. Например, функция printf может использовать системный вызов write для вывода строки, но
функции strcpy (копирование строки) и  atoi (преобразование ASCII-строки
в число) не выполняют системных вызовов.
С точки зрения разработчика системы, между системным вызовом и библиотечной функцией имеются коренные различия. Но с точки зрения пользователя, эти
различия носят непринципиальный характер. В  контексте нашей книги системные вызовы и библиотечные функции можно представлять как обычные функции
языка C. И те и другие предназначены для обслуживания прикладных программ.
Однако при этом нужно понимать, что библиотечные функции можно заменить,
если в этом возникнет необходимость, а системные вызовы — нет.
Рассмотрим в качестве примера функцию выделения памяти malloc. Существует масса способов распределения памяти и  алгоритмов «сборки мусора» (метод
наилучшего приближения, метод первого подходящего и т. д.). Но нет единой методики, оптимальной абсолютно для всех возможных ситуаций. Системный вызов sbrk(2), который занимается выделением памяти, не является диспетчером
памяти общего назначения. Он лишь увеличивает или уменьшает адресное пространство процесса на заданное количество байтов, а управление этим пространством возлагается на сам процесс. Функция malloc(3) реализует одну конкретную
модель распределения памяти. Если она нам не нравится по каким-то причинам,
мы можем написать собственную функцию malloc, которая, вероятно, будет обращаться к системному вызову sbrk. На самом деле многие программные пакеты
реализуют собственные алгоритмы распределения памяти с использованием системного вызова sbrk. На рис. 1.2 показаны взаимоотношения между приложением, функцией malloc и системным вызовом sbrk.

Код приложения

Функция распределения
памяти malloc

Системный
вызов sbrk

Пользовательский
процесс

Ядро

Рис. 1.2. Разделение обязанностей функции malloc и системного вызова sbrk

Здесь мы видим четкое разделение обязанностей: системный вызов выделяет
дополнительную область памяти от имени процесса, а  библиотечная функция
malloc распоряжается этой областью.

1.11. Системные вызовы и библиотечные функции   

57

Еще один пример, иллюстрирующий различия между системным вызовом и библиотечной функцией, — интерфейс определения текущей даты и времени. В некоторых операционных системах имеется два системных вызова: один возвращает
время, другой  — дату. Любая специальная обработка, такая как переход на летнее время, выполняется ядром или требует вмешательства человека. UNIX предоставляет единственный системный вызов, возвращающий количество секунд,
прошедших с  начала Эпохи  — 0 часов 00 минут 1 января 1970 года по согласованному всемирному времени (UTC). Любая интерпретация этого значения, например представление в удобном для человека виде с учетом поясного времени,
полностью возлагается на пользовательский процесс. Стандартная библиотека
языка C содержит функции практически для любых случаев. Они, например, реализуют различные алгоритмы, учитывающие переход на зимнее или летнее время.
Прикладная программа может обращаться к системному вызову и к библиотечной функции. Кроме того, следует помнить, что библиотечные функции, в свою
очередь, также могут обращаться к системным вызовам. Это наглядно показано
на рис. 1.3.
Другое отличие системных вызовов от библиотечных функций заключается в том,
что системные вызовы обеспечивают лишь минимально необходимую функцио­
нальность, тогда как библиотечные функции часто обладают более широкими
возможностями. Мы уже видели это различие на примере сравнения системного
вызова sbrk с  библиотечной функцией malloc. Мы еще столкнемся с  этим различием, когда будем сравнивать функции небуферизованного ввода/вывода (глава 3) и стандартные функции ввода/вывода (глава 5).
Код
приложения
Пользовательский
процесс

Библиотечные
функции

Системные вызовы

Ядро

Рис. 1.3. Разделение обязанностей функции malloc и системного вызова sbrk

Системные вызовы управления процессами (fork, exec и  waitpid) обычно вызываются пользовательским процессом напрямую. (Вспомните простую командную
оболочку в листинге 1.5.) Но существуют также библиотечные функции, которые
служат для упрощения самых распространенных случаев: например, функции
system и  popen. В  разделе 8.13 мы увидим реализацию функции system, выпол-

58    Глава 1. Обзор ОС UNIX
ненную на основе системных вызовов управления процессами. В разделе 10.18 мы
дополним этот пример обработкой сигналов.
Чтобы охарактеризовать интерфейс системы UNIX, используемый большинством программистов, мы должны будем описать не только системные вызовы, но
и некоторые библиотечные функции. Описав, к примеру, только системный вызов
sbrk, мы оставили бы без внимания более удобную для программиста функцию
malloc, которая применяется во множестве приложений. В  этой книге под термином функция мы будем подразумевать и  системные вызовы, и  библиотечные
функции, за исключением случаев, когда потребуется подчеркнуть имеющиеся
отличия.

1.12. Подведение итогов
Эта глава представляет собой обзорную экскурсию по системе UNIX. Мы дали
определение ряда фундаментальных понятий, с которыми столкнемся еще не раз,
и привели примеры небольших программ, чтобы вы могли представить, о чем пойдет речь в этой книге.
Следующая глава рассказывает о стандартизации UNIX и о влиянии деятельности в этой области на ее развитие. Стандарты, особенно ISO C и POSIX.1, будут
постоянно встречаться на протяжении всей книги.

Упражнения
1.1	

В своей системе проверьте и убедитесь, что каталоги «.» и «..» являются различными каталогами, за исключением корневого каталога.

1.2	

Просмотрите еще раз результат работы примера в листинге 1.4 и скажите,
куда пропали процессы с идентификаторами 852 и 853.

1.3	

Аргумент функции perror в разделе 1.7 определен с атрибутом const (в соответствии со стандартом ISO C), в то время как целочисленный аргумент
функции strerror определен без этого атрибута. Почему?

1.4	

Если предположить, что календарное время хранится в виде 32-разрядного
целого числа со знаком, в каком году наступит переполнение? Какими способами можно отдалить дату переполнения? Будут ли найденные решения
совместимы с существующими приложениями?

1.5	

Если предположить, что время работы процесса хранится в виде 32-разрядного целого числа со знаком и система отсчитывает 100 тактов в секунду,
через сколько дней наступит переполнение счетчика?

2

Стандарты и реализации UNIX

2.1. Введение
Немалая работа была проделана для стандартизации системы UNIX и языка программирования C. Хотя приложения всегда обладали высокой переносимостью
между разными версиями UNIX, тем не менее появление многочисленных версий UNIX в течение 80-х годов привело к тому, что крупные пользователи, такие
как правительство США, были вынуждены призвать разработчиков к выработке
стандартов.
В этой главе мы сначала рассмотрим различные попытки стандартизации, предпринимавшиеся за последние два с половиной десятилетия, а затем обсудим их
влияние на реализации UNIX, которые обсуждаются в данной книге. Важной частью любых работ по стандартизации является спецификация различных ограничений, которые должны быть установлены для каждой реализации, поэтому мы
рассмотрим эти ограничения и различные способы определения их значений.

2.2. Стандартизация UNIX
2.2.1. ISO C
В конце 1989 года был одобрен стандарт ANSI для языка программирования C —
X3.159-1989. Этот стандарт также был принят как международный стандарт ISO/
IEC 9899:1990. Аббревиатура ANSI расшифровывается как American National
Standards Institute (Американский национальный институт стандартов, представляющий США в Международной организации по стандартизации — International
Organization for Standardization, ISO). Аббревиатура IEC означает International
Electrotechnical Commission (Международная электротехническая комиссия).
Стандарт языка C теперь поддерживается и развивается международной рабочей
группой ISO/IEC по стандартизации языка программирования C, известной как
ISO/IEC JTC1/SC22/WG14, или сокращенно WG14. Цель стандарта ISO C обеспечить переносимость программ на языке C между самыми разными операционными системами, не только UNIX. Этот стандарт определяет не только синтаксис
и семантику языка, но также состав стандартной библиотеки [ISO 1999, глава 7;
Plauger 1992; Kernighan and Ritchie 1988, приложение B]. Эта библиотека имеет
большое значение, потому что все современные версии UNIX, в  том числе опи-

60    Глава 2. Стандарты и реализации UNIX
санные в этой книге, обязаны предоставлять библиотеки функций, определяемых
стандартом языка C.
В 1999 году стандарт ISO C был обновлен и одобрен как ISO/IEC 9899:1999. Он
в значительной степени улучшил поддержку приложений, выполняющих числовую обработку. Изменения не затронули стандарты POSIX, описываемые в этой
книге, кроме добавления ключевого слова restrict к  некоторым прототипам
функций. Это ключевое слово сообщает компилятору, какие ссылки по указателю
можно оптимизировать, отмечая объекты, доступ к  которым осуществляется из
функций только посредством данного указателя.
Начиная с  1999 года опубликованы три технические поправки, исправляющие
ошибки в стандарте ISO C: в 2001, 2004 и 2007 годах. В большинстве случаев между одобрением стандарта и модификацией программного обеспечения, учитывающей изменения в стандартах, проходит какое-то время. По мере своего развития
все системы компиляции добавляют или совершенствуют поддержку последней
версии стандарта ISO C.
Информацию о текущем уровне соответствия gcc стандарту ISO C от 1999 года можно
найти по адресу http://www.gnu.org/software/gcc/c99status.html. Хотя стандарт языка C
был обновлен и дополнен в 2011 году, в этой книге будет рассматриваться только версия
1999 года, так как другие стандарты пока не учитывают соответствующие изменения.

Библиотеку ISO C можно разбить на 24 раздела, основываясь на именах заголовочных файлов, определяемых стандартом (табл. 2.1). Стандарт POSIX.1 включает эти файлы и, кроме того, определяет ряд дополнительных заголовочных файлов. Как видно в табл. 2.1, все эти заголовочные файлы поддерживаются четырьмя
реализациями (FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 и Solaris 10), описываемыми далее в этой главе.
Перечень заголовочных файлов ISO C зависит от версии компилятора языка C, используемой в той или иной операционной системе. Изучая табл. 2.1, имейте в виду, что FreeBSD 8.0
распространяется с  gcc версии 4.2.1, Solaris 10 — с  gcc версии 3.4.3 (в дополнение к собственному компилятору C, входящему в состав Sun Studio), Ubuntu 12.04 (Linux 3.2.0) —
с gcc версии 4.6.3, а Mac OS X 10.6.8 — с двумя версиями gcc, 4.0.1 и 4.2.1.
Таблица 2.1. Перечень заголовочных файлов, определяемых стандартом ISO C
Заголовочный
файл

FreeBSD
8.0

Linux
3.2.0

Mac OS X
10.6.8

Solaris
10

<assert.h>









Проверка программных утверждений

<complex.h>









Поддержка арифметики комплексных чисел

<ctype.h>









Типы символов

<errno.h>









Коды ошибок (раздел 1.7)

<fenv.h>









Окружение операций с плавающей
запятой

<float.h>









Арифметика с плавающей запятой

Описание

2.2. Стандартизация UNIX   

61

Заголовочный
файл

FreeBSD
8.0

Linux
3.2.0

Mac OS X
10.6.8

Solaris
10

<inttypes.h>









Преобразования целочисленных
типов

<iso646.h>









Альтернативные макросы операторов отношений

<limits.h>









Константы реализации (раздел 2.5)

<locale.h>









Классы региональных настроек
(локалей)

<math.h>









Математические константы

<setjmp.h>









Нелокальные переходы (раздел 7.10)

<signal.h>









Сигналы (глава 10)

<stdarg.h>









Списки аргументов переменной
длины

<stdbool.h>









Логический тип и значения

<stddef.h>









Стандартные определения

<stdint.h>









Целочисленные типы

<stdio.h>









Стандартная библиотека ввода/вывода (глава 5)

<stdlib.h>









Функции общего назначения

<string.h>









Операции над строками

<tgmath.h>









Макроопределения математических операций

<time.h>









Время и дата (раздел 6.10)

<wchar.h>









Расширенная поддержка многобайтных символов

<wctype.h>









Классификация и функции преобразования многобайтных символов

Описание

2.2.2. IEEE POSIX
POSIX — это семейство стандартов, разработанных организацией IEEE (Institute
of Electrical and Electronics Engineers — Институт инженеров электроники и радиотехники). Аббревиатура POSIX расшифровывается как Portable Operating
System Interface (Интерфейс переносимой операционной системы). Изначально
это название относилось только к  стандарту IEEE 1003.1-1988 (интерфейс операционной системы), но позднее оно стало объединять множество других стандартов и предварительных стандартов проекта под номером 1003, в том числе на
командную оболочку и утилиты (1003.2).
Основной интерес для нас представляет стандарт на интерфейс переносимой операционной системы 1003.1, цель которого состоит в повышении переносимости

62    Глава 2. Стандарты и реализации UNIX
приложений между различными версиями UNIX. Этот стандарт определяет набор служб, которые должна предоставлять операционная система, если она претендует на звание «POSIX-совместимой». Хотя стандарт 1003.1 базируется на
операционной системе UNIX, он не ограничивается UNIX и UNIX-подобными
операционными системами. Действительно, некоторые производители проприетарных операционных систем утверждают, что их системы являются POSIXсовместимыми, в то же время сохраняя все свои проприетарные особенности.
Поскольку стандарт 1003.1 определяет интерфейс, а  не реализацию, между системными вызовами и  библиотечными функциями не делается никаких различий. Стандарт именует все процедуры функциями.
Стандарты продолжают непрерывно развиваться, и  1003.1 не является исключением. Версия этого стандарта 1988 года, IEEE Standard 1003.1-1988, была дополнена и представлена на рассмотрение Международной организации по стандартизации (ISO). Текст стандарта был полностью переработан, хотя при этом
не было добавлено каких-либо новых интерфейсов или особенностей. Окончательный документ был опубликован как IEEE Std 1003.1-1990 [IEEE 1990]. Он
также является международным стандартом ISO/IEC 99451: 1990. Обычно этот
стандарт называют POSIX.1, и в этой книге также используется это обозначение.
Рабочая группа IEEE 1003.1 продолжила внесение изменений в  стандарт.
В  1996  году была издана пересмотренная версия стандарта IEEE 1003.1. Она
включала в  себя стандарт 1003.1-1990, стандарт на расширения реального времени 1003.1b-1993 и  интерфейсы многопоточного программирования под названием pthreads для потоков POSIX. Эта версия стандарта была опубликована
как International Standard ISO/IEC 9945-1:1996. В 1999 году с выходом стандарта
IEEE Standard 1003.1d-1999 были добавлены улучшенные интерфейсы реального
времени. Год спустя был опубликован стандарт IEEE Standard 1003.1j-2000, в котором появились дополнительные, улучшенные интерфейсы реального времени.
В этом же году вышел стандарт IEEE Standard 1003.1q-2000, добавивший расширения трассировки событий.
Версия стандарта 1003.1 2001 года отличалась от предшествующих версий тем,
что объединила некоторые поправки из стандартов 1003.1, 1003.2 и часть Single
UNIX Specification (SUS — единая спецификация UNIX) версии 2 (подробнее об
этом стандарте рассказывается ниже). В окончательный вариант IEEE Standard
1003.1-2001 вошли следующие стандарты:
 ISO/IEC 9945-1 (IEEE Standard 1003.1-1996), включающий:
•• IEEE Standard 1003.1-1990;
•• IEEE Standard 1003.1b-1993 (расширения реального времени);
•• IEEE Standard 1003.1c-1995 (pthreads);
•• IEEE Standard 1003.1i-1995 (список технических исправлений);
 IEEE P1003.1a предварительный стандарт (пересмотр системных интерфейсов);
 IEEE Standard 1003.1d-1999 (улучшенные расширения реального времени);
 IEEE Standard 1003.1j-2000 (дополнительные улучшенные расширения реального времени);

2.2. Стандартизация UNIX   

63

 IEEE Standard 1003.1q-2000 (трассировка);
 Части стандарта IEEE Standard 1003.1g-2000 (независимые от протокола интерфейсы);
 ISO/IEC 9945-2 (IEEE Standard 1003.2-1993);
 IEEE P1003.2b предварительный стандарт (оболочка и дополнительные утилиты);
 IEEE Standard 1003.2d-1994 (пакетные расширения);
 Основные спецификации Single UNIX Specification версии 2, включая:
•• System Interface Definitions, Issue 5 (определения системных интерфейсов,
выпуск 5);
•• Commands and Utilities, Issue 5 (команды и утилиты, выпуск 5);
•• System Interfaces and Headers, Issue 5 (системные интерфейсы и заголовочные файлы, выпуск 5);
 Open Group Technical Standard, Networking Services, Issue 5.2 (технический
стандарт на сетевые службы, выпуск 5.2);
 ISO/IEC 9899:1999, Programming Languages — C (языки программирования —
C).
В 2004 году спецификация POSIX.1 была дополнена техническими исправлениями. В 2008-м были произведены более обширные исправления и выпущены как
Base Specifications Issue 7 (базовые спецификации, выпуск 7). Эта версия была
одобрена организацией ISO в конце 2008-го и опубликована в 2009-м под названием International Standard ISO/IEC 9945:2009. Этот стандарт основывается на
некоторых других стандартах:
 IEEE Standard 1003.1, издание 2004 года;
 Open Group Technical Standard, 2006, Extended API Set, Parts 1–4 (расширенные программные интерфейсы, части 1–4);
 ISO/IEC 9899:1999, включающий исправления.
В табл. 2.2, 2.3 и 2.4 приводятся списки обязательных и дополнительных заголовочных файлов, предусматриваемых стандартом POSIX.1. Поскольку POSIX.1
включает стандартные библиотечные функции ISO C, он также требует наличия
заголовочных файлов, перечисленных в табл. 2.1. Все четыре таблицы представляют собой перечень заголовочных файлов, которые включены в  обсуждаемые
здесь реализации операционных систем.
В этой книге мы описываем версию стандарта POSIX.1 от 2008 года, включающую
в  себя функции, определенные стандартом ISO C. Его интерфейсы подразделяются на обязательные для реализации и дополнительные. Кроме того, дополнительные интерфейсы по своей функциональности подразделяются на 40 категорий. Категории еще не устаревших интерфейсов программирования перечислены
в табл. 2.5 с соответствующими им кодами. Коды — это двух- или трехсимвольные
сокращения, которые помогают идентифицировать функциональную область интерфейса. С помощью этих кодов в тексте справочного руководства отмечаются
места, где описываемые интерфейсы зависят от поддержки соответствующего

64    Глава 2. Стандарты и реализации UNIX
дополнения. Многие из дополнительных интерфейсов относятся к расширениям
реального времени.
Таблица 2.2. Перечень обязательных заголовочных файлов, определяемых
стандартом POSIX
Заголовочный файл

FreeBSD Linux
8.0
3.2.0

Mac OS X
10.6.8

Solaris
10

Описание

<aio.h>









Асинхронный ввод/вывод

<cpio.h>









Архиватор cpio

<dirent.h>









Работа с каталогами
(раздел 4.22)

<dlfcn.h>









Динамическое связывание

<fcntl.h>









Управление файлами
(раздел 3.14)

<fnmatch.h>









Шаблоны имен файлов

<glob.h>









Шаблоны путей в файловой
системе

<grp.h>







Файл групп (раздел 6.4)

<iconv.h>







Преобразование кодировок
символов

<langinfo.h>









Константы сведений о языках

<monetary.h>









Типы и функции для финансовых вычислений

<netdb.h>









Операции с распределенной
базой системных данных

<nl_types.h>









Каталоги с сообщениями

<poll.h>









Функция poll (раздел 14.4.2)

<pthread.h>









Потоки (главы 11 и 12)

<pwd.h>









Файл паролей (раздел 6.2)

<regex.h>









Регулярные выражения

<sched.h>









Планировщик

<semaphore.h>









Семафоры

<strings.h>









Операции над строками

<tar.h>









Архиватор tar

<termios.h>









Терминальный ввод/вывод
(глава 18)

<unistd.h>









Символьные константы

2.2. Стандартизация UNIX   

Заголовочный файл

FreeBSD Linux
8.0
3.2.0

<wordexp.h>





<arpa/inet.h>





<net/if.h>



<netinet/in.h>

Mac OS X
10.6.8

Solaris
10

65

Описание



Дополнение слов по шаблону





Сеть Интернет (глава 16)







Локальные сетевые интерфейсы (глава 16)









Семейство адресов Интернета
(раздел 16.3)

<netinet/tcp.h>









Определения протокола TCP

<sys/mman.h>









Управление памятью

<sys/select.h>









Функция select
(раздел 14.4.1)

<sys/socket.h>









Интерфейс сокетов (глава 16)

<sys/stat.h>









Получение сведений о файлах
(глава 4)

<sys/statvfs.h>









Информация о файловой
системе

<sys/times.h>









Время работы процесса
(раздел 8.17)

<sys/types.h>









Примитивы системных типов
данных (раздел 2.8)

<sys/un.h>









Определения, касающиеся
сокетов домена UNIX (раздел 17.2)

<sys/utsname.h>









Название системы (раздел 6.9)

<sys/wait.h>









Управление процессами
(раздел 8.6)

Стандарт POSIX.1 не определяет понятие суперпользователя. Вместо этого он
требует, чтобы некоторые операции были доступны только при наличии «соответствующих привилегий», но определение этого термина POSIX.1 оставляет на усмотрение конкретной реализации. Версии UNIX, разработанные в соответствии
с принципами безопасности Министерства обороны США, имеют многоуровневую систему безопасности. В  этой книге мы будем пользоваться традиционной
терминологией и называть такие действия требующими привилегий суперпользователя.
По прошествии более чем 20 лет сформировались стандарты, которые можно считать достаточно зрелыми и устоявшимися. Стандарт POSIX.1 поддерживается открытой рабочей группой, известной как Austin Group (http://www.opengroup.org/
austin). Чтобы стандарты оставались актуальными, время от времени они должны
подтверждаться или обновляться.

66    Глава 2. Стандарты и реализации UNIX
Таблица 2.3. Заголовочные файлы расширений XSI, определяемые стандартом POSIX
FreeBSD
8.0

Linux
3.2.0

Mac OS X
10.6.8

Solaris
10

<fmtmsg.h>









Вывод сообщений в форматированном виде

<ftw.h>









Обход дерева файлов (раздел 4.21)

<libgen.h>









Определения для функций
поиска по шаблону

<ndbm.h>







Операции с базой данных
(стандарта dbm)

<search.h>









Поиск по таблицам

<syslog.h>









Системное журналирование
(раздел 13.4)







Работа с учетными записями
пользователей

Заголовочный файл

<utmpx.h>

Описание

<sys/ipc.h>









IPC (раздел 15.6)

<sys/msg.h>









Очереди сообщений (15.7)

<sys/resource.h>









Операции c ресурсами (раздел 7.11)

<sys/sem.h>









Семафоры (15.8)

<sys/shm.h>









Разделяемая память (раздел 15.9)

<sys/time.h>









Типы данных для хранения
времени

<sys/uio.h>









Векторные операции ввода/
вывода (раздел 14.7)

2.2.3. Single UNIX Specification
Single Unix Specification (Единая спецификация UNIX)  — это надмножество
стандарта POSIX.1 и  определяет дополнительные интерфейсы, расширяющие
возможности, предоставляемые базовой спецификацией POSIX.1. Стандарт
POSIX.1 является эквивалентом раздела Base Specification (базовые спецификации) спецификации Single UNIX Specification.
Расширение X/Open System Interface (XSI) определяет дополнительные интерфейсы POSIX.1, которые должны поддерживаться реализацией, чтобы она получила право именоваться «XSI-совместимой». В их число входят: синхронизация
файлов, адрес и размер стека потока, синхронизация потоков между процессами
и  символьная константа _XOPEN_UNIX (все они отмечены в  табл. 2.5 как «Обязательные для SUS»). Только XSI-совместимые реализации могут называться операционными системами UNIX.

2.2. Стандартизация UNIX   

67

Торговая марка UNIX принадлежит The Open Group, которая использует единую спецификацию UNIX для определения интерфейсов, обязательных для реализации в системе, чтобы
она получила право называться системой UNIX. Для получения лицензии на право использования торговой марки UNIX реализация должна пройти серию тестов на соответствие.
Таблица 2.4. Необязательные заголовочные файлы, определяемые стандартом POSIX
Заголовочный файл

FreeBSD
8.0

Linux
3.2.0

Mac OS X
10.6.8

Solaris
10

<mqueue.h>









Очереди сообщений

<spawn.h>









Интерфейс запуска программ
в системах реального времени

Описание

Таблица 2.5. Необязательные группы интерфейсов POSIX.1 и их коды
Код

Обязательные
для SUS

Символическая константа

Описание

ADV

_POSIX_ADVISORY_INFO

Консультативная информация
(расширение реального времени)

CPT

_POSIX_CPUTIME

Измерение времени работы
процесса (расширение реального
времени)

_POSIX_FSYNC

Синхронизация файлов

IP6

_POSIX_IPV6

Интерфейсы IPv6

ML

_POSIX_MEMLOCK

Блокировка памяти процесса
(расширение реального времени)

MLК

_POSIX_MEMLOCK_RANGE

Блокировка области памяти
(расширение реального времени)

MON

_POSIX_MONOTONIC_CLOCK

Монотонные часы (расширение
реального времени)

MSG

_POSIX_MESSAGE_PASSING

Передача сообщений (расширение реального времени)

MX

__STDC_IEC_559_ _

Дополнение с плавающей запятой, соответствующее IEC 60599

PIO

_POSIX_PRIORITIZED_IO

Приоритетный ввод/вывод

PS

_POSIX_PRIORITY_SCHEDULING

Планирование процессов (расширение реального времени)

RPI

_POSIX_THREAD_ROBUST_PRIO_INHERIT

Наследование приоритета надежных мьютексов (расширение
реального времени)

RPP

_POSIX_THREAD_ROBUST_PRIO_PROTECT

Защита приоритета надежных
мьютексов (расширение реального времени)

FSC



68    Глава 2. Стандарты и реализации UNIX
Таблица 2.5 (окончание)
Код

Обязательные
для SUS

Символическая константа

Описание

RS

_POSIX_RAW_SOCKETS

Низкоуровневые сокеты

SHM

_POSIX_SHARED_MEMORY_OBJECTS

Объекты разделяемой памяти
(расширение реального времени)

SIO

_POSIX_SYNCHRONIZED_IO

Синхронизированный ввод/
вывод (расширение реального
времени)

SPN

_POSIX_SPAWN

Запуск процессов (расширение
реального времени)

SS

_POSIX_SPORADIC_SERVER

Сервер непериодических (спорадических) процессов (расширение реального времени)

TCT

_POSIX_THREAD_CPUTIME

Измерение процессорного времени для потоков (расширение
реального времени)

TPI

_POSIX_THREAD_PRIO_INHERIT

Наследование приоритета потока
(расширение реального времени)

TPP

_POSIX_THREAD_PRIO_PROTECT

Защита приоритета потока (расширение реального времени)

TPS

_POSIX_THREAD_PRIORITY_SCHEDULING

Планирование выполнения потоков (расширение реального
времени)



_POSIX_THREAD_ATTR_STACKADDR

Адрес стека потока



_POSIX_THREAD_PROCESS_SHARED

Синхронизация потоков между
процессами

_POSIX_THREAD_SPORADIC_SERVER

Сервер непериодических (спорадических) потоков (расширение
реального времени)

_POSIX_THREAD_ATTR_STACKSIZE

Размер стека потока

_POSIX_TYPED_MEMORY_OBJECTS

Типизированная память (расширение реального времени)

_XOPEN_UNIX

Интерфейсы расширений
X/Open

TSA
TSH
TSP

TSS



TYM
XSI



Интерфейсы, необязательные для XSI-совместимых систем, делятся на необязательные группы по функциональному признаку:
 Шифрование: обозначаются символьной константой _XOPEN_CRYPT;
 Расширения реального времени: обозначаются символьной константой
_XOPEN_REALTIME;

2.2. Стандартизация UNIX   

69

 Дополнения реального времени;
 Потоки реального времени: обозначаются символьной константой _XOPEN_
REALTIME_THREADS;
 Дополнения к потокам реального времени.
Единая спецификация UNIX (SUS) публикуется организацией The Open Group,
сформировавшейся в  1996 году в  результате слияния X/Open и  Open Software
Foundation (OSF). X/Open принадлежит издание «X/Open Portability Guide»
(Руководство X/Open по переносимости), которое заимствовало определенные
стандарты и заполнило пробелы, связанные с отсутствующими функциональными возможностями. Целью этих руководств было повышение переносимости прикладных программ, которое стало возможным благодаря простому следованию
опубликованным стандартам.
Первая версия Single UNIX Specification была издана X/Open в 1994 году. Она известна также под названием «Spec 1170», поскольку содержала примерно 1170 интерфейсов. Своими корнями она уходит в  инициативу Common Open Software
Environment (COSE — Общая открытая программная среда), цель которой состояла в том, чтобы еще больше повысить переносимость приложений между различными реализациями UNIX. Группа COSE — Sun, IBM, HP, Novell/USL и OSF —
шагнула значительно дальше простого одобрения стандартов. Дополнительно она
исследовала интерфейсы, обычно используемые коммерческими приложениями.
В  результате были отобраны 1170 интерфейсов и  включены в  X/Open Common
Application Environment, Issue 4 (CAE  — Общая среда приложений, известная
также как XPG4, поскольку исторически ее предшественником было руководство X/Open Portability Guide), System V Interface Definition, Issue  3 (SVID  —
Определение интерфейса System V) и OSF Application Environment Specification
(AES — Спецификация среды приложений).
Вторая версия Single UNIX Specification была издана The Open Group в 1997 году.
В новую версию была добавлена поддержка потоков, интерфейсов реального времени, 64-разрядной арифметики, файлов большого размера и многобайтных символов.
Третья версия Single UNIX Specification (сокращенно — SUSv3) была опубликована The Open Group в 2001 году. Базовые спецификации SUSv3 те же, что и в стандарте IEEE Standard 1003.1-2001, и  разделяются на четыре категории: «Основные определения», «Системные интерфейсы», «Командная оболочка и утилиты»
и «Обоснование». SUSv3 также включает в себя X/Open Curses Issue 4, Version 2,
но эта спецификация не является частью POSIX.1.
В 2002 году Международная организация по стандартизации одобрила эту версию
как международный стандарт ISO/IEC 9945:2002. В  2003 году The Open Group
снова обновила стандарт 1003.1, добавив в  него исправления технического характера, после чего ISO одобрила его как ISO/IEC 9945:2003. В апреле 2004 года
The Open Group опубликовала Single UNIX Specification, Version 3, 2004 Edition.
В нее были включены дополнительные технические исправления основного текста стандарта.
В 2008 году в  спецификацию Single UNIX Specification внесены исправления,
добавлены новые и  удалены устаревшие интерфейсы, а  некоторые интерфейсы

70    Глава 2. Стандарты и реализации UNIX
отмечены как устаревшие, в  подготовке к  удалению в  будущем. Кроме того, некоторым, прежде необязательным, интерфейсам присвоен статус обязательных,
включая асинхронный ввод/вывод, барьеры, выбор тактового генератора, отображение файлов в память, защита памяти, блокировки чтения/записи, сигналы
реального времени, семафоры POSIX, циклические блокировки (spin locks), потокобезопасные функции, потоки выполнения, тайм-ауты и  таймеры. Получившийся стандарт известен как Base Specifications Issue 7 (базовые спецификации,
выпуск  7) и  в  точности соответствует POSIX.1-2008. Организация The Open
Group объединила эту версию с  обновленной спецификацией X/Open Curses
и в 2010 году выпустила их в виде версии 4 спецификации Single UNIX. Мы будем
называть ее SUSv4.

2.2.4. FIPS
Аббревиатура FIPS означает Federal Information Processing Standard (Федеральный стандарт обработки информации). Этот стандарт опубликован правительством США, которое использовало его при покупке компьютерных систем. Стандарт FIPS 151-1 (апрель 1989 года) основан на IEEE Std. 1003.1-1988 и на проекте
стандарта ANSI C. За ним последовал FIPS 151-2 (май 1993 года) на основе IEEE
Standard 1003.1-1990. FIPS 151-2 требовал наличия некоторых возможностей,
которые стандартом POSIX.1 объявлены необязательными. Все они стали обязательными в стандарте POSIX.1-2001.
В результате любой производитель, желавший продавать POSIX.1-совместимые
компьютерные системы американскому правительству, должен поддерживать некоторые дополнительные особенности POSIX.1. Позднее стандарт POSIX.1 FIPS
был отменен, поэтому мы больше не будем возвращаться к нему в этой книге.

2.3. Реализации UNIX
В предыдущем разделе были описаны ISO C, IEEE POSIX и  Single UNIX
Specification — три стандарта, разработанные независимыми организациями. Однако стандарты — это лишь спецификации интерфейса. А как они связаны с реальностью? Производители воплощают эти стандарты в конкретные реализации.
Нам интересны не только сами стандарты, но и их воплощение.
В разделе 1.1 [McKusick et al., 1996] приводится подробная (и отлично иллюстрированная) история генеалогического дерева UNIX. Все началось с 6-й (1976) и 7-й
(1979) редакций UNIX Time-Sharing System для PDP-11 (обычно они именуются
Version 6 и Version 7). Они стали первыми версиями, получившими широкое распространение за пределами Bell Laboratories. Начали самостоятельно развиваться
три ветви UNIX.
1.	 Одна — в AT&T — привела к появлению System III и System V (так называемые коммерческие версии UNIX).
2.	 Другая — в Калифорнийском университете города Беркли — привела к появлению реализаций 4.xBSD.

2.3. Реализации UNIX   

71

3.	 Третья  — исследовательская версия UNIX, которая продолжала разрабатываться в  исследовательском центре вычислительной техники (Computing
Science Research Center) в  AT&T Bell Laboratories,  — привела к  появлению
UNIX Time-Shared System 8-й и 9-й редакций и завершилась выходом 10-й редакции в 1990 году.

2.3.1. UNIX System V Release 4
Версия UNIX System V Release 4 (SVR4) была выпущена подразделением AT&T —
UNIX System Laboratories (USL, ранее — UNIX Software Operation). Версия SVR4
объединила функциональность AT&T UNIX System Release 3.2 (SVR3.2), SunOS —
операционной системы от Sun Microsystems, 4.3BSD, выпущенной Калифорнийским университетом, и Xenix — операционной системы от корпорации Microsoft —
в  единую операционную систему. (Изначально Xenix разрабатывалась на основе
7-й редакции и позднее вобрала в себя многие особенности, присущие System V.)
Исходные тексты SVR4 были опубликованы в конце 1989 года, а первые копии стали доступны конечным пользователям в 1990 году. Реализация SVR4 соответствовала как стандарту POSIX 1003.1, так и X/Open Portability Guide, Issue 3 (XPG3).
Корпорация AT&T также опубликовала «System V Interface Definition» (SVID,
Определение интерфейса System V) [AT&T, 1989]. Выпуск 3 SVID определил функциональные возможности, которые должны поддерживаться операционной системой, чтобы она могла быть квалифицирована как реализация, соответствующая
System V Release 4. Как и в случае с POSIX.1, SVID определяет интерфейс, но не
реализацию. В SVID не проводится различий между системными вызовами и библиотечными функциями. Чтобы обнаружить эти различия, необходимо обращаться к  справочному руководству по фактической реализации SVR4 [AT&T, 1990e].

2.3.2. 4.4BSD
Версии Berkeley Software Distribution (BSD) разрабатывались и  распространялись Computer Systems Research Group (CSRG) — Группой исследования компьютерных систем Калифорнийского университета в  Беркли. Версия 4.2BSD была
выпущена в 1983-м, а 4.3BSD — в 1986 году. Обе версии работали на мини-компьютерах VAX. Следующая версия, 4.3BSD Tahoe, была выпущена в 1988 году и также работала на специфическом мини-компьютере под названием Tahoe. (Книга
Леффлера (Leffler) и др. [1989] описывает версию 4.3BSD Tahoe.) В 1990 году последовала версия 4.3BSD Reno, которая поддерживала большую часть функциональных возможностей, определяемых стандартом POSIX.1.
Изначально BSD-системы содержали исходный код, запатентованный AT&T,
и подпадали под действие лицензий AT&T. Чтобы получить исходный код BSDсистемы, требовалась лицензия AT&T на UNIX. С тех пор положение вещей изменилось, так как на протяжении нескольких лет все больше исходного кода AT&T
замещалось кодом сторонних разработчиков; кроме того, в  системе появилось
много новых функциональных возможностей, исходный код которых был получен из других источников.

72    Глава 2. Стандарты и реализации UNIX
В 1989 году большая часть кода в версии 4.3BSD Tahoe, не принадлежащего AT&T,
была идентифицирована и  выложена в  публичный доступ под названием BSD
Networking Software, Release 1.0. Затем, в  1991 году, последовал второй выпуск
BSD Networking Software (Release 2.0), который был развитием версии 4.3BSD
Reno. Основная цель состояла в том, чтобы освободить большую часть или даже
всю систему 4.4BSD от любых лицензионных ограничений AT&T, сделав исходные тексты общедоступными.
Версия 4.4BSD-Lite должна была стать заключительным релизом CSRG. Однако
ее официальный выпуск был отложен из-за юридических споров с USL. Как только в 1994 году юридические разногласия были устранены, вышла полностью свободная 4.4BSD-Lite и с этого момента, чтобы получить ее, не требовалось приобретать какие-либо лицензии на исходные тексты UNIX. Вслед за этим, в 1995 году,
CSRG выпустила вторую, исправленную версию. Второй выпуск 4.4BSD-Lite
стал заключительной версией BSD от CSRG. (Эта версия BSD описана в книге
Мак-Кьюсика [1996].)
Разработка операционной системы UNIX в  Беркли началась с  PDP-11, переместилась на мини-компьютеры VAX и затем на так называемые рабочие станции.
В  первой половине 90-х годов была добавлена поддержка популярных персональных компьютеров, собранных на базе микропроцессора 80386, что привело
к  появлению версии 386BSD. Реализация была выполнена Биллом Джолитцом
(Bill Jolitz) и описана в серии ежемесячных статей в журнале «Dr. Dobb’s Journal»
за 1991  год. Значительная часть исходного кода была заимствована из BSD
Networking Software, Release 2.0.

2.3.3. FreeBSD
Операционная система FreeBSD базируется на 4.4BSD-Lite. Проект FreeBSD
образован с  целью дальнейшего развития линейки BSD-систем после того, как
в Беркли было принято решение о прекращении работ над BSD-версиями операционной системы UNIX и проект 386BSD оказался заброшенным.
Все программное обеспечение, разработанное в  рамках проекта FreeBSD, является свободно распространяемым как в исходных текстах, так и в виде бинарных
дистрибутивов. ОС FreeBSD 8.0 стала одной из четырех платформ, на которых
тестировались примеры для данной книги.
Существует еще несколько свободных операционных систем, основанных на BSD. Проект
NetBSD (http://www.netbsd.org) аналогичен проекту FreeBSD, основной акцент в нем сделан
на переносимости между различными аппаратными платформами. Проект OpenBSD
(http://www.openbsd.org) также аналогичен FreeBSD, но с акцентом на безопасности.

2.3.4. Linux
Linux  — это операционная система, которая предоставляет все богатства программного окружения UNIX и свободно распространяется в соответствии с Общественной лицензией GNU (GNU Public License). Популярность Linux  — это

2.3. Реализации UNIX   

73

нечто феноменальное в компьютерной индустрии. Linux часто отличается тем, что
первой из операционных систем начинает поддерживать новейшие аппаратные
решения.
ОС Linux была создана Линусом Торвальдсом в 1991 году в качестве замены ОС
MINIX. Семена дали быстрые всходы, и множество разработчиков по всему миру
добровольно взялись за работу по ее улучшению.
Дистрибутив Ubuntu 12.04 стал одной из систем, на которых тестировались примеры из этой книги. В этом дистрибутиве используется ядро Linux версии 3.2.0.

2.3.5. Mac OS X
Mac OS X отличается от предыдущих версий этой системы тем, что основана на
совершенно иных технологиях. Ее ядро называется «Darwin» и представляет собой комбинацию ядра Mach [Accetta et al., 1986], ОС FreeBSD и объектно-ориентированного фреймворка для драйверов и других расширений ядра. Версия Mac
OS X 10.5, портированная на архитектуру Intel, была сертифицирована как UNIXсистема. (Дополнительную информацию о сертификации UNIX-систем вы найдете по адресу http://www.opengroup.org/certification/idx/unix.html.)
Mac OS X 10.6.8 (Darwin 10.8.0) использовалась как одна из тестовых платформ
при написании этой книги.

2.3.6. Solaris
Solaris  — это разновидность ОС UNIX, разработанная в  Sun Microsystems. Основанная на System V Release 4, она совершенствовалась инженерами из Sun
Microsystems более 10 лет. Это единственный коммерчески успешный потомок
SVR4, формально сертифицированный как UNIX-система.
В 2005 году Sun Microsystems открыла большую часть исходных текстов ОС
Solaris в  рамках проекта открытой ОС OpenSolaris с  целью создать сообщество
сторонних разработчиков.
Версия Solaris 10 UNIX использовалась при написании этой книги в качестве одной из тестовых платформ.

2.3.7. Прочие версии UNIX
Среди прочих операционных систем, сертифицированных как UNIX-системы,
можно назвать:
 AIX, версия UNIX от IBM;
 HP-UX, версия UNIX от Hewlett-Packard;
 IRIX, UNIX-система, распространяемая компанией Silicon Graphics;
 UnixWare, версия UNIX, которая происходит от SVR4 и  продается корпорацией SCO.

74    Глава 2. Стандарты и реализации UNIX

2.4. Связь между стандартами
и реализациями
Упомянутые стандарты определяют подмножество любой фактически существующей системы. Основное внимание в  этой книге будет уделяться четырем операционным системам: FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 и Solaris 10. Несмотря на то что только Mac OS X и Solaris могут называться UNIX-системами,
все четыре предоставляют похожую программную среду. Поскольку все четыре
системы в  различной степени являются POSIX-совместимыми, мы сосредоточимся на тех функциональных возможностях, которые считаются обязательными
в соответствии со стандартом POSIX.1, указывая любые различия между POSIX
и фактической реализацией в этих системах. Особенности и технические приемы,
характерные только для конкретной реализации, будут отмечены особо. Мы также обратим внимание на любые особенности, обязательные для UNIX-систем, но
необязательные для POSIX-совместимых систем.
Следует отметить, что реализации обеспечивают обратную совместимость по
функциональным особенностям с  более ранними версиями, такими как SVR3.2
и  4.3BSD. Например, Solaris поддерживает неблокирующие операции ввода/
вывода (O_NONBLOCK), определяемые стандартом POSIX.1, и  традиционный для
System V метод (O_NDELAY). В этой книге мы будем говорить о тех характеристиках, которые предписываются стандартом POSIX.1, и при этом лишь иногда упоминать нестандартные особенности, сохраняемые для обратной совместимости.
Например, SVR3.2 и 4.3BSD реализуют механизм надежных сигналов способом,
который отличается от стандарта POSIX.1. В главе 10 мы опишем только сигналы
POSIX.1.

2.5. Ограничения
Реализации определяют множество системных кодов и констант. Многие из них
жестко зашиты в  тексты программ, для получения других используются специальные методы. Благодаря описанной выше деятельности по стандартизации, сейчас преобладают более универсальные методы определения значений констант
и предусматриваемых реализациями ограничений, что очень помогает в разработке переносимого программного обеспечения.
Существует два типа ограничений.
1.	 Пределы времени компиляции (например, наибольшее значение, которое может принимать переменная типа short int).
2.	 Пределы времени выполнения (например, максимальная длина имени файла).
Пределы времени компиляции могут определяться в заголовочных файлах, которые подключаются программой на этапе компиляции. Но пределы времени выполнения требуют, чтобы процесс получил их значения, вызвав соответствующие
функции.

2.5. Ограничения   

75

Таблица 2.6. Пределы значений целочисленных типов из файла <limits.h>
Имя

Описание

CHAR_BIT

Количество бит на
символ

CHAR_MAX

Минимальное значение

Типовое значение

8

8

Максимальное значение типа char

(см. ниже)

127

CHAR_MIN

Минимальное значение типа char

(см. ниже)

–128

SCHAR_MAX

Максимальное значение типа signed char

127

127

SCHAR_MIN

Минимальное значение типа signed char

–127

–128

UCHAR_MAX

Максимальное значение типа unsigned char

255

255

INT_MAX

Максимальное значение типа int

32 767

2 147 483 647

INT_MIN

Минимальное значение типа int

–32 767

–2 147 483 648

UINT_MAX

Максимальное значение типа unsigned int

65 535

4 294 967 295

SHRT_MAX

Максимальное значение типа short

32 767

32 767

SHRT_MIN

Минимальное значение типа short

–32 767

–32 768

USHRT_MAX

Максимальное значение типа unsigned

65 535

65 535

2 147 483 647

2 147 483 647

–2 147 483 647

–2 147 483 648

4 294 967 295

4 294 967 295

9 223 372 036 854 775 807

9 223 372 036 854 775 807

short
LONG_MAX

Максимальное значение типа long

LONG_MIN

Минимальное значение типа long

ULONG_MAX

Максимальное значение типа unsigned long

LLONG_MAX

Максимальное значение типа long long

LLONG_MIN

Минимальное значение типа long long

–9 223 372 036 854 775 807 –9 223 372 036 854 775 808

ULLONG_MAX

Максимальное значение типа unsigned long

18 446 744 073 709 551 615 18 446 744 073 709 551 615

long
MB_LEN_MAX

Максимальное число
байтов в многобайтных
символах

1

6

76    Глава 2. Стандарты и реализации UNIX
Кроме того, некоторые пределы в одной реализации имеют фиксированные значения и могут определяться статически, в заголовочных файлах. В других реализациях они могут варьироваться, из-за чего для получения их значений требуется обращаться к  соответствующим функциям во время выполнения. Примером
предела такого типа может служить максимальная длина имени файла. System V
до появления SVR4 ограничивала длину имени файла 14 символами, тогда как
BSD-системы увеличили это значение до 255 символов. Сегодня большинство
реализаций UNIX поддерживают множество различных типов файловых систем,
и каждая из них имеет свои пределы — это случай предела времени выполнения,
который зависит от того, в какой файловой системе находится рассматриваемый
файл. Например, корневая файловая система может ограничивать длину имени
файла 14 символами, тогда как в другой файловой системе это ограничение может
составлять 255 символов.
Для решения этих проблем существует три типа ограничений.
1.	 Пределы времени компиляции (заголовочные файлы).
2.	 Пределы времени выполнения, не связанные с  файлами или каталогами
(функция sysconf).
3.	 Пределы времени выполнения, связанные с файлами или каталогами (функции pathconf и fpathconf).
Еще большая путаница возникает, если конкретный предел времени выполнения
не изменяется в данной системе. В этом случае он может быть определен статически в заголовочном файле. Но если он не определен в заголовочном файле, тогда
приложение должно вызвать одну из трех функций conf (которые вскоре будут
описаны), чтобы определить его значение во время выполнения.

2.5.1. Пределы ISO C
Все пределы, определяемые стандартом ISO C, являются пределами времени компиляции. В табл. 2.6 приведены пределы, задаваемые стандартом языка C и определенные в файле <limits.h>. Эти константы всегда определяются заголовочным
файлом и не изменяются. В третьей колонке указаны минимально допустимые значения, определяемые стандартом ISO C. Они были выбраны с учетом 16-разрядной
целочисленной арифметики с поразрядным дополнением до единицы. В четвертой
колонке приводятся значения для системы Linux, использующей 32-разрядную целочисленную арифметику с поразрядным дополнением до двойки. Обратите внимание, что для целочисленных типов без знака не приводится минимальное значение, так как оно всегда будет равно 0. В  64-разрядных системах максимальное
значение типа long соответствует максимальному значению типа long long.
Одно из различий между системами, с которым мы столкнемся: как система представляет тип char со знаком или без него. В четвертой колонке табл. 2.6 мы видим, что в  данной системе тип char представлен как целое со знаком. Значение
константы CHAR_MIN эквивалентно SCHAR_MIN, а  CHAR_MAX эквивалентно SCHAR_MAX.
Если тип char в системе представляется как целое без знака, следовательно, значение CHAR_MIN будет равно 0, а CHAR_MAX — UCHAR_MAX.

2.5. Ограничения   

77

Предельные значения для типов чисел с плавающей запятой аналогично определяются в заголовочном файле <float.h>. Каждый, кто всерьез занимается вычислениями с плавающей запятой, должен ознакомиться с содержимым этого файла.
Хотя стандарт ISO C определяет минимально допустимые значения для целочисленных типов, POSIX.1 вносит свои дополнения в  стандарт языка C. Чтобы соответствовать требованиям POSIX.1, реализация должна поддерживать
константу INT_MAX со значением 2  147  483  647, константу INT_MIN со значением
–2 147 483 647 и константу UINT_MAX со значением 4 294 967 295. Так как POSIX.1
требует от реализаций обеспечить поддержку 8-разрядного типа char, константа
CHAR_BIT должна иметь значение 8, SCHAR_MIN — значение –128, SCHAR_MAX — значение 127 и UCHAR_MAX — значение 255.
Еще одна константа из стандарта ISO C, с которой мы встретимся, — это FOPEN_
MAX. Она определяет гарантированное системой минимальное количество стандартных потоков ввода/вывода, которые могут быть открыты одновременно. Это
значение хранится в  заголовочном файле <stdio.h> и  не может быть меньше 8.
Согласно стандарту POSIX.1 константа STREAM_MAX, если таковая определена,
должна иметь то же значение.
В файле <stdio.h> стандарт ISO C определяет также константу TMP_MAX. Это максимальное количество уникальных имен файла, которые могут быть сгенерированы функцией tmpnam. Более подробно мы поговорим об этом в разделе 5.13.
Хотя стандарт ISO C определяет константу FILENAME_MAX, мы постараемся не использовать ее, потому что в стандарте POSIX.1 определена более удачная альтернатива (NAME_MAX и PATH_MAX). Мы познакомимся с этими константами чуть ниже.
В табл. 2.7 приводятся значения FOPEN_MAX и TMP_MAX для всех четырех платформ,
обсуждаемых в данной книге.
Таблица 2.7. Пределы, определяемые стандартом ISO для различных платформ
Предел
FOPEN_MAX
TMP_MAX
FILENAME_MAX

FreeBSD 8.0

Linux 3.2.0

Mac OS X 10.6.8

Solaris 10

20

16

20

20

308 915 776

238 328

308 915 776

17 576

1 024

4 096

1 024

1 024

2.5.2. Пределы POSIX
Стандарт POSIX.1 определяет многочисленные константы, связанные с предельными значениями. К сожалению, это один из самых запутанных аспектов POSIX.1.
Хотя POSIX.1 определяет огромное количество констант и предельных значений,
мы остановимся лишь на тех из них, которые затрагивают базовые интерфейсы
POSIX.1. Эти пределы и константы делятся на следующие категории.
1.	 Пределы числовых значений: LONG_BIT, SSIZE_MAX и WORD_BIT.
2.	 Минимальные значения: 25 констант, перечисленных в табл. 2.8.
3.	 Максимальное значение: _POSIX_CLOCKRES_MIN.

78    Глава 2. Стандарты и реализации UNIX
4.	 Значения, которые можно увеличить во время выполнения: CHARCLASS_NAME_
MAX, COLL_WEIGHTS_MAX, LINE_MAX, NGROUPS_MAX и RE_DUP_MAX.
5.	 Значения, не изменяемые во время выполнения, возможно, неопределенные:
17 констант, перечисленных в табл. 2.9 (плюс еще четыре константы, описываемые в разделе 12.2, и три константы, описываемые в разделе 14.5).
6.	 Другие неизменяемые значения: NL_ARGMAX, NL_MSGMAX, NL_SETMAX и NL_TEXTMAX.
7.	 Изменяемые значения, связанные с размером строки пути: FILESIZEBITS, LINK_
MAX, MAX_CANON, MAX_INPUT, NAME_MAX, PATH_MAX, PIPE_BUF и SYMLINK_MAX.
Таблица 2.8. Минимальные значения из файла <limits.h>, определяемые
стандартом POSIX.1
Имя

Описание: минимально допустимое значение
для максимального значения...

Значение

_POSIX_ARG_MAX

Длины аргументов функций exec

_POSIX_CHILD_MAX

Количества дочерних процессов на реальный идентификатор пользователя

25

_POSIX_DELAYTIMER_MAX

Количества переполнений каждого таймера

32

_POSIX_HOST_NAME_MAX

Длины имени сетевого узла, возвращаемого функцией

_POSIX_LINK_MAX

Количества ссылок на один файл

8

_POSIX_LOGIN_NAME_MAX

Длины имени пользователя

9

_POSIX_MAX_CANON

Количества байтов в канонической входной очереди
терминала

255

_POSIX_MAX_INPUT

Количества байтов, доступных во входной очереди
терминала

255

_POSIX_NAME_MAX

Количества байтов в имени файла, за исключением завершающего нулевого символа

14

_POSIX_NGROUPS_MAX

Количества идентификаторов дополнительных групп
на процесс

8

_POSIX_OPEN_MAX

Количества открытых файлов на процесс

_POSIX_PATH_MAX

Длины строки пути к файлу, включая завершающий
нулевой символ

256

_POSIX_PIPE_BUF

Количества байтов, которые можно атомарно записать
в канал

512

_POSIX_RE_DUP_MAX

Количества повторяющихся вхождений для основного
регулярного выражения, принимаемого функциями
regexec и regcomp, при использовании интервальной
нотации \{m, n\}

255

_POSIX_RTSIG_MAX

Количества сигналов реального времени, зарезервированных для приложения

8

_POSIX_SEM_NSEMS_MAX

Количества семафоров, одновременно используемых
процессом

gethostname

4096

255

20

256

2.5. Ограничения   

Имя

Описание: минимально допустимое значение
для максимального значения...

79

Значение

_POSIX_SEM_VALUE_MAX

Значения, которые может хранить семафор

_POSIX_SIGQUEUE_MAX

Количества сигналов, которые процесс может поставить в очередь ожидания обработки

_POSIX_SSIZE_MAX

Значения, которые можно сохранить в переменной
типа ssize_t

_POSIX_STREAM_MAX

Количества стандартных потоков ввода/вывода
на процесс

_POSIX_SYMLINK_MAX

Количества байтов в символической ссылке

_POSIX_SYMLOOP_MAX

Количества переходов по символическим ссылкам, допустимого в строке пути

_POSIX_TIMER_MAX

Количества таймеров в процессе

_POSIX_TTY_NAME_MAX

Длины имени терминального устройства, включая завершающий нулевой символ

9

_POSIX_TZNAME_MAX

Количества байтов в имени временной зоны

6

32 767
32
32 767
8
255
8
32

Некоторые из этих пределов и  констант могут быть определены в  файле
<limits.h>, другие могут быть не определены — в зависимости от некоторых условий. Пределы и константы, которые необязательно должны быть определены, мы
рассмотрим в  разделе 2.5.4, когда будем говорить о  функциях sysconf, pathconf
и fpathconf.
В табл. 2.8 перечислено 25 неизменяемых минимальных значений. Эти значения
являются неизменяемыми и не зависят от конкретной реализации операционной
системы. Они задают самые строгие ограничения на функциональные возможности. Реализации, претендующие на звание POSIX-совместимых, должны обеспечивать значения не ниже указанных. Именно поэтому они называются минимально допустимыми, хотя в их именах присутствует окончание MAX. Кроме того,
чтобы обеспечить максимальную переносимость, приложения, строго следующие
стандарту, не должны требовать более высоких значений. Описания этих констант
мы будем приводить по мере знакомства с ними.
Приложения, строго следующие стандарту POSIX, отличаются от просто POSIXсовместимых приложений. Последние используют только интерфейсы, определяемые
стандартом IEEE Standard 1003.1-2008. Приложение, строго следующее стандарту, —
это POSIX-совместимое приложение, которое не полагается ни на какое не определенное
в стандарте поведение, не использует никаких устаревающих интерфейсов и не требует
значений констант больших, чем минимумы, перечисленные в табл. 2.8.

К сожалению, некоторые из этих неизменяемых минимальных значений слишком
малы, чтобы использоваться на практике. Например, большинство современных
UNIX-систем позволяет открывать намного больше 20 файлов на процесс. Минимальный предел 256 для _POSIX_PATH_MAX также слишком мал. Длина строки пути
может превысить это значение, то есть мы не можем использовать константы _POSIX_
OPEN_MAX и _POSIX_PATH_MAX в качестве размеров массивов на этапе компиляции.

80    Глава 2. Стандарты и реализации UNIX
Таблица 2.9. Значения времени выполнения из файла <limits.h>, определяемые
стандартом POSIX.1
Имя предела

Описание

Минимально допустимое
значение

ARG_MAX

Максимальная длина аргументов функций
семейства exec (в байтах)

_POSIX_ARG_MAX

ATEXIT_MAX

Максимальное количество функций, которые
можно зарегистрировать с помощью функции

32

CHILD_MAX

Максимальное число дочерних процессов на
один реальный идентификатор пользователя

_POSIX_CHILD_MAX

DELAYTIMER_MAX

Максимальное количество переполнений
таймера

_POSIX_DELAYTIMER_MAX

HOST_NAME_MAX

Максимальная длина имени сетевого узла,
возвращаемого функцией gethostname

_POSIX_HOST_NAME_MAX

LOGIN_NAME_MAX

Максимальная длина имени пользователя

_POSIX_LOGIN_NAME_MAX

OPEN_MAX

Значение, на единицу больше максимального, которое можно присвоить файловому
дескриптору

_POSIX_OPEN_MAX

PAGESIZE

Размер страницы памяти системы (в байтах)

1

RTSIG_MAX

Максимальное количество сигналов реального
времени, зарезервированных для приложения

_POSIX_RTSIG_MAX

SEM_NSEMS_MAX

Максимальное количество семафоров, одновременно используемых процессом

_POSIX_SEM_NSEMS_MAX

SEM_VALUE_MAX

Максимальное значение семафора

_POSIX_SEM_VALUE_MAX

SIGQUEUE_MAX

Максимальное количество сигналов, которые
процесс может поставить в очередь

_POSIX_SIGQUEUE_MAX

STREAM_MAX

Максимальное число стандартных потоков
ввода/вывода, которые процесс может открыть одновременно

_POSIX_STREAM_MAX

SYMLOOP_MAX

Максимальное количество символических
ссылок, которые можно пройти в процессе
анализа пути к файлу

_POSIX_SYMLOOP_MAX

TIMER_MAX

Максимальное количество таймеров в процессе

_POSIX_TIMER_MAX

TTY_NAME_MAX

Максимальная длина имени терминального
устройства, включая завершающий нулевой
символ

_POSIX_TTY_NAME_MAX

TZNAME_MAX

Количество байтов в имени временной зоны

_POSIX_TZNAME_MAX

atexit

В табл. 2.8 каждому из 25 неизменяемых минимальных значений соответствует
значение, зависящее от реализации, имя которого отличается отсутствием приставки _POSIX_. Константы без приставки _POSIX_ предназначены для хранения

2.5. Ограничения   

81

фактических значений, поддерживаемых конкретной реализацией. (Эти 25 констант, значения которых определяются реализацией, перечислены в пунктах 1, 4,
5 и 7 списка, приведенного выше: 2 значения, которые можно увеличить во время
выполнения, 15 неизменяемых значений времени выполнения и  7 изменяемых
значений, связанных с размером строки пути.) Основная проблема в том, что не
все 25 значений, зависящих от реализации, обязательно будут определены в  заголовочном файле <limits.h>.
Например, определение конкретного значения может отсутствовать в заголовочном файле, если его фактическая величина для данного процесса зависит от объема памяти в  системе. Если значения не определены в  заголовочном файле, их
нельзя использовать для задания границ массивов на этапе компиляции. Поэтому
стандарт POSIX.1 определяет функции sysconf, pathconf и fpathconf, с помощью
которых можно определить фактические значения пределов во время выполнения.
Однако существует еще одна проблема: некоторые значения определены стандартом POSIX.1 как «возможно неопределенные» (следовательно, бесконечные). Это
означает, что на практике значение не имеет верхней границы. Для Solaris, например, количество функций, которые можно зарегистрировать с  помощью atexit
для вызова по завершении процесса, ограничено только объемом доступной памяти. Поэтому предел ATEXIT_MAX для Solaris считается не определенным. Мы еще
вернемся к этой проблеме в разделе 2.5.5.

2.5.3. Пределы XSI
Стандарт XSI тоже определяет ряд констант, значения которых зависят от реализации.
1.	 Минимальные значения: 5 констант, перечисленных в табл. 2.10.
2.	 Числовые неизменяемые пределы времени выполнения, возможно неопределенные: IOV_MAX и PAGE_SIZE.
Минимальные значения перечислены в табл. 2.10. Две последние константы иллюстрируют ситуацию, когда минимумы, объявленные в стандарте POSIX.1, слишком
Таблица 2.10. Минимальные значения из файла <limits.h>, определяемые
стандартом XSI
Имя

Описание

Минимально
допустимое
значение

Типовое
значение

NL_LANGMAX

Максимальный размер переменной окружения LANG в байтах

14

14

NZERO

Приоритет процесса по умолчанию

20

20

_XOPEN_IOV_MAX

Максимальное количество структур iovec,
которое можно передать функциям readv
и writev

16

16

_XOPEN_NAME_MAX

Максимальная длина имени файла (в байтах)

255

255

_XOPEN_PATH_MAX

Максимальная длина строки пути к файлу
(в байтах)

1024

1024

82    Глава 2. Стандарты и реализации UNIX
малы (вероятно, чтобы сделать возможной реализацию POSIX-совместимых систем для встраиваемых устройств), поэтому для использования в XSI-совместимых
системах были добавлены увеличенные минимальные значения.

2.5.4. Функции sysconf, pathconf и fpathconf
Мы перечислили различные минимальные значения, которые должны поддерживаться реализацией, но как узнать фактические пределы, которые поддерживает
конкретная система? Как уже упоминалось выше, некоторые из этих пределов
можно определить на этапе компиляции, другие — во время выполнения. Мы также говорили, что некоторые из них являются неизменяемыми в данной системе,
тогда как другие, связанные с файлами или каталогами, могут изменяться. На этапе выполнения значения пределов можно получить с помощью одной из следующих трех функций.
#include <unistd.h>
long sysconf(int name);
long pathconf(const char *pathname, int name);
long fpathconf(int fd, int name);

Все три возвращают значение соответствующего предела в случае
успеха или –1 в случае ошибки (см. ниже)
Различие между двумя последними функциями состоит в том, что первая получает в аргументе строку пути к файлу, а вторая — файловый дескриптор.
В табл. 2.11 перечисляются значения аргумента name, которые можно передать
функции sysconf для идентификации пределов времени выполнения. Для идентификации пределов этой функции передаются константы, имена которых начинаются с префикса _SC_. В табл. 2.12 перечисляются значения аргумента name для
функций pathconf и  fpathconf. Для идентификации пределов времени выполнения этим функциям передаются константы, имена которых начинаются с префикса _PC_.
Таблица 2.11. Пределы и идентификаторы для аргумента name функции sysconf
Имя предела

Описание

Аргумент name

ARG_MAX

Максимальная длина аргументов функций
семейства exec (в байтах)

_SC_ARG_MAX

ATEXIT_MAX

Максимальное количество функций, которые
можно зарегистрировать с помощью функции

_SC_ATEXIT_MAX

Максимальное число процессов на один реальный идентификатор пользователя

_SC_CHILD_MAX

atexit
CHILD_MAX

2.5. Ограничения   

83

Имя предела

Описание

Аргумент name

Количество тактов
системных часов
в секунду

Количество тактов системных часов в секунду

_SC_CLK_TCK

COLL_WEIGHTS_MAX

Максимальное количество весовых коэффициентов для одного элемента категории LC_
COLLATE в файле региональных настроек

_SC_COLL_WEIGHTS_MAX

DELAYTIMER_MAX

Максимальное количество переполнений
таймера

_SC_DELAYTIMER_MAX

HOST_NAME_MAX

Максимальная длина имени сетевого узла, возвращаемого функцией gethostname

_SC_HOST_NAME_MAX

IOV_MAX

Максимальное количество структур iovec,
которое можно передать функциям readv
и writev

_SC_IOV_MAX

LINE_MAX

Максимальная длина строки ввода, принимаемой утилитами

_SC_LINE_MAX

LOGIN_NAME_MAX

Максимальная длина имени пользователя

_SC_LOGIN_NAME_MAX

NGROUPS_MAX

Максимальное количество идентификаторов
дополнительных групп на процесс

_SC_NGROUPS_MAX

OPEN_MAX

Значение, на единицу большее максимального,
которое можно присвоить файловому дескриптору

_SC_OPEN_MAX

PAGESIZE

Системный размер страницы памяти (в байтах)

_SC_PAGESIZE

PAGE_SIZE

Системный размер страницы памяти (в байтах)

_SC_PAGE_SIZE

RE_DUP_MAX

Максимальное количество повторяющихся
вхождений для основного регулярного выражения, принимаемого функциями regexec
и regcomp, при использовании интервальной
нотации \{m, n\}

_SC_RE_DUP_MAX

RTSIG_MAX

Максимальное количество сигналов реального
времени, зарезервированных для приложения

_SC_RTSIG_MAX

SEM_NSEMS_MAX

Максимальное количество семафоров, одновременно используемых процессом

_SC_SEM_NSEMS_MAX

SEM_VALUE_MAX

Максимальное значение семафора

_SC_SEM_VALUE_MAX

SIGQUEUE_MAX

Максимальное количество сигналов, которые
процесс может поставить в очередь

_SC_SIGQUEUE_MAX

STREAM_MAX

Максимальное число стандартных потоков
ввода/вывода на процесс в любой конкретный момент времени; если определен, должен
иметь значение, равное FOPEN_MAX

_SC_STREAM_MAX

SYMLOOP_MAX

Максимальное количество символических
ссылок, которые можно пройти в процессе
анализа пути к файлу

_SC_SYMLOOP_MAX

84    Глава 2. Стандарты и реализации UNIX
Таблица 2.11 (окончание)
Имя предела

Описание

Аргумент name

TIMER_MAX

Максимальное количество таймеров в процессе

_SC_TIMER_MAX

TTY_NAME_MAX

Максимальная длина имени терминального
устройства, включая завершающий нулевой
символ

_SC_TTY_NAME_MAX

TZNAME_MAX

Количество байтов в имени временной зоны

_SC_TZNAME_MAX

Таблица 2.12. Пределы и идентификаторы для аргумента name функций pathconf
и fpathconf
Имя предела

Описание

Аргумент name

FILESIZEBITS

Минимальное количество
битов, необходимое для
представления максимального размера обычного
файла, допустимого для
заданного каталога, в виде
целого значения со знаком

_PC_FILESIZEBITS

LINK_MAX

Максимальное значение
счетчика ссылок на один
файл

_PC_LINK_MAX

MAX_CANON

Максимальное количество
байтов в канонической входной очереди терминала

_PC_MAX_CANON

MAX_INPUT

Количества байтов, доступных во входной очереди
терминала

_PC_MAX_INPUT

NAME_MAX

Максимальная длина имени
файла в байтах (за исключением завершающего нулевого символа)

_PC_NAME_MAX

PATH_MAX

Максимальная длина строки
пути к файлу, включая завершающий нулевой символ

_PC_PATH_MAX

PIPE_BUF

Максимальное количество
байтов, которые можно записать в канал атомарно

_PC_PIPE_BUF

_POSIX_TIMESTAMP_RESOLUTION

Точность в наносекундах
представления времени
в атрибутах файлов

_PC_TIMESTAMP_RESOLUTION

SYMLINK_MAX

Количество байтов в символической ссылке

_PC_SYMLINK_MAX

2.5. Ограничения   

85

Рассмотрим внимательнее разные значения, возвращаемые этими тремя функциями.
1.	 Все три функции возвращают значение –1 и код ошибки EINVAL в переменной
errno, если аргумент name содержит имя неподдерживаемого предела. В третьей колонке табл. 2.11 и табл. 2.12 даны имена пределов, которые будут использоваться на протяжении всей книги.
2.	 Для некоторых пределов могут возвращаться определенные числовые значения (≥0) либо признак неопределенности — значение –1, но при этом значение
errno не изменяется.
3.	 Значение предела _SC_CLK_TCK  — количество тактов системных часов в  секунду; эта величина используется при работе со значениями, возвращаемыми
функцией times (раздел 8.17).
Ниже перечислены ограничения, накладываемые на аргумент pathname функции
pathconf и аргумент fd функции fpathconf. Несоблюдение любого из этих ограничений может привести к непредсказуемым результатам.
1.	 Файл, к  которому относятся параметры _PC_MAX_CANON и  _PC_MAX_INPUT, должен быть файлом терминального устройства.
2.	 Файл, к которому относятся параметры _PC_LINK_MAX и _PC_TIMESTAMP_RESOLUTION,
должен быть файлом или каталогом. Значение, возвращаемое для каталога, применимо только к самому каталогу, но не к файлам, находящимся в нем.
3.	 Файл, к  которому относятся параметры _PC_FILESIZEBITS и  _PC_NAME_MAX,
должен быть каталогом. Возвращаемое значение относится к именам файлов
в этом каталоге.
4.	 Файл, к которому относится параметр _PC_PATH_MAX, должен быть каталогом.
Возвращаемое значение представляет максимальную длину относительного
пути, когда заданный каталог является рабочим каталогом. (К сожалению, эта
величина не отражает фактическую максимальную длину абсолютного пути,
которую мы в действительности хотим узнать. Мы еще вернемся к этой проблеме в разделе 2.5.5.)
5.	 Файл, к которому относится параметр _PC_PIPE_BUF, должен быть неименованным каналом, именованным каналом или каталогом. В  первых двух случаях
возвращаемое значение относится к самим каналам. В случае каталога ограничение относится к любым именованным каналам, созданным в этом каталоге.
6.	 Файл, к которому относится параметр _PC_SYMLINK_MAX, должен быть каталогом. Возвращаемое значение  — максимальная длина строки, которую может
хранить символическая ссылка в этом каталоге.

Пример
Программа на языке awk(1), представленная в листинге 2.1, генерирует программу на языке C, которая, в свою очередь, выводит значения всех идентификаторов
функций pathconf и sysconf.

86    Глава 2. Стандарты и реализации UNIX
Листинг 2.1. Генерация программы на языке C, которая выводит значения всех
конфигурационных ограничений
#!/usr/bin/awk -f
BEGIN {
printf("#include \"apue.h\"\n")
printf("#include <errno.h>\n")
printf("#include <limits.h>\n")
printf("\n")
printf("static void pr_sysconf(char *, int);\n")
printf("static void pr_pathconf(char *, char *, int);\n")
printf("\n")
printf("int\n")
printf("main(int argc, char *argv[])\n")
printf("{\n")
printf("\tif (argc != 2)\n")
printf("\t\terr_quit(\"Использование: a.out <dirname>\");\n\n")
FS="\t+"
while (getline <"sysconf.sym" > 0) {
printf("#ifdef %s\n", $1)
printf("\tprintf(\"%s определен как %%ld\\n\", (long)%s+0);\n",
$1, $1)
printf("#else\n")
printf("\tprintf(\"идентификатор %s не найден\\n\");\n", $1)
printf("#endif\n")
printf("#ifdef %s\n", $2)
printf("\tpr_sysconf(\"%s =\", %s);\n", $1, $2)
printf("#else\n")
printf("\tprintf(\"идентификатор %s не найден\\n\");\n", $2)
printf("#endif\n")
}
close("sysconf.sym")
while (getline <"pathconf.sym" > 0) {
printf("#ifdef %s\n", $1)
printf("\tprintf(\"%s определен как %%ld\\n\", (long)%s+0);\n",
$1, $1)
printf("#else\n")
printf("\tprintf(\"идентификатор %s не найден\\n\");\n", $1)
printf("#endif\n")
printf("#ifdef %s\n", $2)
printf("\tpr_pathconf(\"%s =\", argv[1], %s);\n", $1, $2)
printf("#else\n")
printf("\tprintf(\"идентификатор %s не найден\\n\");\n", $2)
printf("#endif\n")
}
close("pathconf.sym")
exit
}
END {
printf("\texit(0);\n")
printf("}\n\n")
printf("static void\n")
printf("pr_sysconf(char *mesg, int name)\n")
printf("{\n")
printf("\tlong val;\n\n")
printf("\tfputs(mesg, stdout);\n")
printf("\terrno = 0;\n")
printf("\tif ((val = sysconf(name)) < 0) {\n")

2.5. Ограничения   

}

87

printf("\t\tif (errno != 0) {\n")
printf("\t\t\tif (errno == EINVAL)\n")
printf("\t\t\t\tfputs(\" (не поддерживается)\\n\", stdout);\n")
printf("\t\t\telse\n")
printf("\t\t\t\terr_sys(\"ошибка вызова sysconf\");\n")
printf("\t\t} else {\n")
printf("\t\t\tfputs(\" (нет ограничений)\\n\", stdout);\n")
printf("\t\t}\n")
printf("\t} else {\n")
printf("\t\tprintf(\" %%ld\\n\", val);\n")
printf("\t}\n")
printf("}\n\n")
printf("static void\n")
printf("pr_pathconf(char *mesg, char *path, int name)\n")
printf("{\n")
printf("\tlong val;\n")
printf("\n")
printf("\tfputs(mesg, stdout);\n")
printf("\terrno = 0;\n")
printf("\tif ((val = pathconf(path, name)) < 0) {\n")
printf("\t\tif (errno != 0) {\n")
printf("\t\t\tif (errno == EINVAL)\n")
printf("\t\t\t\tfputs(\" (не поддерживается)\\n\", stdout);\n")
printf("\t\t\telse\n")
printf("\t\t\t\terr_sys(\"ошибка вызова pathconf, path = %%s\", path);\n")
printf("\t\t} else {\n")
printf("\t\t\tfputs(\" (нет ограничений)\\n\", stdout);\n")
printf("\t\t}\n")
printf("\t} else {\n")
printf("\t\tprintf(\" %%ld\\n\", val);\n")
printf("\t}\n")
printf("}\n")

Программа на языке awk читает два входных файла  — pathconf.sym и  sysconf.
sym  — с  перечнем пределов и  идентификаторов, разделенных символами табуляции. Не на каждой платформе определены все идентификаторы, поэтому программа на языке awk заключает все вызовы pathconf и sysconf в директивы условной компиляции #ifdef.
Например, программа трансформирует строку входного файла, которая выглядит
следующим образом:
NAME_MAX

_PC_NAME_MAX

в следующий код на языке C:
#ifdef NAME_MAX
printf("NAME_MAX определен как %d\n", NAME_MAX+0);
#else
printf("идентификатор NAME_MAX не найден\n");
#endif
#ifdef _PC_NAME_MAX
pr_pathconf("NAME_MAX =", argv[1], _PC_NAME_MAX);
#else
printf("идентификатор _PC_NAME_MAX не найден\n");
#endif

88    Глава 2. Стандарты и реализации UNIX
Программа в листинге 2.2 сгенерирована предыдущей программой на awk. Она выводит значения всех пределов, корректно обрабатывая случаи, когда идентификатор не определен.
Листинг 2.2. Вывод всех возможных значений sysconf и pathconf
#include "apue.h"
#include <errno.h>
#include <limits.h>
static void pr_sysconf(char *, int);
static void pr_pathconf(char *, char *, int);
int
main(int argc, char *argv[])
{
if (argc != 2)
err_quit("Использование: a.out <каталог>");
#ifdef ARG_MAX
printf("ARG_MAX определен как %d\n", ARG_MAX+0);
#else
printf("идентификатор ARG_MAX не найден\n");
#endif
#ifdef _SC_ARG_MAX
pr_sysconf("ARG_MAX =", _SC_ARG_MAX);
#else
printf("идентификатор _SC_ARG_MAX не найден\n");
#endif
/* аналогично обрабатываются остальные идентификаторы sysconf... */
#ifdef MAX_CANON
printf("MAX_CANON определен как %d\n", MAX_CANON+0);
#else
printf("идентификатор MAX_CANON не найден\n");
#endif
#ifdef _PC_MAX_CANON
pr_pathconf("MAX_CANON =", argv[1], _PC_MAX_CANON);
#else
printf("идентификатор _PC_MAX_CANON не найден\n");
#endif
/* аналогично обрабатываются остальные идентификаторы pathconf... */
exit(0);
}
static void
pr_sysconf(char *mesg, int name)
{
long
val;
fputs(mesg, stdout);
errno = 0;
if ((val = sysconf(name)) < 0) {
if (errno != 0) {
if (errno == EINVAL)

2.5. Ограничения   

89

fputs(" (не поддерживается)\n", stdout);

else

}

err_sys("ошибка вызова sysconf");
} else {
fputs(" (нет ограничений)\n", stdout);
}
} else {
printf(" %ld\n", val);
}

static void
pr_pathconf(char *mesg, char *path, int name)
{
long
val;

}

fputs(mesg, stdout);
errno = 0;
if ((val = pathconf(path, name)) < 0) {
if (errno != 0) {
if (errno == EINVAL)
fputs(" (не поддерживается)\n", stdout);
else
err_sys("ошибка вызова pathconf, path = %s", path);
} else {
fputs(" (нет ограничений)\n", stdout);
}
} else {
printf(" %ld\n", val);
}

В табл. 2.13 приводятся результаты работы программы из листинга 2.2, в каждой
из четырех систем, обсуждаемых в данной книге. «Нет идентификатора» означает,
что данная платформа не имеет соответствующего идентификатора _SC или _PC,
с помощью которого можно было бы узнать значение константы. В этом случае
предел считается неопределенным. В противоположность этому обозначение «Не
поддерживается» говорит о том, что идентификатор определен, но он не распознается функциями pathconf и sysconf. «Нет ограничений» означает, что система не
задает этот предел, но это не значит, что предела нет вообще.
Следует отметить, что для некоторых пределов могут возвращаться некорректные
значения. Например, в Linux для предела SYMLOOP_MAX сообщается, что он не ограничен,
но, исследовав исходные тексты, можно увидеть, что в действительности количество
переходов по символическим ссылкам ограничивается «жестко зашитым» значением 40
(функция follow_link в файле fs/namei.c).
Еще одна причина неточностей в Linux обусловлена тем, что функции pathconf и fpathconf
реализованы в библиотеке языка C. Значения пределов, возвращаемые этими функциями,
зависят от фактически используемой файловой системы, поэтому, если текущая файловая система неизвестна библиотеке, функции возвращают предполагаемое значение.

В разделе 4.14 мы увидим, что UFS — это реализация файловой системы Berkeley
Fast File System для SVR4, а PCFS — реализация файловой системы MS-DOS FAT
для Solaris.

90    Глава 2. Стандарты и реализации UNIX
Таблица 2.13. Примеры конфигурационных пределов
Solaris 10
Предел

ARG_MAX
ATEXIT_MAX
CHARCLASS_NAME_MAX
CHILD_MAX
Количество тактов
системных часов
в секунду
COLL_WEIGHTS_MAX
FILESIZEBITS
HOST_NAME_MAX

FreeBSD 8.0

Mac OS X
10.6.8

Linux 3.2.0

файловая
система
UFS

файловая
система
PCFS

262 144

2 097 152

262 144

2 096 640

2 096 640

32

2 147 483 647

2 147 483 647

Нет ограничений

Нет ограничений

2 048

14

14

14

1 760

47 211

266

8 021

8021

128

100

100

100

100

0

255

2

10

64

64

64

41

Нет идентификатора

10
Не поддерживается

255

64

255

255

255

IOV_MAX

1024

1024

1024

16

16

LINE_MAX

2048

2048

2048

2048

2048

LINK_MAX

32 768

65 000

32 767

32 767

1

17

256

256

9

9

MAX_CANON

255

255

1024

256

256

MAX_INPUT

255

255

1024

512

512

LOGIN_NAME_MAX

NAME_MAX

255

255

255

255

8

NGROUPS_MAX

1023

65 536

16

16

16

OPEN_MAX

3520

1024

256

256

256

PAGESIZE

4096

4096

4096

8192

8192

PAGE_SIZE

4096

4096

4096

8192

8192

PATH_MAX

1024

4096

1024

1024

1024

PIPE_BUF

512

4096

512

5120

5120

RE_DUP_MAX

255

32 767

255

255

255

STREAM_MAX

3520

16

20

256

256

SYMLINK_MAX

1024

Нет ограничений

255

1024

1024

SYMLOOP_MAX

32

Нет ограничений

32

20

20

TTY_NAME_MAX

255

32

255

128

128

TZNAME_MAX

255

6

255

Нет ограничений

Нет ограничений

2.5. Ограничения   

91

2.5.5. Неопределенные пределы времени выполнения
Выше упоминалось, что некоторые пределы могут быть не определены. Проблема
в том, что если они не определены в заголовочном файле <limits.h>, их нельзя
использовать на этапе компиляции. Но они могут оставаться неопределенными
даже во время выполнения! Давайте рассмотрим два конкретных случая: размещение в памяти строки пути и определение количества файловых дескрипторов.

Строка пути
Многим программам приходится выделять память для хранения строки пути.
Обычно память выделяется на этапе компиляции; в этом случае в качестве размеров массивов выбираются некоторые «магические» числа (немногие из которых
верны), например 256, 512, 1024 или стандартная константа BUFSIZ. В  операционной системе 4.3BSD правильное значение представляет константа MAXPATHLEN,
определяемая в заголовочном файле <sys/param.h>, но большинство приложений,
написанных под 4.3BSD, ее не используют.
Для таких случаев стандартом POSIX.1 предусматривается константа PATH_MAX,
но ее значение может оказаться неопределенным. В  листинге 2.3 приводится
функция, которая будет использоваться в этой книге для определения объема памяти, необходимого для размещения строки пути.
Если константа PATH_MAX определена в файле <limits.h>, используется ее значение. Если нет, необходимо вызвать функцию pathconf. Значение, возвращаемое
этой функцией, — это максимальный размер строки относительного пути для случая, когда первый аргумент является рабочим каталогом, поэтому мы указываем
в  первом аргументе корневой каталог и  прибавляем к  полученному результату
единицу. Если pathconf сообщает, что константа PATH_MAX не определена, остается
лишь надеяться на удачу и выбрать достаточно большое число самостоятельно.
Версии POSIX.1, до выхода редакции 2001 года, не уточняли, должна ли константа PATH_MAX учитывать завершающий нулевой символ в конце строки пути. Если
реализация операционной системы соответствует одному из этих ранних стандартов и не соответствует какой-либо версии Single UNIX Specification (требующей
учитывать наличие нулевого символа), следует на всякий случай добавить единицу к полученному объему памяти.
Выбор того или иного алгоритма в случае неопределенного результата зависит от
того, как используется выделяемая память. Если память выделяется для вызова
функции getcwd, например, чтобы получить абсолютное имя рабочего каталога
(раздел 4.23), тогда, если выделенный объем памяти окажется слишком мал, мы
получим признак ошибки и код ERANGE в  errno. В такой ситуации можно увеличить объем памяти, выделенной под строку, вызвав функцию realloc (раздел 7.8
и упражнение 4.16), и повторить попытку. При необходимости можно продолжать
увеличивать размер строки, пока вызов getcwd не завершится успехом.
Листинг 2.3. Динамическое выделение памяти для строки пути
#include "apue.h"
#include <errno.h>
#include <limits.h>

92    Глава 2. Стандарты и реализации UNIX
#ifdef PATH_MAX
static long pathmax = PATH_MAX;
#else
static long pathmax = 0;
#endif
static long posix_version = 0;
static long xsi_version = 0;
/* Если константа PATH_MAX не определена */
/* адекватность следующего числа не гарантируется */
#define PATH_MAX_GUESS 1024
char *
path_alloc(size_t *sizep) /* если удалось выделить память, */
{
/* возвращает также выделенной объем */
char
*ptr;
size_t size;
if (posix_version == 0)
posix_version = sysconf(_SC_VERSION);
if (xsi_version == 0)
xsi_version = sysconf(_SC_XOPEN_VERSION);
if (pathmax == 0) { /* первый вызов функции */
errno = 0;
if ((pathmax = pathconf("/", _PC_PATH_MAX)) < 0) {
if (errno == 0)
pathmax = PATH_MAX_GUESS; /* если константа не определена */
else
err_sys("ошибка вызова pathconf с параметром _PC_PATH_MAX");
} else {
pathmax++; /* добавить 1, так как путь относительно корня */
}
}
/*
* До версии POSIX.1-2001 не гарантируется, что PATH_MAX включает
* завершающий нулевой байт. То же для XPG3.
*/
if ((posix_version < 200112L) && (xsi_version < 4))
size = pathmax + 1;
else
size = pathmax;
if ((ptr = malloc(size)) == NULL)
err_sys("malloc error for pathname");

}

if (sizep != NULL)
*sizep = size;
return(ptr);

Максимальное количество открытых файлов
Как правило, процесс-демон, то есть процесс, который выполняется в фоновом режиме и не связан с терминальным устройством, закрывает все открытые файлы.
Некоторые программы предусматривают следующую последовательность дей-

2.5. Ограничения   

93

ствий, исходя из предположения, что в заголовочном файле <sys/param.h> определена константа NOFILE:
#include <sys/param.h>
for (i = 0; i < NOFILE; i++)
close(i);

В других программах используется константа _NFILE, которая определена в  некоторых версиях <stdio.h> как верхний предел. В  третьих в  качестве верхнего
предела жестко зашито число 20. Однако ни один из этих способов не переносим.
Мы могли бы понадеяться на константу OPEN_MAX, определяемую стандартом
POSIX.1, чтобы переносимым образом узнать значение этого предела, но если она
не определена, проблема останется нерешенной. Например, цикл в  следующем
фрагменте не выполнится ни разу, если OPEN_MAX не определена, так как sysconf
вернет –1:
#include <unistd.h>
for (i = 0; i < sysconf(_SC_OPEN_MAX); i++)
close(i);

Лучшее, что можно предпринять в такой ситуации, — закрыть все дескрипторы до
некоторого произвольного предела, например 256. Как и в случае со строкой пути,
такой подход не гарантирует желаемого результата во всех возможных случаях, но
это лучшее, что можно сделать. Продемонстрируем его в листинге 2.4.
Листинг 2.4. Определение количества файловых дескрипторов
#include "apue.h"
#include <errno.h>
#include <limits.h>
#ifdef OPEN_MAX
static long openmax = OPEN_MAX;
#else
static long openmax = 0;
#endif
/*
* Если константа PATH_MAX не определена */
* адекватность следующего числа не гарантируется
*/
#define OPEN_MAX_GUESS 256
long
open_max(void)
{
if (openmax == 0) { /* первый вызов функции */
errno = 0;
if ((openmax = sysconf(_SC_OPEN_MAX)) < 0) {
if (errno == 0)
openmax = OPEN_MAX_GUESS; /* неопределенный предел */
else
err_sys("ошибка вызова sysconf с параметром _SC_OPEN_MAX");
}
}
return(openmax);
}

94    Глава 2. Стандарты и реализации UNIX
Легко поддаться искушению просто вызывать функцию close, пока она не вернет
признак ошибки, но дело в том, что по коду ошибки EBADF, которую возвращает
close, нельзя сказать, была это попытка закрыть неправильный дескриптор или
дескриптор просто не был открыт. Если бы мы реализовали такой алгоритм, в случае, когда дескриптор 10 был бы открытым, а  дескриптор 9  — нет, выполнение
цикла остановилось бы на дескрипторе 9 и дескриптор 10 остался бы незакрытым.
С другой стороны, функция dup (раздел 3.12) возвращает признак ошибки, если
превышен предел OPEN_MAX, но создание сотен копий дескриптора — слишком экстремальный способ выяснения значения искомого предела.
Некоторые реализации возвращают значение LONG_MAX для пределов, которые
в  действительности неограниченны. Так обстоит дело с  пределом ATEXIT_MAX
в  Linux (табл. 2.13). Вообще такой подход нельзя назвать приемлемым, потому
что он может привести к непредсказуемой работе программ.
Например, с помощью команды ulimit, встроенной в командный интерпретатор
Bourne-again shell, можно изменить максимальное количество открытых файлов
на процесс. Вообще, если предел фактически не ограничен, для выполнения этой
операции потребуются привилегии суперпользователя. Но если сделать верхний
предел практически неограниченным, функция sysconf будет возвращать LONG_
MAX в качестве предела OPEN_MAX. Тогда программа, которая ориентируется на значение верхнего предела, как в листинге 2.4, будет затрачивать огромное количество времени на попытки закрыть 2  147  483  647 дескрипторов, большинство из
которых даже не открывались.
Системы, поддерживающие расширения XSI стандарта Single UNIX Specification,
предоставляют функцию getrlimit(2) (раздел 7.11). Она может использоваться
для получения максимального количества открытых дескрипторов на процесс.
Таким способом можно узнать, определено ли ограничение на количество открытых файлов, и избежать дальнейших проблем.
Значение OPEN_MAX, согласно определению в стандарте POSIX, относится к разряду неизменяемых во время выполнения. Это значит, что данный предел не изменяется в течение
всей жизни процесса. Однако в системах, поддерживающих расширения XSI, его можно
изменить вызовом функции setrlimit(2) (раздел 7.11). (Значение этого предела также
можно изменить командой limit оболочки C shell или командой ulimit оболочек Bourne,
Bourne-again, Debian Almquist и Korn.) В системах, поддерживающих данную возможность,
функцию в листинге 2.4 можно было бы изменить так, чтобы она вызывала sysconf при
каждом обращении к ней, а не только в первом вызове.

2.6. Необязательные параметры
Мы уже видели список необязательных параметров, определяемых стандартом
POSIX.1 (табл. 2.5), и обсуждали необязательные категории XSI в разделе 2.2.3.
Для написания переносимых приложений, зависящих от любой из этих необязательных особенностей, необходим переносимый способ определения поддержки
заданного необязательного параметра.

2.6. Необязательные параметры   

95

Так же как в  случае с  пределами (раздел 2.5), POSIX.1 определяет три способа
сделать это:
1.	 Параметры времени компиляции определяются в файле <unistd.h>.
2.	 Параметры времени выполнения, не связанные с  файлами или каталогами,
идентифицируются функцией sysconf.
3.	 Параметры времени выполнения, связанные с файлами или каталогами, можно получить с помощью функции pathconf или fpathconf.
В перечень необязательных параметров входят символьные константы из третьей колонки табл. 2.5, а также символьные константы из табл. 2.14 и 2.15. Если
символьная константа не определена, мы должны использовать функции sysconf,
pathconf или fpathconf, чтобы узнать, поддерживается ли заданный необязательный параметр. В этом случае через аргумент name функции передается имя, сформированное заменой префикса _POSIX на _SC или _PC. Для констант с  именами,
начинающимися с префикса _XOPEN, в аргументе name передается идентификатор,
сформированный путем добавления префикса _SC или _PC. Например, если константа _POSIX_RAW_SOCKETS не определена, чтобы узнать, поддерживает ли система
низкоуровневые сокеты, можно вызвать функцию sysconf, передав ей в аргументе
name идентификатор _SC_RAW_SOCKETS. Далее, если константа _XOPEN_UNIX не определена, чтобы узнать, поддерживает ли система расширения XSI, можно вызвать
функцию sysconf, передав ей в  аргументе name идентификатор _SC_XOPEN_UNIX.
Таблица 2.14. Необязательные параметры и идентификаторы для функций pathconf
и fpathconf
Имя параметра

Описание

Аргумент name

_POSIX_CHOWN_RESTRICTED

Указывает, ограничено ли действие
функции chown

_PC_CHOWN_RESTRICTED

_POSIX_NO_TRUNC

Указывает, приводит ли к ошибке применение путей длиннее, чем NAME_MAX

_PC_NO_TRUNC

_POSIX_VDISABLE

Если определен, действие специальных
терминальных символов может быть
запрещено этим значением

_PC_VDISABLE

_POSIX_ASYNC_IO

Указывает, поддерживаются ли операции асинхронного ввода/вывода для
заданного файла

_PC_ASYNC_IO

_POSIX_PRIO_IO

Указывает, поддерживаются ли прио­
ритетные операции ввода/вывода для
заданного файла

_PC_PRIO_IO

_POSIX_SYNC_IO

Указывает, поддерживаются ли операции синхронизированного ввода/вывода для заданного файла

_PC_SYNC_IO

_POSIX2_SYMLINKS

Указывает, поддерживаются ли символические ссылки для каталогов

_PC_2_SYMLINKS

96    Глава 2. Стандарты и реализации UNIX
Для каждого параметра есть три возможных варианта определения его поддержки
системой.
1.	 Если символьная константа не определена или определена со значением –1,
значит, данная функциональная возможность не поддерживается системой на
этапе компиляции. Старое приложение может выполняться в более новой системе, где эта возможность поддерживается, поэтому проверка во время выполнения может показать наличие поддержки, даже если она была недоступна
на этапе компиляции.
2.	 Если символическая константа определена и имеет значение больше нуля, значит, данная функциональная возможность поддерживается.
3.	 Если символическая константа определена и  имеет значение, равное нулю,
значит, следует использовать функции sysconf, pathconf или fpathconf, чтобы
узнать, поддерживается ли заданная функциональная возможность.
В табл. 2.14 перечислены константы, используемые в вызовах функций pathconf
и  fpathconf. В табл. 2.15 перечислены неустаревшие параметры и соответствующие им константы, используемые при обращении к функции sysconf, в дополнение к перечисленным в табл. 2.5. Обратите внимание, что мы опустили параметры,
связанные со вспомогательными командами.
Как и  в  случае с  системными пределами, есть несколько моментов, связанных
с интерпретацией параметров функциями sysconf, pathconf и fpathconf.
1.	 Возвращаемое значение для параметра _SC_VERSION указывает год (первые четыре цифры) и месяц (последние две цифры) публикации стандарта. Это может быть число 198808L, 199009L, 199506L или иное для более поздних версий.
Так, третьей версии Single UNIX Specification соответствует значение 200112L
(редакция стандарта POSIX.1 2001 года). Четвертой версии стандарта Single
UNIX Specification (редакция стандарта POSIX.1 2008 года) соответствует
значение 200809L.
2.	 Возвращаемое значение для параметра _SC_XOPEN_VERSION указывает версию
XSI, которой соответствует система. Третьей версии Single UNIX Specification
соответствует значение 600. Четвертой версии Single UNIX Specification (редакция стандарта POSIX.1 2008 года) — значение 700.
3.	 Возвращаемые значения для параметров _SC_JOB_CONTROL, _SC_SAVED_IDS
и  _PC_VDISABLE сейчас не относятся к дополнительным функциональным возможностям. XPG4 и ранние версии Single UNIX Specification требовали обязательной поддержки этих особенностей, но только начиная с третьей версии
Single UNIX Specification они перешли в разряд обязательных. Эти идентификаторы сохранены для обратной совместимости.
4.	 Платформы, соответствующие требованиям POSIX.1-2008, также должны
поддерживать следующие параметры:
•• _POSIX_ASYNCHRONOUS_IO
•• _POSIX_BARRIERS

2.6. Необязательные параметры   

97

•• _POSIX_CLOCK_SELECTION
•• _POSIX_MAPPED_FILES
•• _POSIX_MEMORY_PROTECTION
•• _POSIX_READER_WRITER_LOCKS
•• _POSIX_REALTIME_SIGNALS
•• _POSIX_SEMAPHORES
•• _POSIX_SPIN_LOCKS
•• _POSIX_THREAD_SAFE_FUNCTIONS
•• _POSIX_THREADS
•• _POSIX_TIMEOUTS
•• _POSIX_TIMERS
Этим константам присвоено значение 200809L. Соответствующие им константы _SC также сохранены для обратной совместимости.
1.	 Для параметров _PC_CHOWN_RESTRICTED и  _PC_NO_TRUNC возвращается значение
–1 без изменения errno, если функциональная возможность не поддерживается для указанного значения аргумента pathname или fd. Во всех POSIXсовместимых системах возвращаемое значение будет больше нуля (указывая,
что данная возможность поддерживается).
2.	 Файл, к  которому относится параметр _PC_CHOWN_RESTRICTED, должен быть
файлом или каталогом. Если это каталог, данная функциональная возможность применяется к файлам в этом каталоге.
3.	 Файл, к  которому относятся параметры _PC_NO_TRUNC и  _PC_2_SYMLINKS, должен быть каталогом.
4.	 Возвращаемое значение для параметра _PC_NO_TRUNC применяется к  именам
файлов в этом каталоге.
5.	 Файл, к которому относится параметр _PC_VDISABLE, должен быть файлом терминального устройства.
6.	 Файл, к которому относятся параметры _PC_ASYNC_IO, _PC_PRIO_IO и _PC_SYNC_
IO, не должен быть каталогом.
Таблица 2.15. Необязательные параметры и их идентификаторы для функции sysconf
Имя параметра

Указывает, поддерживает ли
система...

Аргумент name

_POSIX_ASYNCHRONOUS_IO

Асинхронный ввод/вывод
POSIX

_SC_ASYNCHRONOUS_IO

_POSIX_BARRIERS

Барьеры

_SC_BARRIERS

_POSIX_CLOCK_SELECTION

Выбор часов

_SC_CLOCK_SELECTION

_POSIX_JOB_CONTROL

Управление заданиями

_SC_JOB_CONTROL

_POSIX_MAPPED_FILES

Отображение файлов в память

_SC_MAPPED_FILES

98    Глава 2. Стандарты и реализации UNIX
Таблица 2.15 (окончание)
Имя параметра

Указывает, поддерживает ли
система...

Аргумент name

_POSIX_MEMORY_PROTECTION

Возможность защиты памяти

_SC_MEMORY_PROTECTION

_POSIX_READER_WRITER_LOCKS

Блокировки чтения/записи

_SC_READER_WRITER_LOCKS

_POSIX_REALTIME_SIGNALS

Сигналы реального времени

_SC_REALTIME_SIGNALS

_POSIX_SAVED_IDS

Сохраненные идентификаторы
пользователя и группы

_SC_SAVED_IDS

_POSIX_SEMAPHORES

Семафоры POSIX

_SC_SEMAPHORES

_POSIX_SHELL

Стандартную командную оболочку POSIX

_SC_SHELL

_POSIX_SPIN_LOCKS

Циклические блокировки
(spin-locks)

_SC_SPIN_LOCKS

_POSIX_THREAD_SAFE_
FUNCTIONS

Потокобезопасные функции

_SC_THREAD_SAFE_
FUNCTIONS

_POSIX_THREADS

Потоки выполнения

_SC_THREADS

_POSIX_TIMEOUTS

Версии выбранных функций
с ограничением времени ожидания

_SC_TIMEOUTS

_POSIX_TIMERS

Таймеры

_SC_TIMERS

_POSIX_VERSION

Указывает версию POSIX.1

_SC_VERSION

_XOPEN_CRYPT

Группу интерфейсов шифрования XSI

_SC_XOPEN_CRYPT

_XOPEN_REALTIME

Группу интерфейсов реального
времени XSI

_SC_XOPEN_REALTIME

_XOPEN_REALTIME_THREADS

Группу интерфейсов потоков
реального времени XSI

_SC_XOPEN_REALTIME_
THREADS

_XOPEN_SHM

Группу интерфейсов XSI разделяемой памяти

_SC_XOPEN_SHM

_XOPEN_VERSION

Указывает версию XSI

_SC_XOPEN_VERSION

В табл. 2.16 приведены некоторые конфигурационные параметры и соответствующие им значения для четырех платформ, обсуждаемых в данной книге. Обозначение «Не поддерживается» говорит о том, что соответствующая константа определена, но имеет значение –1 или имеет значение 0, но вызов функции sysconf
или pathconf возвращает –1. Обратите внимание, что некоторые системы еще не
соответствуют последней версии Single UNIX Specification.
Обратите внимание, что в  операционной системе Solaris функция pathconf возвращает значение –1 для параметра _PC_NO_TRUNC, если вызывается для файла,
находящегося в  файловой системе PCFS. Эта файловая система поддерживает
формат DOS (для дискет) и без предупреждения усекает имена файлов до формата 8.3, как того требует файловая система DOS.

99

2.7. Макроопределения проверки особенностей   

Таблица 2.16. Примеры значений конфигурационных параметров
Solaris 10
Предел

FreeBSD
8.0

Linux 3.2.0

Mac OS X
10.6.8

файловая
система
UFS

файловая
система
PCFS

_POSIX_CHOWN_RESTRICTED

1

1

200112

1

1

_POSIX_JOB_CONTROL

1

1

200112

1

1

_POSIX_NO_TRUNC

1

1

200112

1

1

200112

1

1

200112

200809

200112

200112

200112

255

0

255

0

0

200112

_POSIX_SAVED_IDS
_POSIX_THREADS

Не поддерживается

_POSIX_VDISABLE
_POSIX_VERSION

Не поддерживается

200809

200112

200112

200112

_XOPEN_UNIX

Не поддерживается

1

1

1

1

_XOPEN_VERSION

Не поддерживается

700

600

600

600

2.7. Макроопределения проверки
особенностей
В заголовочных файлах определяется множество символов стандарта POSIX.1
и XSI. Большинство реализаций добавляют в эти файлы собственные определения в дополнение к тем, что описываются стандартами POSIX.1 и XSI. Если возникает необходимость скомпилировать программу так, чтобы она зависела только от определений POSIX и не конфликтовала с определениями, зависящими от
реализации, необходимо определить константу _POSIX_C_SOURCE. Эта константа
используется во всех заголовочных файлах стандарта POSIX.1 для исключения
любых зависящих от реализации определений.
Ранние версии стандарта POSIX.1 определяли константу _POSIX_SOURCE. В  редакции
POSIX.1 2001 года ее заменила константа _POSIX_C_SOURCE.

Константы _POSIX_C_SOURCE и  _XOPEN_SOURCE называются макроопределениями
проверки особенностей. Все подобные макроопределения начинаются с  символа
подчеркивания. Обычно они используются в командной строке компилятора cc,
например
cc -D_POSIX_C_SOURCE=200809L file.c

В таком случае макрос будет определен до подключения любого заголовочного файла. Чтобы использовать только определения стандарта POSIX.1, также можно в первой строке файла с исходным текстом программы указать следующее определение:
#define _POSIX_C_SOURCE 200809L

100    Глава 2. Стандарты и реализации UNIX
Чтобы приложениям стали доступны функциональные особенности, определяемые
версией 4 Single UNIX Specification, нужно определить константу _XOPEN_SOURCE со
значением 700. Помимо включения дополнительных интерфейсов XSI, это даст тот
же эффект, что и  определение константы _POSIX_C_SOURCE со значением 200809L,
когда речь идет о функциональности, определяемой стандартом POSIX.1.
Стандарт Single UNIX Specification определяет утилиту c99 в качестве интерфейса
к среде компиляции языка C. Вот как с ее помощью можно скомпилировать файл:
c99 -D_XOPEN_SOURCE=700 file.c -o file

Чтобы разрешить компилятору gcc использовать расширения 1999 ISO C, можно
добавить в командную строку параметр –std=c99, как показано ниже:
gcc -D_XOPEN_SOURCE=700 -std=c99 file.c -o file

2.8. Элементарные системные типы данных
Исторически некоторые типы данных в  языке C были связаны с  некоторыми
переменными системы UNIX. Например, старшие и  младшие номера устройств
исторически хранились в виде 16-разрядного целого числа, где 8 разрядов отводилось для старшего номера устройства и 8 разрядов — для младшего. Но большинству крупных систем необходима возможность определения более 256 различных номеров устройств, поэтому потребовалось предусмотреть иной подход
к нумерации. (Так, в 32-разрядной версии Solaris для хранения номеров устройств
используются 32 разряда — 14 разрядов для старшего и 18 для младшего номера
устройства.)
Заголовочный файл <sys/types.h> определяет ряд зависящих от реализации типов данных, которые называются элементарными системными типами данных.
Кроме того, некоторые из этих типов данных объявляются и в других заголовочных файлах. Все они объявлены посредством директивы typedef. Названия их
обычно завершаются символами _t. В  табл. 2.17 перечислено большинство элементарных типов, с которыми мы будем сталкиваться в этой книге.
Таблица 2.17. Некоторые наиболее распространенные элементарные типы
Тип

Описание

clock_t

Счетчик тактов системных часов (время работы процесса, раздел 1.10)

comp_t

Счетчик тактов в упакованном виде (раздел 8.14)

dev_t

Номер устройства (старший и младший, раздел 4.24)

fd_set

Набор файловых дескрипторов (раздел 14.4.1)

fpos_t

Позиция в файле (раздел 5.10)

gid_t

Числовой идентификатор группы

ino_t

Номер индексного узла (i-node, раздел 4.14)

mode_t

Тип файла, режим создания файла (раздел 4.5)

2.9. Различия между стандартами   

Тип

101

Описание

nlink_t

Счетчик ссылок для записей в каталоге (раздел 4.14)

off_t

Размер файла и смещение в файле (со знаком) (lseek, раздел 3.6)

pid_t

Числовой идентификатор процесса и идентификатор группы процессов
(со знаком, разделы 8.2 и 9.4)

pthread_t

Числовой идентификатор потока выполнения (раздел 11.3)

ptrdiff_t

Разность двух указателей (со знаком)

rlim_t

Предельное значение для ресурса (раздел 7.11)

sig_atomic_t

Тип данных, доступ к которому может выполняться атомарно (раздел 10.15)

sigset_t

Набор сигналов (раздел 10.11)

size_t

Размер объекта (например, строки) (без знака) (раздел 3.7)

ssize_t

Возвращаемый функциями результат, представляющий счетчик байтов
(со знаком) (read, write, раздел 3.7)

time_t

Счетчик секунд календарного времени (раздел 1.10)

uid_t

Числовой идентификатор пользователя

wchar_t

Может представлять символы в любой кодировке

Эти типы определены так, что при написании программ нет необходимости погружаться в детали конкретной реализации, которые могут меняться от системы
к системе. Мы будем описывать, как используется каждый из этих типов, по мере
необходимости.

2.9. Различия между стандартами
В общем и  целом, различные стандарты прекрасно уживаются друг с  другом.
В  основном мы будем обращать внимание на различия между стандартами
ISO C и  POSIX.1, поскольку раздел Base Specifications стандарта Single UNIX
Specification является надмножеством стандарта POSIX.1. Ниже перечисляются
некоторые отличия.
Стандарт ISO C определяет функцию clock, возвращающую количество процессорного времени, использованного процессом. Возвращаемое значение имеет тип
clock_t, но стандарт ISO не определяет единицы измерения. Чтобы преобразовать
это значение в  секунды, необходимо разделить его на константу CLOCKS_PER_SEC,
объявленную в заголовочном файле <time.h>. Стандарт POSIX.1 определяет функцию times, возвращающую как процессорное время (для вызывающего процесса
и для всех его дочерних процессов, завершивших свою работу), так и общее время.
Все эти значения имеют тип clock_t. С помощью функции sysconf необходимо получить количество тактов в секунду и затем использовать его для перевода значений
типа clock_t в секунды. Получается, что одна и та же характеристика — количество
тактов в секунду — определяется стандартами ISO C и POSIX.1 по-разному. Кроме
того, оба стандарта используют один и тот же тип данных (clock_t) для хранения

102    Глава 2. Стандарты и реализации UNIX
разных значений. Разницу можно наблюдать в Solaris, где функция clock возвращает время в микросекундах (следовательно, константа CLOCKS_PER_SEC имеет значение 1 000 000), тогда как функция sysconf возвращает значение 100 (количество
тактов в секунду). Поэтому нужно с особым вниманием относиться к переменным
типа clock_t, чтобы не смешивать разные единицы измерения.
Конфликт возможен также в случаях, когда стандарт ISO C определяет некоторую
функцию, но не так строго, как это делает стандарт POSIX.1. Так, например, обстоит дело с функциями, которые требуют иной реализации в среде POSIX (многозадачной), чем в среде ISO C (где очень немногое можно предположить о целевой операционной системе). Тем не менее большинство POSIX-совместимых
систем реализуют функции в соответствии со стандартом ISO C для сохранения
совместимости. Примером может служить функция signal. Если мы по незнанию
используем функцию signal из Solaris (надеясь написать переносимый код, который будет работать в среде ISO C и в устаревших версиях UNIX), то получим
семантику, отличную от той, которую имеет функция sigaction, определяемая
стандартом POSIX.1. Более подробно о функции signal мы поговорим в главе 10.

2.10. Подведение итогов
Очень многое произошло в  сфере стандартизации программной среды UNIX за
прошедшие два с половиной десятилетия. Мы описали наиболее важные стандарты — ISO C, POSIX и Single UNIX Specification — и их влияние на четыре реализации UNIX, обсуждаемые в данной книге: FreeBSD, Linux, Mac OS X и Solaris. Эти
стандарты пытаются определить конфигурационные параметры, которые могут
варьироваться от системы к системе, и мы видели, что они далеки от совершенства. В этой книге мы еще не раз столкнемся со многими из них.
В списке использованной литературы указывается, как получить копии стандартов, описанных в этой главе.

Упражнения
1.1	

Мы упоминали в  разделе 2.8, что некоторые из элементарных системных
типов данных определены более чем в одном заголовочном файле. Например, в FreeBSD 8.0 тип size_t определен в 29 различных файлах. Поскольку
программа может подключить все 29 файлов, а стандарт ISO C не допускает
множественного определения одного и того же типа, подумайте, как должны быть написаны эти заголовочные файлы.

1.2	

Просмотрите заголовочные файлы в своей системе и перечислите фактические типы данных, используемые для реализации элементарных системных
типов.

1.3	

Измените программу из листинга 2.4 так, чтобы избежать лишней работы,
когда функция sysconf возвращает значение LONG_MAX для предела OPEN_MAX.

3

Файловый ввод/вывод

3.1. Введение
Обсуждение системы UNIX мы начнем с операций файлового ввода/вывода, таких как открытие файла, чтение из файла, запись в файл и т. д. Большинство операций файлового ввода/вывода в UNIX можно выполнить с помощью всего пяти
функций: open, read, write, lseek и  close. Затем мы рассмотрим, как изменение
размера буфера влияет на производительность функций read и write.
Функции, описываемые в этой главе, часто называют функциями небуферизованного ввода/вывода в  противоположность стандартным функциям ввода/вывода,
о которых пойдет речь в главе 5. Термин небуферизованный означает, что каждая
операция чтения или записи обращается к системному вызову в ядре. Функции
небуферизованного ввода/вывода не являются частью стандарта ISO C, но они
определены стандартами POSIX.1 и Single UNIX Specification.
Всякий раз, когда речь заходит о совместном использовании ресурсов несколькими процессами, особую важность приобретает понятие атомарного выполнения
операций. Мы рассмотрим это понятие применительно к  операциям файлового
ввода/вывода и аргументам функции open. Далее мы увидим, как осуществляется одновременный доступ к файлам из нескольких процессов и какие структуры
данных ядра с этим связаны. Затем перейдем к функциям dup, fcntl, sync, fsync
и ioctl.

3.2. Дескрипторы файлов
Все открытые файлы представлены в ядре файловыми дескрипторами. Файловый
дескриптор — это неотрицательное целое число. Когда процесс открывает существующий файл или создает новый, ядро возвращает ему файловый дескриптор.
Чтобы выполнить запись в  файл или чтение из него, нужно передать функции
read или write его файловый дескриптор, полученный вызовом функции open или
creat.
В соответствии с  соглашениями командные оболочки UNIX ассоциируют файловый дескриптор 0 с  устройством стандартного ввода процесса, 1  — с  устройством стандартного вывода и 2 — с устройством стандартного вывода сообщений
об ошибках. Это соглашение используется командными оболочками и большин-

104    Глава 3. Файловый ввод/вывод
ством приложений, но не является особенностью ядра UNIX. Тем не менее многие
приложения не смогли бы работать, если бы это соглашение было нарушено.
Хотя значения этих дескрипторов определены стандартом POSIX.1, в  POSIXсовместимых приложениях вместо фактических значений 0, 1 и 2 следует использовать константы STDIN_FILENO, STDOUT_FILENO и  STDERR_FILENO. Определения
этих констант находятся в заголовочном файле <unistd.h>.
Под файловые дескрипторы отводится диапазон чисел от 0 до OPEN_MAX-1. (Вспомните табл. 2.11.) В ранних реализациях UNIX максимальным значением файлового дескриптора было число 19, что позволяло каждому процессу держать открытыми до 20 файлов, но многие системы увеличили этот предел до 63.
В операционных системах FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 и Solaris 10 этот предел
практически бесконечен и ограничен лишь объемом памяти в системе, размером целых чисел
и прочими жесткими и мягкими ограничениями, задаваемыми администратором системы.

3.3. Функции open и openat
Файл создается или открывается функцией open или openat.
#include <fcntl.h>
int open(const char *path, int oflag, ... /* mode_t mode */ );
int openat(int fd, const char *path, int oflag, ... /* mode_t mode */ );

Обе возвращают дескриптор файла в случае успеха,
–1 — в случае ошибки
Последний аргумент обозначен многоточием (...), таким способом стандарт
ISO C указывает, что количество остальных аргументов и их типы могут варьироваться. В этих функциях последний аргумент используется только при создании нового файла, о чем мы поговорим немного позже. Этот аргумент мы привели
в прототипе функции как комментарий.
Аргумент path представляет имя файла, который будет открыт или создан. Эти
функции могут принимать большое количество параметров, определяемых аргументом oflag. Значение этого аргумента формируется объединением по ИЛИ
(OR) одной или более констант, определяемых в заголовочном файле <fcntl.h>
и перечисленных ниже:
O_RDONLY Файл открывается только на чтение.
O_WRONLY Файл открывается только на запись.
O_RDWR
Файл открывается для чтения и для записи.
В большинстве реализаций для совместимости с устаревшим программным обеспечением
константа O_RDONLY определяется как 0, O_WRONLY — как 1 и O_RDWR — как 2.
O_EXEC

Файл открывается только для выполнения.

3.3. Функции open и openat   

O_SEARCH

105

Файл открывается только для поиска (применяется к каталогам).

Константа O_SEARCH предусмотрена, чтобы позволить проверить права доступа к каталогу в момент его открытия. Последующие операции с файловым дескриптором каталога,
открытого для поиска, не влекут повторной переоценки прав доступа. Ни одна из операционных систем, рассматриваемых в этой книге, пока не поддерживает флаг O_SEARCH.

Должна быть указана одна и только одна из этих пяти констант. Далее приводится
список констант, присутствие которых в аргументе oflag необязательно.
O_APPEND Запись производится в конец файла. Более подробное описание этого
флага мы дадим чуть позже, в разделе 3.11.
O_CLOEXEC Устанавливает флаг FD_CLOEXEC дескриптора файла. Подробнее этот
флаг будет рассматриваться в разделе 3.14.
O_CREAT Если файл не существует, он будет создан. Этот флаг требует наличия
третьего аргумента функции open (mode), который определяет значения битов
прав доступа к создаваемому файлу. (В разделе 4.5, где рассказывается о правах
доступа, мы увидим, как определяется значение аргумента mode и какое влияние
на него оказывает значение параметра umask процесса.)
O_DIRECTORY Вызывает ошибку, если path не является именем каталога.
O_EXCL Вызывает ошибку, если файл уже существует и задан флаг O_CREAT. При
такой комбинации флагов атомарно выполняется проверка существования файла
и  его создание, если файл не существует. Более подробно атомарные операции
описываются в разделе 3.11.
O_NOCTTY Если аргумент path ссылается на файл терминального устройства, это
устройство не назначается управляющим терминалом вызывающего процесса.
Подробнее об управляющих терминалах рассказывается в разделе 9.6.
O_NOFOLLOW Вызывает ошибку, если path является символической ссылкой. Подробнее о символических ссылках рассказывается в разделе 4.17.
O_NONBLOCK Если аргумент path ссылается на именованный канал (FIFO), специальный файл блочного устройства или специальный файл символьного устройства, этот флаг задает неблокирующий режим открытия файла и  последующих
операций ввода/вывода. Подробнее этот режим описывается в разделе 14.2.
В ранних выпусках System V появился флаг O_NDELAY. Он подобен флагу O_NONBLOCK, но вносит двусмысленность в трактовку значения, возвращаемого функцией read. При наличии
флага O_NODELAY функция read возвращает 0 в случае отсутствия данных в именованном
или неименованном канале либо в файле устройства, но тогда возникает конфликт со
значением 0, которое возвращается по достижении конца файла. В системах, основанных
на SVR4, сохранилась поддержка флага O_NODELAY с устаревшей семантикой, однако все
новые приложения должны использовать флаг O_NONBLOCK.

Каждый вызов функции write ожидает завершения физической операции ввода/вывода, включая операцию обновления атрибутов файла. Этот флаг
будет использоваться в разделе 3.14.
O_TRUNC Если файл существует и успешно открывается для записи либо для чтения и записи, его размер усекается до нуля.
O_SYNC

106    Глава 3. Файловый ввод/вывод
При открытии терминального устройства, которое еще не было
открыто, устанавливает нестандартные параметры termios в значения, соответствующие стандарту Single UNIX Specification. Подробнее структура termios
будет рассматриваться в ходе обсуждения терминального ввода/вывода, в главе 18.
Следующие два флага также относятся к  разряду необязательных. Они предназначены для поддержки синхронизированных операций ввода/вывода, определяемых стандартом Single UNIX Specification (а также POSIX.1):
O_DSYNC Каждый вызов функции write ожидает завершения физической операции ввода/вывода, но не ожидает, пока будут обновлены атрибуты файла, если
они не влияют на доступность для чтения только что записанных данных.
O_TTY_INIT

Флаги O_DSYNC и O_SYNC очень похожи друг на друга, но все-таки чуть-чуть отличаются.
Флаг O_DSYNC влияет на атрибуты файла, только если их необходимо обновить, чтобы
отразить изменения в данных (например, обновить размер файла, если в файл были записаны дополнительные данные). При использовании флага O_SYNC данные и атрибуты
всегда обновляются синхронно. При перезаписи существующей части файла, открытого
с флагом O_DSYNC, атрибуты времени файла не будут обновляться синхронно с данными.
Напротив, если файл открывается с флагом O_SYNC, каждое обращение к функции write
будет приводить к изменению атрибутов времени файла независимо от того, были ли
перезаписаны существующие данные или в конец добавлены новые.

Каждый вызов функции read приостанавливается до тех пор, пока не
будут закончены ждущие завершения операции записи в ту же часть файла.
O_RSYNC

Solaris 10 поддерживает все три флага. Исторически FreeBSD и MacOS X поддерживают
флаг O_FSYNC, действующий так же, как O_SYNC. Поскольку оба эти флага полностью эквивалентны, они определены с одним и тем же значением. FreeBSD 8.0 не поддерживает
флаги O_DSYNC и O_RSYNC. Mac OS X не поддерживает флаг O_RSYNC, но поддерживает флаг
D_SYNC, который трактуется так же, как O_SYNC. Linux 3.2.0 поддерживает флаг D_SYNC,
а флаг R_SYNC трактует так же, как O_SYNC.

Функции open и  openat гарантируют, что возвращаемый ими дескриптор файла
будет иметь наименьшее неиспользуемое положительное числовое значение. Это
обстоятельство используется в  некоторых приложениях для открытия нового
файла вместо стандартного ввода, стандартного вывода или стандартного вывода
сообщений об ошибках. Например, приложение может закрыть файл стандартного вывода (обычно это дескриптор 1) и затем открыть другой файл, зная, что
он будет открыт с  дескриптором 1. В  разделе 3.12 мы продемонстрируем более
надежный способ открытия файла на конкретном дескрипторе при помощи функции dup2.
Параметр fd в функции openat отличается от одноименного параметра в функции
open. Возможны три разных варианта.
1.	 Параметр path содержит строку абсолютного пути. В этом случае параметр fd
игнорируется и openat действует подобно функции open.
2.	 Параметр path содержит строку относительного пути, а параметр fd содержит
дескриптор файла, определяющего местоположение в файловой системе, отку-

3.3. Функции open и openat   

107

да будет откладываться относительный путь. Значение для параметра fd можно получить, открыв каталог, относительно которого должен откладываться
относительный путь.
3.	 Параметр path содержит строку относительного пути, а параметр fd содержит
специальное значение AT_FDCWD. В  этом случае путь начинает откладываться
от текущего рабочего каталога и функция openat действует подобно функции
open.
Функция openat принадлежит к группе функций, добавленных в последней версии POSIX.1 для решения двух проблем. Во-первых, она дает потокам выполнения возможность использовать относительные пути для открытия файлов в каталогах, отличных от текущего рабочего каталога. Как будет показано в главе 11, все
потоки выполнения в одном процессе разделяют один и тот же текущий рабочий
каталог, поэтому иногда бывает сложно организовать одновременную работу нескольких потоков выполнения в разных каталогах. Во-вторых, она позволяет избежать ошибок вида «проверка перед использованием» (time-of-check-to-time-ofuse, TOCTTOU).
Суть ошибок TOCTTOU в  том, что программа оказывается уязвимой, если вызывает две функции обращения к  файлам и  при этом второй вызов зависит от
результатов первого вызова. Поскольку два вызова выполняются неатомарно,
файл может измениться между вызовами, сделав результаты первого вызова недействительными, и  вызвать ошибку в  программе. Ошибки TOCTTOU обычно
используются для изменения привилегий доступа к файлам, обманом заставляя
привилегированную программу понизить права доступа к  привилегированному
файлу или изменить его, чтобы пробить брешь в системе безопасности. Вей и Пу
[Wei & Pu, 2005] обсуждают возможные ошибки TOCTTOU в интерфейсе файловой системы UNIX.

Усечение имени файла и строки пути
Что произойдет, если конфигурационный параметр NAME_MAX имеет значение 14
и мы попытаемся создать новый файл, имя которого состоит из 15 символов? Традиционно ранние версии System V, такие как SVR2, допускали это, просто усекая
длину имени файла до 14 символов. BSD-системы возвращали признак ошибки
с кодом ENAMETOOLONG в переменной errno. Простое усечение имени файла создает проблему, которая проявляет себя не только при создании нового файла. Так,
если параметр NAME_MAX имеет значение 14 и существует файл с именем ровно из
14  символов, ни одна из функций, принимающих имя пути к  файлу, например
open или stat, не сможет определить первоначальное имя файла, которое, возможно, было обрезано.
Конфигурационный параметр _POSIX_NO_TRUNC, предусматриваемый стандартом
POSIX.1, определяет, усекаются ли слишком длинные имена файлов и  строки
пути или возвращается признак ошибки. Как уже говорилось в главе 2, значение
этого параметра может варьироваться в зависимости от типа файловой системы,
и  мы можем применить функцию fpathconf или pathconf к  каталогу, чтобы узнать, какое поведение поддерживается.

108    Глава 3. Файловый ввод/вывод
Возвращается признак ошибки или нет, во многом обусловлено историческими причинами. Например, операционные системы, основанные на SVR4, не генерируют ошибку
для традиционной файловой системы S5. Для BSD-подобной файловой системы (известной также как UFS) те же самые системы возвращают признак ошибки. Другой
пример (см. табл. 2.16): Solaris сгенерирует ошибку для файловой системы UFS, но не
для PCFS, совместимой с файловой системой DOS, поскольку она «молча» усекает имена
файлов, не соответствующие формату 8.3. BSD-системы и Linux всегда возвращают
признак ошибки.

Когда параметр _POSIX_NO_TRUNC определен и  полный путь к  файлу превышает
значение PATH_MAX или какой-либо компонент имени файла или строки пути превышает значение NAME_MAX, возвращается признак ошибки и в переменную errno
записывается код ошибки ENAMETOOLONG.
Большинство современных систем поддерживают имена файлов длиной до 255 символов.
Поскольку имена файлов обычно короче этого предела, данное ограничение не является
большой проблемой для большинства приложений.

3.4. Функция creat
Новый файл можно также создать с помощью функции creat.
#include <fcntl.h>
int creat(const char *path, mode_t mode);

В случае успеха возвращает файловый дескриптор, доступный только
для записи, –1 — в случае ошибки
Обратите внимание: эта функция эквивалентна вызову
open(path, O_WRONLY | O_CREAT | O_TRUNC, mode);

В ранних версиях UNIX второй аргумент функции open мог принимать только три значения: 0, 1 или 2. Открыть несуществующий файл не было никакой возможности. Поэтому
для создания нового файла был необходим отдельный системный вызов. В  настоящее
время флаги O_CREAT и  O_TRUNC обеспечивают функцию open необходимыми средствами
для создания файлов, и потребность в функции creat отпала.

Порядок определения аргумента mode мы покажем в  разделе 4.5, когда во всех
подробностях будем описывать права доступа к файлам.
Функция creat имеет один недостаток: файл открывается только на запись. До
появления обновленной версии функции open, чтобы создать временный файл,
записать в него некоторые данные и потом прочитать их, требовалось вызывать
creat, close и затем open. Гораздо удобнее использовать в таких случаях функцию
open, как показано ниже:
open(path, O_RDWR | O_CREAT | O_TRUNC, mode);

3.6. Функция lseek   

109

3.5. Функция close
Закрытие открытого файла производится вызовом функции close.
#include <unistd.h>
int close(int fd);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Закрытие файла приводит также к  снятию любых блокировок, которые могли
быть наложены процессом. Мы обсудим этот вопрос в разделе 14.3.
При завершении процесса все открытые им файлы автоматически закрываются
ядром. Многие приложения используют это обстоятельство и не закрывают файлы явно. Примером тому служит программа в листинге 1.2.

3.6. Функция lseek
С любым открытым файлом связано такое понятие, как текущая позиция в файле.
Как правило, это неотрицательное целое число, которым выражается смещение
в байтах от начала файла. (Некоторые исключения, касающиеся слова «неотрицательное», будут упомянуты чуть позже.) Обычно операции чтения и  записи
начинают выполняться с  текущей позиции в  файле и  увеличивают ее значение
на количество прочитанных или записанных байтов. По умолчанию при открытии файла текущая позиция инициализируется числом 0, если не был установлен
флаг O_APPEND.
Явное изменение текущей позиции в  файле выполняется с  помощью функции
lseek.
#include <unistd.h>
off_t lseek(int fd, off_t offset, int whence);

Возвращает новую текущую позицию файла в случае успеха,
–1 — в случае ошибки
Интерпретация аргумента offset зависит от значения аргумента whence.
 Если аргумент whence имеет значение SEEK_SET, то offset интерпретируется как
смещение от начала файла.
 Если аргумент whence имеет значение SEEK_CUR, то offset интерпретируется как
смещение от текущей позиции в файле. В этом случае offset может принимать
и положительные, и отрицательные значения.
 Если аргумент whence имеет значение SEEK_END, то offset интерпретируется как
смещение от конца файла. В  этом случае offset может принимать и  положительные, и отрицательные значения.

110    Глава 3. Файловый ввод/вывод
Поскольку в случае успеха функция lseek возвращает новую текущую позицию
в файле, в аргументе offset можно передать 0, чтобы узнать текущую позицию:
off_t currpos;
currpos = lseek(fd, 0, SEEK_CUR);

Таким же способом можно определить, поддерживается ли свободное перемещение текущей позиции файла. Если файловый дескриптор относится к именованному или неименованному каналу либо к сокету, функция lseek вернет значение
–1 и запишет в переменную errno код ошибки ESPIPE.
Символьные константы SEEK_SET, SEEK_CUR и SEEK_END изначально появились в System V. До
этого аргумент whence мог принимать значения 0 (смещение от начала файла), 1 (смещение от текущей позиции) или 2 (смещение от конца файла). Многие программы до сих
пор используют эти предопределенные числовые значения.

Буква l в имени функции lseek означает «long integer» (длинное целое). До введения типа данных off_t аргумент offset и возвращаемое значение имели тип long.
Сама функция lseek впервые появилась в Version 7, когда в язык C был добавлен
тип длинных целых чисел. (В Version 6 была похожая функциональность, которая
обеспечивалась функциями seek и tell.)

Пример
Программа в листинге 3.1 проверяет возможность свободного перемещения текущей позиции в файле стандартного ввода.
Листинг 3.1. Проверка возможности свободного перемещения текущей позиции
в файле стандартного ввода
#include "apue.h"
int
main(void)
{
if (lseek(STDIN_FILENO, 0, SEEK_CUR) == -1)
printf("перемещение невозможно\n");
else
printf("перемещение выполнено\n");
exit(0);
}

Запустив эту программу, мы получим следующее:
$ ./a.out < /etc/passwd
перемещение выполнено
$ cat < /etc/passwd | ./a.out
перемещение невозможно
$ ./a.out < /var/spool/cron/FIFO
перемещение невозможно

Обычно смещение относительно текущей позиции должно быть неотрицательным целым числом. Однако некоторые устройства поддерживают отрицательные
смещения. Но для обычных файлов смещение должно быть неотрицательным.
Поскольку отрицательные смещения все-таки возможны, возвращаемое функци-

3.6. Функция lseek   

111

ей lseek значение следует сравнивать именно с числом –1, а не проверять, не является ли оно отрицательным.
В ОС FreeBSD на платформе Intel x86 устройство /dev/kmem поддерживает отрицательные смещения.
Поскольку тип off_t является целым числом со знаком (табл. 2.17), теряется половина
возможного максимального размера файла. Так, если off_t представляет 32-разрядное
целое со знаком, максимальный размер файла будет равен 231–1 байт.

Функция lseek изменяет значение текущей позиции в файле лишь в области данных ядра — фактически она не выполняет никаких операций ввода/вывода. Новое значение текущей позиции будет использовано ближайшей операцией чтения
или записи.
Текущая позиция в файле может превышать его текущий размер. В этом случае
следующая операция записи увеличит размер файла. Это вполне допустимо и может рассматриваться как создание «дырки» в файле. Байты, которые фактически
не были записаны, считываются как нули.
«Дырка» в файле не обязательно должна занимать место на диске. В некоторых
файловых системах в случае переноса текущей позиции за пределы файла на диске могут выделяться новые блоки для данных, но это совершенно необязательно.

Пример
Программа в листинге 3.2 создает файл с «дыркой».
Листинг 3.2. Создание файла с «дыркой»
#include "apue.h"
#include <fcntl.h>
char
char

buf1[] = "abcdefghij";
buf2[] = "ABCDEFGHIJ";

int
main(void)
{
int
fd;
if ((fd = creat("file.hole", FILE_MODE)) < 0)
err_sys("ошибка вызова creat");
if (write(fd, buf1, 10) != 10)
err_sys("ошибка записи buf1");
/* теперь текущая позиция = 10 */
if (lseek(fd, 16384, SEEK_SET) == -1)
err_sys("ошибка вызова lseek");
/* теперь текущая позиция = 16384 */
if (write(fd, buf2, 10) != 10)
err_sys("ошибка записи buf2");
/* теперь текущая позиция = 16394 */
}

exit(0);

112    Глава 3. Файловый ввод/вывод
Запустив эту программу, мы получим следующее:
$ ./a.out
$ ls -l file.hole
-rw-r--r-- 1 sar
$ od -c file.hole
0000000
0000020
*
0040000
0040012

проверим размер файла
16394 Nov 25 01:01 file.hole
посмотрим фактическое содержимое

a b c d e f g h i j \0 \0 \0 \0 \0 \0
\0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0 \0
A

B

C

D

E

F

G

H

I

J

Чтобы увидеть содержимое файла, мы воспользовались командой od(1). Флаг -c
сообщает ей, что содержимое следует выводить в виде символов. Как видите, байты, которые не были фактически записаны, читаются как нули. Семизначные числа в начале каждой строки — это смещение от начала файла в восьмеричном виде.
Чтобы убедиться, что в  файле действительно имеется «дырка», сравним только
что созданный файл с файлом того же размера, но без «дырки»:
$ ls -ls file.hole file.nohole
сравним размеры
8 -rw-r--r-- 1 sar
16394 Nov 25 01:01 file.hole
20 -rw-r--r-- 1 sar
16394 Nov 25 01:03 file.nohole

Несмотря на то что файлы имеют одинаковый размер, файл без «дырки» занимает
20 дисковых блоков, а файл с «дыркой» — всего 8.
В этом примере мы вызывали функцию write (раздел 3.8). О файлах с «дырками»
мы еще поговорим в разделе 4.12.
Поскольку для представления смещения функция lseek использует тип off_t,
реа­лизации поддерживают тот размер, который определен для конкретной платформы. Большинство современных платформ предоставляет два набора интерфейсов для работы со смещением в файле: 32- и 64-разрядный.
Стандарт Single UNIX Specification дает приложениям возможность с помощью
функции sysconf (раздел 2.5.4) узнать, какие интерфейсы поддерживаются системой. В табл. 3.1 приводится список констант для функции sysconf.
Таблица 3.1. Размеры типов данных и имена констант, передаваемые функции sysconf
Имя конфигурационного
параметра

Описание

Значение аргумента
name

_POSIX_V7_ILP32_OFF32

Типы int, long, указатели и off_t представлены 32 разрядами

_SC_V7_ILP32_OFF32

_POSIX_V7_ILP32_OFFBIG

Типы int, long и указатели представлены
32 разрядами, тип off_t имеет размер не
менее 64 разрядов

_SC_V7_ILP32_OFFBIG

_POSIX_V7_LP64_OFF64

Тип int представлен 32 разрядами, типы
long, указатели и off_t имеют размер
64 разряда

_SC_V7_LP64_OFF64

_POSIX_V7_LP64_OFFBIG

Тип int представлен 32 разрядами, типы
long, указатели и off_t имеют размер не
менее 64 разрядов

_SC_V7_LP64_OFFBIG

3.7. Функция read   

113

Компилятор c99 требует использовать команду getconf(1) для отображения
желаемой модели размерностей во флаги компиляции и связывания. В зависимости от конкретной реализации могут потребоваться различные флаги и биб­
лиотеки.
К сожалению, это одна из тех областей, в которых реализации отстают от стандартов.
Если ваша система не соответствует последней версии стандарта, возможно, она поддерживает имена параметров из предыдущей версии Single UNIX Specification: _POSIX_
V6_ILP32_OFF32, _POSIX_V6_ILP32_OFFBIG, _POSIX_V6_LP64_OFF64 и _POSIX_V6_LP64_OFFBIG.
Чтобы обойти эти препятствия, приложение может присвоить константе _FILE_OFFSET_
BITS значение 64 и обеспечить поддержку 64-разрядных смещений. Тогда тип off_t будет
определен как 64-разрядное целое со знаком. Установив константу _FILE_OFFSET_BITS
равной 32, мы сможем работать с 32-разрядными смещениями. Все четыре платформы,
обсуждаемые в данной книге, поддерживают 32- и 64-разрядные смещения, но помните,
что определение константы _FILE_OFFSET_BITS не гарантирует переносимости приложений и может не давать желаемого эффекта.
В табл. 3.2 приводятся размеры типа off_t в байтах для платформ, охватываемых этой
книгой, когда приложение не определяет константу _FILE_OFFSET_BITS, а также когда
приложение присваивает константе _FILE_OFFSET_BITS значение 32 или 64.
Таблица 3.2. Размер типа off_t в байтах для разных платформ
Операционная
система

Аппаратная
архитектура

Значение _FILE_OFFSET_BITS
Не определено

32

64

FreeBSD 8.0

x86 32-разрядная

8

8

8

Linux 3.2.0

x86 64-разрядная

8

8

8

Mac OS X 10.6.8

x86 64-разрядная

8

8

8

Solaris 10

SPARC 64-разрядная

8

4

8

Обратите внимание: даже если у  вас установлены 64-разрядные смещения, возможность создания файлов размером более 2 Гбайт (231–1 байт) зависит от реализации файловой системы.

3.7. Функция read
Чтение данных из открытого файла производится функцией read.
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t nbytes);

Возвращает количество прочитанных байтов,
0 — если достигнут конец файла, –1 — в случае ошибки

114    Глава 3. Файловый ввод/вывод
В случае успеха функция read возвращает количество прочитанных байтов. Если
достигнут конец файла, возвращается 0.
Существует несколько ситуаций, когда количество фактически прочитанных байтов меньше, чем было запрошено:
 При чтении из обычного файла, когда конец файла встретился до того, как
было прочитано требуемое количество байтов. Например, если до конца файла
осталось 30 байт, а запрошено 100, функция read вернет число 30. При следующем вызове она вернет 0 (конец файла).
 При чтении из терминального устройства. Обычно за одно обращение читается одна строка. (В главе 18 мы увидим, как это можно изменить.)
 При чтении данных из Сети. Промежуточная буферизация может стать причиной получения меньшего количества байтов, чем было запрошено.
 При чтении из именованных или неименованных каналов. Если в канале содержится меньше байтов, чем было запрошено, функция read вернет только то,
что ей будет доступно.
 При чтении из устройства, ориентированного на доступ к отдельным записям.
Примером такого устройства является накопитель на магнитной ленте, который может вернуть только одну запись за одно обращение.
 При прерывании операции чтения сигналом, когда часть данных уже была
прочитана. Эту ситуацию мы обсудим подробнее в разделе 10.5.
Операция чтения начинается с текущей позиции в файле. В случае успеха текущая позиция увеличивается на число фактически прочитанных байтов.
Стандарт POSIX.1 изменил прототип функции read. Вот как выглядит классическое определение этой функции:
int read(int fd, char *buf, unsigned nbytes);

 Во-первых, тип второго аргумента (char *) был изменен на void * для совместимости со стандартом ISO C: тип void * используется для определения нетипизированных указателей.
 Далее, возвращаемое значение должно быть целым числом со знаком (ssize_t),
чтобы была возможность вернуть положительное число (количество прочитанных байтов), 0 (признак конца файла) или –1 (признак ошибки).
 И наконец, третий аргумент исторически был целым числом без знака, что
позволяло в  16-разрядных реализациях читать и  записывать до 65  534 байт
за одно обращение. В редакции стандарта POSIX.1 1990 года введены новые
типы данных: ssize_t для представления возвращаемого значения как целого со знаком и  size_t, целое без знака, для представления третьего аргумента.
(Вспомните константу SSIZE_MAX из раздела 2.5.2.)

3.8. Функция write
Запись данных в открытый файл производится функцией write.

3.9. Эффективность операций ввода/вывода   

115

#include <unistd.h>
ssize_t write(int fd, const void *buf, size_t nbytes);

Возвращает количество записанных байтов в случае успеха,
–1 — в случае ошибки
Возвращаемое значение обычно совпадает со значением аргумента nbytes, в противном случае возвращается признак ошибки. Наиболее распространенные случаи, когда возникает ошибка записи,  — переполнение диска или превышение
ограничения на размер файла для заданного процесса (раздел 7.11 и  упражнение 10.11).
Для обычных файлов запись начинается с текущей позиции в файле. Если файл
открыт с флагом O_APPEND, перед началом каждой операции записи текущая позиция устанавливается в  конец файла. По окончании записи значение текущей
позиции увеличивается на количество фактически записанных байтов.

3.9. Эффективность операций ввода/вывода
Программа в  листинге 3.3 выполняет копирование файлов, используя функции
read и write.
Листинг 3.3. Копирование из стандартного ввода в стандартный вывод
#include "apue.h"
#define BUFFSIZE

4096

int
main(void)
{
int
n;
char
buf[BUFFSIZE];
while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
if (write(STDOUT_FILENO, buf, n) != n)
err_sys("ошибка записи");
if (n < 0)
err_sys("ошибка чтения");
}

exit(0);

Вот несколько пояснений к этой программе.
 Если чтение производится из стандартного ввода, а  запись  — в  стандартный
вывод, предполагается, что они должным образом открыты командной оболочкой до запуска программы. В  действительности все командные оболочки UNIX, как правило, позволяют открыть файл для чтения на устройстве
стандартного ввода и создания (или перезаписи) на устройстве стандартного
вывода. Это освобождает программы от необходимости открывать входной

116    Глава 3. Файловый ввод/вывод
и выходной файлы и дает пользователю возможность использовать механизм
перенаправления ввода/вывода, поддерживаемый командной оболочкой.
 Программа не закрывает входной и выходной файлы. Все открытые дескрипторы закрываются ядром UNIX по завершении процесса, и программа использует это свойство.
 Этот пример одинаково хорошо работает с текстовыми и с двоичными файлами, поскольку ядро не делает никаких различий между этими двумя форматами.
Еще один вопрос, на который предстоит ответить: как выбрать правильное значение константы BUFFSIZE. Прежде чем дать на него ответ, попробуем запустить
программу с различными значениями BUFFSIZE. В табл. 3.3 приведены результаты
чтения файла размером 516 581 760 байт с использованием 20 различных размеров буфера.
Таблица 3.3. Производительность операции чтения с различными размерами буфера
в ОС Linux
Пользовательское
время (секунды)

Системное время
(секунды)

1

20,03

117,50

138,73

516 581 760

2

9,69

58,76

68,60

258 290 880

4

4,60

36,47

41,27

129 145 440

8

2,47

15,44

18,38

64 572 720

16

1,07

7,93

9,38

32 286 360

32

0,56

4,51

8,82

16 143 180

64

0,34

2,72

8,66

8 071 590

128

0,34

1,84

8,69

4 035 795

256

0,15

1,30

8,69

2 017 898

512

0,09

0,95

8,63

1 008 949

1024

0,02

0,78

8,58

504 475

2048

0,04

0,66

8,68

252 238

4096

0,03

0,58

8,62

126 119

8192

0,00

0,54

8,52

63 060

16 384

0,01

0,56

8,69

31 530

32 768

0,00

0,56

8,51

15 765

65 536

0,01

0,56

9,12

7883

131 072

0,00

0,58

9,08

3942

262 144

0,00

0,60

8,70

1971

524 288

0,01

0,58

8,58

986

BUFFSIZE

Общее время
(секунды)

Количество циклов

3.10. Совместное использование файлов   

117

Файл читался программой из листинга 3.3 с перенаправлением стандартного вывода в устройство /dev/null. Эксперимент проводился в файловой системе Linux
ext4 с  размером дискового блока 4096 байт. (Значение st_blksize, которое мы
рассмотрим в разделе 4.12, составляет 4096.) Это объясняет, почему наименьшее
системное время приходится именно на этот размер BUFFSIZE. Дальнейшее увеличение буфера дает лишь незначительный положительный эффект.
Для повышения производительности большинство файловых систем поддерживают опережающее чтение. Обнаружив ряд последовательных операций чтения,
система пытается прочитать больший объем данных, чем было запрошено приложением, предполагая, что программа вскоре продолжит чтение. Эффект влияния опережающего чтения можно наблюдать в табл. 3.3, где время чтения для
буфера размером 32 байта почти совпадает со временем для буферов большего
размера.
Позднее мы еще вернемся к этой таблице. В разделе 3.14 мы покажем результат
выполнения операции синхронной записи, в разделе 5.8 сравним время выполнения операций небуферизованного ввода/вывода и функций стандартной библиотеки ввода/вывода.
Будьте внимательны, измеряя производительность программ, работающих с файлами.
Операционная система попытается кэшировать файл в оперативной памяти (incore), поэтому при проведении серии экспериментов с одним и тем же файлом каждый последующий
результат обычно лучше самого первого. Это происходит потому, что первая операция
ввода/вывода поместит файл в системный кэш и каждый последующий прогон программы будет получать данные из кэша, а не с диска. (Термин incore означает оперативную
память. Много лет назад оперативная память компьютеров строилась на магнитных
ферритовых сердечниках (по-английски core). Отсюда же взялся и термин «core dump»
(дамп памяти) — образ оперативной памяти программы, сохраненный в файле на диске
для последующего анализа.)
В эксперименте, результаты которого показаны в  табл. 3.3, участвовали различные
копии файла, поэтому использование системного кэша было сведено к минимуму. Размер
этих файлов достаточно велик, поэтому они не могут находиться в кэше одновременно
(тестовая система имела 6 Гбайт ОЗУ).

3.10. Совместное использование файлов
ОС UNIX поддерживает совместное использование открытых файлов несколькими процессами. Нам необходимо разобраться с этой возможностью, прежде чем
мы перейдем к описанию функции dup. Для этого рассмотрим структуры данных,
которые используются ядром при выполнении всех операций ввода/вывода.
Далее следует лишь концептуальное описание, которое может не совпадать с конкретной реализацией. За описанием структур в System V следует обращаться к [Bach, 1986].
В [McKusick et al., 1996] описаны те же структуры применительно к 4.4BSD. В [McKusick
and NevilleNeil, 2005] рассматривается FreeBSD 5.2. Аналогичное описание для Solaris вы
найдете в [Mauro and McDougall, 2001]. Обсуждение архитектуры ядра Linux 2.6 можно
найти в [Bovet and Cesati, 2006].

118    Глава 3. Файловый ввод/вывод
Ядро использует три структуры данных для представления открытого файла,
а отношения между ними определяют взаимовлияние процессов при совместном
использовании файлов.
1.	 Каждому процессу соответствует запись в  таблице процессов. С  каждой
записью в  таблице процессов связана таблица открытых файловых дескрипторов, которую можно представить как таблицу, в которой каждая строка соответствует одному файловому дескриптору. Для каждого дескриптора хранится
следующая информация:
a)	 флаги дескриптора (флаг close-on-exec  — закрыть-при-вызове-exec, см.
рис. 3.1 и раздел 3.14);
б)	 указатель на запись в таблице файлов.
2.	 Все открытые файлы представлены в  ядре таблицей файлов. Каждая запись
в таблице содержит:
a)	 флаги состояния файла, такие как чтение, запись, добавление в конец, синхронный режим операций ввода/вывода, неблокирующий режим (подробнее о них рассказывается в разделе 3.14);
б)	 текущая позиция в файле;
в)	 указатель на запись в таблице виртуальных узлов (v-node).
3.	 Каждому открытому файлу (или устройству) соответствует структура виртуального узла (v-node) с информацией о типе файла и указатели для функций,
работающих с файлом. Для большинства файлов структура v-node также содержит индексный узел (i-node) файла. Эта информация считывается с диска
при открытии файла, поэтому вся информация о файле сразу же становится
доступной. Индексный узел (i-node) содержит, например, сведения о владельце файла, размере файла, указатели на блоки данных на диске и  т. п. (Более
подробно об индексных узлах мы поговорим в разделе 4.14 при описании типичной файловой системы UNIX.)
В Linux отсутствует понятие виртуальных узлов (vnode). Вместо него используются
структуры индексных узлов (inode). Хотя реализация их различна, концептуально они
представляют собой одно и то же. В обоих случаях индексный узел хранит информацию,
специфичную для конкретной файловой системы.

Мы опустим некоторые особенности отдельных реализаций, не имеющие для
нас большого значения. Например, таблица открытых дескрипторов может храниться не в  таблице процессов, а  в  пространстве пользователя. Сами таблицы
могут быть реализованы по-разному: они не обязательно должны быть массивами, вместо этого они могут быть оформлены в виде связанных списков структур.
Все эти подробности несущественны для нашего обсуждения совместного доступа к файлам.
На рис. 3.1 показаны все три таблицы для одного процесса, открывшего два файла — файл стандартного ввода (дескриптор 0) и файл стандартного вывода (дескриптор 1).

3.10. Совместное использование файлов   

Таблица дескрипторов процесса
Указатель
на запись
Флаги
в таблице
дескриптора
файлов

fd 0:
fd 1:
fd 2:

...

Запись в таблице файлов

Запись в таблице
виртуальных узлов

Флаги состояния файла

Информация
виртуального узла

Текущая позиция в файле

v_data

Указатель на виртуальный узел

Запись в таблице файлов
Флаги состояния файла
Текущая позиция в файле
Указатель на виртуальный узел

119

Индексный узел
Информация
индексного узла
Текущий размер файла
i_vnode

Запись в таблице
виртуальных узлов
Информация
виртуального узла
v_data

Индексный узел
Информация
индексного узла
Текущий размер файла
i_vnode

Рис. 3.1. Структуры данных ядра для открытых файлов

Взаимоотношения между таблицами определились, начиная с  ранних версий
UNIX [Thompson, 1978], и они оказывают весьма существенное влияние на способ совместного использования одного файла несколькими процессами. Мы еще
вернемся к этому рисунку в последующих главах, когда будем обсуждать другие
способы совместного использования файлов.
Идея виртуального узла (vnode) зародилась в попытках обеспечить поддержку нескольких
типов файловых систем в рамках одной операционной системы. Эта работа была проделана независимо Питером Вейнбергером (Peter Weinberger) из Bell Labaratories и Биллом
Джоем (Bill Joy) из Sun Microsystems. В Sun эта концепция получила название Virtual File
System (виртуальная файловая система), а часть индексного узла (inode), не зависящая
от типа файловой системы, была названа виртуальным узлом (vnode) [Kleiman, 1986].
Концепция виртуальных узлов распространилась на различные реализации UNIX вместе
с поддержкой Network File System (NFS — сетевая файловая система) компании Sun. Первой
версией из Беркли, поддерживающей виртуальные узлы, стала 4.3BSD Reno, в которую
была добавлена поддержка NFS.
В SVR4 виртуальные узлы заменили индексные узлы версии SVR3. Solaris, как наследник
SVR4, также использует концепцию виртуальных узлов.
Вместо разделения структур данных на виртуальные и индексные узлы в Linux используются понятия индексных узлов, независимых от типа файловой системы, и индексных
узлов, зависящих от типа файловой системы.

Ситуация, когда два независимых процесса открывают один и  тот же файл, показана на рис. 3.2.

120    Глава 3. Файловый ввод/вывод
Таблица дескрипторов процесса
Флаги
дескриптора

fd 0:
fd 1:
fd 2:
fd 3:

Указатель
на запись
в таблице
файлов

Запись в таблице файлов

...

Флаги состояния файла
Текущая позиция в файле
Указатель на виртуальный узел

Таблица дескрипторов процесса
Флаги
дескриптора

Указатель
на запись
в таблице
файлов

fd 0:
fd 1:
fd 2:
fd 3:
fd 4:

Запись в таблице файлов

Запись в таблице
виртуальных узлов
Информация
виртуального узла

Флаги состояния файла

v_data

Текущая позиция в файле

Индексный узел

Указатель на виртуальный узел

Информация
индексного узла
Текущий размер файла

...

i_vnode

Рис. 3.2. Два независимых процесса открыли один и тот же файл

Здесь мы предполагаем, что первый процесс открывает этот файл с  дескриптором 3, а второй открывает тот же самый файл с дескриптором 4. Каждый процесс,
открывающий файл, создает собственную запись в таблице файлов, но двум этим
записям соответствует единственная запись в таблице виртуальных узлов. Одна
из причин создания отдельной записи в  таблице файлов для каждого процесса
состоит в том, что у каждого процесса должна быть собственная текущая позиция
в файле.
Теперь, разобравшись со структурами данных, рассмотрим подробнее, что происходит в процессе описанных выше операций ввода/вывода.
 В таблице файлов после завершения каждой операции записи текущая позиция в файле увеличивается на количество записанных байтов. Если текущая
позиция оказывается больше текущего размера файла, в  таблице индексных
узлов изменяется размер файла в соответствии с текущей позицией (это происходит, например, при добавлении новых данных в конец файла).
 Если файл открыт с флагом O_APPEND, в таблице файлов устанавливается соответствующий флаг. Каждый раз при выполнении операции записи в качестве
текущей позиции принимается значение размера файла из таблицы индексных
узлов. В результате запись всегда производится в конец файла.
 Если текущая позиция переносится в конец файла с помощью функции lseek,
выполняется только перезапись значения текущего размера файла из таблицы
индексных узлов в поле текущей позиции в таблице файлов. (Обратите вни-

3.11. Атомарные операции   

121

мание: это не то же самое, что открытие файла с флагом O_APPEND, о чем будет
говориться в разделе 3.11.)
 Функция lseek изменяет в таблице файлов только значение текущей позиции
в файле. Никаких операций ввода/вывода при этом не производится.
Существует возможность открыть несколько дескрипторов, ссылающихся на одну
запись в таблице файлов; мы увидим это в разделе 3.12 при обсуждении функции
dup. То же происходит в  результате вызова функции fork, когда родительский
и дочерний процессы совместно используют одни и те же записи в таблице файлов для каждого из открытых дескрипторов (раздел 8.3).
Обратите внимание на различия между флагами дескриптора и флагами состояния файла. Флаги дескриптора уникальны для каждого отдельно взятого дескриптора, открытого процессом, тогда как флаги состояния файла имеют отношение
ко всем дескрипторам в  любом процессе, ссылающемся на одну и  ту же запись
в  таблице файлов. Рассматривая функцию fcntl в  разделе 3.14, мы узнаем, как
получить и изменить значения флагов дескриптора и флагов состояния файла.
Все описанное выше в этом разделе прекрасно работает, когда несколько процессов читают данные из одного и того же файла. Каждый процесс имеет собственную запись в таблице файлов со своим собственным значением текущей позиции
в файле. Однако можно получить совершенно неожиданные результаты, если несколько процессов попытаются выполнить запись данных в один и тот же файл.
Чтобы избежать неприятных сюрпризов в будущем, необходимо разобраться с понятием атомарности операций.

3.11. Атомарные операции
Добавление данных в конец файла
Рассмотрим процесс, который дописывает данные в конец файла. Старые версии
UNIX не поддерживали флаг O_APPEND для функции open, в результате приходилось писать нечто вроде:
if (lseek(fd, 0L, 2) < 0)
/* переместить текущую позицию в конец файла */
err_sys("ошибка вызова функции lseek");
if (write(fd, buf, 100) != 100)
/* и выполнить запись */
err_sys("ошибка вызова функции write");

Такой код будет прекрасно работать в  случае единственного процесса, но могут
возникнуть проблемы, если добавление данных в конец файла производится сразу несколькими процессами. (Подобная ситуация возможна, например, когда несколько процессов добавляют сообщения в файл журнала.)
Допустим, что существуют два независимых процесса A и B, которые записывают
данные в  конец одного и  того же файла. Оба процесса открыли файл без флага
O_APPEND. Эта ситуация изображена на рис. 3.2. Каждый процесс имеет собственную запись в таблице файлов, но при этом они ссылаются на одну и ту же запись
в таблице виртуальных узлов. Предположим, что процесс A вызывает функцию
lseek и  устанавливает текущую позицию файла в  значение 1500 (текущий раз-

122    Глава 3. Файловый ввод/вывод
мер файла). Затем ядро приостанавливает работу процесса A и передает управление процессу B, который, в свою очередь, также вызывает функцию lseek и также
устанавливает текущую позицию файла в значение 1500 (текущий размер файла).
После этого процесс B вызывает функцию write, которая увеличивает текущую
позицию файла до 1600. Поскольку размер файла увеличился, ядро записывает
новое значение размера файла (1600) в таблицу виртуальных узлов. После этого
ядро опять переключает процессы и передает управление процессу A. Когда процесс A вызывает функцию write, запись выполняется с места, на которое указывает значение текущей позиции в файле для процесса A, то есть 1500. В результате
данные окажутся записанными поверх тех, что записаны процессом B.
Проблема в том, что операция «перейти в конец файла и записать данные» требует обращения к двум отдельным функциям (как мы только что показали). Решением проблемы было бы атомарное (относительно других процессов) выполнение
операции позиционирования и записи. Никакая операция, требующая обращения
более чем к  одной функции, не может быть атомарной, поскольку всегда существует вероятность, что ядро временно приостановит процесс между двумя последовательными вызовами функций (как это было показано выше).
ОС UNIX позволяет выполнить эту операцию атомарно, если указать флаг
O_APPEND при открытии файла. Как уже говорилось в предыдущем разделе, этот
флаг заставит ядро выполнять перенос текущей позиции в конец файла непосредственно перед операцией записи. А кроме того, отпадает необходимость вызывать
функцию lseek перед каждым вызовом функции write.

Функции pread и pwrite
Стандарт Single UNIX Specification включает расширения XSI, которые позволяют процессам атомарно выполнять операции перемещения текущей позиции
и ввода/вывода. Эти расширения представлены функциями pread и pwrite.
#include <unistd.h>
ssize_t pread(int fd, void *buf, size_t nbytes, off_t offset);

Возвращает количество прочитанных байтов, 0 — по достижении
конца файла и –1 — в случае ошибки
ssize_t pwrite(int fd, const void *buf, size_t nbytes, off_t offset);

Возвращает количество записанных байтов или –1 — в случае ошибки
Вызов функции pread эквивалентен двум последовательным вызовам функций
lseek и read со следующими отличиями.
 При использовании pread нет возможности прервать выполнение этих двух
операций.
 Значение текущей позиции в файле не изменяется.
Вызов функции pwrite эквивалентен двум последовательным вызовам функций
lseek и write с аналогичными отличиями.

3.12. Функции dup и dup2   

123

Создание файла
Еще один пример атомарной операции мы видели при описании флагов O_CREAT
и O_EXCL функции open. При одновременном указании обоих флагов функция open
будет завершаться ошибкой, если файл уже существует. Мы также говорили, что
проверка существования файла и  создание файла будут выполняться атомарно.
Если бы не было такой атомарной операции, мы могли бы попробовать написать
нечто вроде
if ((fd = open(path, O_WRONLY)) < 0) {
if (errno == ENOENT) {
if ((fd = creat(path, mode)) < 0)
err_sys("ошибка вызова функции creat");
} else {
err_sys("ошибка вызова функции open");
}
}

Эта ситуация чревата проблемами, если файл с тем же именем будет создан другим процессом между обращениями к функциям open и  creat. Если другой процесс создаст файл между вызовами этих функций и  успеет туда что-либо записать, эти данные будут утеряны, когда первый процесс вызовет функцию creat.
Объединение проверки существования файла и его создания в единую атомарную
операцию решает проблему.
Вообще говоря, термин атомарная операция относится к  таким операциям, которые могут состоять из нескольких действий. Если операция атомарна, то либо
будут выполнены все необходимые действия до конца, либо не будет выполнено ни одно из них. Атомарность не допускает выполнения лишь некоторой части
действий. К теме атомарных операций мы еще вернемся, когда будем рассматривать функцию link (раздел 4.15) и блокировку отдельных записей в файле (раздел 14.3).

3.12. Функции dup и dup2
Дубликат дескриптора существующего файла можно создать с помощью одной из
следующих функций:
#include <unistd.h>
int dup(int fd);
int dup2(int fd, int fd2);

Возвращают новый дескриптор файла или –1 — в случае ошибки
Функция dup гарантирует, что возвращаемый ею новый файловый дескриптор
будет иметь наименьшее возможное значение. Вызывая функцию dup2, мы указываем значение нового дескриптора в аргументе fd2. Если дескриптор fd2 перед вызовом функции уже был открыт, он предварительно закрывается. Если значения

124    Глава 3. Файловый ввод/вывод
аргументов fd и fd2 равны, функция dup2 вернет дескриптор fd2, не закрывая его.
В противном случае для дескриптора fd2 сбрасывается флаг FD_CLOEXEC, чтобы он
оставался открытым после вызова exec процессом.
Новый файловый дескриптор, возвращаемый функциями, будет ссылаться на
ту же запись в  таблице файлов, что и  дескриптор fd. Продемонстрируем это на
рис. 3.3.
Таблица дескрипторов процесса
Указатель
на запись
в таблице
файлов

Флаги
дескриптора

fd 0:
fd 1:
fd 2:
fd 3:

Запись в таблице файлов
Флаги состояния файла
Текущая позиция в файле

...

Указатель на виртуальный узел

Запись в таблице
виртуальных узлов
Информация
виртуального узла
v_data

Индексный узел
Информация
индексного узла
Текущий размер файла
i_vnode

Рис. 3.3. Структуры в ядре после вызова функции dup(1)

На рис. 3.3 предполагается, что процесс при запуске выполняет код
newfd = dup(1);

Допустим, что следующий доступный дескриптор — число 3 (что наиболее вероятно, потому что командная оболочка уже открыла для процесса дескрипторы 0,
1 и 2). Поскольку оба дескриптора указывают на одну и ту же запись в таблице
файлов, они совместно будут использовать флаги состояния файла — чтение, запись, добавление в конец и пр. и текущая позиция в файле в них будет совпадать.
Каждый дескриптор имеет собственный набор флагов. Как описывается в разделе 3.14, функция dup всегда сбрасывает флаг close-on-exec («закрыть-при-вызовеexec») в новом дескрипторе.
Дубликат дескриптора можно также создать с помощью функции fcntl, которая
описывается в разделе 3.14. На самом деле вызов
dup(fd);

эквивалентен вызову
fcntl(fd, F_DUPFD, 0);

Аналогично вызов
dup2(fd, fd2);

эквивалентен паре вызовов
close(fd2);
fcntl(fd, F_DUPFD, fd2);

3.13. Функции sync, fsync и fdatasync   

125

В последнем случае вызов dup2 не является точным эквивалентом двух последовательных вызовов close и fcntl. Имеются следующие различия.
1.	 Функция dup2 действует атомарно, тогда как альтернативная форма состоит
из вызовов двух функций. В результате возникает вероятность, что между обращениями к  функциям close и  fcntl будет вызван обработчик сигнала, который изменит дескриптор файла. (Сигналы будут обсуждаться в  главе 10.)
Та  же проблема может возникнуть, если другой поток выполнения изменит
дескриптор. (Потоки выполнения будут обсуждаться в главе 10.)
2.	 Существуют отличия в кодах ошибок, возвращаемых через errno функциями
dup2 и fcntl.
Системный вызов dup2 впервые появился в  Version 7 и  затем перекочевал в  BSD. Возможность создания дубликатов дескрипторов с  помощью fcntl появилась в  System III
и перешла в System V. В SVR3.2 была включена функция dup2, а в 4.2BSD — функция fcntl
и параметр F_DUPFD. Стандарт POSIX.1 требует как наличия функции dup2, так и поддержки функцией fcntl параметра F_DUPFD.

3.13. Функции sync, fsync и fdatasync
Традиционные реализации UNIX имеют в  своем распоряжении буферный кэш,
или кэш страниц, через который выполняется большинство дисковых операций
ввода/вывода. При записи данных в файл они, как правило, сначала помещаются
ядром в один из буферов, а затем ставятся в очередь для записи на диск в более
позднее время. Этот прием называется отложенной записью. (В главе 3 [Bach,
1986] детально рассматривается работа буферного кэша.)
Ядро обычно записывает отложенные данные на диск, когда возникает необходимость в  повторном использовании буфера. Для синхронизации файловой системы на диске и содержимого буферного кэша существуют функции sync, fsync
и fdatasync.
#include <unistd.h>
int fsync(int fd);
int fdatasync(int fd);

Возвращают 0 в случае успеха, –1 — в случае ошибки
void sync(void);

Функция sync просто ставит все измененные блоки буферов в очередь для записи
и возвращает управление — она не ждет, пока данные фактически запишутся на
диск.
Функция sync, как правило, вызывается периодически (обычно каждые 30 секунд) из системного демона, часто называемого update. Это обеспечивает регуляр-

126    Глава 3. Файловый ввод/вывод
ную очистку буферного кэша ядра. Команда sync(1) также обращается к функции
sync.
Функция fsync применяется только к одному файлу, который определяется файловым дескриптором fd, кроме того, она ожидает завершения физической записи
данных на диск, прежде чем вернуть управление. В основном функция fsync предназначена для таких приложений, как базы данных, чтобы гарантировать запись
измененных блоков с данными на диск.
Функция fdatasync похожа на функцию fsync, но воздействует только на содержимое файла. (При использовании fsync также синхронно обновляются атрибуты файла.)
Все четыре платформы, обсуждаемые в  книге, поддерживают функции sync и  fsync.
Однако функция fdatasync не поддерживается в FreeBSD 8.0.

3.14. Функция fcntl
С помощью функции fcntl можно изменять свойства уже открытого файла.
#include <fcntl.h>
int fcntl(int fd, int cmd, ... /* int arg */ );

Возвращаемое значение зависит от аргумента cmd (см. ниже)
в случае успеха, –1 — в случае ошибки
В последующих примерах третий аргумент всегда будет представлен целым числом — в соответствии с комментарием в прототипе функции. Однако при обсуждении блокировки записей в  разделе 14.3 третий аргумент будет представлять
указатель на структуру.
Функция fcntl используется в пяти различных случаях.
1.	 Создание дубликата существующего дескриптора (cmd = F_DUPFD или F_DUPFD_
CLOEXEC).
2.	 Получение/установка флагов дескриптора (cmd = F_GETFD или F_SETFD).
3.	 Получение/установка флагов состояния файла (cmd = F_GETFL или F_SETFL).
4.	 Проверка/установка владельца для асинхронных операций ввода/вывода
(cmd = F_GETOWN или F_SETOWN).
5.	 Получение/установка блокировки на отдельную запись в  файле (cmd =
F_GETLK, F_SETLK или F_SETLKW).
Теперь рассмотрим первые восемь значений аргумента cmd из одиннадцати возможных. (Описание остальных трех, связанных с блокировкой записей, отложим
до раздела 14.3.) Взгляните еще раз на рис. 3.1, так как мы будем ссылаться на флаги дескрипторов файлов, связанные с каждым дескриптором в таблице дескрипторов процесса, и на флаги состояния файла, связанные с каждым файлом в таблице
файлов.

3.14. Функция fcntl   

127

Создает дубликат дескриптора fd. Новый файловый дескриптор передается в вызывающую программу в виде возвращаемого значения. Это будет наименьший неиспользованный дескриптор, значение которого больше или равно
третьему аргументу (заданному в  виде целого числа). Новый дескриптор будет
ссылаться на ту же запись в таблице файлов, что и fd (рис. 3.3). Но при этом новый
дескриптор будет иметь собственный набор флагов, а флаг FD_CLOEXEC будет сброшен. (Это означает, что дескриптор останется открытым после вызова функции
exec, которая обсуждается в главе 8.)
F_DUPFD_CLOEXEC Создает дубликат дескриптора и устанавливает флаг FD_CLOEXEC
для нового дескриптора. Возвращает новый файловый дескриптор.
F_GETFD Возвращает флаги дескриптора fd. В настоящее время определен только
один флаг — FD_CLOEXEC.
F_SETFD Устанавливает флаги дескриптора fd. Новые значения флагов берутся
из третьего аргумента (заданного в виде целого числа).
F_DUPFD

Вы должны знать, что существуют программы, которые работают с флагами дескрипторов, но не используют константу FD_CLOEXEC. Вместо этого они используют значение 0
(сбросить флаг FD_CLOEXEC) или 1 (установить флаг FD_CLOEXEC).
F_GETFL Возвращает флаги состояния файла fd. Мы уже описывали флаги состояния файла, когда обсуждали функцию open. Они перечислены в табл. 3.4.

К сожалению, пять флагов, O_RDONLY, O_WRONLY, O_RDWR, O_EXEC и  O_SEARCH, представлены числовыми значениями, а не отдельными битами, которые можно было
бы проверить. (Как уже говорилось, первые три в  силу исторических причин
обычно имеют значения 0, 1 и 2 соответственно. Кроме того, эти значения являются взаимоисключающими — для файла может быть установлен только один из
этих флагов.) Поэтому следует сначала применить маску O_ACCMODE, чтобы выделить режимы доступа, и лишь потом сравнивать полученный результат с любым
из пяти значений.
F_SETFL Устанавливает флаги состояния файла. Новые значения флагов берутся
из третьего аргумента (заданного в виде целого числа). Изменить можно только
флаги O_APPEND, O_NONBLOCK, O_SYNC, O_DSYNC, O_RSYNC, O_FSYNC и O_ASYNC.
F_GETOWN Возвращает идентификатор процесса или группы процессов, которые
в настоящее время получают сигналы SIGIO и  SIGURG. Эти сигналы асинхронного
ввода/вывода рассматриваются в разделе 14.5.2.
F_SETOWN Назначает идентификатор процесса или группы процессов, которые будут получать сигналы SIGIO и SIGURG. Положительное значение аргумента arg интерпретируется как идентификатор процесса, отрицательное — как идентификатор группы процессов, эквивалентный абсолютному значению аргумента arg.
Значение, возвращаемое функцией fcntl, зависит от конкретной команды. Все
команды возвращают –1 в случае ошибки и другие значения — в случае успеха.
Команды F_DUPFD, F_GETFD, F_GETFL и F_GETOWN возвращают специальные значения.
Первые две — дескриптор файла, другие две — соответствующие флаги и последняя — идентификатор процесса (положительное значение) или группы процессов
(отрицательное значение).

128    Глава 3. Файловый ввод/вывод
Таблица 3.4. Флаги состояния файла, используемые функцией fcntl
Флаг состояния
файла

Описание

O_RDONLY

Файл открыт только для чтения

O_WRONLY

Файл открыт только для записи

O_RDWR

Файл открыт для чтения и записи

O_EXEC

Файл открыт только для выполнения

O_SEARCH

Каталог открыт только для поиска

O_APPEND

Файл открыт для добавления в конец

O_NONBLOCK

Неблокирующий режим

O_SYNC

Ожидать завершения операции записи (данных и атрибутов)

O_DSYNC

Ожидать завершения операции записи (только данных)

O_RSYNC

Синхронизировать операции чтения и записи

O_FSYNC

Ожидать завершения операции записи (только FreeBSD и Mac OS X)

O_ASYNC

Асинхронный режим ввода/вывода (только FreeBSD и Mac OS X)

Пример
Программа в листинге 3.4 принимает из командной строки один аргумент, который определяет дескриптор файла, и выводит значения флагов состояния файла
для этого дескриптора.
Листинг 3.4. Вывод флагов состояния файла для заданного дескриптора
#include "apue.h"
#include <fcntl.h>
int
main(int argc, char *argv[])
{
int
val;
if (argc != 2)
err_quit("Использование: a.out <номер_дескриптора>");
if ((val = fcntl(atoi(argv[1]), F_GETFL, 0)) < 0)
err_sys("ошибка fcntl для дескриптора %d", atoi(argv[1]));
switch (val & O_ACCMODE) {
case O_RDONLY:
printf("только для чтения");
break;
case O_WRONLY:

3.14. Функция fcntl   

129

printf("только для записи");
break;
case O_RDWR:
printf("для чтения и для записи");
break;
default:
err_dump("неизвестный режим доступа");
}
if (val & O_APPEND)
printf(", добавление в конец");
if (val & O_NONBLOCK)
printf(", неблокирующий режим");
if (val & O_SYNC)
printf(", синхронный режим записи");
#if !defined(_POSIX_C_SOURCE) && defined(O_FSYNC) && (O_FSYNC != O_SYNC)
if (val & O_FSYNC)
printf(", синхронный режим записи");
#endif

}

putchar('\n');
exit(0);

Обратите внимание, что мы использовали макроопределение проверки функцио­
нальных особенностей _POSIX_C_SOURCE и  условную компиляцию для флагов,
которые не являются частью стандарта POSIX.1. Следующий сценарий демонстрирует работу программы, когда она запускается из bash (Bourne-again shell).
В зависимости от используемой командной оболочки полученные результаты могут несколько отличаться от приведенных здесь.
$ ./a.out 0 < /dev/tty
Только для чтения
$ ./a.out 1 > temp.foo
$ cat temp.foo
Только для записи
$ ./a.out 2 2>>temp.foo
Только для записи, добавление в конец
$ ./a.out 5 5<>temp.foo
Для чтения и для записи

Выражение 5<>temp.foo открывает файл temp.foo для чтения и  записи на дескрипторе 5.

Пример
Изменяя флаги дескриптора или флаги состояния файла, необходимо сначала
получить все имеющиеся значения флагов, изменить желаемые и затем записать
полученное значение обратно. Нельзя просто изменить отдельные флаги с помощью команд F_SETFD или F_SETFL, поскольку так можно сбросить другие флаги,
которые были установлены.
В листинге 3.5 приводится функция, которая устанавливает один или более флагов состояния файла.

130    Глава 3. Файловый ввод/вывод
Листинг 3.5. Включает один или более флагов состояния файла
#include "apue.h"
#include <fcntl.h>
void
set_fl(int fd, int flags) /* flags — флаги, которые нужно включить */
{
int
val;
if ((val = fcntl(fd, F_GETFL, 0)) < 0)
err_sys("ошибка выполнения команды F_GETFL функции fcntl");
val |= flags; /* включить флаги */

}

if (fcntl(fd, F_SETFL, val) < 0)
err_sys("ошибка выполнения команды F_SETFL функции fcntl");

Если изменить код в середине на
val &= .flags; /* выключить флаги */

мы получим функцию clr_fl, которая будет использоваться в  примерах ниже.
В этой строке производится объединение по И (AND) текущего значения переменной val с логическим дополнением до единицы значения аргумента flags.
Если в начало программы в листинге 3.3 добавить строку
set_fl(STDOUT_FILENO, O_SYNC);

она включит режим синхронной записи. В  результате каждый вызов функции
write будет ждать завершения физической записи данных на диск, прежде чем
вернуть управление. Обычно в UNIX функция write лишь ставит записываемые
данные в очередь, а собственно запись на диск производится несколько позднее.
Флаг O_SYNC часто используется в  системах управления базами данных, так как
дает дополнительные гарантии своевременной записи данных на диск и  их сохранности в случае отказа системы.
Предполагается, что использование флага O_SYNC увеличивает общее время работы
программы. Для проверки воспользуемся программой из листинга 3.3. Скопируем
с ее помощью 492,6 Мбайт данных из одного файла на диске в другой и сравним
результаты с версией программы, которая устанавливает флаг O_SYNC. Результаты,
полученные нами в Linux с файловой системой ext4, приводятся в табл. 3.5.
Во всех шести случаях замеры производились со значением BUFFSIZE, равным
4096. Результаты в табл. 3.3 были получены при чтении файла с диска и записи
в устройство /dev/null, то есть запись на диск не производилась. Вторая строка
в табл. 3.5 соответствует чтению файла с диска и записи в другой файл на диске.
По этой причине значения времени в первой и во второй строках отличаются. При
записи в файл на диске системное время увеличивается, потому что в этом случае
ядро должно скопировать данные, полученные от процесса, и поставить их в очередь на запись, которая будет выполняться драйвером диска. Мы ожидали, что
общее время также увеличится при записи файла на диск.

3.14. Функция fcntl   

131

Таблица 3.5. Результаты проверки производительности различных режимов
синхронизации в Linux с файловой системой ext4
Операция

Пользовательское время
(секунды)

Системное
время
(секунды)

Общее
время
(секунды)

Время чтения, взятое из табл. 3.3, для BUFFSIZE = 4096

0,03

0,58

  8,62

Нормальный режим записи файла на диск

0,00

1,05

  9,70

Запись на диск с флагом O_SYNC

0,02

1,09

10,28

Запись на диск с последующим вызовом fdatasync

0,02

1,14

17,93

Запись на диск с последующим вызовом fsync

0,00

1,19

18,17

Запись на диск с флагом O_SYNC и последующим
вызовом fsync

0,02

1,15

17,88

Включая синхронную запись, мы ожидали существенного увеличения системного
и общего времени. Но, как видно в третьей строке, синхронная запись выполняется практически за то же время, что и отложенная. Это означает, что либо Linux
проделывает одинаковый объем работы при отложенной и  синхронной запи­
си (что маловероятно), либо флаг O_SYNC не оказывает должного эффекта в ней.
В данном случае Linux не позволяет устанавливать флаг O_SYNC с помощью fcntl
и не возвращает признак ошибки (но этот флаг будет учитываться, если установить его при открытии файла).
Общее время в  последних трех строках отражает дополнительные затраты времени на ожидание фактической записи на диск. После выполнения синхронной
запи­си ожидается, что вызов fsync не будет иметь никакого эффекта. Данное
предположение должна была бы подтвердить последняя строка, но поскольку
флаг O_SYNC не оказывает ожидаемого эффекта, последняя строка содержит значение, практически равное значению в пятой строке.
В табл. 3.6 приводятся результаты тех же экспериментов в Mac OS X 10.6.8 с файловой системой HFS. Обратите внимание, что полученные значения времени полностью соответствуют нашим ожиданиям: синхронная запись оказывается более
дорогостоящей по сравнению с отложенной, а вызов функции fsync не сказывается на времени при использовании синхронного режима записи. Отметьте также,
что добавление вызова функции fsync после выполнения обычной отложенной
записи не дает существенного прироста времени. Это, скорее всего, говорит о том,
что данные из кэша переписывались операционной системой на диск по мере поступления новых данных, так что к моменту вызова функции fsync в кэше их оставалось не так много.
Сравните эффект от использования функций fsync и  fdatasync, которые обновляют содержимое файла при обращении к ним, и действие флага O_SYNC, который
обновляет содержимое файла при каждой операции записи. Производительность
каждой из альтернатив зависит от множества факторов, включая реализацию
самой операционной системы, производительность дискового устройства и  тип
файловой системы.

132    Глава 3. Файловый ввод/вывод
Таблица 3.6. Результаты проверки производительности различных режимов
синхронизации файловой системы HFS в Mac OS X
Пользовательское время
(секунды)

Системное
время
(секунды)

Общее
время
(секунды)

Запись в устройство /dev/null

0,14

  1,02

  5,28

Нормальный режим записи файла на диск

0,14

  3,21

17,04

Запись на диск с флагом O_SYNC

0,39

16,89

60,82

Запись на диск с последующим вызовом fsync

0,13

  3,07

17,10

Запись на диск с флагом O_SYNC и последующим
вызовом fsync

0,39

18,18

62,39

Операция

Этот пример наглядно демонстрирует, для чего нужна функция fcntl. Наша программа работает с дескриптором (стандартный вывод), не зная названия файла,
открытого командной оболочкой на этом дескрипторе. Мы лишены возможности
установить флаг O_SYNC при открытии файла, так как его открывает командная
оболочка. С  помощью функции fcntl можно изменить свойства дескриптора,
зная только дескриптор открытого файла. Позже мы рассмотрим еще одну область применения функции fcntl, когда будем рассказывать о  неблокирующих
операциях ввода/вывода для неименованных каналов (раздел 15.2), поскольку
при работе с ними нам доступен только дескриптор.

3.15. Функция ioctl
Функция ioctl всегда была универсальным инструментом ввода/вывода. Все, что
невозможно выразить с помощью функций, описанных в этой главе, как правило,
делается с  помощью ioctl. Возможности этой функции чаще всего использовались в операциях терминального ввода/вывода. (Когда мы доберемся до главы 18,
то увидим, что стандарт POSIX.1 заменил операции терминального ввода/вывода
отдельными функциями.)
#include <unistd.h>

/* System V */

#include <sys/ioctl.h> /* BSD и Linux */
int ioctl(int fd, int request, ...);

Возвращает –1 в случае ошибки, другие значения — в случае успеха
Функция ioctl включена в стандарт Single UNIX Specification только как расширение для
работы с устройствами STREAMS [Rago, 1993], но в SUSv4 ей присвоен статус устаревшей. Различные версии UNIX используют ioctl для выполнения самых разнообразных
операций с устройствами. Некоторые реализации даже расширили ее функциональность
для использования с обычными файлами.

3.16. /dev/fd   

133

Приведенный выше прототип функции определяется стандартом POSIX.1.
В операционных системах FreeBSD 8.0 и Mac OS X 10.6.8 второй аргумент определен как unsigned long. Это не имеет большого значения, так как в качестве второго аргумента всегда передается имя константы, определяемой в заголовочном
файле.
Согласно стандарту ISO C, необязательные аргументы обозначены многоточием.
Однако в  большинстве случаев передается только один дополнительный аргумент — указатель на переменную или структуру.
В этом прототипе мы указали только те заголовочные файлы, которые требуются
для самой функции ioctl. Но, как правило, при работе с ней необходимо подключать дополнительные заголовочные файлы для конкретных устройств. Например,
все команды ioctl для операций терминального ввода/вывода, определяемые
стандартом POSIX.1, требуют подключения заголовочного файла <termios.h>.
Каждый драйвер устройства может определять собственный набор команд ioctl.
Тем не менее операционная система предоставляет набор универсальных команд
ioctl для различных классов устройств. Примеры некоторых категорий универсальных команд ioctl, поддерживаемых FreeBSD, приводятся в табл. 3.7.
Таблица 3.7. Команды ioctl в ОС FreeBSD
Категория

Имена
констант

Заголовочный файл

Количество
команд

Метки диска

DIOxxx

<sys/disklabel.h>

 4

Файловый ввод/вывод

FIOxxx

<sys/filio.h>

14

Ввод/вывод для накопителей на магнитной
ленте

MTIOxxx

<sys/mtio.h>

11

Ввод/вывод для сокетов

SIOxxx

<sys/sockio.h>

73

Терминальный ввод/вывод

TIOxxx

<sys/ttycom.h>

43

Операции с  накопителями на магнитной ленте позволяют записывать на ленту
признак конца файла, перематывать ленту в начало, перемещаться вперед через
заданное число файлов или записей и т. п. Ни одну из этих операций нельзя достаточно просто выразить в терминах других функций, описанных в данной главе
(read, write, lseek и т. д.). Поэтому простейший способ взаимодействия с такими
устройствами всегда заключался в управлении ими через функцию ioctl.
Мы еще вернемся к функции ioctl в разделе 18.12, где с ее помощью будем получать и изменять размер окна терминала, и в разделе 19.7, когда будем исследовать
расширенные возможности псевдотерминалов.

3.16. /dev/fd
В современных операционных системах имеется каталог /dev/fd, в котором находятся файлы с именами 0, 1, 2 и т. д. Открытие файла /dev/fd/n эквивалентно созданию дубликата дескриптора с номером n, при условии, что дескриптор n открыт.

134    Глава 3. Файловый ввод/вывод
Поддержка каталога /dev/fd была реализована Томом Даффом (Tom Duff) и впервые появилась в 8-й редакции Research UNIX System. Эта особенность поддерживается всеми
четырьмя операционными системами, о которых идет речь в данной книге: FreeBSD 8.0,
Linux 3.2.0, Mac OS X 10.6.8 и Solaris 10. Она не является частью стандарта POSIX.1.

Большинство систем игнорируют аргумент mode в вызове
fd = open("/dev/fd/0", mode);

но есть и такие, которые требуют, чтобы он представлял подмножество флагов, которые использовались при открытии оригинального файла (в данном случае файл
стандартного ввода). Поскольку данный вызов эквивалентен вызову
fd = dup(0);

дескрипторы 0 и  fd будут совместно использовать одну и ту же запись в таблице
файлов (см. рис. 3.3). Например, если дескриптор 0 открыт только для чтения,
дескриптор fd также будет доступен только для чтения. Даже если система игнорирует режим открытия дескриптора и вызов
fd = open("/dev/fd/0", O_RDWR);

не завершится ошибкой, мы все равно не сможем ничего записать в  файл с  дескриптором fd.
Реализация /dev/fd в Linux является исключением. Она отображает файловые дескрипторы в символические ссылки, указывающие на фактические файлы. Например, при попытке открыть файл /dev/fd/0 в действительности открывается файл, связанный со
стандартным вводом. Поэтому возвращаемый режим нового файлового дескриптора никак
не связан с режимом файлового дескриптора в /dev/fd.

Кроме того, имя каталога /dev/fd можно использовать в аргументе path функции
creat, равно как и в функции open с флагом O_CREAT. Это позволяет программам,
обращающимся к  creat, продолжать работу, даже если аргумент path, например,
содержит строку /dev/fd/1.
Не используйте этот прием в Linux. Так как в Linux используются символические ссылки
на фактические файлы, вызов creat с файлом в  /dev/fd приведет к усечению файла, на
который указывает ссылка.

В некоторых системах имеются файлы /dev/stdin, /dev/stdout и /dev/stderr, эквивалентные файлам /dev/fd/0, /dev/fd/1 и /dev/fd/2 соответственно.
Файлы из каталога /dev/fd в основном используются командными оболочками.
Это позволяет программам, требующим указания имени файла, работать со стандартными устройствами ввода и  вывода так же, как с  обычными файлами. Например, в следующем примере программа cat(1) использует в качестве входного
файла стандартный ввод, обозначаемый символом «–»:
filter file2 | cat file1 – file3 | lpr

Сначала cat читает содержимое файла file1, затем файл стандартного ввода (результат работы утилиты filter, обрабатывающей файл file2) и,  наконец, файл

Упражнения   

135

file3. Если система поддерживает /dev/fd, можно опустить символ «–» и  пе­

реписать команду так:

filter file2 | cat file1 /dev/fd/0 file3 | lpr

Символ «–» в качестве аргумента командной строки для обозначения файла стандартного ввода или стандартного вывода — своего рода ляп, который присутствует во многих программах. Например, на месте первого файла он будет очень похож на начало другого аргумента командной строки. Использование /dev/fd — это
шаг к единообразию и порядку.

3.17. Подведение итогов
В этой главе были описаны базовые функции ввода/вывода в системе UNIX. Их
часто называют функциями небуферизованного ввода/вывода, потому что каждый вызов read или write обращается к  системному вызову ядра. Мы увидели,
как влияет изменение размера буфера ввода/вывода на время чтения файла. Мы
также рассмотрели несколько способов записи данных на диск и их влияние на
производительность приложения.
Мы познакомились с  атомарными операциями, когда рассматривали дописывание данных в  один файл несколькими процессами и  создание одного и  того же
файла несколькими процессами. Мы также увидели структуры данных, используемые ядром для организации совместного доступа к информации об открытых
файлах. В дальнейшем мы еще вернемся к этим структурам.
Также были описаны функции ioctl и fcntl. Мы еще поговорим о них в главе 14,
где fcntl будет использоваться для организации блокировки отдельных записей
в файле. В главах 18 и 19 мы используем функцию ioctl для работы с терминальными устройствами.

Упражнения
3.1	

Действительно ли функции чтения и записи файлов, описанные в данной
главе, являются небуферизованными? Объясните почему.

3.2	

Напишите свою версию функции dup2, которая реализует функциональность, описанную в  разделе 3.12, но без использования функции fcntl.
Предусмотрите обработку ошибок.

3.3	

Предположим, что некоторый процесс вызывает следующие функции:
fd1 = open(path, oflags);
fd2 = dup(fd1);
fd3 = open(path, oflags);

Нарисуйте диаграмму, подобную той, что приведена на рис. 3.3. На какой дескриптор окажет влияние функция fcntl, если ей передать в качестве аргументов fd1 и F_SETFD? На какой дескриптор окажет влияние функция fcntl,
если ей передать в качестве аргументов fd1 и F_SETFL?

136    Глава 3. Файловый ввод/вывод
3.4	

Во многих программах можно наблюдать следующую последовательность
операций:
dup2(fd, 0);
dup2(fd, 1);
dup2(fd, 2);
if (fd > 2)
close(fd);

3.5	

Чтобы понять, для чего нужен условный оператор if, предположите, что fd
изначально имеет значение 1, и  нарисуйте картинку, отображающую, что
происходит со всеми тремя дескрипторами и соответствующими записями
в  таблице файлов после каждого вызова функции dup2. Затем нарисуйте
аналогичную картинку, исходя из предположения, что изначально fd имел
значение 3.
Командные оболочки Bourne shell, Bourne-again shell и Korn shell предусматривают такую нотацию:
digit1>&digit2
Она говорит о том, что дескриптор digit1 должен быть перенаправлен в тот
же файл, что и дескриптор digit2. Чем отличаются следующие две команды
(подсказка: командные оболочки обрабатывают командную строку слева
направо):
./a.out > outfile 2>&1
./a.out 2>&1 > outfile

3.6	

Если файл открыт для чтения и  записи с  флагом O_APPEND, можно ли читать данные из произвольного места в  файле с  помощью функции lseek?
Можно ли воспользоваться функцией lseek для изменения данных в произвольном месте в файле? Напишите программу, чтобы получить ответы на
эти вопросы.

4

Файлы и каталоги

4.1. Введение
В предыдущей главе обсуждались базовые функции, выполняющие операции
ввода/вывода. Основное внимание уделялось операциям ввода/вывода с  обычными файлами: открытие, чтение файла или запись в  файл. Теперь мы рассмотрим дополнительные особенности файловой системы и свойства файла. Сначала
познакомимся с  функцией stat, а  затем исследуем каждый элемент структуры
stat и  все существующие атрибуты файлов. Попутно рассмотрим все функции,
изменяющие эти атрибуты: владельца, права доступа и др. Также более подробно
рассмотрим структуру файловой системы UNIX и символические ссылки. А в завершение перейдем к функциям для работы с каталогами и напишем функцию,
выполняющую обход дерева каталогов.

4.2. Функции stat, fstat и lstat
В этой главе основное внимание уделяется четырем функциям семейства stat
и информации, которую они возвращают.
#include <sys/stat.h>
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat(int fd, struct stat *buf);
int lstat(const char *restrict pathname, struct stat restrict buf);
int fstatat(int fd, const char *restrict pathname,
struct stat *restrict buf, int flag);

Все четыре возвращают 0 в случае успеха, –1 — в случае ошибки
Функция stat возвращает структуру с информацией о файле, указанном в аргументе pathname. Функция fstat возвращает информацию об открытом файле по
его дескриптору fd. Функция lstat похожа на функцию stat, но когда ей передается имя символической ссылки, она возвращает сведения о самой символической ссылке, а не о файле, на который она ссылается. (Эта функция понадобится

138    Глава 4. Файлы и каталоги
нам в  разделе 4.21, когда мы будем спускаться вниз по дереву каталогов. Более
подробно символические ссылки описываются в разделе 4.17.)
Функция fstatat возвращает информацию о файле, относительный путь pathname
к  которому начинается в  открытом каталоге, представленном дескриптором fd.
Аргумент flag определяет правила следования по символическим ссылкам: если
установлен флаг AT_SYMLINK_NOFOLLOW, функция fstatat не будет следовать по
символическим ссылкам, а  вернет информацию о  самой ссылке. Иначе она будет выполнять переходы и  возвращать информацию о  файлах, на которые эти
ссылки указывают. Если в аргументе fd передать значение AT_FDCWD, а в аргументе pathname — строку относительного пути, путь к файлу pathname будет откладываться относительно текущего каталога. Если в  аргументе pathname передать
строку абсолютного пути, аргумент fd будет игнорироваться. В этих двух случаях
fstatat действует подобно stat или lstat, в зависимости от значения аргумента
flag.
Второй аргумент, buf, является указателем на структуру, которую функция заполнит информацией. Определение структуры может отличаться в разных реализациях, но основная ее часть выглядит так:
struct stat {
mode_t
ino_t
dev_t
dev_t
nlink_t
uid_t
gid_t
off_t
struct timespec
struct timespec
struct timespec
blksize_t
blkcnt_t
};

st_mode;
st_ino;
st_dev;
st_rdev;
st_nlink;
st_uid;
st_gid;
st_size;
st_atim;
st_mtim;
st_ctim;
st_blksize;
st_blocks;

/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*

тип файла и режим (права доступа) */
номер индексного узла */
номер устройства (файловой системы) */
номер устройства для специальных файлов */
количество ссылок */
идентификатор пользователя владельца */
идентификатор группы владельца */
размер в байтах, для обычных файлов */
время последнего обращения к файлу */
время последнего изменения файла */
время последнего изменения состояния файла */
оптимальный размер блока ввода/вывода */
количество занятых дисковых блоков */

Стандарт POSIX.1 не требует наличия полей st_rdev, st_blksize и st_blocks. Они определены как расширения XSI в стандарте Single UNIX Specification.

Структура timespec определяет время в секундах и наносекундах и содержит по
меньшей мере два поля:
time_t
long

tv_sec;
tv_nsec;

До появления редакции стандарта 2008 года поля со значениями времени назывались
st_atime, st_mtime и st_ctime и имели тип time_t (время в секундах). Структура timespec
позволяет хранить отметки времени (timestamps) с более высокой точностью. Старые
имена можно определить в терминах членов tv_sec структуры для совместимости. Например, st_atime можно определить как st_atim.tv_sec.

Обратите внимание, что большинство членов структуры stat имеют тот или иной
элементарный системный тип данных (раздел 2.8). А теперь исследуем атрибуты
файла и познакомимся ближе с каждым членом структуры.

4.3. Типы файлов   

139

Вероятно, наиболее часто функцию stat использует команда ls –l, которая выводит полную информацию о файле.

4.3. Типы файлов
Мы уже упоминали файлы двух типов: обычные файлы и каталоги. Большинство
файлов в  UNIX являются либо обычными файлами, либо каталогами, но есть
и другие типы файлов. Перечислим их.
1.	 Обычный файл — наиболее распространенный тип файлов, хранящих данные
в  некотором виде. Ядро UNIX не делает различий между текстовыми и  двоичными файлами. Интерпретация содержимого файла полностью зависит от
прикладной программы, обрабатывающей файл.
Одно из наиболее известных исключений из этого правила — выполняемые файлы. Чтобы
запустить программу, ядро должно опознать формат файла. Все двоичные выполняемые
файлы следуют конкретному формату, который позволяет ядру определить, куда загрузить выполняемый код и данные программы.

2.	 Файл каталога. Файлы этого типа содержат имена других файлов и ссылки на
информацию о них. Любой процесс, обладающий правом на чтение каталога,
может прочитать его содержимое, но только ядро обладает правом на запись
непосредственно в файл каталога. Чтобы внести изменения в каталог, процессы должны пользоваться функциями, обсуждаемыми в данной главе.
3.	 Специальный файл блочного устройства. Этот тип файлов обеспечивает буферизованный ввод/вывод фиксированными блоками для таких устройств, как
жесткие диски.
Обратите внимание, что FreeBSD больше не поддерживает специальные файлы блочных
устройств. Доступ ко всем устройствам осуществляется через специальный символьный
интерфейс.

4.	 Специальный файл символьного устройства. Этот тип файлов обеспечивает
небуферизованный ввод/вывод для устройств с  переменным размером блока. Все устройства в системе являются либо специальными файлами блочных
устройств, либо специальными файлами символьных устройств.
5.	 FIFO, или именованный канал. Этот тип файлов используется для организации обмена информацией между процессами. Именованные каналы описываются в разделе 15.5.
6.	 Сокет. Этот тип файлов используется для обмена информацией между процессами через сетевые соединения. Сокеты можно также применять для обмена
информацией между процессами на одной и той же машине. Мы будем использовать сокеты для взаимодействий между процессами в главе 16.
7.	 Символическая ссылка. Файлы этого типа являются ссылками на другие файлы. Более подробно о символических ссылках мы поговорим в разделе 4.17.

140    Глава 4. Файлы и каталоги
Тип файла хранится в поле st_mode структуры stat. Определить тип файла можно
с помощью макроопределений, перечисленных в табл. 4.1. В качестве аргумента
каждое из них принимает значение поля st_mode структуры stat.
Таблица 4.1. Макросы для определения типа файла из <sys/stat.h>
Макроопределение

Тип файла

S_ISREG()

Обычный файл

S_ISDIR()

Каталог

S_ISCHR()

Специальный файл символьного устройства

S_ISBLK()

Специальный файл блочного устройства

S_ISFIFO()

Канал (именованный или неименованный)

S_ISLNK()

Символическая ссылка

S_ISSOCK()

Сокет

Стандарт POSIX.1 допускает реализацию и представление объектов межпроцессных взаимодействий (IPC), таких как очереди сообщений и  семафоры, в  виде
файлов. Макроопределения из табл. 4.2 позволяют определить тип объекта IPC
из структуры stat. Главное их отличие от макросов, перечисленных в  табл.  4.1,
в том, что аргументом для них является указатель на структуру stat, а не значение
поля st_mode.
Таблица 4.2. Макросы для определения типа объекта IPC из <sys/stat.h>
Макроопределение

Тип файла

S_TYPEISMQ()

Очередь сообщений

S_TYPEISSEM()

Семафор

S_TYPEISSHM()

Объект разделяемой памяти

Очереди сообщений, семафоры и объекты разделяемой памяти будут рассматриваться в главе 15. Однако ни одна из реализаций, обсуждаемых в данной книге, не
представляет эти объекты в виде файлов.

Пример
Программа в листинге 4.1 выводит тип файла для каждого аргумента командной
строки.
Листинг 4.1. Вывод типа файла для каждого аргумента командной строки
#include "apue.h"
int
main(int argc, char *argv[])
{
int
i;
struct stat buf;

4.3. Типы файлов   

char

141

*ptr;

for (i = 1; i < argc; i++) {
printf("%s: ", argv[i]);
if (lstat(argv[i], &buf) < 0) {
err_ret("ошибка вызова функции lstat");
continue;
}
if (S_ISREG(buf.st_mode))
ptr = "обычный файл";
else if (S_ISDIR(buf.st_mode))
ptr = "каталог";
else if (S_ISCHR(buf.st_mode))
ptr = "файл символьного устройства";
else if (S_ISBLK(buf.st_mode))
ptr = "файл блочного устройства";
else if (S_ISFIFO(buf.st_mode))
ptr = "fifo";
else if (S_ISLNK(buf.st_mode))
ptr = "символическая ссылка";
else if (S_ISSOCK(buf.st_mode))
ptr = "сокет";
else
ptr = "** неизвестный тип файла **";

}

printf("%s\n", ptr);
}
exit(0);

Пример вывода программы из листинга 4.1:
$ ./a.out /etc/passwd /etc /dev/log /dev/tty \
> /var/lib/oprofile/opd_pipe /dev/sr0 /dev/cdrom
/etc/passwd: обычный файл
/etc: каталог
/dev/log: сокет
/dev/tty: файл символьного устройства
/var/lib/oprofile/opd_pipe: fifo
/dev/sr0: файл блочного устройства
/dev/cdrom: символическая ссылка

(Символ обратного слеша в конце первой строки сообщает командной оболочке,
что ввод команды не закончен. В таких случаях командная оболочка выводит на
следующей строке вторичное приглашение к вводу — символ >.) Мы нарочно использовали функцию lstat вместо stat, чтобы обнаружить символические ссылки. Используя функцию stat, мы никогда не увидели бы их.
Ранние версии UNIX не имели макроопределений S_ISxxx. Вместо этого необходимо было выполнять объединение по И  (AND) значения st_mode с  маской
S_IFMT и  затем сравнивать результат с  константами S_IFxxx. Определение этой
маски и связанных с ней констант в большинстве систем находится в файле <sys/
stat.h>. Заглянув в этот файл, мы обнаружим, что макрокоманда S_ISDIR определена примерно так:
#define S_ISDIR(mode) (((mode) & S_IFMT) == S_IFDIR)

142    Глава 4. Файлы и каталоги
Мы уже говорили, что обычные файлы являются самыми распространенными, но
было бы интересно узнать, какой процент от всех файлов в  данной системе занимают файлы каждого типа. В табл. 4.3 приводится количество файлов каждого
типа и его процентное выражение в ОС Linux, используемой в качестве однопользовательской рабочей станции. Эти данные получены с помощью программы, которую мы продемонстрируем в разделе 4.22.
Таблица 4.3. Количество файлов различных типов и его процентное выражение
Тип файла

Обычные файлы

Количество

Процент от общего числа

415 803

79,77

Каталоги

62 197

11,93

Символические ссылки

40 018

  8,25

Файлы символьных устройств

155

  0,03

Файлы блочных устройств

47

  0,01

Сокеты

45

  0,01

0

  0,00

FIFO

4.4. set-user-ID и set-group-ID
С каждым процессом связаны шесть или более идентификаторов. Все они перечислены в табл. 4.4.
Таблица 4.4. Идентификаторы пользователя и группы, связанные с каждым
процессом
Реальный идентификатор пользователя
Реальный идентификатор группы

Определяет, кто мы на самом деле

Эффективный идентификатор пользователя
Эффективный идентификатор группы
Идентификаторы дополнительных групп

Используются при проверке прав доступа
к файлам

Сохраненный идентификатор пользователя
Сохраненный идентификатор группы

Идентификаторы, сохраняемые функциями
exec

 Реальные идентификаторы пользователя и группы определяют, кто мы на самом деле. Эти идентификаторы извлекаются из файла паролей во время входа
в систему. Обычно в течение сеанса значения этих идентификаторов не меняются, хотя процессы, обладающие правами суперпользователя, имеют возможность изменять их, о чем мы поговорим в разделе 8.11.
 Эффективные идентификаторы пользователя и группы и идентификаторы дополнительных групп определяют права доступа к файлам, о чем мы поговорим
в следующем разделе. (Определение дополнительных групп было дано в разделе 1.8.)

4.5. Права доступа к файлу   

143

 Сохраненные идентификаторы пользователя и группы — это копии эффективных идентификаторов, которые создаются в момент запуска программы. Мы
расскажем о назначении этих двух идентификаторов, когда будем описывать
функцию setuid в разделе 8.11.
Сохраненные идентификаторы перешли в  разряд обязательных для реализации в  соответствии с  версией POSIX.1 2001 года. В  более ранних версиях POSIX они находились в  категории необязательных. Приложение может проверить наличие константы
_POSIX_SAVED_IDS на этапе компиляции или вызвать функцию sysconf с  аргументом
_SC_SAVED_IDS на этапе выполнения, чтобы определить, поддерживает ли реализация
эту функциональную возможность.

Обычно эффективные идентификаторы пользователя и группы совпадают с соответствующими реальными идентификаторами.
У каждого файла в системе есть владелец и группа-владелец. Идентификатор владельца файла хранится в  поле st_uid структуры stat, а  идентификатор группы
владельца — в поле st_gid.
В момент запуска файла программы эффективными идентификаторами пользователя и  группы процесса обычно становятся соответствующие реальные идентификаторы. Но можно также установить специальный флаг в  поле st_mode,
который как бы говорит: «При запуске этого файла в  качестве эффективного
идентификатора процесса взять идентификатор пользователя владельца файла
(st_uid)». Точно так же в поле st_mode можно установить другой флаг, который
назначит в качестве эффективного идентификатора группы идентификатор группы владельца файла (st_gid). Эти два флага в поле st_mode называются битами
set-user-ID и set-group-ID соответственно.
Например, если владельцем файла является суперпользователь и у файла установлен бит set-user-ID, во время работы программы соответствующий процесс будет обладать правами суперпользователя. Это происходит независимо от реального идентификатора пользователя процесса, запустившего файл. Так, системная утилита
UNIX, позволяющая любому пользователю изменять свой пароль, passwd(1), является программой с установленным битом set-user-ID. Это необходимо, чтобы утилита могла записать новый пароль в файл паролей (обычно это файл /etc/passwd или
/etc/shadow), который должен быть доступен на запись только суперпользователю.
Поскольку в подобных случаях программы, запускаемые рядовыми пользователями, обычно расширяют их привилегии, при их написании следует проявлять особую
осторожность. Такие программы мы обсудим более подробно в главе 8.
Биты set-user-ID и set-group-ID хранятся в поле st_mode структуры stat, ассоциированной с файлом. Проверить их можно с помощью констант S_ISUID и S_ISGID.

4.5. Права доступа к файлу
Поле st_mode содержит также биты прав доступа к файлу. Под файлом мы подразу­
меваем файл любого типа из описанных выше. Любые файлы — каталоги, специальные файлы устройств и  пр.  — обладают правами доступа. Многие полагают,
что понятие прав доступа присуще только обычным файлам.

144    Глава 4. Файлы и каталоги
Права доступа к файлу определяются девятью битами, которые подразделяются
на три категории. Все они перечислены в табл. 4.5.
Таблица 4.5. Биты прав доступа из файла <sys/stat.h>
Маска для поля st_mode

Назначение

S_IRUSR

user-read — доступно пользователю для чтения

S_IWUSR

user-write — доступно пользователю для записи

S_IXUSR

user-execute — доступно пользователю для выполнения

S_IRGRP

group-read — доступно группе для чтения

S_IWGRP

group-write — доступно группе для записи

S_IXGRP

group-execute — доступно группе для выполнения

S_IROTH

other-read — доступно остальным для чтения

S_IWOTH

other-write — доступно остальным для записи

S_IXOTH

other-execute — доступно остальным для выполнения

Под термином пользователь (user) в  табл. 4.5 подразумевается владелец файла.
Команда chmod(1), которая обычно используется для изменения прав доступа
к файлам, позволяет указать имя категории посредством символов: u — user (пользователь, или владелец), g  — group (группа) и  o  — other (остальные). В  некоторых книгах эти три категории обозначаются как owner (владелец), group (группа)
и  world (весь остальной мир), что может привести к  путанице, так как команда
chmod использует символ o не в смысле owner (владелец), а в смысле other (остальные). Мы будем использовать термины user (пользователь), group (группа) и other
(остальные), чтобы сохранить совместимость с командой chmod.
Три категории из табл. 4.5 — чтение, запись и выполнение — используются разными функциями по-разному. Сейчас мы коротко опишем их, а затем будем к ним
возвращаться при обсуждении конкретных функций.
 Первое правило: чтобы открыть файл любого типа по его полному имени, необходимо иметь право на выполнение для всех каталогов, указанных в имени
файла, включая текущий. По этой причине бит права на выполнение для каталогов часто называют битом права на поиск.
Например, чтобы открыть файл /usr/include/stdio.h, мы должны иметь право на выполнение для каталогов /, /usr и  /usr/include. Далее мы должны обладать соответствующими правами на доступ к открываемому файлу в зависимости от режима — только для чтения, для чтения и записи и т. д.
Если текущим является каталог /usr/include, тогда, чтобы открыть файл
stdio.h, мы должны обладать правом на выполнение для текущего каталога.
В этом примере текущий каталог не указан явно, но подразумевается. С тем же
успехом можно было бы обозначить имя файла как ./stdio.h.
Обратите внимание, что право на чтение и право на выполнение для каталогов имеют иной смысл. Право на чтение дает возможность прочитать файл

4.5. Права доступа к файлу   

145

каталога и получить полный список файлов, находящихся в нем. Право на выполнение дает возможность войти в каталог, когда он является одним из компонентов пути к файлу, к которому требуется получить доступ. (Чтобы найти
нужный файл, необходимо выполнить поиск по каталогу).
Еще один пример неявной ссылки на каталог — переменная окружения PATH
(обсуждается в разделе 8.10). Если она определяет каталог, для которого у нас
нет права на выполнение, командная оболочка никогда не будет просматривать
его при поиске выполняемых файлов.
 Право на чтение для файла определяет возможность открыть существующий
файл для чтения (флаги O_RDONLY и O_RDWR функции open).
 Право на запись для файла определяет возможность открыть существующий
файл для записи (флаги O_WRONLY и O_RDWR функции open).
 Чтобы указать флаг O_TRUNC в вызове функции open, нужно обладать правом
на запись.
 Нельзя создать новый файл в каталоге при отсутствии права на запись и права
на выполнение для этого каталога.
 Чтобы удалить существующий файл, необходимо обладать правом на запись
и правом на выполнение для каталога, который содержит этот файл. Не нужно
обладать правом на чтение или на запись для самого файла.
 Чтобы запустить файл на выполнение с  помощью одной из шести функций
семейства exec (раздел 8.10), нужно обладать правом на выполнение. Кроме
того, файл должен быть обычным файлом.
Решение о  выдаче полномочий на доступ к  файлу, которое принимается ядром
всякий раз, когда процесс открывает, создает или удаляет файл, зависит от принадлежности файла (st_uid и  st_gid), от значений эффективных идентификаторов процесса (эффективный идентификатор пользователя и эффективный идентификатор группы) и от идентификаторов дополнительных групп процесса, если
таковые поддерживаются. Оба идентификатора владельца являются свойствами
самого файла, тогда как эффективные идентификаторы и идентификаторы дополнительных групп — это свойства процесса. Решение принимается ядром по следующему алгоритму.
1.	 Если процесс имеет эффективный идентификатор пользователя, равный 0 (суперпользователь), доступ разрешается. Это дает суперпользователю абсолютную свободу действий во всей файловой системе.
2.	 Если процесс имеет эффективный идентификатор пользователя, совпадающий с идентификатором владельца файла (то есть процесс является владельцем файла), доступ разрешается, если установлен соответствующий бит права
доступа для владельца. Иначе доступ к файлу запрещается. Под выражением
соответствующий бит права доступа понимается следующее: если процесс
открывает файл для чтения, должен быть установлен бит user-read, если файл
открывается для записи, должен быть установлен бит user-write, если процесс
собирается запустить файл на выполнение, должен быть установлен бит userexecute.

146    Глава 4. Файлы и каталоги
3.	 Если эффективный идентификатор группы или один из идентификаторов
дополнительных групп процесса совпадает с  идентификатором группы файла, доступ разрешается, если установлен соответствующий бит права доступа.
Иначе доступ к файлу запрещается.
4.	 Если установлен соответствующий бит права доступа для остальных, доступ
разрешается, иначе доступ запрещается.
Эти четыре шага выполняются в указанной последовательности. Обратите внимание: если процесс является владельцем файла (шаг 2), решение о предоставлении
доступа или об отказе в доступе к файлу принимается только на основании прав
доступа владельца, права группы уже не проверяются. Аналогично, если процесс
не является владельцем файла, но принадлежит к соответствующей группе, решение принимается на основе анализа прав доступа для группы — права остальных
не принимаются во внимание.

4.6. Принадлежность новых файлов
и каталогов
Рассматривая в главе 3 процедуру создания новых файлов с помощью функций
open и  creat, мы не упоминали, какие значения принимаются в качестве идентификатора пользователя и группы для нового файла. Как создаются каталоги, мы
покажем в разделе 4.21 при описании функции mkdir. Правила выбора владельца
для нового каталога аналогичны приводимым здесь правилам выбора владельца
для нового файла.
В качестве идентификатора пользователя (владельца) для нового файла принимается значение эффективного идентификатора пользователя процесса. При
определении идентификатора группы для нового файла стандарт POSIX.1 допускает выбор одного из двух вариантов.
1.	 В качестве идентификатора группы для нового файла может быть принят эффективный идентификатор группы процесса.
2.	 В качестве идентификатора группы для нового файла может быть принят
идентификатор группы каталога, в котором создается файл.
Операционные системы FreeBSD 8.0 и Mac OS X 10.6.8 всегда используют идентификатор
группы каталога в качестве идентификатора группы для создаваемого файла. Некоторые
файловые системы в Linux допускают возможность выбора любого из этих двух вариантов
с помощью специального флага команды mount(1). В операционных системах Linux 3.2.0
и Solaris 10 выбор идентификатора группы для нового файла зависит от значения бита
set-group-ID у  каталога, в  котором создается файл. Если этот бит установлен, идентификатором группы для нового файла назначается идентификатор группы каталога,
иначе — эффективный идентификатор группы процесса.

Второй вариант — наследование идентификатора группы от каталога — дает гарантию, что все файлы и  подкаталоги, создаваемые в  заданном каталоге, будут
принадлежать той же группе, что и  родительский каталог. Порядок назначения

4.7. Функции access и faccessat   

147

группы владельца для файлов и каталогов будет распространяться вниз по всем
вложенным каталогам. Например, именно так организована структура каталога
/var/mail в Linux.
Как упоминалось выше, этот вариант назначения идентификатора группы принят по
умолчанию в системах FreeBSD 8.0 и Mac OS X 10.6.8, но в Linux и Solaris он является одним
из возможных. Чтобы описанная схема работала в Linux 3.2.0 и Solaris 10, для каталога
необходимо установить бит set-group-ID, а функция mkdir должна устанавливать его
автоматически для всех вложенных каталогов. (Это будет описано в разделе 4.21.)

4.7. Функции access и faccessat
Как говорилось выше, при открытии файла ядро выполняет серию проверок прав
доступа, основываясь на эффективных идентификаторах пользователя и  группы
процесса. Однако в  некоторых случаях необходимо проверить права доступа на
основе реальных идентификаторов пользователя и  группы. Это бывает удобно,
когда процесс запущен с правами другого пользователя с помощью set-user-ID или
set-group-ID. Даже когда установка бита set-user-ID предоставляет процессу права
суперпользователя, все еще может быть необходимость проверить права реального пользователя на доступ к тому или иному файлу. Функции access и  faccessat
выполняют проверку прав доступа, основываясь на реальных идентификаторах
пользователя и группы процесса. (Замените слово эффективный на слово реальный
в алгоритме принятия решения, что приводится в конце раздела 4.5.)
#include <unistd.h>
int access(const char *pathname, int mode);
int faccessat(int fd, const char *pathname, int mode, int flag);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Аргумент mode — это набор констант из табл. 4.6, объединяемых по ИЛИ (OR).
Таблица 4.6. Константы, используемые в аргументе mode функции access
mode

Описание

R_OK

Проверка права на чтение

W_OK

Проверка права на запись

X_OK

Проверка права на выполнение

Функция faccessat действует подобно access, когда в аргументе pathname передается строка абсолютного пути или когда в аргументе fd передается значение AT_
FDCWD и в аргументе pathname — строка относительного пути. В противном случае
faccessat откладывает путь pathname относительно открытого каталога, определяемого дескриптором fd.

148    Глава 4. Файлы и каталоги
Аргумент flag можно использовать для изменения поведения faccessat. Если
установлен флаг AT_EACCESS, проверка доступа выполняется не для реальных
идентификаторов пользователя и  группы вызывающего процесса, а  для эффективных.

Пример
В листинге 4.2 приводится пример использования функции access.
Листинг 4.2. Пример использования функции access
#include "apue.h"
#include <fcntl.h>
int
main(int argc, char *argv[])
{
if (argc != 2)
err_quit("Использование: a.out <имя_файла>");
if (access(argv[1], R_OK) < 0)
err_ret("ошибка вызова функции access для файла %s", argv[1]);
else
printf("доступ для чтения разрешен\n");
if (open(argv[1], O_RDONLY) < 0)
err_ret("ошибка вызова функции open для файла %s", argv[1]);
else
printf("файл благополучно открыт для чтения\n");
exit(0);
}

Вот пример сеанса работы с этой программой:
$ ls -l a.out
-rwxrwxr-x 1 sar
15945 Nov 30 12:10 a.out
$ ./a.out a.out
Доступ для чтения разрешен
Файл благополучно открыт для чтения
$ ls -l /etc/shadow
-r-------- 1 root
1315 Jul 17 2002 /etc/shadow
$ ./a.out /etc/shadow
ошибка вызова функции access для файла /etc/shadow: Permission denied
ошибка вызова функции open для файла /etc/shadow: Permission denied
$ su
получим права суперпользователя
Password:
вводим пароль суперпользователя
# chown root a.out
делаем суперпользователя владельцем файла
# chmod u+s a.out
и устанавливаем бит set-user-ID
# ls -l a.out
проверяем владельца файла и состояние бита SUID
-rwsrwxr-x 1 root
15945 Nov 30 12:10 a.out
# exit
возвращаемся к правам обычного пользователя
$ ./a.out /etc/shadow
ошибка вызова функции access для файла /etc/shadow: Permission denied
файл благополучно открыт для чтения

В этом примере программа с установленным битом set-user-ID смогла определить,
что реальный пользователь не имеет права на чтение для указанного файла, хотя
вызов функции open завершается успехом.

4.8. Функция umask   

149

В предыдущем примере и в главе 8 мы иногда переходим в режим суперпользователя, чтобы
продемонстрировать некоторые приемы. Если вы работаете в многопользовательской
системе и не обладаете правами суперпользователя, вы не сможете полностью протестировать такие примеры.

4.8. Функция umask
Теперь, когда мы рассмотрели девять бит прав доступа, свойственных всем файлам, перейдем к маске режима создания файла, которой обладает каждый процесс.
Функция umask устанавливает маску режима создания файлов для процесса и возвращает предыдущее значение. (Это одна из немногих функций, которые не возвращают признак ошибки.)
#include <sys/stat.h>
mode_t umask(mode_t cmask);

Возвращает предыдущее значение маски
Аргумент cmask — это набор констант из табл. 4.5 (S_IRUSR, S_IWUSR и т. д.), объединяемых по ИЛИ (OR).
Маска режима создания файлов используется при создании процессом новых
файлов или новых каталогов. (Загляните в разделы 3.3 и 3.4, где были описаны
функции open и  creat. Обе функции принимают аргумент mode, в котором указываются биты прав доступа к создаваемому файлу.) Процедуру создания новых
каталогов мы рассмотрим в разделе 4.21. Любые биты, которые включены в маске,
выключают соответствующие биты прав доступа к файлу.

Пример
Программа в  листинге 4.3 создает два файла: один со значением маски, равным
нулю, и второй — с маской, которая выключает все биты прав доступа для группы
и остальных.
Листинг 4.3. Пример использования функции umask
#include "apue.h"
#include <fcntl.h>
#define RWRWRW (S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH)
int
main(void)
{
umask(0);
if (creat("foo", RWRWRW) < 0)
err_sys("ошибка вызова функции creat для файла foo");
umask(S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH);
if (creat("bar", RWRWRW) < 0)
err_sys("ошибка вызова функции creat для файла bar");
exit(0);
}

150    Глава 4. Файлы и каталоги
Запустив эту программу, можно увидеть, как устанавливаются биты прав доступа.
$ umask
002
$ ./a.out
$ ls -l foo bar
-rw------- 1
-rw-rw-rw- 1
$ umask
002

сначала выведем текущее значение маски

sar 0 Dec 7 21:20 bar
sar 0 Dec 7 21:20 foo
проверим, изменилось ли значение маски

Большинство пользователей UNIX никогда не имеют дела с этой маской. Она обычно устанавливается командной оболочкой единожды, в  момент входа в  систему,
и  никогда не изменяется. Тем не менее при разработке программ, создающих новые файлы, необходимо модифицировать значение маски на время работы процесса, чтобы обеспечить установку конкретных битов прав доступа. Например, чтобы
дать любому пользователю право на чтение создаваемого файла, нужно установить
значение маски в 0. Иначе, вследствие применения действующей маски, может получиться, что необходимые биты прав доступа окажутся сброшенными.
В предыдущем примере мы использовали команду umask для вывода значения
маски режимов создания файлов до и после запуска программы. Тем самым мы
показали, что изменение маски в процессе не влияет на маску родительского процесса (которым часто является командная оболочка). Все командные оболочки
имеют встроенную команду umask, которая используется для вывода и изменения
значения маски режима создания новых файлов.
Пользователи могут установить значение umask для управления правами доступа
к создаваемым файлам по умолчанию. Значение маски задается в восьмеричной
системе счисления, где каждый бит маски соответствует биту прав доступа, который он отключает, как показано в табл. 4.7. Права доступа отключаются установкой соответствующих битов. Наиболее распространенные значения маски — 002
(запрещает запись в файл всем пользователям, кроме владельца), 022 (запрещает
запись в файл членам группы и остальным пользователям) и 027 (запрещает членам группы запись в файл, а всем остальным — чтение, запись и исполнение).
Таблица 4.7. Биты прав доступа для маски
Бит маски

Значение

0400

user-read

0200

user-write

0100

user-execute

0040

group-read

0020

group-write

0010

group-execute

0004

other-read

0002

other-write

0001

other-execute

4.9. Функции chmod, fchmod и fchmodat   

151

Стандарт Single UNIX Specification требует, чтобы командная оболочка поддерживала возможность определения маски в  символической форме. В  отличие от
восьмеричного формата, символический формат определяет набор прав, которые
разрешаются (то есть сброшены в маске), а не тех, которые запрещаются (то есть
установлены в маске). Сравните два варианта вызова команды umask:
$ umask
002
$ umask -S
u=rwx,g=rwx,o=rx
$ umask 027
$ umask –S
u=rwx,g=rx,o=

выведем текущее значение маски режима создания
новых файлов
выведем значение маски в символическом представлении
изменим значение маски режима создания файлов
выведем значение маски в символическом представлении

4.9. Функции chmod, fchmod и fchmodat
Функции chmod, fchmod и fchmodat позволяют изменять права доступа к существующим файлам.
#include <sys/stat.h>
int chmod(const char *pathname, mode_t mode);
int fchmod(int fd, mode_t mode);
int fchmodat(int fd, const char *pathname, mode_t mode, int flag);

Все три возвращают 0 в случае успеха, –1 — в случае ошибки
Функция chmod работает с  файлом, заданным его именем, а  функция fchmod  —
с уже открытым файлом, заданным дескриптором. Функция fchmodat действует
подобно chmod, когда в аргументе pathname передается строка абсолютного пути
или когда в аргументе fd передается значение AT_FDCWD и в аргументе pathname —
строка относительного пути. Иначе fchmodat откладывает путь pathname относительно открытого каталога, определяемого дескриптором fd. Аргумент flag
можно использовать для изменения поведения fchmodat: когда установлен флаг
AT_SYMLINK_NOFOLLOW, функция fchmodat не выполняет переходы по символическим ссылкам.
Чтобы можно было изменить права доступа к файлу, эффективный идентификатор процесса должен совпадать с  идентификатором владельца файла либо процесс должен обладать привилегиями суперпользователя.
Аргумент mode — это набор констант из табл. 4.8, объединяемых по ИЛИ (OR).
Обратите внимание, что имена девяти констант из табл. 4.8 совпадают с именами
констант из табл. 4.5. Здесь добавились две константы set-ID (S_ISUID и S_ISGID),
константа saved-text (S_ISVTX) и  три комбинированные константы (S_IRWXU, S_
IRWXG и S_IRWXO).

152    Глава 4. Файлы и каталоги
Таблица 4.8. Константы режимов для функции chmod, определенные
в файле <sys/stat.h>
Описание

mode
S_ISUID

set-user-ID при запуске на выполнение

S_ISGID

set-group-ID при запуске на выполнение

S_ISVTX

saved-text (бит sticky)

S_IRWXU

Право на чтение, запись и выполнение для пользователя (владельца)

S_IRUSR

Право на чтение для пользователя (владельца)

S_IWUSR

Право на запись для пользователя (владельца)

S_IXUSR

Право на выполнение для пользователя (владельца)

S_IRWXG

Право на чтение, запись и выполнение для группы

S_IRGRP

Право на чтение для группы

S_IWGRP

Право на запись для группы

S_IXGRP

Право на выполнение для группы

S_IRWXO

Право на чтение, запись и выполнение для остальных

S_IROTH

Право на чтение для остальных

S_IWOTH

Право на запись для остальных

S_IXOTH

Право на выполнение для остальных

Бит saved-text (S_ISVTX) не является частью стандарта POSIX.1. Он определен как
расширение XSI в  стандарте Single UNIX Specification. Его назначение будет описано
в следующем разделе.

Пример
Вспомните состояние файлов foo и  bar, созданных программой из листинга 4.3,
которая демонстрирует работу функции umask:
$ ls -l foo bar
-rw------- 1 sar
-rw-rw-rw- 1 sar

0 Dec 7 21:20 bar
0 Dec 7 21:20 foo

Программа в листинге 4.4 изменяет режимы доступа к этим файлам.
Листинг 4.4. Пример использования функции chmod
#include "apue.h"
int
main(void)
{
struct stat

statbuf;

/* включить бит set-group-ID и выключить group-execute */
if (stat("foo", &statbuf) < 0)

4.9. Функции chmod, fchmod и fchmodat   

153

err_sys("ошибка вызова функции stat для файла foo");
if (chmod("foo", (statbuf.st_mode & .S_IXGRP) | S_ISGID) < 0)
err_sys("ошибка вызова функции chmod для файла foo");
/* установить режим в значение "rw-r--r--" */
if (chmod("bar", S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH) < 0)
err_sys("ошибка вызова функции chmod для файла bar");
}

exit(0);

После запуска программы из листинга 4.4 мы увидим, что режимы доступа к файлам изменились:
$ ls -l foo bar
-rw-r--r-- 1
-rw-rwSrw- 1

sar 0 Dec 7 21:20 bar
sar 0 Dec 7 21:20 foo

В этом примере для файла bar мы установили абсолютные значения прав доступа, не обращая внимания на текущие. Для файла foo, наоборот, мы установили
права доступа относительно их текущего состояния. Для этого мы сначала получили набор прав доступа с помощью функции stat и затем изменили их. Мы явно
включили бит set-group-ID и выключили бит group-execute. Обратите внимание,
что команда ls вывела значение бита group-execute в виде символа S, подчеркивая
тем самым, что бит set-group-ID установлен при сброшенном бите group-execute.
В ОС Solaris вместо символа S команда ls выводит символ l, чтобы подчеркнуть, что для
файла включен режим обязательных блокировок файла и отдельных записей. Это справедливо только для обычных файлов, и мы еще обсудим эту тему в разделе 14.3.

И наконец, отметьте, что дата и время, отображаемые командой ls, не изменились
после запуска программы из листинга 4.4. Позже, в разделе 4.19, мы увидим, что
функция chmod обновляет только время последнего изменения индексного узла
(i-node). Команда ls -l по умолчанию выводит время последнего изменения содержимого файла.
Функция chmod автоматически сбрасывает два бита прав доступа при следующих
условиях:
 В некоторых системах, таких как Solaris, бит sticky имеет особое значение для
обычных файлов. Если попытаться установить бит sticky (S_ISVTX) для обычного файла, не обладая привилегиями суперпользователя, этот бит в аргументе
mode будет автоматически сброшен. (Бит sticky рассматривается в следующем
разделе.) Отсюда следует, что его может установить только суперпользователь.
Сделано это, чтобы предотвратить установку бита S_ISVTX злоумышленником
и тем самым избежать нанесения ущерба работоспособности системы в целом.
В системах FreeBSD 8.0 и Solaris 10 только суперпользователь может устанавливать бит
sticky на обычные файлы. В Linux 3.2.0 и Mac OS X 10.6.8 это ограничение отсутствует,
поскольку для обычных файлов в этих системах данный бит не имеет никакого значения.
Несмотря на то что в FreeBSD этот бит также не имеет значения для обычных файлов,
его установка для обычных файлов разрешена только суперпользователю.

154    Глава 4. Файлы и каталоги
 При создании файла ему можно назначить идентификатор группы, отличный
от идентификатора группы процесса, создающего файл. В разделе 4.6 говорилось, что возможна ситуация, когда файл наследует идентификатор группы
от каталога, в  котором он размещается. Поэтому если идентификатор группы создаваемого файла не является эффективным идентификатором группы
процесса или одним из идентификаторов дополнительных групп и процесс не
обладает привилегиями суперпользователя, бит set-group-ID автоматически
сбрасывается. Это предотвращает возможность создания файла с идентификатором группы, с которой пользователь никак не связан.
В ОС FreeBSD 8.0 попытка установить бит set-group-ID в  такой ситуации терпит
неудачу. Другие системы просто сбрасывают бит, не сообщая об ошибке при попытке
изменить права доступа.
Системы FreeBSD 8.0, Mac OS X 10.6.8, Linux 3.2.0 и Solaris 10 имеют еще одну особенность,
предотвращающую злонамеренное использование некоторых битов. Если процесс, не обладающий привилегиями суперпользователя, производит запись в файл, биты set-user-ID
и set-group-ID автоматически сбрасываются. Даже если злоумышленнику удастся отыскать доступные на запись файлы с установленными битами set-user-ID или set-group-ID,
в момент модификации эти файлы утратят особые привилегии.

4.10. Бит sticky
Интересна история появления бита S_ISVTX. В версиях UNIX, поддерживавших
предварительную подкачку страниц, этот бит был известен под названием sticky
bit (липкий бит). Если этот бит устанавливался на выполняемый файл, при первом запуске программы ее сегмент кода записывался в  файл подкачки и  сохранялся там после ее завершения. (Сегмент кода программы состоит из машинных
инструкций.) Это приводило к тому, что при следующем вызове программы она
запускалась намного быстрее, поскольку файл подкачки представлял собой непрерывную область на диске в отличие от обычных файлов, которые могут размещаться в  разрозненных дисковых блоках. Бит sticky обычно устанавливался
на наиболее часто используемые программы, такие как текстовые редакторы или
компилятор языка C. Естественно, существовало ограничение на количество таких «липких» файлов, которые могли одновременно разместиться в  файле подкачки, тем не менее этот прием был очень удобен. Название sticky (липкий) объясняется тем, что сегмент кода программы как бы вклеивался в пространство файла
подкачки и  оставался там до перезагрузки системы. В  более поздних версиях
UNIX этот бит стал называться saved-text bit (закрепляемый сегмент кода), отсюда и название константы — S_ISVTX. Большинство современных версий UNIX обладают системой виртуальной памяти и более быстродействующими файловыми
системами, поэтому надобность в подобном «закреплении» отпала.
В современных системах назначение бита sticky было расширено. Стандарт Single
UNIX Specification допускает установку этого бита на каталоги. Если бит sticky
установлен на каталог, удалять или изменять файлы в  таком каталоге сможет
только пользователь, обладающий правом на запись в каталог и являющийся:

4.11. Функции chown, fchown, fchownat и lchown   

155

 владельцем файла;
 или владельцем каталога;
 или суперпользователем.
Типичные примеры каталогов, на которые, как правило, устанавливается бит
sticky, — /tmp и  /var/tmp. Обычно любой пользователь может создавать файлы
в этих каталогах. Часто эти каталоги доступны для записи, чтения и выполнения всем пользователям, но удалять или изменять файлы могут только их владельцы.
Бит saved-text не является частью стандарта POSIX.1. Он входит в состав определяемых
стандартом Single UNIX Specification расширений XSI и поддерживается операционными
системами FreeBSD 8.0, Linus 3.2.0, Mac OS X 10.6.8 и Solaris 10.
В Solaris 10 бит sticky для обычных файлов имеет специальное значение. Если для файла
установлен бит sticky и сброшены биты прав на выполнение, операционная система не
будет кэшировать содержимое этого файла.

4.11. Функции chown, fchown, fchownat
и lchown
Функции семейства chown позволяют изменять идентификаторы пользователя
и группы файла, но если в аргументе owner или group передается –1, соответствующий идентификатор не изменяется.
#include <unistd.h>
int chown(const char *pathname, uid_t owner, gid_t group);
int fchown(int fd, uid_t owner, gid_t group);
int fchownat(int fd, const char *pathname, uid_t owner, gid_t group, int flag);
int lchown(const char *pathname, uid_t owner, gid_t group);

Все четыре возвращают 0 в случае успеха и –1 — в случае ошибки
Эти четыре функции практически идентичны, за исключением случая, когда они
применяются к символическим ссылкам. Функции lchown и  fchownat (с установленным флагом AT_SYMLINK_NOFOLLOW) изменяют владельца самой символической
ссылки, а не файла, на который она указывает.
Функция fchown изменяет владельца открытого файла, на который ссылается дескриптор fd. Поскольку операция выполняется над уже открытым файлом, fchown
не может использоваться для изменения владельца символической ссылки.
Функция fchownat может действовать подобно chown или lchown, когда в аргументе pathname передается строка абсолютного пути или когда в  аргументе fd
передается значение AT_FDCWD и в аргументе pathname — строка относительного
пути. В этих случаях fchownat действует подобно lchown, если в аргументе flag

156    Глава 4. Файлы и каталоги
установлен флаг AT_SYMLINK_NOFOLLOW, а если флаг AT_SYMLINK_NOFOLLOW в аргументе flag сброшен, она действует подобно chown. Если в аргументе fd передается файловый дескриптор открытого каталога и в аргументе pathname — строка
относительного пути, fchownat откладывает путь pathname относительно открытого каталога.
Исторически в BSD-системах существует ограничение на эту операцию — только суперпользователь может изменить владельца файла. Это предотвращает несанкционированную передачу права на владение файлами другим пользователям
и  тем самым возможность превышения установленных дисковых квот. Однако
в System V всем пользователям позволено изменять владельцев для любых файлов, которыми они владеют.
Стандарт POSIX.1 допускает любой из двух режимов в зависимости от значения константы _POSIX_CHOWN_RESTRICTED.
В Solaris 10 режим работы зависит от значения параметра конфигурации, значение по
умолчанию — ограниченный режим изменения владельца файла. В системах FreeBSD 8.0,
Linux 3.2.0 и Mac OS X 10.6.8 ограниченный режим изменения владельца файла действует
всегда.

В разделе 2.6 упоминалось, что константа _POSIX_CHOWN_RESTRICTED не всегда определяется в заголовочном файле <unistd.h>, но ее значение всегда можно получить
с помощью функции pathconf или fpathconf. Значение этого параметра может зависеть от конкретного файла; кроме того, это ограничение может поддерживаться
или не поддерживаться самой файловой системой. Мы будем употреблять выражение «если действует ограничение _POSIX_CHOWN_RESTRICTED» в отношении конкретных файлов, о которых идет речь, вне зависимости от наличия определения
константы в заголовочном файле <unistd.h>.
Если ограничение _POSIX_CHOWN_RESTRICTED действует, тогда:
1.	 Только процесс, обладающий правами суперпользователя, сможет изменить
идентификатор пользователя файла.
2.	 Процесс, не обладающий правами суперпользователя, сможет изменить идентификатор группы файла, если является владельцем этого файла (эффективный идентификатор пользователя процесса совпадает с  идентификатором
пользователя файла), аргумент owner имеет значение –1 или совпадает с идентификатором пользователя файла и аргумент group совпадает с эффективным
идентификатором группы или с одним из идентификаторов дополнительных
групп процесса.
Это означает, что если ограничение _POSIX_CHOWN_RESTRICTED действует, вы не
сможете изменить идентификатор пользователя (владельца) файла. Изменить
идентификатор группы файла может только владелец этого файла и только при
условии, что присваивает идентификатор одной из групп, к которой принадлежит
сам.
Если эти функции вызываются из процесса, не обладающего привилегиями суперпользователя, в случае успешного завершения они сбрасывают биты set-userID и set-group-ID.

4.12. Размер файла   

157

4.12. Размер файла
Поле st_size структуры stat содержит размер файла в  байтах. Это поле имеет
смысл только для обычных файлов, каталогов и символических ссылок.
FreeBSD 8.0, Mac OS X 10.6.8 и Solaris 10 поддерживают размер файла также для каналов;
он обозначает доступное для чтения количество байтов в канале. О каналах речь пойдет
в разделе 15.2.

Обычные файлы могут иметь размер, равный нулю. В этом случае первая же операция чтения вернет признак конца файла. Для каталогов размер файла обычно
кратен некоторому числу, такому как 16 или 512. О чтении каталогов мы поговорим в разделе 4.22.
Размер файла для символических ссылок обозначает длину имени файла в байтах. Например, в  следующем случае число 7 обозначает длину пути к  каталогу
usr/lib:
lrwxrwxrwx

1 root

7 Sep 25 07:14 lib -> usr/lib

(Обратите внимание, что символические ссылки не имеют завершающего нулевого символа в конце имени, типичного для строк в языке C, поэтому поле st_size
всегда определяет длину строки имени файла.)
В большинстве современных версий UNIX есть поля st_blksize и  st_blocks.
Первое определяет оптимальный размер блока для операций ввода/вывода, а второй — фактическое количество 512-байтных блоков, занимаемых файлом. В разделе 3.9 мы определили, что наименьшее время на операции чтения затрачивается,
если используется буфер с размером st_blksize. Стандартная библиотека ввода/
вывода, которую мы рассмотрим в главе 5, также старается производить операции
ввода/вывода блоками по st_blksize байт, что повышает производительность.
Существуют такие версии UNIX, которые измеряют величину st_blocks не в 512-байтных
блоках. Использование этого значения снижает переносимость программ.

Дырки в файлах
В разделе 3.6 говорилось, что обычные файлы могут содержать «дырки». Мы продемонстрировали это на примере программы из листинга 3.2. Дырки создаются
в результате переноса текущей позиции за пределы файла и последующей записи
некоторых данных. Рассмотрим следующий пример:
$ ls -l core
-rw-r--r-1 sar
$ du -s core
272
core

8483248 Nov 18 12:18 core

Размер файла core превышает 8 Мбайт, хотя команда du сообщает, что он занимает
всего 272 блока по 512 байт (139 264 байт). Очевидно, что этот файл имеет дырки.
Команда du в большинстве систем, происходящих от BSD, выводит количество 1024-байтных блоков, тогда как в Solaris — количество 512-байтных блоков. В Linux единица измере-

158    Глава 4. Файлы и каталоги
ния зависит от переменной окружения POSIXLY_CORRECT. Если она установлена, команда du
выводит размеры в блоках по 1024 байт, иначе — в блоках по 512 байт.

Как упоминалось в разделе 3.6, функция read возвращает 0 для байтов, которые
фактически не были записаны. Запустив следующую команду, мы увидим, что
обычные операции ввода/вывода считывают полное количество байтов, соответствующее размеру файла:
$ wc -c core
8483248 core

Команда wc(1) с ключом –c подсчитывает количество символов (байтов) в файле.

Если скопировать этот файл, например, с помощью утилиты cat(1), дырки будут
скопированы как обычные байты данных со значением 0:
$ cat core > core.copy
$ ls -l core*
-rw-r--r-- 1
8483248 Nov 18 12:18 core
-rw-rw-r-- 1 sar
8483248 Nov 18 12:27 core.copy
$ du -s core*
272
core
16592
core.copy

Здесь фактический размер нового файла составил 8 495 104 байт (то есть 512 ×
16 592). Различие между этим числом и размером, выведенным командой ls, обусловлено использованием файловой системой некоторого количества блоков для
хранения указателей на блоки с фактическими данными.
Кому интересны вопросы, связанные с физическим размещением файлов, могут
обратиться к  разделу 4.2 [Bach, 1986], разделам 7.2 и  7.3 [McKusick, 1996] (или
к разделам 8.2 и 8.3 в [McKusick and Neville-Neil, 2005]), к разделу 15.2 [McDougall
and Mauro, 2007] и к главе 12 [Singh, 2006].

4.13. Усечение файлов
Иногда возникает необходимость отсечь некоторые данные, расположенные
в конце файла. Усечение размера файла до нуля, которое осуществляется при использовании флага O_TRUNC в вызове функции open, есть частный случай усечения
файла.
#include <unistd.h>
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Эти две функции усекают существующий файл до размера, определяемого аргументом length. Если первоначальный размер файла превышал значение length,

4.14. Файловые системы   

159

данные за этим пределом будут недоступны. Если первоначальный размер файла
меньше значения length, размер файла будет увеличен, а данные, расположенные
между старым и новым концом файла, будут читаться как нули (то есть в файле,
вероятно, будет создана дырка).
В версиях BSD, предшествовавших 4.4BSD, функция truncate может только уменьшать
размер файла.
Solaris включает расширение fcntl (F_FREESP), позволяющее вырезать любую часть файла,
а не только ту, что находится в конце.

Мы будем использовать функцию ftruncate в программе, представленной в лис­
тинге 13.2, где требуется очистить содержимое файла после получения блокировки.

4.14. Файловые системы
Чтобы понять идею ссылок на файлы, сначала нужно в общих чертах разобраться в устройстве файловой системы UNIX. Также пригодится понимание разницы
между индексным узлом (i-node) и записью в файле каталога, которая указывает
на индексный узел.
В настоящее время используются самые разные реализации файловых систем
UNIX. Например, Solaris поддерживает несколько типов дисковых файловых систем: традиционную для BSD-систем UNIX File System (UFS), DOS-совместимую
файловую систему PCFS и файловую систему HSFS, предназначенную для компакт-дисков. Мы уже видели одно из различий между разными типами файловых
систем в табл. 2.16. UFS основана на системе Berkeley fast file system, которая рассматривается в этом разделе.
Каждая файловая система имеет свои специфические особенности, и некоторые из этих
особенностей могут сбить с толку. Например, большинство файловых систем для UNIX поддерживают имена файлов, чувствительные к регистру символов. То есть если попытаться
создать один файл с именем file.txt и другой файл с именем file.TXT, будет создано два
разных файла. Однако в Mac OS X поддерживается файловая система HFS, сохраняющая
регистр символов в именах файлов, но выполняющая сравнение без учета регистра символов.
То есть если попытаться создать файл с именем file.txt и затем file.TXT, файл file.
txt будет затерт. Однако в файловой системе будет сохранено имя, использованное при
создании файла (с сохранением регистра символов). Фактически любые комбинации букв
верхнего и нижнего регистров в последовательности f, i, l, e, ., t, x, t будут соответствовать
данному имени файла (сравнение выполняется без учета регистра символов). Как следствие,
помимо имен file.txt и file.TXT для доступа к файлу можно также использовать имена
File.txt, fILE.tXt и FiLe.TxT.

Представим диск, поделенный на несколько разделов. Каждый раздел может содержать файловую систему, как показано на рис. 4.1. Индексные узлы — это записи фиксированной длины, которые содержат большую часть сведений о файлах.
Присмотревшись к той части группы цилиндров, где находятся индексные узлы
и блоки данных, мы увидим картину, изображенную на рис. 4.2.

160    Глава 4. Файлы и каталоги

Дисковое
устройство

Раздел

Файловая
система

Раздел

Раздел

Группа цилиндров 1

Группа цилиндров 0

...

Группа цилиндров n

Загрузочный
блок(и)
Суперблок
Копия
суперблока

Информация
о группе
цилиндров

Карта
индексных
узлов

Индексный
узел

Карта
блоков

Индексные
узлы

Блоки данных

...

Индексный
узел

Индексный
узел

Рис. 4.1. Дисковое устройство, разделы и файловая система

Блоки каталогов и данных

пер
вы
дан й бл
ны ок
х

Массив
индексных узлов

Блок
данных

Индексный
узел

Индексный
узел

Индексный
узел

Блок
данных

ок
бл
й ых
о
ор нн
вт да

Блок
каталога

Блок
данных

Блок
каталога

лок
ий б
трет нных
да

Индексный
узел
Номер
индексного
узла

Имя
файла
Номер
индексного
узла

Имя
файла

Рис. 4.2. Часть группы цилиндров с индексными узлами и блоками данных
более детально

Отметим на рис. 4.2 следующие моменты:
 Здесь мы видим две записи в файле каталога, которые ссылаются на один и тот
же индексный узел. Каждый индексный узел имеет счетчик ссылок; в нем хранится число записей в файле каталога, которые ссылаются на данный индексный узел. Только когда этот счетчик достигнет значения 0, файл будет удален
(то есть блоки данных, связанные с  файлом, перейдут в  список свободных
блоков). Поэтому операция «отсоединения файла» (unlink) не всегда приводит к «удалению блоков, связанных с файлом» (delete). Именно по этой при-

4.14. Файловые системы   

161

чине функция удаления записей из каталога носит имя unlink (отцепить), а не
delete (удалить). В структуре stat счетчик ссылок находится в поле st_nlink.
Оно имеет элементарный системный тип nlink_t. Этот тип ссылок называют
жесткими ссылками. В разделе 2.5.2 мы говорили о константе LINK_MAX, которая задает максимальное значение для счетчика ссылок.
 Другую разновидность ссылок называют символическими ссылками. В  этом
случае в блоках данных файла-ссылки хранится имя файла, на который указывает эта символическая ссылка. В следующем примере имя файла в каталожной записи представлено трехсимвольной строкой lib, сам же файл содержит
7 символов — usr/lib.
lrwxrwxrwx

1 root

7 Sep 25 07:14 lib -> usr/lib

Тип файла в индексном узле должен быть определен как S_IFLNK, чтобы файловая система корректно распознавала символические ссылки.
 Индексный узел содержит полную информацию о  файле: тип файла, биты
прав доступа, размер файла, указатели на блоки данных файла и  т. п. Большая часть информации для структуры stat берется из индексного узла. Только
два элемента, которые могут представлять для нас интерес, берутся из записи
в файле каталога: имя файла и номер индексного узла. Другие элементы, такие
как длина имени файла и размер записи в файле каталога, пока для нас особого
интереса не представляют. Для хранения номера индексного узла используется тип данных ino_t.
 Поскольку номер индексного узла в каталожной записи ссылается на индексный узел, находящийся в той же файловой системе, нельзя создать запись, которая указывала бы на индексный узел в  другой файловой системе. По этой
причине команда ln(1) (создающая новую запись в каталоге, которая указывает на индексный узел существующего файла) не может создавать ссылки на
файлы, расположенные в других файловых системах. Функция link рассмат­
ривается в следующем разделе.
 При переименовании/перемещении файла в пределах одной файловой системы фактическое содержимое файла никуда не перемещается. Все, что нужно
сделать, — это добавить в  каталог новую запись, которая будет указывать на
существующий индексный узел, а затем отцепить старую запись. При этом значение счетчика ссылок не изменится. Например, чтобы переименовать файл
/usr/lib/foo в  /usr/foo, нет необходимости перемещать содержимое файла
foo, если каталоги /usr/lib и /usr находятся в одной файловой системе. Обычно именно так работает команда mv(1).
Мы только что обсудили смысл счетчика ссылок для обычных файлов, а что означает понятие счетчика ссылок для каталога? Предположим, что мы создаем новый
каталог в текущем каталоге:
$ mkdir testdir

На рис. 4.3 показан результат выполнения этой команды. Обратите внимание: мы
явно показали наличие записей о каталогах «точка» (текущий каталог) и «точкаточка» (родительский каталог).

162    Глава 4. Файлы и каталоги
Блоки каталогов и данных
Блок
каталога

Массив
индексных узлов

к
ло

б

Индексный
узел
0

Индексный
узел
1267

ых

нн

да

Блок
каталога

блок

ых

данн

Индексный
узел
2549

2549
1267

.
..

.

1267
Номер
индексного
узла

2549

..
testdir

Рис. 4.3. Группа цилиндров после создания каталога testdir

Индексный узел с номером 2549 в поле «тип» хранит значение «каталог», а в счетчике ссылок — значение 2. Любой оконечный каталог (который не содержит других
каталогов) в счетчике ссылок всегда хранит число 2, потому что на индексный узел
ссылаются две каталожные записи: запись, указывающая на каталог testdir, и запись
в этом же каталоге, указывающая на каталог «точка». Индексный узел с номером 1267
в поле «тип» хранит значение «каталог», а в счетчике ссылок — значение 3 или выше.
Причина, по которой значение счетчика ссылок больше или равно 3, теперь должна
быть нам понятна. Число 3 — это минимальное значение, учитывающее записи в каталоге верхнего уровня (который на рисунке не показан), в самом каталоге («точка»)
и в каталоге testdir («точка-точка»). Обратите внимание, что появление каждого нового подкаталога увеличивает счетчик ссылок в родительском каталоге на единицу.
Этот формат похож на классический формат файловой системы UNIX, описанный в  главе 4 [Bach, 1986]. За дополнительной информацией по изменениям,
которые появились в Berkeley fast file system, обращайтесь к главе 7 [McKusick,
1996] или к  главе 8 [McKusik and Neville-Neil, 2005]. Подробную информацию
о  файловой системе UFS версии Berkeley fast file system для Solaris вы найдете
в главе 15 [Mauro and McDougall, 2007]. Информацию о файловой системе HFS,
используемой в Mac OS X, см. в главе 12 [Singh, 2006].

4.15. Функции link, linkat, unlink, unlinkat
и remove
Как мы уже говорили в  предыдущем разделе, на индексный узел любого файла
могут указывать несколько каталожных записей. Такие ссылки создаются с  помощью функции link или linkat.

4.15. Функции link, linkat, unlink, unlinkat и remove   

163

#include <unistd.h>
int link(const char *existingpath, const char *newpath);
int linkat(int efd, const char *existingpath, int nfd, const char *newpath,
int flag);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Эти функции создают в каталоге новую запись с именем newpath, которая будет
указывать на существующий файл existingpath. Если запись с именем newpath уже
существует, функция вернет признак ошибки. Создается только последний компонент полного пути newpath, все промежуточные компоненты должны существовать к моменту вызова функции.
В функции linkat существующий файл определяется обоими аргументами, efd
и existingpath, а новая запись определяется аргументами nfd и newpath. По умолчанию, если какая-нибудь из строк путей определяет относительный путь, этот
путь откладывается относительно каталога, представленного соответствующим
файловым дескриптором. Если в  каком-либо аргументе файлового дескриптора
передается значение AT_FDCWD, соответствующий путь, если он относительный, откладывается от текущего каталога. Если в какой-либо из строк пути передается
абсолютный путь, соответствующий аргумент с файловым дескриптором игнорируется.
Если существующий файл является символической ссылкой, с  помощью аргумента flag можно указать, создавать ли ссылку на символическую ссылку или
на файл, на который указывает эта символическая ссылка. Если в аргументе flag
установить флаг AT_SYMLINK_FOLLOW, будет создана ссылка на файл, на который
указывает символическая ссылка. Если передать пустой аргумент flag, будет со­
здана ссылка на саму символическую ссылку.
Операции создания новой записи в каталоге и увеличения счетчика ссылок должны выполняться атомарно. (Вспомните обсуждение атомарных операций в разделе 3.11.)
Большинство реализаций требуют, чтобы оба пути находились в пределах одной
файловой системы, хотя стандарт POSIX.1 допускает возможность создания
ссылок на файлы, расположенные в других файловых системах. Если поддерживается создание жестких ссылок на каталоги, то эта операция может выполняться только суперпользователем. Причина такого ограничения в том, что создание
жесткой ссылки на каталог может привести к  появлению замкнутых «петель»
в файловой системе и большинство обслуживающих ее утилит не смогут обработать их надлежащим образом. (В разделе 4.17 мы покажем пример замкнутой
петли, образованной с  помощью символической ссылки.) По этой же причине
многие реализации файловых систем вообще не допускают создания жестких
ссылок на каталоги.
Удаление записей из каталога производится с  помощью функции unlink или
unlinkat.

164    Глава 4. Файлы и каталоги

#include <unistd.h>
int unlink(const char *pathname);
int unlinkat(int fd, const char *pathname, int flag);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Эти функции удаляют запись из файла каталога и уменьшают значение счетчика
ссылок на файл pathname. Если на файл указывает несколько ссылок, его содержимое будет по-прежнему доступно через них. В случае ошибки файл не изменяется.
Как мы уже говорили, чтобы удалить жесткую ссылку на файл, необходимо обладать правом на запись и на выполнение для каталога, в котором находится удаляемая запись. Кроме того, в разделе 4.10 говорилось, что если для каталога установлен бит sticky, мы должны обладать правом на запись в каталог и являться либо
владельцем файла, либо владельцем каталога, либо суперпользователем.
Содержимое файла может быть удалено, только если счетчик ссылок достиг 0.
Кроме того, содержимое файла нельзя удалить, если он открыт каким-либо процессом. Во время закрытия файла ядро в первую очередь проверяет счетчик процессов, открывших его. Если значение счетчика достигло нуля, ядро проверяет
счетчик ссылок, и только если его значение достигло нуля, содержимое файла будет удалено.
Если в  аргументе pathname передается строка относительного пути, функция
unlinkat откладывает путь относительно открытого каталога, представленного
файловым дескриптором fd. Если в  аргументе fd передается значение AT_FDCWD,
относительный путь pathname откладывается относительно текущего рабочего
каталога вызывающего процесса. Если в  аргументе pathname передается строка
абсолютного пути, аргумент fd игнорируется.
Аргумент flag позволяет вызывающей программе изменять поведение по умолчанию функции unlinkat. Если установлен флаг AT_REMOVEDIR, функция unlinkat
может использоваться для удаления каталога подобно функции rmdir. Если передать пустой аргумент flag, unlinkat действует подобно функции unlink.

Пример
Программа в листинге 4.5 открывает файл и отцепляет его (то есть удаляет с помощью функции unlink). Затем программа приостанавливается на 15 секунд и завершает работу.
Листинг 4.5. Открывает файл, а затем удаляет его
#include "apue.h"
#include <fcntl.h>
int
main(void)
{
if (open("tempfile", O_RDWR) < 0)

4.15. Функции link, linkat, unlink, unlinkat и remove   

}

165

err_sys("ошибка вызова функции open");
if (unlink("tempfile") < 0)
err_sys("ошибка вызова функции unlink");
printf("файл удален\n");
sleep(15);
printf("конец\n");
exit(0);

Запуск программы дает следующие результаты:
$ ls -l tempfile
посмотрим размер файла
-rw-r----- 1 sar
413265408 Jan 21 07:14 tempfile
$ df /home
проверим объем доступного свободного пространства
Filesystem
1K-blocks
Used Available
Use% Mounted on
/dev/hda4
11021440
1956332
9065108
18% /home
$ ./a.out &
запустим программу из листинга 4.5 как фоновый процесс
1364
командная оболочка вывела идентификатор процесса
$ файл удален
файл отцеплен
ls -l tempfile
проверим, остался ли файл на месте
ls: tempfile: No such file or directory
запись из каталога была удалена
$ df /home
проверим, освободилось ли дисковое пространство
Filesystem
1K-blocks
Used Available
Use% Mounted on
/dev/hda4
11021440
1956332
9065108
18% /home
$ конец
программа завершилась, все файлы закрыты
df /home
теперь должно освободиться пространство на диске
Filesystem
1K-blocks
Used Available
Use% Mounted on
/dev/hda4
11021440
1552352
9469088
15% /home
на диске освободилось 394,1 Mбайт

Эта характерная особенность функции unlink часто используется программами,
чтобы обеспечить удаление временных файлов в случае аварийного завершения.
Процесс создает файл вызовом open или creat и  сразу же вызывает функцию
unlink. Однако файл не будет удален, поскольку остается открытым. Только когда процесс закроет файл или завершит работу, что, в свою очередь, заставит ядро
закрыть все файлы, открытые процессом, файл удалится.
Если аргумент pathname является символической ссылкой, удалится сама символическая ссылка, а не файл, на который она ссылается, — не существует функции,
которая удаляла бы файл по символической ссылке.
Процесс, обладающий привилегиями суперпользователя, может вызвать функцию unlink для удаления каталога, если такая возможность поддерживается системой, но вообще в таких случаях следует использовать функцию rmdir, которую
мы рассмотрим в разделе 4.21.
Удалить жесткую ссылку на файл или каталог можно также с помощью функции
remove. Для файлов функция remove абсолютно идентична функции unlink, для
каталогов — функции rmdir.
#include <stdio.h>
int remove(const char *pathname);

Возвращает 0 в случае успеха, –1 — в случае ошибки

166    Глава 4. Файлы и каталоги
Стандарт ISO C определяет remove как функцию для удаления файлов. Исторически сложившееся в UNIX название unlink было заменено, потому что в то время в большинстве
других операционных систем, которые следовали стандарту ISO C, понятие ссылок на
файлы не поддерживалось.

4.16. Функции rename и renameat
Для переименования файла или каталога используется функция rename или
renameat.
#include <stdio.h>
int rename(const char *oldname, const char *newname);
int renameat(int oldfd, const char *oldname, int newfd, const char *newname);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Стандарт ISO C определяет rename как функцию для переименования файлов. (ISO C
вообще не касается каталогов.) Стандарт POSIX.1 расширил это определение, включив
в него каталоги и символические ссылки.

Следует отдельно рассмотреть случаи, когда аргумент oldname представляет файл,
символическую ссылку или каталог. Также необходимо упомянуть о том, что произойдет, если newname уже существует.
1.	 Если аргумент oldname указывает на файл, который не является каталогом,
происходит переименование файла или символической ссылки. Если файл
newname уже существует, он не должен быть каталогом. Если файл newname
существует и  не является каталогом, он будет удален, а  файл oldname будет
переименован в newname. Процесс должен обладать правом записи в каталоги,
где находятся файлы newname и oldname, поскольку предполагается внесение
изменений в оба каталога.
2.	 Если аргумент oldname указывает на каталог, выполняется переименование
каталога. Если newname существует, он также должен быть каталогом, и этот
каталог должен быть пустым. (Под «пустым каталогом» имеется в виду каталог, содержащий только две записи: «точка» и «точка-точка».) Если newname
существует и является пустым каталогом, он будет удален, а каталог oldname
будет переименован в newname. Кроме того, при переименовании каталога аргумент newname не должен начинаться с имени каталога oldname. Так, например, нельзя переименовать каталог /usr/foo в  /usr/foo/testdir, поскольку
прежнее имя каталога (/usr/foo) содержится в  начале нового имени и  он не
может быть удален.
3.	 Если аргументы oldname или newname содержат имя символической ссылки,
будет переименована сама символическая ссылка, а не файл, на который она
ссылается.

4.17. Символические ссылки   

167

4.	 Каталоги «точка» и «точка-точка» нельзя переименовать. Точнее, ни одно из
этих имен не может передаваться в аргументах oldname и newname.
5.	 В особом случае, когда аргументы oldname и newname указывают на один и тот
же файл, функция завершается без признака ошибки, но и не производит никаких изменений.
Если файл newname уже существует, мы должны обладать теми же правами, что
и для удаления файла. Кроме того, поскольку мы удаляем запись из каталога, содержащего файл oldname, и создаем новую запись в файле каталога, где будет находиться newname, мы должны обладать правом на запись и выполнение для обоих каталогов.
Функция renameat действует так же, как функция rename, кроме случая, когда какой-либо из аргументов, oldname или newname, содержит строку относительного
пути. Если oldname определяет относительный путь, он откладывается относительно каталога, представленного файловым дескриптором oldfd. Аналогично,
если newname определяет относительный путь, он откладывается относительно
каталога, представленного файловым дескриптором newfd. В любом из аргументов oldfd и newfd (или в обоих) можно передать значение AT_FDCWD. В этом случае
соответствующие относительные пути будут откладываться относительно текущего каталога.

4.17. Символические ссылки
Символическая ссылка  — это косвенная ссылка на файл в  отличие от жесткой
ссылки, которая является прямым указателем на индексный узел файла. Символические ссылки придуманы с целью обойти ограничения, присущие жестким
ссылкам.
 Жесткие ссылки обычно требуют, чтобы ссылка и файл размещались в одной
файловой системе.
 Только суперпользователь имеет право создавать жесткие ссылки на каталоги
(если это поддерживается файловой системой).
Символические ссылки не имеют ограничений, связанных с файловой системой,
и  любой пользователь сможет создать символическую ссылку на каталог. Символические ссылки обычно используются для «перемещения» файлов или даже
целой иерархии каталогов в другое местоположение в системе.
При использовании функций, которые обращаются к файлам по именам, всегда
нужно знать, как они обрабатывают символические ссылки. Если функция следует по символической ссылке, она будет воздействовать на файл, на который указывает символическая ссылка. В противном случае операция будет производиться над самой символической ссылкой, а не над файлом, на который она указывает.
В  табл. 4.9 приводится перечень описываемых в  этой главе функций, которые
следуют по символическим ссылкам. В этом списке отсутствуют функции mkdir,
mkfifo, mknod и rmdir — они возвращают признак ошибки, если им в качестве аргумента передается символическая ссылка. Кроме того, функции, которые принима-

168    Глава 4. Файлы и каталоги
ют дескриптор файла, такие как fstat и fchmod, также не были включены в список,
поскольку в этом случае обработка символических ссылок производится функциями, возвращающими файловые дескрипторы (как правило, open). Исторически
в  разных реализациях функция chown по-разному обрабатывала символические
ссылки. Однако во всех современных системах chown следует по символическим
ссылкам.
Впервые символические ссылки появились в  4.2BSD. Первоначально функция chown не
следовала по символическим ссылкам, но это ее поведение было изменено в версии 4.4BSD.
Поддержка символических ссылок в System V появилась в версии SVR4, но, в отличие от
оригинальной версии, она следовала по символическим ссылкам. В старых версиях Linux
(до 2.1.81) функция chown не следовала по символическим ссылкам. Начиная с версии 2.1.81
функция chown следует по символическим ссылкам. В системах FreeBSD 8.0, Mac OS X 10.6.8
и Solaris 10 функция chown также следует по символическим ссылкам. Все эти платформы
предоставляют функцию lchown для изменения владельца самих символических ссылок.
Таблица 4.9. Интерпретация символических ссылок различными функциями
Функция

Не следует
по символической ссылке

Следует по символической
ссылке

access



chdir



chmod



chown



creat



exec
lchown




link
lstat




open



opendir



pathconf



readlink



remove



rename



stat



truncate
unlink




Существует одно исключение, не отмеченное в табл. 4.9: когда функция open вызывается с установленными одновременно флагами O_CREAT и O_EXCL. Если в этом
случае аргумент pathname содержит имя символической ссылки, функция будет
завершаться ошибкой с кодом EEXIST. Сделано это с целью закрыть брешь в си-

4.17. Символические ссылки   

169

стеме безопасности и предотвратить возможность «обмана» привилегированных
процессов путем подмены файлов символическими ссылками.

Пример
С помощью символической ссылки можно создать замкнутую петлю в файловой
системе. Большинство функций, анализирующих путь к файлу, обнаружив такую
петлю, возвращают в  errno код ошибки ELOOP. Рассмотрим следующую последовательность команд:
$ mkdir foo
создать новый каталог
$ touch foo/a
создать пустой файл
$ ln -s ../foo foo/testdir
создать символическую ссылку
$ ls -l foo
total 0
-rw-r----- 1 sar
0 Jan 22 00:16 a
lrwxrwxrwx 1 sar
6 Jan 22 00:16 testdir -> ../foo

Эта последовательность команд создает каталог foo, файл a в нем и символическую ссылку на каталог foo. На рис. 4.4 приводится схема, на которой каталоги
представлены в виде окружностей, а файл — в виде квадрата.

foo

a

testdir

Рис. 4.4. Символическая ссылка testdir создает замкнутую петлю

Написав простую программу, которая использует стандартную функцию ftw(3)
для обхода дерева каталогов и вывода имен всех встретившихся файлов, и запустив ее в Solaris, мы получим
foo
foo/a
foo/testdir
foo/testdir/a
foo/testdir/testdir
foo/testdir/testdir/a
foo/testdir/testdir/testdir
foo/testdir/testdir/testdir/a

(и еще много строк, пока не произойдет ошибка с кодом ELOOP).
В разделе 4.22 будет представлена версия функции ftw, которая использует lstat
вместо stat, чтобы предотвратить следование по символическим ссылкам.

170    Глава 4. Файлы и каталоги
Обратите внимание, что в Linux функция ftw использует функцию lstat, поэтому вы не
сможете наблюдать подобный эффект.

Разорвать такую замкнутую петлю не составляет труда. Для этого можно вызовом
unlink удалить файл foo/testdir, так как unlink не следует по символическим
ссылкам. Однако если аналогичную петлю создать с помощью жесткой ссылки, разорвать ее будет намного сложнее. По этой причине функция link создает жесткие
ссылки на каталоги только при наличии у процесса привилегий суперпользователя.
При написании оригинального текста к этому разделу Ричард Стивенс ради эксперимента
действительно создал такую петлю у себя. В результате файловая система была повреждена, и не помогла даже утилита fsck(1). Для восстановления файловой системы
пришлось прибегнуть к помощи утилит clri(8) и dcheck(8).
Потребность в  жестких ссылках на каталоги давно прошла. Пользователи больше не
нуждаются в них благодаря функции mkdir и символическим ссылкам.

Когда мы открываем файл и передаем функции open имя символической ссылки,
она следует по ссылке и открывает файл, на который эта ссылка указывает. Если
файл отсутствует, функция open возвращает признак ошибки, сообщая о  невозможности открытия файла. Это может ввести в заблуждение пользователей, которые не знакомы с символическими ссылками, например:
$ ln -s /no/such/file myfile
создать символическую ссылку
$ ls myfile
myfile
команда ls говорит, что файл существует
$ cat myfile
попробуем заглянуть внутрь файла
cat: myfile: No such file or directory
$ ls -l myfile
попробуем с ключом –l
lrwxrwxrwx 1 sar
13 Jan 22 00:26 myfile -> /no/such/file

Файл myfile существует, однако утилита cat утверждает обратное, потому что
myfile — это символическая ссылка, а сам файл, на который она указывает, отсутствует. Запуск команды ls с ключом –l дает нам две подсказки: во-первых, строка
вывода ls начинается с  символа l, который обозначает символическую ссылку
(link), а во-вторых, последовательность -> говорит о том же. У команды ls есть
еще один ключ (–F), который добавляет к  именам символических ссылок символ «@», благодаря чему можно без труда распознать их даже без ключа –l.

4.18. Создание и чтение
символических ссылок
Символические ссылки создаются с помощью функции symlink или symlinkat.
#include <unistd.h>
int symlink(const char *actualpath, const char *sympath);
int symlinkat(const char *actualpath, int fd, const char *sympath);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки

4.19. Временные характеристики файлов   

171

В файле каталога создается новая запись sympath, которая указывает на файл
actualpath. Функция не требует существования файла actualpath на момент создания символической ссылки. (Мы продемонстрировали эту возможность на примере в предыдущем разделе.) Кроме того, не требуется, чтобы файлы actualpath
и sympath находились в одной и той же файловой системе.
Функция symlinkat действует подобно symlink, но когда в  аргументе sympath
передается строка относительного пути, этот путь откладывается относительно
каталога, представленного файловым дескриптором fd. Если в аргументе sympath
передается строка абсолютного пути или если в аргументе fd передается специальное значение AT_FDCWD, функция symlinkat действует точно как функция symlink.
Поскольку функция open следует по символическим ссылкам, нам необходим
инструмент, с помощью которого можно было бы открыть саму символическую
ссылку, чтобы прочитать имя файла, на который она ссылается. Эти действия выполняют функции readlink и readlinkat.
#include <unistd.h>
ssize_t readlink(const char *restrict pathname, char *restrict buf,
size_t bufsize);
ssize_t readlinkat(int fd, const char *restrict pathname,
char *restrict buf, size_t bufsize);

Обе возвращают количество прочитанных байтов в случае успеха,
–1 — в случае ошибки
Эти функции совмещают в себе операции open, read и close. В случае успеха они
возвращают количество прочитанных байтов, размещенных в  buf. Содержимое
символической ссылки, помещаемое в  буфер buf, не завершается нулевым символом.
Функция readlinkat действует подобно readlink, когда в  аргументе pathname
передается строка абсолютного пути или когда аргумент fd установлен в специальное значение AT_FDCWD. Однако когда в аргументе fd указывается действительный файловый дескриптор открытого каталога и в аргументе pathname передается
строка относительного пути, функция readlinkat откладывает путь pathname относительно каталога, представленного дескриптором fd.

4.19. Временные характеристики файлов
В разделе 4.2 говорилось, что в  редакции стандарта Single UNIX Specification
2008  года было увеличено разрешение полей структуры stat, представляющих
время, и теперь они представляют время не как прежде — в секундах, а в секундах и  наносекундах. Фактическое разрешение значений времени, сохраняемых
в атрибутах файла, зависит от реализации файловой системы. В файловых системах, сохраняющих время с  точностью до секунды, поля с  наносекундами будут
получать нулевое значение. В  файловых системах, сохраняющих время с  более

172    Глава 4. Файлы и каталоги
высокой точностью, доли секунд будут преобразовываться в наносекунды и возвращаться в полях с наносекундами.
Каждый файл характеризуется тремя атрибутами времени. Их назначение приводится в табл. 4.10.
Таблица 4.10. Три атрибута времени
Поле

Описание

Пример

Ключи
команды ls(1)

st_atim

Время последнего доступа к содержимому файла

read

-u

st_mtim

Время последнего изменения содержимого файла

write

по умолчанию

st_ctim

Время последнего изменения статуса индексного
узла

chmod, chown

-с

Обратите внимание на различие между временем последнего изменения содержимого файла (st_mtim) и  временем последнего изменения статуса индексного
узла (st_ctim). Время последнего изменения содержимого файла показывает, когда в  последний раз вносились изменения в  файл. Время последнего изменения
статуса индексного узла определяет время последней модификации индексного
узла файла. В  этой главе мы упоминали множество операций, которые изменяют индексный узел, не затрагивая содержимого файла: изменение прав доступа,
идентификатора пользователя (владельца), количества ссылок на файл и др. Поскольку информация индексного узла хранится отдельно от содержимого файла,
то кроме времени последнего изменения содержимого файла существует и такая
характеристика, как время последнего изменения его статуса.
Отметьте также, что система не отслеживает время последнего доступа к индексному узлу. По этой причине функции access и  stat, например, не изменяют ни
одной из трех величин.
Время последнего доступа к файлу часто используется системными администраторами для удаления ненужных файлов, к  которым давно никто не обращался.
Классический пример — удаление файлов с именами a.out и  core, к которым не
обращались более одной недели. Для выполнения подобного рода действий часто
применяется утилита find(1).
Время последнего изменения содержимого файла и время последнего изменения
статуса индексного узла могут использоваться, чтобы отобрать для архивирования только те файлы, содержимое которых претерпело изменения или у которых
был изменен статус индексного узла.
Команда ls может отображать или сортировать только по одному из трех значений.
По умолчанию при запуске с ключом –l или –t она использует время последнего изменения содержимого файла. Ключ –u заставляет ее использовать время последнего
доступа, а ключ –c — время последнего изменения статуса индексного узла.
В табл. 4.11 приводится перечень функций и их воздействие на эти три величины.
В разделе 4.14 мы уже говорили, что каталог — это на самом деле файл, состоящий
из серии записей, каждая из которых содержит имя файла и  номер индексного
узла файла. Добавление, удаление или изменение этих записей приводит к  из-

4.19. Временные характеристики файлов   

173

менению значений времени, связанных с каталогом. По этой причине табл. 4.11
содержит одну колонку для атрибутов времени, связанных с самим файлом или
каталогом, и отдельную колонку для атрибутов времени родительского каталога.
Создание нового файла, например, воздействует на временные характеристики не
только самого файла, но и  каталога, в  котором этот файл размещается. Однако
операции чтения и записи оказывают влияние только на индексный узел файла
и никак не сказываются на содержащем этот файл каталоге.
Таблица 4.11. Влияние различных функций на время последнего доступа к файлу,
последнего изменения содержимого файла и последнего изменения статуса
индексного узла
Функция

Файл
Родительский
или каталог
каталог
a

m

c

a

m

Раздел

chmod, chmod



4.9

chown, fchown



4.11

creat



creat
exec











Примечание

c



3.4

Создание нового файла (O_CREAT)

3.4

Усечение существующего файла
(O_TRUNC)

8.10



lchown



link







4.15

4.11
Родительский каталог для второго аргумента

mkdir











4.21

mkfifo











15.5

open











3.3

Создание нового файла (O_CREAT)





3.3

Усечение существующего файла
(O_TRUNC)





15.2

open
pipe



read



3.7

remove



remove
rename



rmdir
truncate,
ftruncate



unlink
utimes,
utimensat,
futimens
write



4.15

Когда remove = unlink





4.15

Когда remove = rmdir





4.16

Для обоих аргументов





4.21
4.13












4.15





4.20





3.8

174    Глава 4. Файлы и каталоги
(Функции mkdir и rmdir обсуждаются в разделе 4.21. Функции utimes, utimensat,
futimens описаны в следующем разделе. Шесть функций семейства exec рассмат­
риваются в разделе 8.10, а функции mkfifo и pipe — в главе 15.)

4.20. Функции futimens, utimensat и utimes
Существует несколько функций, позволяющих изменять значения времени последнего доступа и последнего изменения файла. Функции futimens и  utimensat
поддерживают значения времени с точностью до наносекунд, принимая структуру timespec (ту же самую, что используется семейством функций stat, как описывается в разделе 4.2).
#include <sys/stat.h>
int futimens(int fd, const struct timespec times[2]);
int utimensat(int fd, const char *path, const struct timespec times[2],
int flag);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
В первом элементе массива times обе функции принимают время последнего доступа к  файлу, а  во втором  — время последнего изменения содержимого файла.
Оба значения интерпретируются как календарное время  — количество секунд,
прошедших с начала Эпохи, как описывается в разделе 1.10. Доли секунд выражаются в наносекундах.
В аргументе times можно передать четыре значения.
1.	 Пустой указатель. В этом случае время последнего доступа к  файлу и  время
последнего изменения файла устанавливаются равными текущему времени.
2.	 Указатель на массив с  двумя структурами timespec. Если в  какой-либо из
структур поле tv_nsec содержит специальное значение UTIME_NOW, в  качестве
соответствующего значения времени файла принимается текущее время, при
этом значение поля tv_sec игнорируется.
3.	 Указатель на массив с  двумя структурами timespec. Если в  какой-либо из
структур поле tv_nsec содержит специальное значение UTIME_OMIT, соответствующее значение времени файла не изменяется, при этом значение поля
tv_sec игнорируется.
4.	 Указатель на массив с двумя структурами timespec. Если в какой-либо из структур поле tv_nsec содержит значение, отличное от UTIME_NOW и  UTIME_OMIT, соответствующее значение времени файла определяется полями tv_sec и  tv_nsec.
Привилегии, необходимые для вызова функций, зависят от значения аргумента
times.
 Если в аргументе times передается пустой указатель или поле tv_nsec какойлибо из структур установлено в значение UTIME_NOW, процесс должен обладать

4.20. Функции futimens, utimensat и utimes   

175

правом записи в файл, или иметь эффективный идентификатор пользователя,
совпадающий с идентификатором владельца файла, или обладать привилегиями суперпользователя.
 Если в аргументе times передается непустой указатель и поле tv_nsec в обеих
структурах имеет значение, отличное от UTIME_NOW и  UTIME_OMIT, процесс должен иметь эффективный идентификатор пользователя, совпадающий с идентификатором владельца файла, или обладать привилегиями суперпользователя. Простого права на запись будет недостаточно.
 Если в  аргументе times передается непустой указатель и  поле tv_nsec в  обеих
структурах имеет значение UTIME_OMIT, проверка прав доступа не производится.
Изменить значения времени с  помощью futimens можно только для открытого
файла. Функция utimensat позволяет изменить время последнего доступа и время последнего изменения файла по его имени. Значение аргумента pathname интерпретируется как строка относительного пути от каталога, представленного аргументом fd, в котором можно передать файловый дескриптор открытого каталога
или специальное значение AT_FDCWD, соответствующее текущему каталогу вызывающего процесса. Если в аргументе pathname указана строка абсолютного пути,
аргумент fd игнорируется.
Аргумент flag функции utimensat можно использовать для изменения поведения
по умолчанию этой функции. Если в этом аргументе передать флаг AT_SYMLINK_
NOFOLLOW, будет изменяться время самой символической ссылки (если аргумент
pathname ссылается на символическую ссылку). По умолчанию функция следует
по символическим ссылкам и изменяет значения времени целевого файла, на который указывает ссылка.
Обе функции, futimens и utimensat, включены в стандарт POSIX.1. Третья функция, utimes, включена в стандарт Single UNIX Specification как часть расширений
XSI.
#include <sys/time.h>
int utimes(const char *pathname, const struct timeval times[2]);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Функция utimes изменяет значения времени в  файле с  именем pathname. Аргумент times — указатель на массив двух значений времени — последнего доступа
и  последнего изменения содержимого, но выраженных в  секундах и  микросе­
кундах:
struct timeval {
time_t tv_sec; /* секунды */
long
tv_usec; /* микросекунды */
};

Обратите внимание: невозможно задать время последнего изменения статуса индексного узла (st_ctim), так как оно автоматически изменяется в результате вызова функции utimes.

176    Глава 4. Файлы и каталоги
В некоторых версиях UNIX команда touch(1) использует эту функцию. Кроме
того, стандартные архиваторы tar(1) и  cpio(1) могут вызывать эти функции для
установки сохраненных при архивации временных характеристик распакованных
файлов.

Пример
Программа в листинге 4.6 усекает размер файла до нуля, используя функцию open
с флагом O_TRUNC, но не изменяет при этом ни время последнего доступа к файлу,
ни время последнего изменения файла. Чтобы добиться такого эффекта, программа сначала получает значения временных характеристик файла с помощью функции stat, затем усекает размер файла до нуля и в заключение переустанавливает
значения времени с помощью функции futimens.
Листинг 4.6. Пример использования функции futimens
#include "apue.h"
#include <fcntl.h>
int
main(int argc, char
{
int
struct stat
struct timespec

}

*argv[])
i, fd;
statbuf;
times[2];

for (i = 1; i < argc; i++) {
if (stat(argv[i], &statbuf) < 0) { /* получить значения времени */
err_ret("%s: ошибка вызова функции stat", argv[i]);
continue;
}
if ((fd = open(argv[i], O_RDWR | O_TRUNC)) < 0) { /* усечение */
err_ret("%s: ошибка вызова функции open", argv[i]);
continue;
}
times[0] = statbuf.st_atim;
times[1] = statbuf.st_mtim;
if (futimens(fd, times) < 0) { /* установить значения времени */
err_ret("%s: ошибка вызова функции futimens", argv[i]);
close(fd);
}
exit(0);

Продемонстрируем работу программы из листинга 4.6 на примере.
$ ls -l changemod times
определим размер и время последнего изменения файлов
-rwxr-xr-x 1 sar
13792 Jan 22 01:26 changemod
-rwxr-xr-x 1 sar
13824 Jan 22 01:26 times
$ ls -lu changemod times
определим время последнего доступа
-rwxr-xr-x 1 sar
13792 Jan 22 22:22 changemod
-rwxr-xr-x 1 sar
13824 Jan 22 22:22 times
$ date
выведем текущее время и дату
Fri Jan 27 20:53:46 EST 2012
$ ./a.out changemod times запустим программу из листинга 4.6
$ ls -l changemod times
и проверим результаты
-rwxr-xr-x 1 sar
0 Jan 22 01:26 changemod

4.21. Функции mkdir, mkdirat и rmdir   

177

-rwxr-xr-x 1 sar
0 Jan 22 01:26 times
$ ls -lu changemod times
проверим также время последнего доступа
-rwxr-xr-x 1 sar
0 Jan 22 22:22 changemod
-rwxr-xr-x 1 sar
0 Jan 22 22:22 times
$ ls -lc changemod times
и время последнего изменения статуса индексного узла
-rwxr-xr-x 1 sar
0 Jan 27 20:53 changemod
-rwxr-xr-x 1 sar
0 Jan 27 20:53 times

Как и ожидалось, время последнего доступа к файлу и время последнего изменения его содержимого не изменились. Однако время последнего изменения статуса
индексного узла было установлено равным времени запуска программы.

4.21. Функции mkdir, mkdirat и rmdir
Создание каталогов производится с помощью функций mkdir и  mkdirat, а удаление — с помощью функции rmdir.
#include <sys/stat.h>
int mkdir(const char *pathname, mode_t mode);
int mkdirat(int fd, const char *pathname, mode_t mode);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Эти функции создают новый пустой каталог. Записи «точка» и «точка-точка» создаются автоматически. Права доступа к  каталогу, задаваемые аргументом mode,
модифицируются маской режима создания файлов процесса.
Часто встречается ошибка, когда аргумент mode назначается по аналогии с файлами: выдаются только права на запись и на чтение. Но для каталогов, как правило,
необходимо устанавливать хотя бы один бит, дающий право на выполнение, чтобы разрешить доступ к файлам, находящимся в каталоге, по их именам (упражнение 4.16).
Идентификаторы пользователя и группы устанавливаются в соответствии с правилами, приведенными в разделе 4.6.
В системах Solaris 10 и Linux 3.2.0 новый каталог наследует бит set-group-ID от родительского каталога. Файлы, созданные в новом каталоге, наследуют от каталога идентификатор группы. В Linux это поведение определяется реализацией файловой системы.
Например, файловые системы ext2, ext3 и ext4 предоставляют такую возможность при
использовании определенных ключей команды mount(1). Однако реализация файловой системы UFS для Linux не предполагает возможности выбора: бит set-group-ID наследуется
всегда, чтобы имитировать исторически сложившуюся реализацию BSD, где идентификатор группы каталога наследуется от родительского каталога.
Реализации, основанные на BSD, не передают бит set-group-ID по наследству — в них просто наследуется идентификатор группы. Поскольку операционные системы FreeBSD 8.0
и Mac OS X 10.6.8 основаны на 4.4BSD, они не требуют наследования бита set-group-ID.
На этих платформах вновь создаваемые файлы и каталоги всегда наследуют идентификатор группы родительского каталога независимо от состояния бита set-group-ID.

178    Глава 4. Файлы и каталоги
В ранних версиях UNIX не было функции mkdir. Она впервые появилась в 4.2BSD и SVR3.
Чтобы создать новый каталог в этих версиях, процесс должен был вызывать функцию
mknod. Однако использовать эту функцию мог только процесс, обладающий привилегиями
суперпользователя. Чтобы как-то обойти это ограничение, обычная команда создания
каталога mkdir(1) должна была иметь установленный бит set-user-ID и принадлежать
пользователю root. Чтобы создать каталог из процесса, необходимо было вызывать
­команду mkdir(1) с помощью функции system(3).

Функция mkdirat действует подобно функции mkdir. Если в  аргументе fd передается специальное значение AT_FDCWD или в аргументе pathname указана строка
абсолютного пути, mkdirat действует точно как mkdir. Иначе аргумент fd интерпретируется как файловый дескриптор открытого каталога, относительно которого откладывается путь pathname.
Удаление пустого каталога производится с помощью функции rmdir. Напоминаем, что пустым называется каталог, который содержит только две записи: «точка»
и «точка-точка».
#include <unistd.h>
int rmdir(const char *pathname);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Если в  результате вызова этой функции счетчик ссылок на каталог становится
равным нулю и при этом никакой процесс не удерживает каталог открытым, пространство, занимаемое каталогом, освобождается. Если один или более процессов
держат каталог открытым в момент, когда счетчик ссылок достигает значения 0,
функция удаляет последнюю ссылку и перед возвратом управления удаляет записи «точка» и «точка-точка». Кроме того, в таком каталоге не могут быть созданы
новые файлы. Однако файл каталога не удаляется, пока последний процесс не закроет его. (Даже если другой процесс держит каталог открытым, вряд ли он там
может делать что-то особенное, так как для успешного завершения функции rmdir
каталог должен был быть пуст.)

4.22. Чтение каталогов
Прочитать информацию из файла каталога может любой, кто имеет право на чтение этого каталога. Но только ядро может выполнять запись в каталоги, благодаря
чему обеспечивается сохранность файловой системы. В разделе 4.5 мы утверждали, что возможность создания и удаления файлов в каталоге определяется битами
прав на запись и на выполнение, но это не относится к непосредственной записи
в файл каталога.
Фактический формат файлов каталогов зависит от реализации UNIX и архитектуры файловой системы. В ранних версиях UNIX, таких как Version 7, структура каталогов была очень простой — каждая запись имела фиксированную длину
16 байт: 14 байт отводилось для имени файла и 2 байта — для номера индексно-

4.22. Чтение каталогов   

179

го узла. Когда в 4.2BSD была добавлена поддержка более длинных имен файлов,
записи стали иметь переменную длину. Это означало, что любая программа, выполняющая прямое чтение данных из файла каталога, попадала в зависимость от
конкретной реализации. Чтобы упростить положение дел, был разработан набор
функций для работы с каталогами, который стал частью стандарта POSIX.1. Многие реализации не допускают чтения содержимого файлов каталогов с помощью
функции read, тем самым препятствуя зависимости приложений от особенностей,
присущих конкретной реализации.
#include <dirent.h>
DIR *opendir(const char *pathname);
DIR *fdopendir(int fd);

Возвращает указатель в случае успеха или
NULL — в случае ошибки
struct dirent *readdir(DIR *dp);

Возвращает указатель в случае успеха,
NULL — по достижении конца каталога или в случае ошибки
void rewinddir(DIR *dp);
int closedir(DIR *dp);

Возвращает 0 в случае успеха или –1 — в случае ошибки
long telldir(DIR *dp);

Возвращает значение текущей позиции в каталоге, ассоциированном с dp
void seekdir(DIR *dp, long loc);

Функция fdopendir впервые появилась в  версии 4 стандарта Single UNIX
Specification. Она преобразует дескриптор открытого файла в структуру DIR для
использования в других функциях обслуживания каталогов.
Функции telldir и  seekdir не являются частью стандарта POSIX.1. Это расширения XSI стандарта Single UNIX Specification, поэтому предполагается, что они
должны быть реализованы во всех версиях UNIX, следующих этой спецификации.
Как вы помните, некоторые из этих функций использовались в  программе из
листинга 1.1, которая воспроизводила ограниченную функциональность команды ls.
Структура dirent определена в файле <dirent.h> и зависит от конкретной реализации. Однако в любой версии UNIX эта структура содержит как минимум следующие два поля:
ino_t d_ino;
/* номер индексного узла */
char d_name[]; /* строка с именем файла, завершающаяся нулевым символом */

180    Глава 4. Файлы и каталоги
Поле d_ino не определено в  стандарте POSIX.1, поскольку эта характеристика зависит  от конкретной реализации, но оно определяется в  расширении XSI базового
стандарта POSIX.1. Сам же стандарт POSIX.1 определяет в этой структуре только
поле d_name.

Обратите внимание, что размер поля d_name не определен, но гарантируется, что
он будет не меньше NAME_MAX, исключая нулевой символ (вспомните табл. 2.12).
Так как строка имени файла заканчивается нулевым символом, не имеет значения, как определен массив d_name в заголовочном файле, поскольку размер массива не соответствует длине имени файла.
DIR — это внутренняя структура, которая используется этими семью функциями
для хранения информации о каталоге. Она похожа на структуру FILE, используемую функциями из стандартной библиотеки ввода/вывода, о которых рассказывается в главе 5.
Указатель на структуру DIR, возвращаемый функциями opendir и  fdopendir, используется в качестве аргумента остальных пяти функций. Функция opendir выполняет первичную инициализацию так, чтобы последующий вызов readdir прочитал первую запись из файла каталога. Когда структура DIR создается функцией
fdopendir, выбор первой записи, возвращаемой функцией readdir, зависит от смещения в файле, связанном с дескриптором, переданным функции fdopendir. Порядок следования записей в каталоге, как правило, зависит от реализации и обычно не совпадает с алфавитным.

Пример
Воспользуемся этими функциями и напишем программу, выполняющую обход
дерева каталогов. Цель программы  — подсчитать количество файлов каждого
типа из перечисленных в табл. 4.3. Программа в листинге 4.7 принимает единственный параметр  — имя начального каталога  — и  рекурсивно спускается от
этой точки вниз по дереву каталогов. В Solaris имеется функция ftw(3), которая
обходит дерево каталогов, вызывая пользовательскую функцию для каждого
встреченного файла. Но с  ней связана одна проблема: она вызывает функцию
stat для каждого файла, в результате чего программа следует по символическим
ссылкам. Например, если мы начнем просмотр каталогов от корня файловой системы, в  котором имеется символическая ссылка с  именем /lib, указывающая
на каталог /usr/lib, все файлы в  каталоге /usr/lib будут посчитаны дважды.
Чтобы устранить эту проблему, Solaris предоставляет дополнительную функцию nftw(3), позволяющую отключить следование по символическим ссылкам.
Мы  могли бы использовать функцию nftw, но давайте напишем собственную
версию функции обхода дерева каталогов, чтобы показать принципы работы
с каталогами.
В SUSv4 функция nftw включена в стандарт как часть расширения XSI. Реализации этой
функции имеются в  операционных системах FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8
и Solaris 10. Системы, основанные на BSD, предоставляют функцию fts(3) с аналогичной
функциональностью. Она реализована в операционных системах FreeBSD 8.0, Linux 3.2.0
и Mac OS X 10.6.8.

4.22. Чтение каталогов   

181

Листинг 4.7. Рекурсивный обход дерева каталогов с подсчетом количества файлов
по типам
#include "apue.h"
#include <dirent.h>
#include <limits.h>
/* тип функции, которая будет вызываться для каждого встреченного файла */
typedef int Myfunc(const char *, const struct stat *, int);
static Myfunc
static int
static int

myfunc;
myftw(char *, Myfunc *);
dopath(Myfunc *);

static long nreg, ndir, nblk, nchr, nfifo, nslink, nsock, ntot;
int
main(int argc, char *argv[])
{
int ret;
if (argc != 2)
err_quit("Использование: ftw <начальный_каталог>");
ret = myftw(argv[1], myfunc); /* выполняет всю работу */

}

ntot = nreg + ndir + nblk + nchr + nfifo + nslink + nsock;
if (ntot == 0)
ntot = 1;/* во избежание деления на 0 вывести 0 для всех счетчиков */
printf("обычные файлы = %7ld, %5.2f %%\n", nreg,
nreg*100.0/ntot);
printf("каталоги = %7ld, %5.2f %%\n", ndir,
ndir*100.0/ntot);
printf("специальные файлы блочных устройств = %7ld, %5.2f %%\n", nblk,
nblk*100.0/ntot);
printf("специальные файлы символьных устройств = %7ld, %5.2f %%\n", nchr,
nchr*100.0/ntot);
printf("FIFO = %7ld, %5.2f %%\n", nfifo,
nfifo*100.0/ntot);
printf("символические ссылки = %7ld, %5.2f %%\n", nslink,
nslink*100.0/ntot);
printf("сокеты = %7ld, %5.2f %%\n", nsock,
nsock*100.0/ntot);
exit(ret);

/*
* Выполняет обход дерева каталогов, начиная с каталога "pathname".
* Для каждого встреченного файла вызывает пользовательскую функцию func().
*/
#define
#define
#define
#define

FTW_F 1
FTW_D 2
FTW_DNR 3
FTW_NS 4

/*
/*
/*
/*
/*

файл, не являющийся каталогом */
каталог */
каталог, который недоступен для чтения */
файл, информацию о котором */
невозможно получить с помощью stat */

static char *fullpath; /* полный путь к каждому из файлов */
static size_t pathlen;

182    Глава 4. Файлы и каталоги
static int /* возвращает то, что вернула функция func() */
myftw(char *pathname, Myfunc *func)
{
fullpath = path_alloc(&len); /* выделить память для PATH_MAX+1 байт */
/* (листинг 2.3) */
if (pathlen <= strlen(pathname)) {
pathlen = strlen(pathname) * 2;
if ((fullpath = realloc(fullpath, pathlen)) == NULL)
err_sys("ошибка вызова realloc");
}
strcpy(fullpath, pathname);
return(dopath(func));
}
/*
* Выполняет обход дерева каталогов, начиная с "fullpath".
* Если "fullpath" не является каталогом, для него вызывается lstat(),
* func() и затем выполняется возврат.
* Для каталогов производится рекурсивный вызов функции.
*/
static int /* возвращает то, что вернула функция func() */
dopath(Myfunc* func)
{
struct stat
statbuf;
struct dirent *dirp;
DIR
*dp;
int
ret, n;
if (lstat(fullpath, &statbuf) < 0) /* ошибка вызова функции stat */
return(func(fullpath, &statbuf, FTW_NS));
if (S_ISDIR(statbuf.st_mode) == 0) /* не каталог */
return(func(fullpath, &statbuf, FTW_F));
/*
* Это каталог. Сначала вызвать функцию func(),
* а затем обработать все файлы в этом каталоге.
*/
if ((ret = func(fullpath, &statbuf, FTW_D)) != 0)
return(ret);
n = strlen(fullpath);
if (n + NAME_MAX + 2 > pathlen) { /* увеличить размер буфера */
pathlen *= 2;
if ((fullpath = realloc(fullpath, pathlen)) == NULL)
err_sys("ошибка вызова realloc");
}
fullpath[n++] = '/';
fullpath[n] = 0
if ((dp = opendir(fullpath)) == NULL) /* каталог недоступен */
return(func(fullpath, &statbuf, FTW_DNR));
while ((dirp = readdir(dp)) != NULL) {
if (strcmp(dirp->d_name, ".") == 0 ||
strcmp(dirp->d_name, "..") == 0)
continue; /* пропустить каталоги "." и ".." */
strcpy(&fullpath[n], dirp->d_name); /* добавить имя после слеша */
if ((ret = dopath(func)) != 0)
/* рекурсия */
break; /* выход по ошибке */
}

4.23. Функции chdir, fchdir и getcwd   

183

fullpath[n-1] = 0; /* стереть часть строки от слеша и до конца */

}

if (closedir(dp) < 0)
err_ret("невозможно закрыть каталог %s", fullpath);
return(ret);

static int
myfunc(const char *pathname, const struct stat *statptr, int type)
{
switch (type) {
case FTW_F:
switch (statptr->st_mode & S_IFMT) {
case S_IFREG:
nreg++;
break;
case S_IFBLK:
nblk++;
break;
case S_IFCHR:
nchr++;
break;
case S_IFIFO:
nfifo++;
break;
case S_IFLNK:
nslink++;
break;
case S_IFSOCK:
nsock++;
break;
case S_IFDIR: /* каталоги должны иметь type = FTW_D*/
err_dump("признак S_IFDIR для %s", pathname);
}
break;
case FTW_D:
ndir++;
break;
case FTW_DNR:
err_ret("закрыт доступ к каталогу %s", pathname);
break;
case FTW_NS:
err_ret("ошибка вызова функции stat для %s", pathname);
break;
default:
err_dump("неизвестный тип %d для файла %s", type, pathname);
}
return(0);
}

Эта программа получилась даже более универсальной, чем необходимо для демонстрации возможностей функций ftw и nftw. Например, функция myfunc всегда
возвращает 0, хотя функция, которая ее вызывает, готова обработать и ненулевое
значение.
За дополнительной информацией о  технике обхода дерева каталогов и  использовании ее в  стандартных командах UNIX  — find, ls, tar и  др.  — обращайтесь
к [Fowler, Korn and Vo, 1989].

4.23. Функции chdir, fchdir и getcwd
Для каждого процесса определен текущий рабочий каталог. Относительно этого
каталога вычисляются все относительные пути (то есть пути, которые не начинаются с  символа слеша). Когда пользователь входит в  систему, текущим рабочим каталогом обычно становится каталог в шестом поле записи из файла /etc/
passwd — домашний каталог пользователя. Текущий рабочий каталог — это атрибут процесса, домашний каталог — атрибут пользователя.

184    Глава 4. Файлы и каталоги
Процесс может изменить текущий рабочий каталог вызовом функции chdir или
fchdir.
#include <unistd.h>
int chdir(const char *pathname);
int fchdir(int fd);

Возвращают 0 в случае успеха, –1 — в случае ошибки
Новый рабочий каталог можно задать строкой pathname или файловым дескриптором.

Пример
Поскольку текущий рабочий каталог является атрибутом процесса, вызов функции chdir в дочернем процессе никак не влияет на текущий рабочий каталог родительского процесса. (Отношения между процессами подробно рассматриваются
в главе 8.) Это значит, что программа в листинге 4.8 работает не так, как мы ожидаем.
Листинг 4.8. Пример использования функции chdir
#include "apue.h"
int
main(void)
{
if (chdir("/tmp") < 0)
err_sys("ошибка вызова функции chdir");
printf("каталог /tmp стал текущим рабочим каталогом\n");
exit(0);
}

После компиляции и запуска этой программы мы получим следующие результаты
(mycd — выполняемый файл программы):
$ pwd
/usr/lib
$ mycd
каталог /tmp стал текущим рабочим каталогом
$ pwd
/usr/lib

Текущий рабочий каталог командной оболочки, запустившей программу mycd, не
изменился. Это побочный эффект способа, каким командная оболочка запускает
программы. Каждая программа выполняется как отдельный процесс, благодаря
чему текущий рабочий каталог самой командной оболочки нельзя изменить вызовом функции chdir из программы. По этой причине функция chdir должна вызываться самой командной оболочкой, для чего командные оболочки предоставляют
встроенную команду cd.
Поскольку ядро хранит сведения о текущем рабочем каталоге, должен быть способ получить его текущее значение. К  сожалению, ядро хранит не полный путь

4.23. Функции chdir, fchdir и getcwd   

185

к каталогу, а некоторую иную информацию, такую как указатель на виртуальный
узел (v-node) каталога.
Ядро Linux может определить полный путь к каталогу. Компоненты этого пути разбросаны по таблицам смонтированных файловых систем и кэша каталогов и повторно
собираются воедино, например, когда выполняется попытка прочитать символическую
ссылку /proc/self/cwd.

Чтобы определить абсолютный путь к текущему рабочему каталогу, нужна функция, перемещающаяся вверх по дереву каталогов, начиная с текущего («точка»)
и далее через специальные каталоги «точка-точка», пока не достигнет корневого
каталога. В каждом из промежуточных каталогов функция должна читать записи
из файла каталога, пока не найдет название, соответствующее индексному узлу
предыдущего каталога. Повторяя эту процедуру до достижения корневого каталога, мы в результате получим абсолютный путь к текущему рабочему каталогу.
К счастью, такая функция уже существует.
#include <unistd.h>
char *getcwd(char *buf, size_t size);

Возвращает указатель на buf в случае успеха, NULL — в случае ошибки
Эта функция требует передать ей адрес буфера buf и его размер в байтах. Буфер
должен быть достаточно большим, чтобы вместить строку абсолютного пути к каталогу плюс завершающий нулевой символ. (Проблему выделения памяти для
строки абсолютного пути к файлу мы уже обсуждали в разделе 2.5.5.)
Некоторые старые версии UNIX допускают в качестве указателя на буфер передавать
значение NULL. В этом случае функция сама выделяет для буфера память размером size
байтов с помощью функции malloc. Такое поведение не предусматривается стандартами
POSIX.1 или Single UNIX Specification, и его не следует использовать в программах.

Пример
Программа в  листинге 4.9 переходит в  указанный каталог, после чего вызывает
getcwd и выводит строку пути к текущему рабочему каталогу. Запустив программу, мы получили следующее:
$ ./a.out
cwd = /var/spool/uucppublic
$ ls -l /usr/spool
lrwxrwxrwx 1 root 12 Jan 31 07:57 /usr/spool -> ../var/spool

Листинг 4.9. Пример использования функции getcwd
#include "apue.h"
int
main(void)
{
char
size_t

*ptr;
size;

186    Глава 4. Файлы и каталоги
if (chdir("/usr/spool/uucppublic") < 0)
err_sys("ошибка вызова функции chdir");
ptr = path_alloc(&size); /* наша собственная функция */
if (getcwd(ptr, size) == NULL)
err_sys("ошибка вызова getcwd");

}

printf("cwd = %s\n", ptr);
exit(0);

Обратите внимание, что функция chdir следует по символическим ссылкам, как
это и должно быть в соответствии с табл. 4.9, но когда происходит подъем вверх
по дереву каталогов, getcwd понятия не имеет, что попала в  каталог /var/spool
по символической ссылке /usr/spool. Это одна из особенностей символических
ссылок.
Функция getcwd очень удобна для приложений, в которых возникает необходимость возврата к  первоначальному текущему каталогу. Для этого перед сменой
текущего рабочего каталога нужно вызвать getcwd и  сохранить полученное значение. По окончании работы можно передать сохраненную строку функции chdir
и вернуться в первоначальный рабочий каталог.
Функция fchdir позволяет решить задачу еще проще. Вместо вызова getcwd можно открыть текущий каталог, сохранить файловый дескриптор и  затем сменить
текущий каталог. Когда возникнет необходимость вернуться к первоначальному
местоположению, остается просто передать дескриптор функции fchdir.

4.24. Специальные файлы устройств
Очень часто возникает путаница с полями st_dev и st_rdev. Нам они потребуются
в разделе 18.9 при написании функции ttyname. Правила их использования просты.
 Каждая файловая система характеризуется старшим и  младшим номерами
устройства, представленными элементарным системным типом dev_t. Старший номер устройства идентифицирует драйвер устройства и  иногда указывает, с  какой платой периферийного устройства следует взаимодействовать.
Младший номер идентифицирует конкретное подустройство. Как показано на
рис. 4.1, на одном и том же дисковом устройстве может размещаться несколько
файловых систем. Все файловые системы на одном и том же дисковом устройстве, как правило, имеют одинаковые старшие номера, но различные младшие
номера устройства.
 Обычно старший и младший номера устройства можно получить с помощью
макросов, определенных в большинстве реализаций: major и minor. То есть нам
не нужно задумываться, как хранятся два номера в  одной переменной типа
dev_t.
В ранних версиях UNIX старший и младший номера устройств хранились в виде 16-разрядного целого числа, в котором 8 разрядов отводилось для старшего и 8 разрядов — для
младшего номера устройства. FreeBSD 8.0 и Mac OS X 10.6.8 используют для этих целей

4.24. Специальные файлы устройств   

187

32-разрядные целые числа, где для хранения старшего номера устройства отводится 8 разрядов, а для младшего — 24 разряда. На 32-разрядных платформах Solaris 10 использует
32-разрядные целые числа, в которых для старшего номера отводится 14 разрядов, а для
младшего — 18 разрядов. На 64-разрядных платформах Solaris 10 используются 64-разрядные целые числа, в которых каждому номеру отводится по 32 разряда. В Linux 3.2.0,
несмотря на то что тип dev_t определен как 64-разрядное целое, для старшего номера
отводится только 12 разрядов, а для младшего — 20 разрядов.
Стандарт POSIX.1 оговаривает существование типа dev_t, но не определяет формат
хранения и  способ интерпретации его содержимого. В  большинстве систем для этих
целей существуют макросы major и  minor, но имя заголовочного файла, в  котором они
определены, зависит от конкретной системы. В BSD-системах их определения находятся
в файле <sys/types.h>; в Solaris — в файле <sys/mkdev.h>, потому что макросы в файле
<sys/sysmacros.h> в Solaris считаются устаревшими; в Linux — в файле <sys/sysmacros.h>,
который подключается в файле <sys/types.h>.

 В поле st_dev для каждого файла хранится номер устройства файловой системы, где располагается файл и соответствующий ему индексный узел.
 Поле st_rdev имеет определенное значение только для специальных файлов
символьных или блочных устройств. В этом поле хранится номер фактического устройства.

Пример
Программа в  листинге 4.10 выводит номера устройств для каждого аргумента
командной строки. Кроме того, если аргумент представляет специальный файл
блочного или символьного устройства, дополнительно выводится содержимое
поля st_rdev.
Листинг 4.10. Вывод содержимого полей st_dev и st_rdev
#include "apue.h"
#ifdef SOLARIS
#include <sys/mkdev.h>
#endif
int
main(int argc, char *argv[])
{
int
i;
struct stat buf;
for (i = 1; i < argc; i++) {
printf("%s: ", argv[i]);
if (stat(argv[i], &buf) < 0) {
err_ret("ошибка вызова функции stat");
continue;
}
printf("dev = %d/%d", major(buf.st_dev), minor(buf.st_dev));
if (S_ISCHR(buf.st_mode) || S_ISBLK(buf.st_mode)) {
printf(" (%s) rdev = %d/%d",
(S_ISCHR(buf.st_mode)) ? "симв. устр." : "блочное устр.",
major(buf.st_rdev), minor(buf.st_rdev));

188    Глава 4. Файлы и каталоги

}
}

}
printf("\n");

exit(0);

Запуск этой программы дает следующие результаты:
$ ./a.out / /home/sar /dev/tty[01]
/: dev = 8/3
/home/sar: dev = 8/4
/dev/tty0: dev = 0/5 (симв. устр.) rdev = 4/0
/dev/tty1: dev = 0/5 (симв. устр.) rdev = 4/1
$ mount
какие устройства в какие каталоги смонтированы?
/dev/sda3 on / type ext3 (rw,errors=remount-ro,commit=0)
/dev/sda4 on /home type ext3 (rw,commit=0)
$ ls -l /dev/tty[01] /dev/sda[34]
brw-rw---- 1 root
8, 3 2011-07-01 11:08 /dev/sda3
brw-rw---- 1 root
8, 4 2011-07-01 11:08 /dev/sda4
crw--w---- 1 root
4, 0 2011-07-01 11:08 /dev/tty0
crw------- 1 root
4, 1 2011-07-01 11:08 /dev/tty1

Первые два аргумента программы — это каталоги (/ и  /home/sar), другие два —
специальные файлы устройств /dev/tty[01]. (Мы воспользовались поддержкой
регулярных выражений в  языке командной оболочки, чтобы сократить объем
вводимого с  клавиатуры текста. Командная оболочка преобразует строку /dev/
tty[01] в /dev/tty0 /dev/tty1.)
Мы предполагаем, что специальные файлы представляют символьные устройства. Наша программа показала, что номера устройств для каталогов / и  /home/
sar различны, следовательно, они находятся в  разных файловых системах. Это
подтверждается командой mount(1).
Затем мы воспользовались командой ls, чтобы отыскать дисковые устройства,
о  которых сообщила команда mount, и  терминальные устройства. Два дисковых
устройства представлены специальными файлами блочных устройств, терминальные устройства — специальными файлами символьных устройств. (Обычно файлы
блочных устройств представляют устройства, которые могут содержать файловые
системы с произвольным доступом к данным, — жесткие диски, накопители на гибких магнитных дисках, CD-ROM. Некоторые старые версии UNIX поддерживали
накопители на магнитных лентах, но они не получили широкого распространения.)
Обратите внимание, что имена файлов и  индексные узлы терминальных
устройств (st_dev) находятся на устройстве 0/5, в  псевдофайловой системе
devtmpfs, которая реализована в виде каталога /dev, но их фактические номера
устройств: 4/0 и 4/1.

4.25. Коротко о битах прав доступа к файлам
Мы рассмотрели все биты прав доступа к  файлам, некоторые из которых могут
иметь множество интерпретаций. В табл. 4.12 приводится полный перечень битов
прав доступа и их интерпретация для обычных файлов и для каталогов.

4.25. Коротко о битах прав доступа к файлам   

189

Таблица 4.12. Перечень битов прав доступа к файлам
Константа

Описание

Назначение для обычных файлов

Назначение для каталогов

S_ISUID

set-user-ID

Устанавливает эффективный
идентификатор пользователя
при выполнении

Не используется

S_ISGID

set-group-ID

Если установлен бит groupexecute, устанавливает эффективный идентификатор группы
при выполнении, иначе включает
режим обязательной блокировки
файла или отдельных записей
(если поддерживается)

Устанавливает идентификатор группы для файлов,
создаваемых в этом каталоге, в соответствии с идентификатором группы самого
каталога

S_ISVTX

бит sticky

Управляет кэшированием содержимого файлов (если поддерживается)

Ограничивает возможность
удаления и переименования
файлов в каталоге

S_IRUSR

user-read

Разрешает пользователю читать
файл

Разрешает пользователю читать записи в файле каталога

S_IWUSR

user-write

Разрешает пользователю писать
в файл

Разрешает пользователю
удалять и создавать файлы
в каталоге

S_IXUSR

user-execute

Разрешает пользователю выполнять файл

Разрешает пользователю
производить поиск по
каталогу

S_IRGRP

group-read

Разрешает группе читать файл

Разрешает группе читать
записи в файле каталога

S_IWGRP

group-write

Разрешает группе писать в файл

Разрешает группе удалять
и создавать файлы в каталоге

S_IXGRP

group-execute

Разрешает группе выполнять
файл

Разрешает группе производить поиск по каталогу

S_IROTH

other-read

Разрешает всем остальным читать файл

Разрешает всем остальным
читать записи в файле
каталога

S_IWOTH

other-write

Разрешает всем остальным писать в файл

Разрешает всем остальным
удалять и создавать файлы
в каталоге

S_IXOTH

other-execute

Разрешает всем остальным выполнять файл

Разрешает всем остальным производить поиск по
каталогу

И наконец, девять констант, которые могут быть сгруппированы по три:
S_IRWXU = S_IRUSR | S_IWUSR | S_IXUSR
S_IRWXG = S_IRGRP | S_IWGRP | S_IXGRP
S_IRWXO = S_IROTH | S_IWOTH | S_IXOTH

190    Глава 4. Файлы и каталоги

4.26. Подведение итогов
Основным предметом обсуждения в этой главе была функция stat. Мы детально
рассмотрели каждое поле структуры stat. Это, в свою очередь, заставило нас исследовать все существующие в UNIX атрибуты файлов. Мы увидели, как файлы
и каталоги располагаются в файловой системе и как осуществлять обход файлов
и каталогов. Уверенное знание всех свойств файла и всех функций, которые работают с файлами, составляет основу программирования в системе UNIX.

Упражнения
4.1	

Измените программу в листинге 4.1, чтобы вместо функции lstat она вызывала stat. Что изменится, если в аргументе командной строки передать
программе символическую ссылку?

4.2	

Что произойдет, если маску режима создания задать равной 777 (в восьмеричном представлении)? Проверьте результаты с помощью команды umask.

4.3	

Убедитесь, что при сброшенном бите user-read вы не сможете прочитать
свои собственные файлы.

4.4	

Запустите программу в листинге 4.3 после создания файлов foo и  bar. Что
произойдет в этом случае?

4.5	

В разделе 4.12 мы говорили, что нулевой размер для обычных файлов вполне допустим. Мы также говорили, что поле st_size имеет определенный
смысл для каталогов и символических ссылок. Могут ли существовать каталоги или символические ссылки с нулевым размером?

4.6	

Напишите утилиту, аналогичную cp(1), которая копировала бы файлы
с дырками, не записывая байты со значением 0 в выходной файл.

4.7	

Взгляните на вывод команды ls в  разделе 4.12, который показывает, что
файлы core и  core.copy имеют различные права доступа. Объясните, как
могли появиться такие различия, если исходить из предположения, что
в промежутке времени между созданием этих файлов значение umask не изменялось.

4.8	

При запуске программы из листинга 4.5 мы проверяли доступный объем
дискового пространства с  помощью команды df(1). Почему нельзя было
воспользоваться командой du(1)?

4.9	

Таблица 4.11 утверждает, что функция unlink воздействует на время последнего изменения статуса индексного узла. Как это может быть?

4.10	 Как влияет системный предел числа одновременно открытых файлов на
функцию myftw из раздела 4.22?
4.11	 Наша версия функции ftw никогда не покидает текущий каталог. Измените эту функцию так, чтобы каждый раз, встречая каталог, она вызывала
функцию chdir для перехода в этот каталог и передавала функции lstat не
полный путь к файлу, а только его имя. После обработки всех файлов в ка-

Упражнения   

191

талоге произведите вызов chdir(".."). Сравните время работы этих двух
версий.
4.12	 Для каждого процесса определен также корневой каталог, который используется в качестве отправной точки при разрешении абсолютных путей
к файлам. Корневой каталог процесса можно изменить вызовом функции
chroot. Найдите описание этой функции в своем справочном руководстве.
В каких случаях можно использовать эту функцию?
4.13	 Как с помощью функции utimes можно изменить только один атрибут времени из двух?
4.14	 Некоторые версии команды finger(1) выводят сообщения «New mail
received ...» (Получена новая почта ...) и «unread since ...» (не прочитано после ...), где многоточием обозначены соответствующее время и  дата. Как
программа может определить эти время и дату?
4.15	 Изучите различные форматы архивов, создаваемых командами cpio(1)
и tar(1). (Их описание обычно можно найти в разделе 5 «UNIX Programmer’s
Manual».) Какие временные характеристики файлов могут быть сохранены
в архиве? Какое значение времени последнего доступа к файлу будет установлено при его разархивировании и почему?
4.16	 Существует ли в UNIX фундаментальное ограничение на количество вложенных каталогов? Чтобы узнать это, напишите программу, которая в цикле
будет создавать новый каталог и сразу же выполнять переход в него. Убедитесь, что длина строки абсолютного пути к последнему каталогу превышает
системный предел PATH_MAX. Есть ли возможность вызвать функцию getcwd
из последнего каталога, чтобы получить абсолютный путь к  нему? Как
стандартные утилиты UNIX работают с такими длинными путями? Можно
ли заархивировать такое дерево каталогов с помощью tar или cpio?
4.17	 В разделе 3.16 мы описали специальный каталог /dev/fd/. Чтобы любой
пользователь смог обращаться к файлам в этом каталоге, для них должны
быть установлены права доступа rw-rw-rw-. Некоторые программы перед
созданием нового файла сначала удаляют его, если он уже существует, игнорируя при этом возвращаемое значение функции. Вот как это делается:
unlink(path);
if ((fd = creat(path, FILE_MODE)) < 0)
err_sys(...);

Что произойдет, если в аргументе path передать строку /dev/fd/1?

5

Стандартная библиотека
ввода/вывода

5.1. Введение
В этой главе мы исследуем стандартную библиотеку ввода/вывода. Эта библио­
тека определена стандартом ISO C, потому что реализована во многих операционных системах, не относящихся к  семейству UNIX. Стандарт Single UNIX
Specification определяет для нее дополнительные интерфейсы в качестве расширений стандарта ISO C.
Стандартная библиотека ввода/вывода сама производит размещение буферов
и выполняет операции ввода/вывода блоками оптимального размера, что избавляет от необходимости задумываться о  правильности выбора (раздел 3.9). Это
упрощает использование библиотеки, но в то же время неумелое обращение с ней
может стать источником других проблем.
Стандартная библиотека ввода/вывода написана Деннисом Ритчи примерно в 1975 году.
Это была генеральная ревизия библиотеки Portable I/O Майка Леска. Удивительно, насколько несущественно изменилась библиотека за последние 30 лет.

5.2. Потоки и объекты FILE
Все функции, описанные в главе 3, работали с файлами посредством дескрипторов. Функция, открывающая файл, возвращает дескриптор, который затем используется во всех последующих операциях ввода/вывода. При обсуждении стандартной библиотеки ввода/вывода мы будем отталкиваться от термина поток
ввода/вывода, или просто поток. (Не путайте стандартный термин поток ввода/
вывода (stream) с  системой ввода/вывода STREAMS, которая является частью
System V и стандартизирована в расширении XSI STREAMS к стандарту Single
UNIX Specification.) Открывая или создавая файл средствами стандартной библиотеки ввода/вывода, мы говорим, что связали поток с файлом.
В наборе символов ASCII каждый символ представлен одним байтом. В  национальных наборах символов один символ может быть представлен несколькими
байтами. Стандартные файловые потоки ввода/вывода могут использоваться как
с однобайтными, так и с многобайтными («wide» — «широкими») наборами символов. Ориентация потока определяет, являются ли читаемые и  записываемые
символы однобайтными или многобайтными. Изначально, в  момент создания,

5.2. Потоки и объекты FILE   

193

­ оток не имеет ориентации. Если с  неориентированным потоком ввода/вывода
п
используется функция, оперирующая многобайтными символами (см. <wchar.h>),
для потока устанавливается ориентация на «широкие» символы. Если с неориентированным потоком ввода/вывода используется функция, оперирующая однобайтными символами, устанавливается ориентация на однобайтные символы. Изменить установленную ориентацию могут только две функции. Функция freopen
(рассматривается чуть ниже) сбрасывает ориентацию потока, а  функция fwide
устанавливает ориентацию потока.
#include <stdio.h>
#include <wchar.h>
int fwide(FILE *fp, int mode);

Возвращает положительное число, если поток ориентирован
на многобайтные символы, отрицательное число, если ориентирован
на однобайтные символы, или 0, если поток не имеет ориентации
Функция fwide решает разные задачи в зависимости от значения аргумента mode.
 Если аргумент mode — отрицательное число, функция fwide попытается назначить потоку ориентацию на однобайтные символы.
 Если аргумент mode — положительное число, функция fwide попытается назначить потоку ориентацию на многобайтные символы.
 Если аргумент mode равен 0, функция fwide не будет менять ориентацию потока, а просто вернет значение, соответствующее текущей ориентации.
Обратите внимание: функция fwide не может изменить ориентацию уже ориентированного потока. Кроме того, она не возвращает признак ошибки. Единственное, что можно сделать в этом случае, — очистить переменную errno перед вызовом функции fwide и затем проверить ее значение после вызова. На протяжении
оставшейся части книги мы будем иметь дело только с потоками, ориентированными на однобайтные символы.
При открытии потока стандартная функция fopen (раздел 5.5) возвращает указатель на объект FILE. Этот объект, как правило, является структурой со всей
информацией, необходимой для управления потоком средствами стандартной
библиотеки ввода/вывода: дескриптор файла, используемый в операциях ввода/
вывода, указатель на буфер потока, размер буфера, счетчик символов, находящихся в настоящий момент в буфере, флаг ошибки и т. д.
Прикладные программы никогда не работают с объектом FILE напрямую. Чтобы
сослаться на поток, достаточно просто передать указатель на объект FILE в аргументе любой стандартной функции ввода/вывода. Далее в тексте книги указатель
на объект FILE, тип FILE * мы будем называть указателем на файл.
В этой главе стандартная библиотека ввода/вывода обсуждается в контексте ОС
UNIX. Как мы уже упоминали, эта библиотека перенесена на самые разные платформы. Но чтобы вы получили некоторое представление, как эта библиотека мо-

194    Глава 5. Стандартная библиотека ввода/вывода
жет быть реализована, мы будем отталкиваться от типичной ее реализации в системе UNIX.

5.3. Стандартные потоки ввода,
вывода и сообщений об ошибках
Для любого процесса автоматически создается три предопределенных потока:
стандартный поток ввода, стандартный поток вывода и  стандартный поток сообщений об ошибках. Эти потоки связаны с теми же файлами, что и дескрипторы
STDIN_FILENO, STDOUT_FILENO и STDERR_FILENO, упоминавшиеся в разделе 3.2.
Эти три потока доступны посредством предопределенных указателей на файлы
stdin, stdout и stderr. Определения файловых указателей находятся в заголовочном файле <stdio.h>.

5.4. Буферизация
Поддержка буферизации в  стандартной библиотеке ввода/вывода реализована
с целью уменьшить количество обращений к функциям read и  write. (В табл. 3.3
мы приводили зависимость производительности операций ввода/вывода от размера буфера.) Кроме того, библиотека стремится произвести буферизацию потоков ввода/вывода автоматически, чтобы избавить приложения от необходимости
беспокоиться о ней. К сожалению, буферизация — это тот самый аспект стандартной библиотеки ввода/вывода, который более всего смущает программистов.
Библиотека поддерживает три типа буферизации.
1.	 Полная буферизация. В этом случае фактический ввод/вывод осуществляется, только когда будет заполнен стандартный буфер ввода/вывода. Обычно
стандартная библиотека ввода/вывода использует полную буферизацию для
файлов на диске. Буфер, как правило, создается одной из стандартных функций ввода/вывода вызовом malloc (раздел 7.8) во время первой операции ввода/вывода.
Операция записи содержимого стандартного буфера ввода/вывода описывается термином flush (сбрасывать). Буфер может сбрасываться на диск автоматически одной из функций, например при его заполнении или с помощью
функции fflush. К сожалению, в UNIX термин flush имеет два разных смысла.
В  терминах стандартной библиотеки ввода/вывода он означает «запись содержимого буфера на диск». В  терминах драйвера терминала, например, для
функции tcflush (глава 18), он означает «удаление данных из буфера».
2.	 Построчная буферизация. В  этом случае фактический ввод/вывод осуществляется, когда в  потоке встречается символ перевода строки. Это позволяет
выводить по одному символу за раз (с помощью стандартной функции fputc),
зная при этом, что фактическая запись произойдет, только когда строка будет
закончена. Построчная буферизация обычно используется для потоков, свя-

5.4. Буферизация   

195

занных с  терминальными устройствами, например для стандартного ввода
и стандартного вывода.
Необходимо упомянуть несколько аспектов, касающихся построчной буферизации. Во-первых, буфер, используемый стандартной библиотекой ввода/вывода для сборки строки, имеет фиксированный размер, поэтому фактическая
операция ввода/вывода может быть выполнена еще до того, как встретится
символ перевода строки, если буфер заполнится раньше. Во-вторых, всякий
раз, когда ввод производится средствами стандартной библиотеки ввода/вывода либо (а) из небуферизованного потока, либо (б) из потока с построчной
буферизацией, который требует обращения к ядру за данными, все выходные
потоки с построчной буферизацией сбрасываются. Уточнение для случая (б)
необходимо, поскольку требуемые данные могут уже находиться в буфере и за
ними не обязательно было бы обращаться к ядру. В случае (а) вполне очевидно,
что требуемые данные можно получить только от ядра.
3.	 Отсутствие буферизации. Стандартная библиотека ввода/вывода не буферизует операции с  символами. Если мы записываем в  поток 15 символов (например, с  помощью функции fputs), то рассчитываем, что эти 15 символов
будут выведены как можно скорее, возможно, с  помощью функции write
(раздел 3.8).
Так, например, стандартный поток сообщений об ошибках обычно не буферизуется. В результате сообщения выводятся максимально быстро, вне зависимости от наличия символа перевода строки.
Стандарт ISO C предъявляет следующие требования к буферизации:
 Стандартные потоки ввода/вывода буферизуются полностью, но только если
они не связаны с интерактивными устройствами.
 Стандартный поток сообщений об ошибках никогда не подвергается полной
буферизации.
Однако эти требования ничего не говорят о  том, могут ли стандартные потоки
ввода и вывода быть небуферизованными или построчно буферизованными, если
они связаны с  интерактивными устройствами, и  должен ли стандартный поток
сообщений об ошибках быть небуферизованным или построчно буферизованным.
В большинстве реализаций по умолчанию используются следующие виды буферизации:
 Стандартный поток сообщений об ошибках никогда не буферизуется.
 Все остальные потоки подвергаются построчной буферизации, если связаны
с терминальным устройством, и полной буферизации — в любом другом случае.
Все четыре платформы, обсуждаемые в этой книге, следуют этим соглашениям: стандартный поток сообщений об ошибках не буферизуется, потоки, связанные с терминальными устройствами, подвергаются построчной буферизации, а  все остальные потоки
буферизуются полностью.

Более детально мы исследуем буферизацию стандартного ввода/вывода в разделе 5.12 и на примере программы в листинге 5.3.

196    Глава 5. Стандартная библиотека ввода/вывода
Если нас не устраивают принятые по умолчанию виды буферизации для какоголибо потока, их можно изменить с помощью функции setbuf или setvbuf.
#include <stdio.h>
void setbuf(FILE *restrict fp, char *restrict buf);
int setvbuf(FILE *restrict fp, char *restrict buf, int mode,
size_t size);

Возвращают 0 в случае успеха, ненулевое значение — в случае ошибки
Эти функции должны вызываться только после открытия потока (это очевидно,
так как каждая требует передачи действительного указателя на файл в первом аргументе), но перед любой другой операцией, выполняемой над потоком.
С помощью функции setbuf можно разрешить или запретить буферизацию. Чтобы разрешить буферизацию, аргумент buf должен содержать указатель на буфер
размером BUFSIZ (константа, значение которой определено в  файле <stdio.h>).
В этом случае поток обычно буферизуется полностью, но некоторые системы могут назначить потоку построчную буферизацию, если он связан с терминальным
устройством. Чтобы запретить буферизацию, нужно в аргументе buf передать значение NULL.
При использовании функции setvbuf явно указывается желаемый режим буферизации. Делается это с помощью аргумента mode:
_IOFBF полная буферизация.
_IOLBF построчная буферизация.
_IONBF буферизация отсутствует.
Когда выполняется отключение буферизации, значения аргументов buf и size игнорируются. Когда включается полная или построчная буферизация, через аргументы buf и  size можно передать указатель на буфер и  его размер. Если в  аргументе buf передать значение NULL, библиотека автоматически выделит для потока
собственный буфер соответствующего размера. (Под «соответствующим размером» здесь подразумевается значение константы BUFSIZ.)
Некоторые реализации библиотеки языка C используют значение из поля st_blksize
структуры stat (раздел 4.2), чтобы определить оптимальный размер буфера ввода/
вывода. Далее в этой главе мы увидим, что библиотека GNU C использует этот метод.

В табл. 5.1 перечислены действия, выполняемые этими двумя функциями, в зависимости от значения их аргументов.
Следует знать, что если стандартный буфер ввода/вывода размещен как автоматическая переменная внутри функции, перед возвращением из функции необходимо закрыть поток. (Подробнее мы обсудим этот вопрос в разделе 7.8.) Кроме того, некоторые реализации используют часть буфера для своих внутренних
целей, поэтому фактический объем данных, которые могут храниться в  буфере,
меньше указанного размера size. Вообще, лучше позволить системе самой выбирать размер буфера и  автоматически размещать его в  памяти. В  этом случае

5.5. Открытие потока   

197

Таблица 5.1. Функции setbuf и setvbuf
Функция

mode

setbuf

setvbuf

_IOFBF

_IOLBF

_IONBF

buf

Буфер и его размер

Тип буферизации

Непустой
указатель

Пользовательский буфер
размером BUFSIZ

Полная или построчная
буферизация

NULL

Нет буфера

Буферизация отсутствует

Непустой
указатель

Пользовательский буфер
размером size

Полная буферизация

NULL

Системный буфер соответствующего размера

Непустой
указатель

Пользовательский буфер
размером size

NULL

Системный буфер соответствующего размера

(Игнорируется) Нет буфера

Построчная буферизация

Буферизация отсутствует

стандартная библиотека ввода/вывода сама освободит память, занимаемую буфером в момент закрытия потока.
Содержимое буфера потока можно сбросить в любой момент.
#include <stdio.h>
int fflush(FILE *fp);

Возвращает 0 в случае успеха, EOF — в случае ошибки
Функция fflush передает ядру все незаписанные данные из буфера. В особом случае, когда в аргументе fp передается NULL, сбрасывается содержимое буферов всех
потоков вывода.

5.5. Открытие потока
Функции fopen, freopen и fdopen открывают стандартный поток ввода/вывода.
#include <stdio.h>
FILE *fopen(const char *restrict pathname, const char *restrict type);
FILE *freopen(const char *restrict pathname, const char *restrict type,
FILE *restrict fp);
FILE *fdopen(int fd, const char *type);

Все три возвращают указатель на файл в случае успеха,
NULL — в случае ошибки

198    Глава 5. Стандартная библиотека ввода/вывода
Перечислим различия между этими функциями.
1.	 Функция fopen открывает указанный файл.
2.	 Функция freopen открывает указанный файл и связывает его с указанным потоком, предварительно закрывая поток, если он уже был открыт. Если перед
этим поток имел ориентацию, функция сбрасывает ее. Как правило, эта функция используется для связывания открываемого файла с  предопределенным
стандартным потоком ввода, вывода или сообщений об ошибках.
3.	 Функция fdopen принимает открытый дескриптор файла, полученный вызовом функций open, dup, dup2, fcntl, pipe, socket, socketpair или accept,
и связывает его с потоком ввода/вывода. Часто эта функция вызывается с дескриптором, который получен в результате создания канала или сетевого соединения. Поскольку эти типы файлов нельзя открыть стандартной функцией
fopen, приходится сначала открывать их специальными функциями, чтобы
получить дескриптор файла, а затем связывать дескриптор с потоком ввода/
вывода, используя функцию fdopen.
Обе функции, fopen и freopen, являются частью стандарта ISO C. Функция fdopen определена стандартом POSIX.1, потому что ISO C не имеет дела с дескрипторами.
Таблица 5.2. Возможные значения аргумента type при открытии потока
type

Описание

Флаги open(2)

r или rb

Открыть для чтения

O_RDONLY

w или wb

Усечь размер файла до 0 или создать и открыть
на запись

O_WRONLY|O_CREAT|O_TRUNC

a или ab

Открыть для записи в конец файла или создать
для записи

O_WRONLY|O_CREAT|O_APPEND

r+,

Открыть для чтения и для записи

O_RDWR

w+,

Усечь размер файла до 0 или создать и открыть
для чтения и для записи

O_RDWR|O_CREAT|O_TRUNC

a+,

Открыть или создать для чтения и для записи
в конец файла

O_RDWR|O_CREAT|O_APPEND

или r+b,
или rb+
или w+b,
или wb+
или a+b,
или ab+

Стандарт ISO C определяет 15 возможных значений аргумента type. Все они перечислены в  табл. 5.2. Использование символа b в  аргументе type позволяет стандартной системе ввода/вывода различать текстовые и двоичные файлы. Так как
ядро UNIX не различает эти типы файлов, указание символа b не оказывает никакого влияния.
Для функции fdopen значение аргумента type несколько отличается. Так как дескриптор уже открыт, открытие для записи не приводит к усечению файла. (Если

5.5. Открытие потока   

199

дескриптор для существующего файла создается, например, функцией open, усечение можно выполнить с помощью флага O_TRUNC. Функция fdopen сама не может выполнить усечение файла, который она открывает для записи.) Кроме того,
открытие для записи в конец файла не приводит к созданию нового файла (так
как дескриптор может быть связан только с существующим файлом).
Когда файл открыт в  режиме добавления в  конец, все операции записи производятся в  конец файла. Если несколько процессов откроют один и  тот же файл
в этом режиме, стандартная функция ввода/вывода будет корректно записывать
данные каждого процесса.
Версии функции fopen из Беркли, предшествовавшие 4.4BSD, и простейшая версия, которая приводится на с. 177 в [Kernighan и Ritchie, 1988], работают с режимом добавления
в конец файла не совсем корректно. Эти версии вызывают функцию lseek для перехода
в конец файла при его открытии. В случае, когда с файлом работают несколько процессов,
он должен быть открыт с флагом O_APPEND, который мы рассматривали в разделе 3.3.
Вызов функции lseek перед каждой операцией записи не даст желаемого эффекта; эту
проблему мы также обсуждали в разделе 3.11.

Когда файл открывается для чтения и записи (символ «+» в аргументе type), применяются следующие ограничения.
 Вывод не может сразу же следовать за вводом без промежуточного вызова
функций fflush, fseek, fsetpos или rewind.
 Ввод не может сразу следовать за выводом без вызова функций fseek, fsetpos
или rewind или операции ввода, которая встречает конец файла.
Различные характеристики шести способов открытия потока, перечисленных
в табл. 5.2, можно обобщить, как показано в табл. 5.3.
Таблица 5.3. Шесть способов открытия потоков ввода/вывода
Ограничение

Файл должен существовать

r

Поток доступен для записи

a



Предыдущее содержимое файла будет утеряно
Поток доступен для чтения

w

r+

w+

a+









Запись возможна только в конец потока

















Обратите внимание, что, используя в аргументе type символы a или w, можно создать новый файл, но при этом нельзя определить биты прав доступа к файлу, как
мы делали это с помощью функции open или creat в главе 3. Стандарт POSIX.1
требует, чтобы реализации создавали файлы со следующим набором битов прав
доступа:
S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH | S_IWOTH

Однако в разделе 4.8 говорилось, что эти права могут ограничиваться значением
маски umask.

200    Глава 5. Стандартная библиотека ввода/вывода
По умолчанию поток открывается в режиме полной буферизации, если, конечно,
он не связан с  терминальным устройством, так как в  этом случае используется
режим построчной буферизации. Сразу же после открытия потока, но до выполнения первой операции ввода/вывода режим буферизации можно изменить с помощью функций setbuf и setvbuf, описанных в предыдущем разделе.
Закрывается открытый поток с помощью функции fclose.
#include <stdio.h>
int fclose(FILE *fp);

Возвращает 0 в случае успеха, EOF — в случае ошибки
Перед закрытием потока все данные, находящиеся в  буфере вывода, сбрасываются. Все данные, находящиеся в буфере ввода, будут утеряны. Если память под
буфер была выделена самой библиотекой ввода/вывода, она освобождается автоматически.
При нормальном завершении процесса, то есть когда непосредственно вызывается функция exit или происходит возврат из функции main, все незаписанные данные в буферах вывода сбрасываются на диск, после чего все потоки закрываются.

5.6. Чтение из потока и запись в поток
После открытия потока можно выбрать один из трех типов неформатированного
ввода/вывода.
1.	 Посимвольный ввод/вывод. Можно читать или писать по одному символу за
раз с помощью стандартных функций ввода/вывода, которые буферизуют данные, если поток буферизован.
2.	 Построчный ввод/вывод. Если необходимо читать или писать данные построчно, используются функции fgets и  fputs. Каждая строка заканчивается
символом перевода строки, а  при использовании функции fgets нужно указать максимальную длину строки, которую мы можем принять. Эти две функции рассматриваются в разделе 5.7.
3.	 Прямой ввод/вывод. Этот тип ввода/вывода поддерживается функциями
fread и fwrite. Каждая операция выполняет чтение или запись определенного
количества объектов, имеющих заданный размер. Эти функции часто используются для работы с  двоичными файлами, когда в  каждой операции чтения
или записи участвует одна структура данных. Эти функции рассматриваются
в разделе 5.9.
Термин «прямой ввод/вывод» из стандарта ISO C имеет также несколько синонимов:
двоичный ввод/вывод, ввод/вывод объектами, ввод/вывод записями или ввод/вывод структурами. Не путайте эту особенность с флагом O_DIRECT функции open, поддерживаемым
в FreeBSD и Linux, — они никак не связаны между собой.

5.6. Чтение из потока и запись в поток   

201

(Функции форматированного ввода/вывода, такие как printf и  scanf, описываются в разделе 5.11.)

Функции ввода
Три функции позволяют читать по одному символу за одно обращение.
#include <stdio.h>
int getc(FILE *fp);
int fgetc(FILE *fp);
int getchar(void);

Все три возвращают очередной символ в случае успеха,
EOF — в случае ошибки
Функция getchar определена как эквивалент getc(stdin). Разница между первыми двумя функциями заключается в том, что getc может быть реализована в виде
макроса, а fgetc — нет. Это означает следующее.
1.	 Аргумент функции getc не должен быть выражением с побочными эффектами.
2.	 Поскольку fgetc обязательно будет функцией, мы всегда можем узнать ее
адрес. Это позволит передать адрес функции fgetc в  виде аргумента другой
функции.
3.	 Вызов функции fgetc, скорее всего, будет более длительным, чем вызов getc,
так как обычно вызов функции занимает больше времени, чем обращение к макросу.
Все три функции возвращают очередной символ как unsigned char, преобразованный в int. Причина в том, что функции должны возвращать положительное значение, даже когда старший бит символа установлен в 1. Преобразование в  int связано с тем, что наряду с обычными символами функции могут возвращать признак
ошибки или признак конца файла. Константа EOF, определяемая в файле <stdio.h>,
должна иметь отрицательное значение. Чаще она имеет значение –1. Это также означает, что мы не сможем сохранить возвращаемое значение любой из этих трех
функций в  переменной символьного типа и  затем сравнить его с  константой EOF.
Обратите внимание, что эти функции возвращают одно и то же значение и в случае ошибки, и в случае достижения конца файла. Чтобы отличить один случай от
другого, следует использовать функцию ferror или feof.
#include <stdio.h>
int ferror(FILE *fp);
int feof(FILE *fp);

Обе возвращают ненулевое значение (истина), если условие истинно,
или 0 (ложь), если условие ложно
void clearerr(FILE *fp);

202    Глава 5. Стандартная библиотека ввода/вывода
В большинстве реализаций в объекте FILE для каждого потока предусматриваются два флага:
 флаг ошибки;
 флаг конца файла.
Оба флага сбрасываются вызовом функции clearerr.
После чтения символа из потока его можно вернуть обратно в  поток вызовом
функции ungetc.
#include <stdio.h>
int ungetc(int c, FILE *fp);

Возвращает значение аргумента c в случае успеха, EOF — в случае ошибки
Символы, возвращенные в поток, будут заново прочитаны следующими операциями чтения в  порядке, обратном порядку их возврата. Надо отметить, что хотя
стандарт ISO C позволяет возвращать в поток произвольное количество символов, реализации обязаны предоставлять возможность возврата только одного
символа. Поэтому не следует рассчитывать более чем на один символ.
Возвращаемый символ не обязательно должен быть последним прочитанным
символом. Нельзя вернуть в поток признак конца файла (EOF). Однако по достижении конца файла можно вернуть в  поток один символ. Следующая операция
чтения вернет этот символ, а следующая за ней вернет EOF. Этот прием работает,
потому что функция ungetc сбрасывает флаг конца файла у потока.
Возврат символов в поток часто используется, когда необходимо прервать чтение
на границе слова или лексемы определенного вида. Иногда нужно увидеть следующий символ, чтобы решить, как обрабатывать текущий. В этом случае мы просто
возвращаем прочитанный символ в поток, и он будет получен следующим вызовом
функции getc. Если бы стандартная библиотека ввода/вывода не давала такой возможности, нам приходилось бы сохранять его в переменной, равно как и флаг, указывающий, что следующий символ следует взять из переменной, а не из потока.
Когда символ возвращается в поток вызовом ungetc, он на самом деле не записывается
обратно в файл или в устройство. Возвращаемые символы просто сохраняются библиотекой ввода/вывода во внутреннем буфере потока.

Функции вывода
Каждой из описанных выше функций ввода соответствует функция вывода.
#include <stdio.h>
int putc(int c, FILE *fp);
int fputc(int c, FILE *fp);
int putchar(int c);

Все три возвращают значение аргумента c в случае успеха,
EOF — в случае ошибки

5.7. Построчный ввод/вывод   

203

По аналогии с  функциями ввода, вызов putchar(c) эквивалентен вызову
putc(c, stdout), и putc также может быть реализована в виде макроса, тогда как
fputc — нет.

5.7. Построчный ввод/вывод
Построчный ввод выполняется двумя функциями, fgets и gets.
#include <stdio.h>
char *fgets(char *restrict buf, int n, FILE *restrict fp);
char *gets(char *buf);

Обе возвращают buf в случае успеха, NULL– в случае ошибки
или по достижении конца файла
Обеим функциям передается адрес буфера для размещения прочитанной строки.
Функция gets читает из стандартного потока ввода, функция fgets — из указанного потока.
Для функции fgets указывается размер приемного буфера, n. Эта функция будет читать входные данные в буфер до тех пор, пока не встретит символ перевода строки, но не более n – 1 символов. В конец прочитанной строки добавляется
нулевой символ. Если длина строки, включая символ перевода строки, составляет
более n – 1 символов, функция вернет только часть строки, но в конец буфера все
равно будет добавлен завершающий нулевой символ. Последующий вызов fgets
вернет остаток строки.
Функцию gets использовать не следует. Проблема в  том, что она не позволяет
определить размер приемного буфера. Если входная строка окажется длиннее буфера, это приведет к его переполнению и порче данных, которые находятся в памяти сразу после буфера. Описание, как эта брешь в безопасности использовалась
программой-червем в 1988 году, вы найдете в июньском номере «Communications
of the ACM» за 1989 год (vol. 32 no. 6). Еще одно отличие gets от fgets заключается в том, что функция gets не сохраняет символ перевода строки в буфере, как это
делает функция fgets.
Это различие в обработке символа перевода строки уходит корнями в историю UNIX.
Еще в руководстве к Version 7 (1979) было отмечено, что: «gets удаляет символ перевода строки, fgets оставляет его, и все это ради сохранения обратной совместимости».

Хотя стандарт ISO C требует, чтобы реализация предоставляла функцию gets, используйте вместо нее функцию fgets. В  версии стандарта SUSv4 функция gets
объявлена устаревшей и была исключена из последней версии стандарта ISO C
(ISO/IEC 9899:2011).
Операции построчного вывода обеспечиваются функциями fputs и puts.

204    Глава 5. Стандартная библиотека ввода/вывода

#include <stdio.h>
int fputs(const char *restrict str, FILE *restrict fp);
int puts(const char *str);

Обе возвращают неотрицательное значение в случае успеха,
EOF — в случае ошибки
Функция fputs записывает строку, завершающуюся нулевым символом, в указанный поток. Нулевой символ в поток не записывается. Примечательно, что это не
построчный вывод в строгом смысле слова, поскольку строка может не содержать
символ перевода строки в качестве последнего ненулевого символа. Обычно завершающему нулевому символу действительно предшествует символ перевода
строки, но это совершенно не обязательно.
Функция puts записывает строку, завершающуюся нулевым символом, в  поток
стандартного вывода. Она не выводит завершающий нулевой символ, но добавляет символ перевода строки.
Функция puts достаточно безопасна в отличие от парной ей gets. Однако мы также
рекомендуем не пользоваться ею, чтобы не задумываться постоянно о том, добавляет ли она символ перевода строки. Пользуясь только функциями fgets и fputs, мы
всегда будем точно знать, что должны обрабатывать символ перевода строки.

5.8. Эффективность стандартных функций
ввода/вывода
Используя функции из предыдущего раздела, мы можем оценить эффективность
стандартной библиотеки ввода/вывода. Программа в листинге 5.1 очень похожа
на ту, что приводилась в листинге 3.1, — она просто копирует данные из стандартного ввода в стандартный вывод с помощью функций getc и  putc. Эти две функции могут быть реализованы в виде макросов.
Листинг 5.1. Копирование данных со стандартного ввода на стандартный вывод
с помощью функций getc и putc
#include "apue.h"
int
main(void)
{
int

c;

while ((c = getc(stdin)) != EOF)
if (putc(c, stdout) == EOF)
err_sys("ошибка вывода");
if (ferror(stdin))
err_sys("ошибка ввода");
}

exit(0);

5.8. Эффективность стандартных функций ввода/вывода   

205

Можно также написать версию этой программы с использованием функций fgetc
и  fputc, которые всегда реализованы как функции, а не как макросы. (Не будем
здесь приводить изменения в  исходном коде, поскольку они достаточно тривиальны.)
В заключение приведем еще одну версию программы, которая выполняет чтение
и запись построчно (листинг 5.2).
Листинг 5.2. Копирование данных со стандартного ввода на стандартный вывод
с помощью функций fgets и fputs
#include "apue.h"
int
main(void)
{
char
buf[MAXLINE];
while (fgets(buf, MAXLINE, stdin) != NULL)
if (fputs(buf, stdout) == EOF)
err_sys("ошибка вывода");
if (ferror(stdin))
err_sys("ошибка ввода");
}

exit(0);

Обратите внимание, что программы в  листингах 5.1 и  5.2 не закрывают потоки
ввода/вывода явно. Мы уже знаем, что функция exit сбросит все незаписанные данные из буферов и закроет все открытые потоки. (Этот вопрос еще будет
обсуждаться в  разделе 8.5.) Интересно сравнить время, затраченное этими тремя программами, с  результатами из табл. 3.3. Данные для сравнения приводятся в табл. 5.4 (все операции производились с одним и тем же файлом размером
98,5 Мбайт, содержащим 3 миллиона строк).
Таблица 5.4. Время выполнения операций стандартными функциями ввода/вывода
Пользовательское время
(секунды)

Системное
время
(секунды)

Общее
время
(секунды)

Лучшее время из табл. 3.3

  0,01

   0,54

   8,51

fgets, fputs

  2,27

   0,30

   3,49

143

getc, putc

  8,45

   0,29

  10,33

114

fgetc, fputc

  8,16

   0,40

  10,18

114

Время из табл. 3.3, с размером
буфера 1 байт

20,03

117,50

138,73

Функция

Размер
программы
(байты)

Для каждой из трех версий, использующих стандартные функции ввода/вывода, пользовательское время получилось больше, чем наилучший результат из
табл. 3.3, потому что две версии выполняют 100 миллионов циклов для переда-

206    Глава 5. Стандартная библиотека ввода/вывода
чи данных по одному байту, а версия с построчным вводом/выводом выполняет
3  144  984 циклов. Версия программы, основанная на функции read, выполняет
всего 25  244 цикла (для размера буфера 4096 байт). Различия общего времени
выполнения обусловлены различиями в  пользовательском времени и  во времени ожидания завершения ввода/вывода, тогда как значения системного времени
вполне сопоставимы.
Системное время примерно то же, что и  прежде, потому что производится примерно одинаковое количество системных вызовов. Одно из преимуществ стандартной библиотеки ввода/вывода состоит в том, что она избавляет нас от беспокойства по поводу буферизации или оптимальности выбранного размера буфера.
Конечно, мы все-таки должны определиться с  максимальным размером строки
для версии программы, которая использует функцию fgets, но это гораздо проще,
чем выбирать оптимальный размер буфера.
В последней колонке табл. 5.4 приводится размер сегмента кода программы, сгенерированного компилятором языка C. Здесь мы видим, что версия с функциями
fgetc/fputc имеет тот же размер, что и версия с функциями getc/putc. Обычно
функции getc и  putc реализованы в виде макросов, но в библиотеке GNU C эти
макросы просто разворачиваются в вызовы функций.
Версия программы с построчным вводом/выводом выполняется почти в два раза
быстрее, чем версии с  посимвольным вводом/выводом. Если бы fgets и  fputs
были реализованы через функции getc и  putc (раздел 7.7 [Kernighan and Ritchie,
1988]), результаты совпали бы с  результатами версии, основанной на функции
getc. На самом деле версия с построчным вводом/выводом выполнялась бы даже
значительно дольше, так как в этом случае к существующим 6 миллионам вызовов
функций добавились бы еще 200 миллионов. Из полученных результатов можно
сделать вывод, что функции построчного ввода/вывода реализованы с помощью
функции memccpy(3). Часто для повышения эффективности функция memccpy пишется не на C, а на языке ассемблера.
И последнее, что представляет для нас интерес в  этих результатах,  — версия на
основе функции fgetc выполняется намного быстрее, чем версия из листинга 3.1
с размером буфера BUFFSIZE=1. Обе версии производят одно и то же количество
вызовов функций  — приблизительно 200 миллионов, и  все же на выполнение
версии на основе функции fgetc потребовалось почти в  16 раз меньше пользовательского времени, а общее время выполнения получилось более чем в 39 раз
меньше. Эта разница обусловлена тем, что версия на основе функции open выполняет 200 миллионов вызовов функций, которые, в свою очередь, производят
200 миллионов системных вызовов. Версия на основе функции fgetc также выполняет 200 миллионов вызовов функций, но производит всего 25 224 обращений
к системным вызовам. Обращение к системному вызову обычно намного дороже,
чем обращение к обычной функции.
Тут мы должны оговориться: результаты испытаний справедливы только для той
системы, в  которой они получены. Результаты зависят от многих особенностей
конкретных реализаций UNIX. Тем не менее приводимые здесь числа и объяснения различий между версиями одной программы помогут нам лучше понять саму
операционную систему. Сравнивая результаты из этого раздела и из раздела 3.9,

5.9. Ввод/вывод двоичных данных   

207

мы узнали, что стандартная библиотека ввода/вывода не намного медленнее, чем
прямое обращение к функциям read и  write. В большинстве сложных приложений наибольшее количество пользовательского времени уходит на выполнение
самого приложения, а не на обращения к стандартным функциям ввода/вывода.

5.9. Ввод/вывод двоичных данных
Функции из раздела 5.6 оперируют одним символом, функции из раздела 5.7 —
одной строкой. При выполнении операций ввода/вывода двоичных данных предпочтительнее читать или записывать сразу целые структуры. Чтобы сделать это
с помощью getc или putc, нам пришлось выполнить обход полей структуры, выполняя чтение или запись по одному байту. Мы не можем воспользоваться функциями построчного ввода/вывода, поскольку функция fputs прекращает запись,
встретив нулевой байт, а  внутри структуры вполне могут содержаться нулевые
байты. Точно так же и функция fgets не сможет корректно читать данные с нулевыми байтами или символами перевода строки. Поэтому для ввода/вывода двоичных данных предоставляются следующие две функции.
#include <stdio.h>
size_t fread(void *restrict ptr, size_t size, size_t nobj, FILE *restrict fp);
size_t fwrite(const void *restrict ptr, size_t size, size_t nobj,
FILE *restrict fp);

Обе возвращают количество прочитанных или записанных объектов
Два наиболее распространенных случая использования этих функций:
1.	 Чтение или запись массивов двоичных данных. Например, вот как можно записать со 2-го по 5-й элементы массива чисел с плавающей точкой:
float

data[10];

if (fwrite(&data[2], sizeof(float), 4, fp) != 4)
err_sys("ошибка вызова функции fwrite");

Здесь мы передали в аргументе size размер одного элемента массива, а в аргументе nobj — количество элементов.
2.	 Чтение или запись структур данных. Вот как это делается:
struct {
short count;
long total;
char name[NAMESIZE];
} item;
if (fwrite(&item, sizeof(item), 1, fp) != 1)
err_sys("ошибка вызова функции fwrite");

Здесь в аргументе size указан размер структуры, а в аргументе nobj — количество объектов для записи (один).

208    Глава 5. Стандартная библиотека ввода/вывода
Очевидное обобщение этих двух случаев — чтение или запись массива структур.
Для этого аргумент size должен содержать размер структуры (определяемый с помощью оператора sizeof), а аргумент nobj — количество элементов массива.
Обе функции, fread и fwrite, возвращают количество прочитанных или записанных объектов. Для функции fread это число может быть меньше значения nobj,
если произошла ошибка или достигнут конец файла. В этой ситуации нужно вызвать функцию ferror или feof. Если функция fwrite вернула число меньше значения аргумента nobj, это свидетельствует об ошибке.
Фундаментальная проблема, связанная с вводом/выводом двоичных данных, заключается в том, что они корректно читаются только в той же системе, в какой
были записаны. Много лет назад, когда все версии UNIX работали на PDP-11,
этой проблемы не существовало, но сегодня стало нормой объединение в сети разнородных систем. И нередко возникает желание записать данные в одной системе
и обработать их в другой. В такой ситуации эти две функции не будут работать по
двум причинам.
1.	 Смещение полей структур может отличаться для разных компиляторов и операционных систем из-за различных требований выравнивания. Некоторые
компиляторы могут упаковывать структуры в  целях экономии занимаемого
пространства и, возможно, в  ущерб производительности либо, наоборот, выполнять выравнивание полей для повышения скорости доступа во время выполнения. Это означает, что даже для одной и той же системы раскладка структуры может варьироваться в зависимости от параметров компиляции.
2.	 Форматы представления многобайтных целых чисел или чисел с плавающей
точкой могут различаться на разных аппаратных платформах.
Мы коснемся некоторых из этих проблем, когда будем говорить о сокетах в главе 16. Решение проблемы обмена двоичными данными между различными системами заключается в использовании высокоуровневого протокола. За описанием
приемов, используемых сетевыми протоколами для обмена двоичными данными, обращайтесь к разделу 8.2 [Rago, 1993] или к разделу 5.18 [Stevens, Fenner, &
Rudoff, 2004].
Мы еще вернемся к функции fread в разделе 8.14, когда с ее помощью будем читать двоичные структуры данных учетной информации о процессах.

5.10. Позиционирование в потоке
Существует три способа позиционирования в потоке ввода/вывода.
1.	 С помощью функций ftell и  fseek, которые впервые появились в  Version 7.
Они предполагают, что позиция в файле может быть представлена в виде длинного целого.
2.	 С помощью функций ftello и fseeko. Они определены стандартом Single UNIX
Specification для случаев, когда длинного целого недостаточно для представления позиции в файле. Вместо типа данных long int они используют off_t.

5.10. Позиционирование в потоке   

209

3.	 С помощью функций fgetpos и  fsetpos. Они определены стандартом ISO C.
Для представления позиции в  файле эти функции используют абстрактный
тип данных fpos_t. Этот тип может быть увеличен настолько, насколько это
необходимо для представления позиции в файле.
Переносимые приложения, которые предполагается портировать в операционные
системы, отличные от UNIX, должны использовать функции fgetpos и fsetpos.
#include <stdio.h>
long ftell(FILE *fp);

Возвращает текущую позицию файла в случае успеха,
–1L — в случае ошибки
int fseek(FILE *fp, long offset, int whence);

Возвращает 0 в случае успеха, –1 — в случае ошибки
void rewind(FILE *fp);

Для двоичных файлов текущая позиция измеряется в байтах относительно начала
файла. Функция ftell возвращает для двоичных файлов позицию данного байта.
Чтобы установить позицию в двоичном файле с помощью функции fseek, нужно
указать в  аргументе offset смещение байта и  как это смещение интерпретируется. Значение аргумента whence выбирается точно так же, как для функции lseek
(раздел 3.6): SEEK_SET означает смещение от начала файла, SEEK_CUR — от текущей
позиции файла и  SEEK_END — от конца файла. Стандарт ISO C не требует, чтобы
реализации поддерживали константу SEEK_END для двоичных файлов, поскольку
некоторые системы требуют дополнения двоичных файлов в конце нулями, чтобы
сделать размер файла кратным некоторому числу. Однако UNIX поддерживает
использование константы SEEK_END для двоичных файлов.
В случае текстовых файлов текущая позиция может не соответствовать простому
смещению байта. Опять же это главным образом относится к системам, отличным от
UNIX, которые могут хранить текстовые данные в другом формате. Чтобы установить текущую позицию в текстовом файле, аргумент whence должен иметь значение
SEEK_SET, а для аргумента offset допускаются только два значения — 0, что означает
возврат к началу файла, или значение, полученное вызовом функции ftell для этого
файла. Кроме того, вернуться в начало файла можно с помощью функции rewind.
Функция ftello практически идентична функции ftell, а  функция fseeko  —
функции fseek, за исключением того, что тип смещения у них не long, а off_t.
#include <stdio.h>
off_t ftello(FILE *fp);

Возвращает текущую позицию файла в случае успеха,
(off_t)–1 — в случае ошибки
int fseeko(FILE *fp, off_t offset, int whence);

Возвращает 0 в случае успеха, –1 — в случае ошибки

210    Глава 5. Стандартная библиотека ввода/вывода
О типе off_t мы говорили в разделе 3.6. Реализации могут определять тип off_t
большего размера, чем 32-разрядное целое.
Как уже говорилось ранее, функции fgetpos и  fsetpos определены стандартом ISO C.
#include <stdio.h>
int fgetpos(FILE *restrict fp, fpos_t *restrict pos);
int fsetpos(FILE *fp, const fpos_t *pos);

Обе возвращают 0 в случае успеха,
ненулевое значение — в случае ошибки
Функция fgetpos записывает значение текущей позиции в  объект, на который
указывает аргумент pos. Это значение может использоваться в последующих вызовах fsetpos для переустановки текущей позиции в файле.

5.11. Форматированный ввод/вывод
Форматированный вывод
Форматированный вывод производится с помощью пяти функций из семейства
printf.
#include <stdio.h>
int printf(const char *restrict format, ...);
int fprintf(FILE *restrict fp, const char *restrict format, ...);
int dprintf(int fd, const char *restrict format, ...);

Все три возвращают количество выведенных символов в случае
успеха, отрицательное значение — в случае ошибки
int sprintf(char *restrict buf, const char *restrict format, ...);

Возвращает количество символов, записанных в массив, в случае
успеха, отрицательное значение — в случае ошибки
int snprintf(char *restrict buf, size_t n, const char *restrict format, ...);

Возвращает количество символов, записанных в массив, если буфер
имеет достаточный размер, отрицательное значение — в случае ошибки

5.11. Форматированный ввод/вывод   

211

Функция printf осуществляет запись в  стандартный поток вывода, fprintf  —
в заданный поток, dprintf — в заданный файловый дескриптор, а  sprintf помещает форматированную строку в массив buf. Функция sprintf автоматически добавляет нулевой байт в конец массива buf, но он не включается в возвращаемое
значение.
Обратите внимание, что функция sprintf может вызвать переполнение буфера,
на который указывает аргумент buf. Поэтому вызывающая программа должна передавать ей буфер достаточного размера. Во избежание проблем, связанных с переполнением буфера, была добавлена функция snprintf. Эта функция принимает
размер буфера в виде дополнительного аргумента и игнорирует символы, которые
могли бы быть записаны за пределы буфера. Функция snprintf возвращает количество символов, которое было бы записано в буфер, если бы он имел достаточно
большой размер. Как и в случае с функцией sprintf, возвращаемое значение не
включает завершающий нулевой байт. Если snprintf возвращает положительное
значение, меньшее, чем размер буфера n, это означает, что строка полностью записана в буфер и не была усечена. Если возникает ошибка, функция snprintf возвращает отрицательное значение.
Хотя функция dprintf не принимает указатель на файл, мы включили ее в раздел с описанием остальных, родственных ей функций форматированного вывода.
Обратите внимание, что функция dprintf избавляет от необходимости вызывать
fdopen, чтобы преобразовать дескриптор файла в файловый указатель для использования в вызове функции fprintf.
Спецификация формата управляет порядком интерпретации и в конечном счете
отображением остальных аргументов. Каждый аргумент интерпретируется согласно спецификатору формата, который начинается с символа процента (%). Все
символы строки формата, за исключением спецификаторов, копируются без изменений. Спецификатор формата включает четыре необязательных компонента,
которые ниже показаны в квадратных скобках:
%[flags][fldwidth][precision][lenmodifier]convtype

Перечень возможных значений компонента flags приводится в табл. 5.5.
Таблица 5.5. Значения компонента flags строки спецификации формата
Флаг

Описание

‘

Апостроф, вывод целых чисел с выделением групп десятичных разрядов

-

Выравнивание по левому краю поля

+

Всегда отображать знак числа

(пробел)

Выводить пробел, если отсутствует знак числа

#

Преобразовать в альтернативную форму (например, включить префикс 0x
при выводе чисел в шестнадцатеричном формате)

0

Дополнять нулями слева вместо пробелов при выравнивании по правому краю

212    Глава 5. Стандартная библиотека ввода/вывода
Компонент fldwidth определяет минимальную ширину поля для преобразования.
Если в результате преобразования получено меньшее количество символов, они
будут дополнены пробелами. Ширина поля выражается положительным целым
числом или звездочкой (*).
Компонент precision определяет минимальное количество цифр для отображения целых чисел, минимальное количество цифр, расположенных правее десятичной точки, для чисел с плавающей точкой или максимальное количество символов
для отображения строк. Компонент precision представляется в виде точки (.), за
которой следует неотрицательное целое число или символ звездочки.
В полях fldwidth и  precision можно указать звездочку. В этом случае значение
компонента определяется целочисленным аргументом функции. Этот аргумент
должен стоять непосредственно перед аргументом, значение которого будет подвергнуто преобразованию.
Компонент lenmodifier определяет размер аргумента. Возможные значения приведены в табл. 5.6.
Таблица 5.6. Значения компонента lenmodifier строки спецификации формата
Модификатор длины

Описание

hh

signed char или unsigned char

h

signed short или unsigned short

l

signed long, unsigned long или многобайтный символ

ll

signed long long или unsigned long long

j

intmax_t или uintmax_t

z

size_t

t

ptrdiff_t

L

long double

Компонент convtype является обязательным. Он управляет интерпретацией аргумента. Различные виды преобразований приведены в табл. 5.7.
Обычно спецификаторы применяются к  аргументам в  порядке их следования
за аргументом format. Однако существует альтернативный синтаксис спецификаторов, позволяющий явно определять аргументы, к  которым они относятся:
последовательность %n$ представляет n-й аргумент. Но имейте в  виду, что эти
две формы записи спецификаторов нельзя смешивать в  одной строке формата.
Нумерация аргументов при использовании альтернативного синтаксиса определения формата начинается с единицы. Если значение для какого-либо из полей,
fldwidth или precision, определяется дополнительным аргументом, форма записи со звездочкой должна иметь вид: *m$, где m — порядковый номер аргумента
с требуемым значением.
Следующие пять разновидностей printf очень похожи на предыдущие, но в них
список аргументов переменной длины (...) заменен аргументом arg.

5.11. Форматированный ввод/вывод   

213

Таблица 5.7. Значения компонента convtype строки спецификации формата
Спецификатор

Описание

d, i

Десятичное число со знаком

o

Восьмеричное число без знака

u

Десятичное число без знака

x, X

Шестнадцатеричное число без знака

f, F

Число с плавающей точкой двойной точности

e, E

Число с плавающей точкой двойной точности, в экспоненциальной форме

g, G

Интерпретируется как f, F, e или E, в зависимости от значения интерпретируемого аргумента

a, A

Число с плавающей точкой двойной точности в шестнадцатеричной
экспоненциальной форме

c

Символ (с модификатором длины l — многобайтный символ)

s

Строка (с модификатором длины l — строка многобайтных символов)

p

Указатель типа void

n

Указатель на целое со знаком, куда записывается количество уже
выведенных символов

%

Символ %

C

Многобайтный символ (расширение XSI, эквивалент lc)

S

Строка многобайтных символов (расширение XSI, эквивалент ls)

#include <stdarg.h>
#include <stdio.h>
int vprintf(const char *restrict format, va_list arg);
int vfprintf(FILE *restrict fp, const char *restrict format,
va_list arg);
int vdprintf(int fd, const char *restrict format, va_list arg);

Все три возвращают количество выведенных символов в случае
успеха, отрицательное значение — в случае ошибки
int vsprintf(char *restrict buf, const char *restrict format,
va_list arg);

Возвращает количество символов, записанных в массив, в случае
успеха, отрицательное значение — в случае ошибки
int vsnprintf(char *restrict buf, size_t n,
const char *restrict format, va_list arg);

Возвращает количество символов, записанных в массив, если буфер
имеет достаточный размер, отрицательное значение — в случае ошибки

214    Глава 5. Стандартная библиотека ввода/вывода
Мы использовали функцию vsnprintf в функциях вывода сообщений об ошибках
(приложение B).
Описание особенностей обработки списков аргументов переменной длины в соответствии со стандартом ISO C вы найдете в разделе 7.3 [Kernighan and Ritchie,
1988]. Следует помнить, что средства обработки списков аргументов переменной
длины, определяемые стандартом ISO C, — заголовочный файл <stdarg.h> и связанные с  ним функции  — отличаются от функций <varargs.h>, которые предоставлялись старыми версиями UNIX.

Форматированный ввод
Форматированный ввод выполняется с  помощью трех функций из семейства
scanf.
#include <stdio.h>
int scanf(const char *restrict format, ...);
int fscanf(FILE *restrict fp, const char *restrict format, ...);
int sscanf(const char *restrict buf, const char *restrict format, ...);

Все три возвращают количество введенных элементов или EOF, если
возникла ошибка ввода или перед каким-либо преобразованием
достигнут конец файла
Функции семейства scanf используются для анализа входной строки и  преобразования последовательностей символов в переменные указанных типов. Аргументы, следующие за строкой формата, содержат адреса переменных, куда будут
записаны результаты преобразований.
Спецификация формата управляет порядком преобразования. Символ процента
(%) обозначает начало спецификатора формата. Все символы в строке формата, за
исключением спецификаторов формата и  пробелов, должны совпадать с  вводимыми символами. Если обнаружится какое-либо несоответствие, обработка ввода
остановится и остальная часть входной строки остается непрочитанной.
Спецификатор формата включает четыре необязательных компонента, которые
ниже показаны в квадратных скобках:
%[*][fldwidth][m][lenmodifier]convtype

Необязательный первый компонент с символом звездочки (*) используется для
подавления преобразования. Вводимая строка преобразуется согласно указанному формату, но результат преобразования не сохраняется.
Компонент fldwidth определяет максимальную ширину поля в  символах. Компонент lenmodifier  — размер аргумента, куда будет записан результат преобразования. Семейство функций scanf поддерживает те же модификаторы длины
(lenmodifier), что и семейство функций printf (табл. 5.6).

5.11. Форматированный ввод/вывод   

215

Компонент convtype подобен соответствующему компоненту спецификатора
формата функции printf, но между ними есть и некоторые отличия. Одно из них
состоит в том, что результат преобразования, который сохраняется как беззнаковый тип, может на входе быть числом со знаком. Например, число –1 будет преобразовано в 4 294 967 295 и записано в переменную беззнакового типа. В табл. 5.8
перечисляются типы преобразований, которые поддерживаются функциями семейства scanf.
Таблица 5.8. Значения компонента convtype строки спецификации формата
Спецификатор

Описание

d

Десятичное число со знаком, с основанием 10

i

Десятичное число со знаком, основание определяется форматом ввода

o

Восьмеричное число без знака (на входе может быть со знаком)

u

Десятичное число без знака, с основанием 10 (на входе может быть
со знаком)

x

Шестнадцатеричное число без знака (на входе может быть со знаком)

a, A, e, E, f, F,
g, G

Число с плавающей точкой

c

Символ (с модификатором длины l — многобайтный символ)

s

Строка (с модификатором длины l — строка многобайтных символов)

[

Начинает последовательность, состоящую только из указанных символов,
ограниченную символом ]

[^

Начинает последовательность любых символов, кроме указанных, ограниченную символом ]

p

Указатель типа void

n

Указатель на целое со знаком, куда записывается количество уже выведенных символов

%

Символ %

C

Многобайтный символ (расширение XSI, эквивалент lc)

S

Строка многобайтных символов (расширение XSI, эквивалент ls)

Необязательный символ m между полями fldwidth и lenmodifier называется символом выделения памяти при присваивании. Его можно использовать со спецификаторами %c, %s и %[, чтобы обеспечить выделение памяти для строки, полученной
в  результате преобразования. В  этом случае соответствующий аргумент должен
быть адресом указателя, куда будет скопирован адрес выделенного буфера. В случае успешного вызова вызывающий код должен по окончании использования буфера освободить выделенную таким способом память вызовом функции free.
Семейство функций scanf также поддерживает альтернативный синтаксис специ­
фикаторов формата, позволяющий явно определять аргументы, к  которым они
относятся: последовательность %n$ представляет n-й аргумент. Как и в функци-

216    Глава 5. Стандартная библиотека ввода/вывода
ях семейства printf, на один и тот же аргумент можно неоднократно ссылаться
в строке формата. Однако стандарт Single UNIX Specification отмечает, что поведение функций семейства scanf в этом случае не определено.
Аналогично семейству printf семейство scanf также включает функции, поддерживающие передачу списка аргументов в  виде переменной, как это определено
в заголовочном файле <stdarg.h>.
#include <stdarg.h>
#include <stdio.h>
int vscanf(const char *restrict format, va_list arg);
int vfscanf(FILE *restrict fp, const char *restrict format,
va_list arg);
int vsscanf(const char *restrict buf, const char *restrict format,
va_list arg);

Все три возвращают количество введенных элементов или EOF,
если возникла ошибка ввода или перед каким-либо преобразованием
достигнут конец файла
За дополнительной информацией о  функциях семейства scanf обращайтесь
к справочному руководству вашей системы UNIX.

5.12. Подробности реализации
Как уже упоминалось, функции стандартной библиотеки ввода/вывода в конечном итоге обращаются к функциям, описанным в главе 3. Каждому потоку ввода/
вывода соответствует дескриптор файла, который можно получить, обратившись
к функции fileno.
Обратите внимание, что функция fileno не определена стандартом ISO C — это расширение, поддерживаемое стандартом POSIX.1.
#include <stdio.h>
int fileno(FILE *fp);

Возвращает дескриптор файла, ассоциированный с потоком
Эта функция необходима, например, для вызова функции dup или fcntl.
Чтобы увидеть, как реализована стандартная библиотека ввода/вывода в вашей
системе, начните с заголовочного файла <stdio.h>. Здесь вы найдете определение
объекта FILE, флагов потока и  всех стандартных функций ввода/вывода, таких
как getc, которые определены как макросы. В разделе 8.5 [Kernighan and Ritchie,
1988] приводится пример, демонстрирующий особенности большинства реализаций в UNIX. В главе 12 [Plauger, 1992] вы найдете полные исходные тексты одной

5.12. Подробности реализации   

217

из реализаций стандартной библиотеки ввода/вывода. Кроме того, в  свободном
доступе имеется реализация стандартной библиотеки ввода/вывода GNU.

Пример
Программа в листинге 5.3 демонстрирует особенности буферизации для всех трех
стандартных потоков ввода/вывода и  для потока, ассоциированного с  обычным
файлом.
Листинг 5.3. Вывод сведений о буферизации для различных потоков ввода/вывода
#include "apue.h"
void
int
int
int

pr_stdio(const char *, FILE *);
is_unbuffered(FILE *);
is_linebuffered(FILE *);
buffer_size(FILE *);

int
main(void)
{
FILE

*fp;

fputs("введите любой символ\n", stdout);
if (getchar() == EOF)
err_sys("ошибка вызова функции getchar");
fputs("эта строка выводится в стандартный вывод сообщений об ошибках\n",
stderr);
pr_stdio("stdin", stdin);
pr_stdio("stdout", stdout);
pr_stdio("stderr", stderr);

}

if ((fp = fopen("/etc/passwd", "r")) == NULL)
err_sys("ошибка вызова функции fopen");
if (getc(fp) == EOF)
err_sys("ошибка вызова функции getc");
pr_stdio("/etc/passwd", fp);
exit(0);

void
pr_stdio(const char *name, FILE *fp)
{
printf("поток = %s, ", name);
if (is_unbuffered(fp))
printf("буферизация отсутствует");
else if (is_linebuffered(fp))
printf("построчная буферизация");
else /* ни один из вышеперечисленных режимов */
printf("полная буферизация");
printf(", размер буфера = %d\n", buffer_size(fp));
}
/*
* Следующий код непереносим.
*/
#if defined(_IO_UNBUFFERED)

218    Глава 5. Стандартная библиотека ввода/вывода
int
is_unbuffered(FILE *fp)
{
return(fp->_flags & _IO_UNBUFFERED);
}
int
is_linebuffered(FILE *fp)
{
return(fp->_flags & _IO_LINE_BUF);
}
int
buffer_size(FILE *fp)
{
return(fp->_IO_buf_end - fp->_IO_buf_base);
}
#elif defined(__SNBF)
int
is_unbuffered(FILE *fp)
{
return(fp->_flags & __SNBF);
}
int
is_linebuffered(FILE *fp)
{
return(fp->_flags & __SLBF);
}
int
buffer_size(FILE *fp)
{
return(fp->_bf._size);
}
#elif defined(_IONBF)
#ifdef _LP64
#define _flag __pad[4]
#define _ptr __pad[1]
#define _base __pad[2]
#endif
int
is_unbuffered(FILE *fp)
{
return(fp->_flag & _IONBF);
}
int
is_linebuffered(FILE *fp)
{
return(fp->_flag & _IOLBF);
}
int

5.12. Подробности реализации   

219

buffer_size(FILE *fp)
{
#ifdef _LP64
return(fp->_base - fp->_ptr);
#else
return(BUFSIZ); /* простая попытка угадать */
#endif
}
#else
#error неизвестная реализация stdio!
#endif

Обратите внимание: для каждого потока, перед выводом сведений о буферизации,
мы выполняем операцию ввода/вывода, поскольку размещение буферов в памяти
производится обычно во время первой операции ввода/вывода. Поля структуры
и константы, используемые в этом примере, определены в реализациях стандартной библиотеки ввода/вывода во всех четырех платформах, описываемых в этой
книге. Помните, что реализации стандартной библиотеки ввода/вывода могут
различаться в разных версиях UNIX, и программы, такие как в данном примере,
являются непереносимыми, потому что в них используются особенности конкретных реализаций.
Запустив программу дважды: один раз, когда все три стандартных потока ввода/
вывода были связаны с терминалом, и второй раз, когда они были перенаправлены в файлы, — мы получили следующие результаты:
$ ./a.out
введите любой символ

stdin, stdout и stderr связаны с терминалом

здесь мы ввели символ перевода строки
эта строка выводится в стандартный вывод сообщений об ошибках
поток = stdin, построчная буферизация, размер буфера = 1024
поток = stdout, построчная буферизация, размер буфера = 1024
поток = stderr, буферизация отсутствует, размер буфера = 1
поток = /etc/motd, полная буферизация, размер буфера = 4096
$ ./a.out < /etc/group > std.out 2> std.err
запустим еще раз с перенаправлением
трех стандартных потоков в файлы
$ cat std.err
эта строка выводится в стандартный вывод сообщений об ошибках
$ cat std.out
введите любой символ
поток = stdin, полная буферизация, размер буфера = 4096
поток = stdout, полная буферизация, размер буфера = 4096
поток = stderr, буферизация отсутствует, размер буфера = 1
поток = /etc/motd, полная буферизация, размер буфера = 4096

Как видите, в данной системе стандартные потоки ввода и вывода буферизуются
построчно, когда они связаны с терминалом. Размер буфера в этом случае составляет 1024 байта. Обратите внимание, что это не ограничивает размер вводимых и выводимых строк 1024 байтами — это лишь размер буфера. Для записи строки длиной
2048 байт в стандартный поток вывода потребуется два обращения к системному
вызову write. Когда эти два потока перенаправляются в обычные файлы, они при-

220    Глава 5. Стандартная библиотека ввода/вывода
обретают режим полной буферизации с размером буфера, равным предпочтительному размеру блока ввода/вывода (значение st_blksize структуры stat) для данной файловой системы. Также можно видеть, что стандартный поток сообщений об
ошибках не буферизуется ни в одном из случаев, как это и должно быть, и что по
умолчанию для обычных файлов назначается режим полной буферизации.

5.13. Временные файлы
Стандарт ISO C определяет две вспомогательные функции для создания временных файлов.
#include <stdio.h>
char *tmpnam(char *ptr);

Возвращает указатель на строку с уникальным именем файла
FILE *tmpfile(void);

Возвращает указатель на файл в случае успеха,
NULL — в случае ошибки
Функция tmpnam генерирует строку с уникальным полным именем файла, не существующего в данный момент в системе. При каждом вызове эта функция генерирует неповторяющиеся имена файлов до TMP_MAX раз. Константа TMP_MAX определена в файле <stdio.h>.
Стандарт ISO C определяет эту константу и требует, чтобы ее значение было не меньше 25. Стандарт Single UNIX Specification требует, чтобы XSI-совместимые системы
поддерживали константу TMP_MAX со значением не меньше 10  000. Это минимальное
значение позволяет использовать четыре цифры (0000–9999) для создания уникальных
имен файлов, но большинство реализаций UNIX используют для этих целей алфавитноцифровые символы.
В SUSv4 функция tmpnam отмечена как устаревшая, но стандарт ISO C продолжает
поддерживать ее.

Если аргумент ptr содержит значение NULL, генерируемое имя файла сохраняется в  статической области памяти и  функция возвращает указатель на эту область. Последующие вызовы функции tmpnam могут затереть эту область памяти.
(То есть если требуется вызвать функцию tmpnam более одного раза и каждый раз
сохранять имя временного файла, мы должны копировать сами строки, а не указатели на них.) Если в аргументе ptr передается непустой указатель, предполагается,
что он содержит адрес буфера размером не менее L_tmpnam символов. (Константа
L_tmpnam определена в файле <stdio.h>.) Сгенерированное имя файла сохраняется в этом буфере, и функция возвращает значение указателя ptr.
Функция tmpfile создает временный двоичный файл (wb+), который автоматически удаляется при его закрытии или по завершении процесса. В UNIX не имеет
никакого значения тот факт, что файл двоичный.

5.13. Временные файлы   

221

Пример
Программа в листинге 5.4 демонстрирует работу с обеими функциями.
Листинг 5.4. Демонстрация функций tmpnam и tmpfile
#include "apue.h"
int
main(void)
{
char
FILE

name[L_tmpnam], line[MAXLINE];
*fp;

printf("%s\n", tmpnam(NULL));

/* первое имя временного файла */

tmpnam(name);
printf("%s\n", name);

/* второе имя временного файла */

if ((fp = tmpfile()) == NULL)
/* создать временный файл */
err_sys("ошибка вызова функции tmpfile");
fputs("записанная строка\n", fp); /* записать во временный файл */
rewind(fp);
/* затем прочитать */
if (fgets(line, sizeof(line), fp) == NULL)
err_sys("ошибка вызова функции fgets");
fputs(line, stdout);
/* и вывести прочитанную строку */
}

exit(0);

Запустив программу из листинга 5.4, мы получили следующие результаты:
$ ./a.out
/tmp/fileT0Hsu6
/tmp/filekmAsYQ
записанная строка

Как правило, функция tmpfile использует следующий алгоритм: сначала вызовом tmpnam создается уникальное имя файла, затем создается сам файл, для которого сразу же вызывается функция unlink. В разделе 4.15 упоминалось, что вызов
функции unlink не приводит к немедленному удалению файла. Он будет удален
системой автоматически в момент закрытия или по завершении процесса.
Стандарт Single UNIX Specification определяет в  качестве расширений XSI две
дополнительные функции для работы с временными файлами, mkdtemp и mkstemp.
Прежние версии стандарта Single UNIX Specification определяли функцию tempnam как
способ создания временных файлов в каталоге, указанном вызывающей программой. В версии SUSv4 она отмечена как устаревшая.
#include <stdlib.h>
char *mkdtemp(char *template);

Возвращает указатель на имя каталога в случае успеха,
NULL — в случае ошибки
int mkstemp(char *template);

Возвращает дескриптор файла в случае успеха, –1 — в случае ошибки

222    Глава 5. Стандартная библиотека ввода/вывода
Функция mkdtemp создает каталог с  уникальным именем, а  функция mkstemp  —
обычный файл с  уникальным именем. Имя файла генерируется с  использованием строки шаблона template. Эта строка должна быть строкой пути, в которой
последние шесть символов должны быть XXXXXX. Функция заменит эти символы
другими, чтобы обеспечить уникальность имени. В случае успеха эти функции изменяют строку template, сохраняя в ней имя временного файла.
Функция mkdtemp создает каталог со следующими установленными битами прав
доступа: S_IRUSR | S_IWUSR | S_IXUSR. Имейте в  виду, что эти права могут быть
ограничены маской umask вызывающего процесса. В  случае успеха mkdtemp возвращает имя нового каталога.
Функция mkstemp создает обычный файл с уникальным именем и открывает его.
Файловый дескриптор, возвращаемый функцией mkstemp, открыт для чтения
и для записи. Файлы создаются со следующими установленными битами прав доступа: S_IRUSR | S_IWUSR.
В отличие от tmpfile, функция mkstemp создает временные файлы, которые не
удаляются автоматически. Если это необходимо, следует вручную вызвать функцию unlink.
Применение функций tmpnam и tempnam имеет как минимум один недостаток: между моментом, когда приложение получит уникальное имя файла, и моментом, когда оно создаст файл с этим именем, проходит некоторое время. В этот промежуток
другой процесс может создать файл с тем же именем. Вместо них следует использовать функции tmpfile и mkstemp, так как они не порождают такую ошибку.

Пример
Программа в листинге 5.5 демонстрирует, как следует (и как не следует) использовать функцию mkstemp.
Листинг 5.5. Использование функции mkstemp
#include "apue.h"
#include <errno.h>
void make_temp(char *template);
int
main()
{
char
char

}

good_template[] = "/tmp/dirXXXXXX"; /* правильно */
*bad_template = "/tmp/dirXXXXXX";
/* неправильно */

printf("попытка создать первый временный файл...\n");
make_temp(good_template);
printf("попытка создать второй временный файл...\n");
make_temp(bad_template);
exit(0);

void
make_temp(char *template)

5.14. Потоки ввода/вывода в памяти   

{

}

223

int
fd;
struct stat sbuf;
if ((fd = mkstemp(template)) < 0)
err_sys("ошибка создания временного файла");
printf("temp name = %s\n", template);
close(fd);
if (stat(template, &sbuf) < 0) {
if (errno == ENOENT)
printf("файл отсутствует\n");
else
err_sys("ошибка вызова stat");
} else {
printf("файл существует\n");
unlink(template);
}

Запустив эту программу, мы получили следующие результаты:
$ ./a.out
попытка создать первый временный файл...
temp name = /tmp/dirUmBT7h
файл существует
попытка создать второй временный файл...
Segmentation fault

Разница в  поведении обусловлена способом объявления двух строк шаблонов.
Первая строка шаблона размещается в стеке, потому что используется переменная-массив. Во втором случае используется указатель, и  только этот указатель
размещается в стеке, сама же строка размещается компилятором в сегменте кода,
доступном только для чтения. Когда mkstemp пытается изменить строку, возникает
ошибка доступа к памяти.

5.14. Потоки ввода/вывода в памяти
Как мы уже знаем, стандартная библиотека ввода/вывода буферизует данные
в памяти, что увеличивает эффективность операций посимвольного и построчного ввода/вывода. Мы также знаем, что с помощью функций setbuf и  setvbuf
можно передать библиотеке собственные буферы. В  версии 4 стандарта Single
UNIX Specification добавлена поддержка потоков ввода/вывода в  памяти
(memory streams). Это стандартные потоки ввода/вывода, которые не связаны
с файлами, хотя доступ к ним также осуществляется с применением файловых
указателей FILE. Все операции ввода/вывода с  такими потоками заключаются
в  передаче байтов в  буферы, находящиеся в  памяти, и  обратно. Как будет показано ниже, даже при том, что эти потоки напоминают файлы, они имеют некоторые особенности, которые делают их более подходящими для работы со
строками символов.
Создать поток ввода/вывода в памяти можно с помощью одной из трех функций.
Первая из них — fmemopen.

224    Глава 5. Стандартная библиотека ввода/вывода

#include <stdio.h>
FILE *fmemopen(void *restrict buf, size_t size,
const char *restrict type);

Возвращает указатель потока в случае успеха,
NULL — в случае ошибки
Функция fmemopen позволяет вызывающей программе передать буфер для использования в  качестве потока ввода/вывода в  памяти: аргумент buf указывает
на начало буфера, а аргумент size определяет размер буфера в байтах. Если в buf
передать пустой указатель, функция fmemopen выделит буфер размером size байтов. В этом случае буфер будет автоматически освобожден при закрытии потока.
Аргумент type определяет способ использования потока. Возможные значения аргумента type перечислены в табл. 5.9.
Таблица 5.9. Возможные значения аргумента type при открытии потока в памяти
type

Описание

r или rb

Открыть для чтения

w или wb

Открыть для записи

a или ab

Открыть для записи в конец, с первого нулевого байта

r+, или r+b, или rb+

Открыть для чтения и для записи

w+, или w+b, или wb+

Усечь размер до 0 или создать и открыть для чтения и для записи

a+, или a+b, или ab+

Открыть для записи в конец, открыть для чтения и для записи
с первого нулевого байта

Обратите внимание, что эти значения аналогичны значениям аргумента type
в  функциях открытия стандартных файловых потоков ввода/вывода, но имеют
некоторые тонкие отличия. Во-первых, когда поток в  памяти открывается для
запи­си в конец, текущая позиция в файле устанавливается в позицию первого нулевого байта в буфере. Если буфер не содержит нулевых байтов, текущей становится позиция предпоследнего байта в буфере. Если поток в памяти открывается
не для записи в  конец, текущая позиция устанавливается в  начало буфера. Поскольку в  режиме открытия для записи в  конец текущая позиция определяется
позицией первого нулевого байта, потоки ввода/вывода в памяти не очень хорошо
подходят для хранения двоичных данных (которые могут содержать нулевые байты внутри фактических данных).
Во-вторых, если в аргументе buf передается пустой указатель, бессмысленно открывать поток только для чтения или только для записи. Поскольку в этом случае
буфер создается самой функцией fmemopen, нет никакой возможности получить
адрес буфера, поэтому, открывая таким способом поток только для записи, вы никогда не сможете прочитать из него то, что было записано. Аналогично, открывая
поток только для чтения, вы сможете только читать содержимое буфера, в который никогда не сможете ничего записать.

5.14. Потоки ввода/вывода в памяти   

225

В-третьих, когда после записи в поток вызывается функция fclose, fflush, fseek,
fseeko или fsetpos, в текущую позицию всегда записывается нулевой байт.

Пример
Будет очень поучительно взглянуть, как операция записи в поток в памяти воздействует на буфер. Программа в  листинге 5.6 заполняет буфер определенным
шаблоном, позволяя посмотреть, как действует операция записи в поток.
Листинг 5.6. Исследование особенностей поведения операции записи в поток
#include "apue.h"
#define BSZ 48
int
main()
{
FILE *fp;
char buf[BSZ];
memset(buf, 'a', BSZ-2);
buf[BSZ-2] = '\0';
buf[BSZ-1] = 'X';
if ((fp = fmemopen(buf, BSZ, "w+")) == NULL)
err_sys("ошибка вызова fmemopen");
printf("первоначально буфер содержит: %s\n", buf);
fprintf(fp, "привет, мир");
printf("перед вызовом flush: %s\n", buf);
fflush(fp);
printf("после вызова fflush: %s\n", buf);
printf("длина строки в буфере = %ld\n", (long)strlen(buf));
memset(buf, 'b', BSZ-2);
buf[BSZ-2] = '\0';
buf[BSZ-1] = 'X';
fprintf(fp, "привет, мир");
fseek(fp, 0, SEEK_SET);
printf("после вызова fseek: %s\n", buf);
printf("длина строки в буфере = %ld\n", (long)strlen(buf));
memset(buf, 'c', BSZ-2);
buf[BSZ-2] = '\0';
buf[BSZ-1] = 'X';
fprintf(fp, "привет, мир");
fclose(fp);
printf("после вызова fclose: %s\n", buf);
printf("длина строки в буфере = %ld\n", (long)strlen(buf));
}

return(0);

Запустив программу в Linux, мы получили следующее:
$ ./a.out
первоначально буфер содержит:
перед вызовом flush:

буфер заполняется символами ‘a’
fmemopen поместила нулевой байт в начало буфера
буфер не изменится, пока поток не будет сброшен

226    Глава 5. Стандартная библиотека ввода/вывода
после вызова fflush: привет, мир
длина строки в буфере = 11
в конец строки добавлен нулевой байт
теперь буфер заполнен символами ‘b’
после вызова fseek: bbbbbbbbbbbпривет, мир
fseek вызывает сброс
длина строки в буфере = 22
снова добавлен нулевой байт
теперь буфер заполнен символами ‘c’
после вызова fclose: привет, мирccccccccccccccccccccccccccccccccccc
длина строки в буфере = 46
нулевой байт не добавляется

Этот пример наглядно демонстрирует, как при сбросе потока добавляются нулевые байты. Нулевой байт добавляется автоматически всякий раз, когда производится запись в  поток, для поддержки представления о  размере содержимого
потока (в противоположность размеру буфера, который имеет фиксированное
значение). Размер содержимого потока позволяет определить, как много данных
записано в него.
Из всех четырех платформ, описываемых в книге, только Linux 3.2.0 поддерживает потоки
в памяти. Это показывает, что не все реализации успевают за последними стандартами,
но должны будут измениться со временем.

Двумя другими функциями, с помощью которых можно создавать потоки в памяти, являются open_memstream и open_wmemstream.
#include <stdio.h>
FILE *open_memstream(char **bufp, size_t *sizep);
#include <wchar.h>
FILE *open_wmemstream(wchar_t **bufp, size_t *sizep);

Обе возвращают указатель потока в случае успеха,
NULL — в случае ошибки
Функция open_memstream создает поток для работы с данными на уровне байтов,
а  open_wmemstream  — для работы с  данными на уровне многобайтных символов
(обсуждение многобайтных символов можно найти в разделе 5.2). Эти две функции имеют следующие отличия от fmemopen:
 Создаваемый поток открывается только для записи.
 Функциям нельзя передать свой буфер, но можно получить доступ к буферу
и его размеру через аргументы bufp и sizep соответственно.
 После закрытия потока буфер должен освобождаться вручную.
 Буфер будет расти в размерах по мере добавления новых байтов в поток.
При использовании значений, определяющих адрес и размер буфера, необходимо
следовать определенным правилам. Во-первых, адрес и длина буфера могут использоваться только после вызова fclose или fflush. Во-вторых, эти значения остаются
действительными только до следующей операции записи в поток или вызова fclose
или fflush. Поскольку буфер автоматически увеличивается в размерах, память для
него может перераспределяться. В этом случае можно обнаружить, что после вызова fclose или fflush значение адреса буфера в памяти изменилось.

5.15. Альтернативы стандартной библиотеке ввода/вывода   

227

Потоки в памяти хорошо подходят для создания строк, потому что не подвержены ошибке переполнения буфера. Они могут также способствовать увеличению
производительности функций, принимающих стандартные потоки ввода/вывода
для хранения временных данных, потому что хранятся в оперативной памяти, а не
в файлах на диске.

5.15. Альтернативы стандартной библиотеке
ввода/вывода
Стандартная библиотека ввода/вывода несовершенна. В книге [Korn and Vo, 1991]
перечисляются ее многочисленные недостатки, часть которых присуща базовой
архитектуре, но большая часть связана с различными аспектами реализации.
Один из врожденных недостатков стандартной библиотеки ввода/вывода, снижающий ее эффективность, заключается в большом количестве операций копирования данных. При использовании функций построчного ввода/вывода, fgets
и fputs, данные обычно копируются дважды: один раз — между ядром и буфером
ввода/вывода (то есть при вызове функций read и  write) и второй раз — между
буфером ввода/вывода и строкой. Библиотека скоростного ввода/вывода (fio(3)
в [AT&T, 1990a]) обходит этот недостаток за счет того, что функция, которая читает строку, возвращает указатель на нее, а  не копирует строку в  другой буфер.
В  [Hume, 1988] говорится, что таким образом можно в  три раза увеличить скорость работы утилиты grep(1).
В [Korn and Vo, 1991] описывается другая альтернатива стандартной библиотеке ввода/вывода — sfio. Этот пакет почти не уступает в скорости библиотеке fio
и  обычно гораздо эффективнее стандартной библиотеки ввода/вывода. Кроме
того, пакет sfio реализует некоторые функциональные возможности, недоступные
в  других библиотеках: потоки ввода/вывода более универсальны и  могут представлять как файлы, так и  области памяти; операции с  потоками ввода/вывода
можно изменять за счет подключения дополнительных модулей; улучшена обработка исключительных ситуаций.
В [Krieger, Stumm, and Unrau, 1992] рассматривается другая альтернатива — с использованием файлов, отображаемых в  память с  помощью функции mmap (она
описана в разделе 14.8). Этот пакет называется ASI, Alloc Stream Interface (интерфейс размещения потоков). Программный интерфейс очень напоминает функции
распределения памяти, используемые в UNIX (malloc, realloc и free, которые мы
рассмотрим в разделе 7.8). Как и пакет sfio, ASI старается минимизировать количество операций копирования за счет использования указателей.
Существуют реализации стандартной библиотеки ввода/вывода, спроектированные для систем с небольшими объемами памяти, таких как встраиваемые устройства. Скромное потребление памяти — их сильная сторона, в то время как переносимости, скорости или функциональным возможностям в них уделяется меньше
внимания. В  качестве примеров таких реализаций можно назвать библиотеку
uClibc (за подробной информацией обращайтесь по адресу http://www.uclibc.org)
и библиотеку Newlib (http://sources.redhat.com/newlib).

228    Глава 5. Стандартная библиотека ввода/вывода

5.16. Подведение итогов
Стандартная библиотека ввода/вывода используется в  большинстве приложений UNIX. Мы рассмотрели все функции, предоставляемые этой библиотекой,
а также некоторые особенности ее реализации и вопросы эффективности. Самое
главное — никогда не забывайте о буферизации, поскольку именно в связи с ней
возникает больше всего проблем и недопонимания.

Упражнения
5.1	

Напишите реализацию функции setbuf с использованием функции setvbuf.

5.2	

Измените программу в  листинге 5.2, которая копирует файл с  помощью
функций построчного ввода/вывода (fgets и fputs), так, чтобы вместо константы MAXLINE использовалось значение 4. Что произойдет, если попытаться скопировать файл, в котором длина строк превышает 4 байта? Объясните почему.

5.3	

О чем говорит значение 0, возвращаемое функцией printf?

5.4	

Следующий код корректно работает в одних системах и некорректно в других. В чем причина такого поведения?
#include <stdio.h>
int
main(void)
{
char

}

c;

while ((c = getchar()) != EOF)
putchar(c);

5.5	

Как можно использовать функцию fsync (раздел 3.13) с потоками ввода/
вывода?

5.6	

В программах из листингов 1.5 и 1.8 строка приглашения не содержит символа перевода строки, и мы не вызываем функцию fflush. Почему тогда она
выводится на экран?

5.7	

В BSD-системах имеется функция funopen, позволяющая перехватывать
операции чтения, записи, позиционирования и закрытия потоков. На основе этой функции реализуйте функцию fmemopen для FreeBSD и Mac OS X.

6

Информация о системе
и файлы данных

6.1. Введение
Нормальное функционирование любой UNIX-системы требует наличия различных файлов данных. Файл паролей /etc/passwd и  файл групп /etc/group очень
часто используются в самых разных приложениях. Например, обращение к файлу
паролей происходит всякий раз, когда пользователь входит в систему или когда
кто-либо выполняет команду ls -l.
Исторически эти файлы содержат простой текст в  формате ASCII и  их можно
прочитать с помощью стандартной библиотеки ввода/вывода. Но в больших системах последовательный просмотр записей в  файле паролей может требовать
довольно много времени. Имело бы смысл хранить эти данные в формате, отличном от ASCII, но при этом необходим интерфейс для прикладных программ, который мог бы работать с любым форматом. Переносимые интерфейсы для доступа
к  этим файлам  — тема данной главы. Кроме того, мы рассмотрим функции для
получения информации о системе и функции даты и времени.

6.2. Файл паролей
Файл паролей в UNIX, который стандарт POSIX.1 называет базой данных пользователей, содержит поля, перечисленные в  табл. 6.1. Эти поля также имеются
в структуре passwd, которая определена в заголовочном файле <pwd.h>.
Обратите внимание, что стандарт POSIX.1 определяет только пять из десяти полей
структуры passwd. Большинство платформ поддерживают как минимум семь полей.
Системы, производные от BSD, поддерживают все десять.

Традиционно файл паролей хранится под именем /etc/passwd и представляет собой обычный текстовый файл в  формате ASCII. Каждая строка файла состоит
из полей (см. табл. 6.1), разделенных двоеточием. Для примера приведем четыре
строки из файла /etc/passwd в Linux:
root:x:0:0:root:/root:/bin/bash
squid:x:23:23::/var/spool/squid:/dev/null
nobody:x:65534:65534:Nobody:/home:/bin/sh
sar:x:205:105:Stephen Rago:/home/sar:/bin/bash

230    Глава 6. Информация о системе и файлы данных
Таблица 6.1. Поля в файле /etc/passwd
Описание

Поле структуры
passwd

POSIX.1

FreeBSD
8.0

Linux
3.2.0

Mac OS X
10.6.8

Solaris
10



















Имя пользователя

char *pw_name

Зашифрованный
пароль

char *pw_passwd

Числовой идентификатор пользователя

uid_t pw_uid











Числовой идентификатор группы

gid_t pw_gid











Поле комментария

char *pw_gecos









Начальный рабочий
каталог

char *pw_dir











Командный интерпретатор

char *pw_shell











Класс доступа пользователя

char *pw_class





Время следующего
изменения пароля

time_t pw_change





Время истечения действия учетной записи

time_t pw_expire





Обратите внимание на следующие обстоятельства.
 Как правило, в файле паролей имеется запись для пользователя с именем root.
Этот пользователь имеет числовой идентификатор 0 (суперпользователь).
 Поле зашифрованного пароля содержит единственный символ-заполнитель.
Старые версии UNIX хранили в этом поле зашифрованный пароль. Поскольку
хранение даже зашифрованных паролей в файле, доступном для чтения всем
пользователям, представляет угрозу безопасности, современные системы хранят зашифрованные пароли в  другом месте. Мы подробнее рассмотрим этот
вопрос в следующем разделе, когда будем обсуждать пароли.
 Некоторые поля могут быть пустыми. Так, если поле зашифрованного пароля
не заполнено, это означает, что у пользователя нет пароля (что не рекомендуется). Запись для пользователя squid имеет одно пустое поле — поле комментария. Пустое поле комментария не оказывает никакого эффекта.
 Поле командного интерпретатора содержит имя выполняемого файла программы, которая используется в  качестве командной оболочки при входе
пользователя в  систему. Если поле пустое, для него выбирается значение по
умолчанию /bin/sh. Однако отметьте, что для пользователя squid в качестве
командного интерпретатора используется устройство /dev/null. Очевидно,
что оно не является выполняемым файлом, — это предотвращает возможность
входа в систему под именем squid для кого бы то ни было.

6.2. Файл паролей   

231

Многие процессы-демоны, предоставляющие различные службы, имеют собственные
идентификаторы пользователей (глава 13). Так, учетная запись squid предназначена для
процессов, которые предоставляют услуги кэширующего прокси-сервера squid.

 Использование псевдоустройства /dev/null — не единственный способ воспрепятствовать конкретному пользователю войти в  систему. Не менее часто
в  роли командного интерпретатора используется программа /bin/false. Она
просто возвращает признак ошибки (ненулевое значение); оболочка расценивает этот код завершения как ложь. Также нередко для отключения учетной записи используется команда /bin/true. Она всегда возвращает признак успешного завершения (нулевое значение). В некоторых системах имеется команда
nologin. Она выводит заданное сообщение об ошибке и возвращает код завершения, отличный от нуля.
 Имя пользователя nobody применяется с целью дать возможность кому-либо
войти в систему, но с идентификатором пользователя 65534 и идентификатором группы 65534, которые не дают никаких привилегий. Такой пользователь
сможет получить доступ лишь к тем файлам, которые доступны на чтение или
на запись для всех. (Это предполагает отсутствие в системе файлов, принадлежащих пользователю с идентификатором 65534 или группе с идентификатором 65534.)
 Некоторые системы, имеющие команду finger(1), поддерживают включение
дополнительной информации в  поле комментария. Дополнительные поля
в поле комментария отделяются друг от друга запятой и содержат реальное
имя пользователя, место работы, номера рабочего и  домашнего телефонов.
Кроме того, некоторые утилиты заменяют амперсанд (&) в поле комментария
именем пользователя (в верхнем регистре). Например, представьте такую
учетную запись:
sar:x:205:105:Steve Rago, SF 5-121, 555-1111, 555-2222:/home/sar:/bin/sh

В этом случае утилита finger выведет следующую информацию о пользователе Steve Rago:
$ finger -p sar
Login: sar Name:
Directory: /home/sar
Office: SF 5-121, 555-1111
On since Mon Jan 19 03:57 (EST)
No Mail.

Steve Rago
Shell: /bin/sh
Home Phone: 555-2222
on ttyv0 (messages off)

Даже если система не поддерживает команду finger, ничто не мешает включать дополнительную информацию в  поле комментария, поскольку это поле
никак не интерпретируется системными утилитами.
В некоторых системах администратору доступна команда vipw, предназначенная
для редактирования файла паролей. Команда vipw производит сериализацию изменений в  файле паролей и  обеспечивает согласование внесенных изменений
с данными, хранящимися в дополнительных файлах. Многие системы предоставляют подобные возможности через графический интерфейс.

232    Глава 6. Информация о системе и файлы данных
Стандарт POSIX.1 определяет всего две функции для доступа к отдельным учетным записям в файле паролей. Эти функции позволяют найти учетную запись по
числовому идентификатору или имени пользователя.
#include <pwd.h>
struct passwd *getpwuid(uid_t uid);
struct passwd *getpwnam(const char *name);

Обе возвращают указатель в случае успеха, NULL — в случае ошибки
Функция getpwuid используется утилитой ls(1) для преобразования числового
идентификатора, хранящегося в  индексном узле, в  имя пользователя. Функция
getpwnam используется утилитой login(1), когда пользователь вводит свое имя
при входе в систему.
Обе функции возвращают указатель на заполненную структуру passwd. Эта структура обычно является статической переменной, расположенной в области памяти
функции; в результате ее содержимое перезаписывается при каждом обращении
к функции.
Эти две функции удобно использовать для получения сведений о  конкретном
пользователе по его имени или числовому идентификатору, однако некоторым
программам может потребоваться просмотреть весь файл паролей. Для этого
предназначены следующие три функции.
#include <pwd.h>
struct passwd *getpwent(void);

Возвращает указатель в случае успеха,
NULL — в случае ошибки или по достижении конца файла
void setpwent(void);
void endpwent(void);

Эти три функции не включены в базовый стандарт POSIX.1, а определены как расширения
XSI в Single UNIX Specification. Поэтому предполагается, что все версии UNIX должны
их поддерживать.

Функция getpwent возвращает следующую запись из файла паролей. Как и предыдущие две, getpwent возвращает указатель на заполненную структуру passwd.
Содержимое структуры обычно перезаписывается при каждом вызове функции.
Первый вызов функции открывает все необходимые файлы. Порядок, в котором
возвращаются записи, заранее не определен — они могут следовать в любом порядке, потому что некоторые системы используют хешированную версию файла
/etc/passwd.

6.3. Теневые пароли   

233

Функция setpwent переходит в начало каждого из используемых файлов, а функция endpwent закрывает файлы. По окончании работы с  getpwent всегда следует
закрывать файлы вызовом endpwent. Функция getpwent в состоянии определить,
когда нужно открывать файлы (при первом обращении к ней), но она не может
определить момент окончания работы с файлом паролей.

Пример
В листинге 6.1 показана реализация функции getpwnam.
Листинг 6.1. Функция getpwnam
#include <pwd.h>
#include <stddef.h>
#include <string.h>
struct passwd *
getpwnam(const char *name)
{
struct passwd *ptr;

}

setpwent();
while ((ptr = getpwent()) != NULL)
if (strcmp(name, ptr->pw_name) == 0)
break; /* совпадение найдено */
endpwent();
return(ptr); /* вернет NULL в ptr, если совпадение не найдено */

Обращение к  функции setpwent в  самом начале  — это мера предосторожности;
мы просто выполняем переход в начало файла на тот случай, если вызывающая
программа уже открыла его вызовом функции getpwent. Функция endpwent вызывается по окончании работы потому, что ни getpwnam, ни getpwuid не должны
оставлять файлы открытыми.

6.3. Теневые пароли
Зашифрованный пароль  — это пароль пользователя, пропущенный через односторонний алгоритм шифрования. Поскольку алгоритм является односторонним,
невозможно получить оригинальный пароль, имея его зашифрованную версию.
Традиционно этот алгоритм (см. [Morris and Thompson, 1979]) генерирует 13 печатных символов из 64-символьного набора [a-zA-Z0-9./]. Некоторые современные системы используют для шифрования паролей алгоритм MD5 или SHA-1,
который генерирует более длинную последовательность символов. (Чем больше
символов используется для хранения зашифрованного пароля, тем больше возможных комбинаций и тем сложнее будет подобрать истинный пароль простым
перебором вариантов.) Если в  поле зашифрованного пароля поместить единственный символ, зашифрованный пароль гарантированно никогда не будет совпадать с этим значением.

234    Глава 6. Информация о системе и файлы данных
Нет алгоритма, который можно было бы применить к  зашифрованному паролю
и получить простой текст. (Пароль в виде простого текста — это тот набор символов, который мы вводим в ответ на приглашение Password:.) Однако пароль можно
подобрать, перебирая различные комбинации символов, пропуская их через односторонний алгоритм шифрования и сравнивая полученные результаты с зашифрованной версией пароля. Если бы пароли пользователей представляли собой набор
случайных символов, такой метод был бы не очень удачным решением. Но пользователи стремятся выбирать пароли не случайным образом, нередко в этом качестве
они используют имена супругов, названия улиц или клички домашних животных.
Это облегчает задачу любому, кто получил в свои руки копию файла паролей и пытается вычислить их. (Глава 4 книги [Garfinkel et al., 2003] содержит дополнительные сведения о паролях и о схеме шифрования, используемой в UNIX.)
Чтобы затруднить доступ к зашифрованным паролям, современные системы хранят их в другом файле, который часто называют теневым файлом паролей (shadow
password file). Этот файл должен содержать как минимум имена пользователей
и  зашифрованные пароли. Здесь также хранится другая информация, имеющая
отношение к паролям (табл. 6.2).
Таблица 6.2. Поля записей в файле /etc/shadow
Описание

Поле структуры spwd

Имя пользователя

char *sp_namp

Зашифрованный пароль

char *sp_pwdp

Время последнего изменения пароля в днях от начала Эпохи

int sp_lstchg

Минимальный период в днях между изменениями пароля

int sp_min

Максимальный период в днях между изменениями пароля

int sp_max

Количество дней до истечения срока действия пароля, в течение
которых пользователь будет предупреждаться о необходимости
его изменения

int sp_warn

Количество дней, когда учетная запись не использовалась

int sp_inact

Время отключения учетной записи в днях от начала Эпохи

int sp_expire

Резерв

unsigned int sp_flag

Обязательными являются только два поля  — имя пользователя и  зашифрованный пароль. Другие поля хранят информацию о том, как часто должен изменяться
пароль и как долго будет оставаться активной учетная запись.
Теневой файл паролей не должен быть доступен на чтение для всех. Доступ к нему
должны иметь лишь несколько программ, например login(1) и  passwd(1). Часто
владельцем таких программ является суперпользователь и для них устанавливается бит set-user-ID. При использовании теневых паролей обычный файл паролей, /etc/passwd, может быть доступен для чтения любому.
В Linux 3.2.0 и  Solaris 10 для доступа к  теневому файлу паролей предусмотрен
отдельный набор функций, очень похожих на те, что используются для работы
с обычным файлом паролей.

6.4. Файл групп   

235

#include <shadow.h>
struct spwd *getspnam(const char *name);
struct spwd *getspent(void);

Обе возвращают указатель в случае успеха, NULL — в случае ошибки
void setspent(void);
void endspent(void);

В FreeBSD 8.0 и Mac OS X 10.6.8 теневой файл паролей отсутствует1, а вся дополнительная информация хранится в обычном файле паролей (см. табл. 6.1).

6.4. Файл групп
Файл групп UNIX, называемый в стандарте POSIX.1 базой данных групп, содержит поля, перечисленные в табл. 6.3. Значения этих полей хранятся в структуре
group, определенной в файле <grp.h>.
Таблица 6.3. Поля в файле /etc/group
Описание

Поле структуры
group

POSIX.1

FreeBSD
8.0

Linux
3.2.0

Mac OS X
10.6.8

Solaris
10



















Имя группы

char *gr_name

Зашифрованный пароль

char *gr_passwd

Числовой идентификатор группы

int gr_gid











Массив указателей на
отдельные имена пользователей

char **gr_mem











Поле gr_mem — это массив указателей на имена пользователей, входящих в состав
группы. Этот массив завершается пустым указателем.
Для поиска имени группы или ее числового идентификатора в файле групп стандарт POSIX.1 определяет следующие две функции.
#include <grp.h>
struct group *getgrgid(gid_t gid);
struct group *getgrnam(const char *name);

Обе возвращают указатель в случае успеха, NULL — в случае ошибки
	В BSD-системах функцию файла теневых паролей выполняет файл /etc/master.passwd.
По формату он аналогичен файлу passwd, но содержит зашифрованный пароль. Подробнее см. в разделе 6.6. — Примеч. пер.

1

236    Глава 6. Информация о системе и файлы данных
Как и  в  случае с  файлом паролей, обе функции обычно возвращают указатель
на статическую переменную, которая перезаписывается при каждом обращении
к функциям.
Чтобы произвести поиск по всему файлу групп, потребуются некоторые дополнительные функции. Следующие три функции напоминают те, что используются
для работы с файлом паролей.
#include <grp.h>
struct group *getgrent(void);

Возвращает указатель в случае успеха,
NULL — в случае ошибки или по достижении конца файла
void setgrent(void);
void endgrent(void);

Эти три функции не включены в базовый стандарт POSIX.1. Они определены как расширения XSI в Single UNIX Specification и предоставляются всеми версиями UNIX.

Функция setgrent открывает файл групп, если он еще не был открыт, и переходит
в его начало. Функция getgrent читает очередную запись из файла групп, предварительно открыв его, если он еще не был открыт. Функция endgrent закрывает
файл групп.

6.5. Идентификаторы дополнительных групп
Правила использования групп в  UNIX существенно изменились за прошедшее
время. Так, в Version 7 каждый пользователь в конкретный момент времени мог
принадлежать только к  одной группе. После входа в  систему пользователю назначался реальный идентификатор группы, соответствующий числовому идентификатору группы из записи в  файле паролей. Пользователь в  любой момент
мог изменить свою принадлежность к группе с помощью утилиты newgrp(1). Если
команда newgrp завершалась успехом (за информацией о  правилах назначения
прав доступа обращайтесь к справочному руководству), реальный идентификатор
группы заменялся идентификатором новой группы, который затем использовался
во всех последующих проверках прав доступа к файлам. Пользователь всегда мог
вернуться к первоначальной группе, запустив команду newgrp без параметров.
Такая практика сохранялась до тех пор, пока не была изменена в версии 4.2BSD
(около 1983 года). Начиная с  версии 4.2BSD, появилось понятие идентификаторов дополнительных групп. Теперь пользователь мог принадлежать к группе,
идентификатор которой указан в учетной записи в файле паролей, и входить в состав до 16 дополнительных групп. Проверки прав доступа к файлам изменились
так, чтобы проверялся не только эффективный идентификатор группы, но и все
идентификаторы дополнительных групп.

6.5. Идентификаторы дополнительных групп   

237

Дополнительные группы — обязательная для реализации функциональная особенность
в соответствии со стандартом POSIX.1. (В ранних версиях POSIX.1 она была необязательной.) Константа NGROUPS_MAX (см. табл. 2.8) определяет количество идентификаторов
дополнительных групп. Наиболее часто встречающееся значение — 16 (см. табл. 2.13).

Преимущество дополнительных групп состоит в  том, что пользователю больше
не нужно явно изменять свою принадлежность к группе. Членство в нескольких
группах одновременно стало самым обычным делом (например, участие в разработке нескольких проектов).
Для получения и изменения идентификаторов дополнительных групп предназначены следующие три функции.
#include <unistd.h>
int getgroups(int gidsetsize, gid_t grouplist[]);

Возвращает количество дополнительных групп в случае успеха,
–1 — в случае ошибки
#include <grp.h>
/* в Linux */
#include <unistd.h> /* в FreeBSD, Mac OS X и Solaris */
int setgroups(int ngroups, const gid_t grouplist[]);
#include <grp.h>
/* в Linux и Solaris */
#include <unistd.h> /* в FreeBSD и Mac OS X */
int initgroups(const char *username, gid_t basegid);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Из этих трех функций только getgroups определена стандартом POSIX.1. Функции
setgroups и initgroups не вошли в стандарт, поскольку относятся к разряду привилегированных операций. Однако четыре платформы, рассматриваемые в данной книге, поддерживают все три функции. В Mac OS X 10.6.8 аргумент basegid объявлен с типом int.

Функция getgroups заполняет массив grouplist идентификаторами дополнительных групп. В массив будет записано до gidsetsize элементов. Количество идентификаторов, записанных в  массив, передается в  вызывающую программу в  виде
возвращаемого значения.
Если в аргументе gidsetsize передается 0, функция возвращает только количество
дополнительных групп. Массив grouplist не изменяется. (Это позволяет вызывающей программе определить размер массива grouplist перед его размещением в динамической памяти.)
Функция setgroups может вызываться только суперпользователем для изменения списка идентификаторов дополнительных групп вызывающего процесса:
в этом случае grouplist содержит массив идентификаторов групп, а ngroups — количество элементов в массиве. Значение ngroups не должно превышать константу
NGROUPS_MAX.

238    Глава 6. Информация о системе и файлы данных
Единственное практическое применение функции setgroups — вызов из функции
initgroups, которая читает файл групп с помощью getgrent, setgrent и  endgrent
и определяет группы, к которым принадлежит username. После этого она вызывает setgroups, чтобы инициализировать список идентификаторов дополнительных
групп пользователя. Чтобы вызвать функцию initgroups, процесс должен обладать привилегиями суперпользователя, так как она вызывает функцию setgroups.
В  дополнение ко всем найденным группам, к  которым принадлежит username,
initgroups также включает в  список идентификаторов дополнительных групп
и  значение basegid, где basegid  — идентификатор группы, взятый из записи для
username в файле паролей.
Функция initgroups используется немногими программами, в качестве примера
можно упомянуть утилиту login(1), которая вызывает initgroups, когда пользователь входит в систему.

6.6. Различия реализаций
Мы уже рассмотрели теневой файл паролей, который поддерживается в  Linux
и  Solaris. Системы FreeBSD и  Mac OS X хранят зашифрованные пароли иначе.
В табл. 6.4 обобщены сведения о том, как четыре платформы, обсуждаемые в данной книге, хранят информацию о пользователях и группах.
Таблица 6.4. Различия в реализации хранения учетных записей
Информация

FreeBSD 8.0

Linux 3.2.0

Mac OS X
10.6.8

Solaris 10

Учетные записи

/etc/passwd

/etc/passwd

Служба
каталогов

/etc/passwd

Зашифрованные пароли

/etc/master.passwd

/etc/shadow

Служба
каталогов

/etc/shadow

Наличие хешированных
файлов паролей

Да

Нет

Нет

Нет

Информация о группах

/etc/group

/etc/group

Служба
каталогов

/etc/group

В ОС FreeBSD теневой файл паролей хранится под именем /etc/master.passwd.
Для редактирования этого файла используются специальные команды, которые,
в свою очередь, генерируют файл /etc/passwd на основе теневого файла паролей.
Кроме того, создаются хешированные версии файлов: /etc/pwd.db  — хешированная версия файла /etc/passwd, и  /etc/spwd.db  — хешированная версия файла /etc/master.passwd. Они обеспечивают более высокую производительность
в крупных системах.
Однако в  Mac OS X файлы /etc/passwd и  /etc/master.passwd используются
только в  однопользовательском режиме (когда администратор проводит обслуживание системы; однопользовательский режим обычно означает, что системные
службы не запущены). В нормальном, то есть многопользовательском, режиме доступ к информации о пользователях и группах обеспечивает служба каталогов.

6.7. Прочие файлы данных   

239

Хотя Linux и  Solaris поддерживают схожие интерфейсы теневых паролей, в  их
реа­лизации все же имеются некоторые отличия. Например, в Solaris целочисленные поля (см. табл. 6.2) определены с  типом int, а  в  Linux  — с  типом long int.
Другое отличие — поле, где подсчитывается период, в течение которого учетная
запись оставалась неактивной. В Solaris это поле обозначает количество дней, прошедших с момента последнего входа пользователя в систему, тогда как в Linux —
это количество дней, оставшихся до окончания максимального срока действия
существующего пароля.
Во многих системах базы данных пользователей и групп реализованы с использованием сетевой информационной службы (Network Information Service, NIS). Это
позволяет администраторам редактировать эталонные копии баз данных и  распространять их автоматически по всем серверам в организации. Клиентские системы соединяются с серверами и получают от них необходимые сведения о пользователях и группах. Аналогичные функциональные возможности предоставляют
NIS+ и  LDAP (Lightweight Directory Access Protocol  — облегченный протокол
доступа к каталогам). В большинстве систем метод администрирования каждого
вида информации контролируется с  помощью конфигурационного файла /etc/
nsswitch.conf.

6.7. Прочие файлы данных
До сих пор обсуждались только два файла системных данных: файл паролей
и  файл групп. В  своей повседневной работе UNIX-системы используют множество других файлов. Например, для поддержки сетевых взаимодействий платформы BSD используют файлы /etc/services (перечень служб, предоставляемых
серверами сети), /etc/protocols (перечень сетевых протоколов) и  /etc/networks
(список сетей). К счастью, интерфейсы для работы с этими файлами похожи на те,
что используются для доступа к файлам паролей и групп.
Эти интерфейсы следуют одному общему принципу — для работы с каждым файлом предоставляется по меньшей мере три функции.
1.	 Функция get читает следующую запись, открывая файл при необходимости.
Эти функции обычно возвращают указатель на структуру. Если достигнут конец файла, возвращается пустой указатель. Большинство функций get возвращают указатель на структуру, размещенную статически, поэтому мы должны
скопировать ее содержимое, чтобы сохранить для последующего использования.
2.	 Функция set открывает файл, если он еще не открыт, и  переходит в  начало.
Эта функция используется, если по каким-то причинам необходимо вернуться
в начало файла.
3.	 Функция end закрывает файл данных. Как уже упоминалось выше, она всегда
должна вызываться по завершении работы с файлом.
Кроме того, если файл данных поддерживает тот или иной вид поиска по ключу, предусматриваются функции, которые выполняют такой поиск. Например,

240    Глава 6. Информация о системе и файлы данных
для файла паролей имеются две функции: getpwnam ищет запись с определенным
именем пользователя и  getpwuid ищет запись с определенным идентификатором
пользователя.
В табл. 6.5 перечислены некоторые функции для работы с файлами данных, обычные для систем UNIX. В эту таблицу включены функции для работы с файлами
паролей и  групп, которые рассматривались ранее в  этой главе, и  некоторые из
функций поддержки сети. Перечислены все функции get, set и end для всех файлов данных, упомянутых в таблице.
Таблица 6.5. Функции для работы с системными файлами данных
Описание

Файл

Заголовочный
файл

Структура

Дополнительные
функции поиска

Пароли

/etc/passwd

<pwd.h>

passwd

getpwnam, getpwuid

Группы

/etc/group

<grp.h>

group

getgrnam, getgrgid

Теневой файл паролей

/etc/shadow

<shadow.h>

spwd

getspnam

Сетевые узлы

/etc/hosts

<netdb.h>

hostent

getnameinfo,
getaddrinfo

Сети

/etc/networks

<netdb.h>

netent

getnetbyname,
getnetbyaddr

Протоколы

/etc/protocols

<netdb.h>

protoent

getprotobyname,
getprotobynumber

Службы

/etc/services

<netdb.h>

servent

getservbyname,
getservbyport

В Solaris последние четыре файла из табл. 6.5 являются символическими ссылками на
файлы с теми же именами в каталоге /etc/inet. Большинство реализаций UNIX предоставляют дополнительные функции, подобные перечисленным, но предназначенные для
системного администрирования и  специфичные для каждой конкретной реализации.

6.8. Учет входов в систему
В большинстве систем UNIX имеется два файла данных: utmp, с  информацией
обо  всех работающих в  системе пользователях, и  wtmp, с  информацией обо  всех
попытках входа в систему и выхода из нее. В Version 7 в оба файла информация
записывалась в двоичном виде и определялась одной и той же структурой:
struct utmp {
char ut_line[8]; /* имя устройства: "ttyh0", "ttyd0", "ttyp0", ... */
char ut_name[8]; /* пользователь */
long ut_time;
/* количество секунд от начала Эпохи */
};

Во время входа пользователя в систему программа login заполняла одну такую
структуру и записывала в файл utmp, и та же самая структура добавлялась в файл
wtmp. При выходе из системы процесс init стирал запись в файле utmp, заполняя

6.9. Информация о системе   

241

ее нулевыми байтами, а в файл wtmp добавлялась новая запись. В этой записи, соответствующей выходу из системы, поле ut_name очищалось. Во время перезагрузки системы, а также до и после изменения системной даты и времени в файл
wtmp добавлялись специальные записи. Утилита who(1) извлекала данные из файла utmp и выводила их в удобочитаемом виде. В более поздних версиях UNIX имеется коман­да last(1), которая читает данные из файла wtmp и выводит выбранные
записи.
Большинство версий UNIX все еще поддерживают файлы utmp и  wtmp, но, как
и  следовало ожидать, объем информации в  этих файлах вырос. Так, 20-байтная
структура, использовавшаяся в  Version 7, выросла до 36 байт в  SVR2, а  в  SVR4
расширенная структура utmp занимает уже 350 байт!
Детальное описание формата этих записей в Solaris приводится на странице справочного
руководства utmpx(4). В Solaris 10 оба файла находятся в каталоге /var/adm. ОС Solaris
предоставляет много функций для работы с этими файлами, описание которых можно
найти в getutxent(3).
На странице справочного руководства utmp(5) в Linux 3.2.0 и FreeBSD 8.0 дается описание
формата записей для этих версий. Полные имена этих двух файлов — /var/run/utmp и /var/
log/wtmp. В Mac OS X 10.6.8 файлы utmp и wtmp отсутствуют. Начиная с версии Mac OS
X 10.5 информацию, прежде находившуюся в файле wtmp, можно получить с помощью системного механизма журналирования, а файл utmpx содержит информацию об активных
сеансах, открытых пользователями.

6.9. Информация о системе
Стандарт POSIX.1 определяет функцию uname, которая возвращает сведения о текущем хосте и операционной системе.
#include <sys/utsname.h>
int uname(struct utsname *name);

Возвращает неотрицательное значение в случае успеха,
–1 — в случае ошибки
В качестве аргумента передается адрес структуры utsname, и функция заполняет
ее. Стандартом POSIX.1 определен лишь минимальный набор полей в этой структуре, каждое из которых является массивом символов, а размеры этих массивов
определяются конкретными реализациями. Некоторые реализации добавляют
в эту структуру дополнительные поля.
struct utsname {
char sysname[];
char nodename[];
char release[];
char version[];
char machine[];
};

/*
/*
/*
/*
/*

имя операционной системы */
имя узла сети */
номер выпуска операционной системы */
номер версии этого выпуска */
тип аппаратной архитектуры */

242    Глава 6. Информация о системе и файлы данных
Каждая строка заканчивается нулевым символом. В табл. 6.6 приводятся максимальные размеры массивов для всех четырех платформ, обсуждаемых в  книге.
Информация, содержащаяся в  структуре utsname, обычно выводится командой
uname(1).
Стандарт POSIX.1 предупреждает, что поле nodename может не соответствовать действительному сетевому имени хоста. Это поле пришло из System V и ранее хранило имя
хоста в сети, работающей по протоколу UUCP.
Кроме того, помните, что содержимое этой структуры не дает никакой информации
о версии POSIX.1. Эти сведения можно получить при помощи константы _POSIX_VERSION
(как описывалось в разделе 2.6).
Наконец, эта функция дает лишь возможность получить информацию в виде структуры; стандарт POSIX.1 никак не оговаривает порядок инициализации этой информации.

Системы, производные от BSD, традиционно предоставляют функцию gethost­
name, возвращающую только имя хоста. Как правило, это имя соответствует сетевому имени хоста в сети TCP/IP.
#include <unistd.h>
int gethostname(char *name, int namelen);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Аргумент namelen определяет размер буфера name. Если в  буфере достаточно
места, возвращаемая в name строка будет завершаться нулевым символом. Если
места в буфере недостаточно, то не оговаривается, будет ли полученная строка завершаться нулевым символом.
В настоящее время функция gethostname является частью стандарта POSIX.1,
который указывает, что максимальная длина имени хоста равна HOST_NAME_MAX.
Значения максимальной длины имен хостов для всех четырех обсуждаемых платформ приводятся в табл. 6.6.
Таблица 6.6. Ограничения на размеры строк идентификации системы
Функция

Максмальная длина аргумента name
FreeBSD 8.0

Linux 3.2.0

Mac OS X 10.6.8

Solaris 10

uname

256

65

256

257

gethostname

256

64

256

256

Если хост подключен к сети TCP/IP, имя хоста обычно представляет собой полное доменное имя.
Существует также команда hostname(1), которая может выводить или изменять
имя хоста. (Имя хоста устанавливается суперпользователем с  помощью аналогичной функции sethostname.) Как правило, имя хоста устанавливается во время
загрузки системы в одном из файлов инициализации, вызываемых сценариями из
/etc/rc или init.

6.10. Функции даты и времени   

243

6.10. Функции даты и времени
Роль основной службы времени в ядре UNIX играет счетчик секунд, прошедших
от начала Эпохи — 00:00:00 1 января 1970 года по всеобщему скоординированному времени (UTC). В разделе 1.10 мы уже говорили, что значение счетчика представлено типом данных time_t и называется календарным временем. С помощью
календарного времени можно представить как дату, так и время суток. UNIX всегда отличалась от других систем тем, что она (а) хранит время UTC, а не местное
время, (б) автоматически выполняет преобразования, такие как переход на летнее
время, и (в) хранит дату и время как единое целое.
Функция time возвращает текущее время и дату.
#include <time.h>
time_t time(time_t *calptr);

Возвращает значение времени в случае успеха, –1 — в случае ошибки
Функция всегда возвращает значение времени. Если в качестве аргумента calptr
передается непустой указатель, значение времени дополнительно записывается
по указанному адресу.
Расширения реального времени, определяемые стандартом POSIX.1, добавляют поддержку нескольких системных часов. В  версии 4 стандарта Single UNIX
Specification интерфейсы управления этими часами были перенесены из категории необязательных в  категорию базовых. Часы идентифицируются типом
clockid_t. Стандартные значения перечислены в табл. 6.7.
Таблица 6.7. Идентификаторы типов часов
Идентификатор

Параметр

CLOCK_REALTIME

Описание

Действительное системное время

CLOCK_MONOTONIC

_POSIX_MONOTONIC_CLOCK

Действительное системное время
без отрицательных переходов

CLOCK_PROCESS_CPUTIME_ID

_POSIX_CPUTIME

Процессорное время вызывающего процесса

CLOCK_THREAD_CPUTIME_ID

_POSIX_THREAD_CPUTIME

Процессорное время вызывающего потока выполнения

Получить время конкретных часов можно с  помощью функции clock_gettime.
Она возвращает время в виде структуры timespec, представленной в разделе 4.2,
которая выражает время в секундах и наносекундах.
#include <sys/time.h>
int clock_gettime(clockid_t clock_id, struct timespec *tsp);

Возвращает 0 в случае успеха, –1 — в случае ошибки

244    Глава 6. Информация о системе и файлы данных
Когда в  аргументе clock_id передается идентификатор CLOCK_REALTIME, функция
clock_gettime действует подобно функции time, за исключением того, что с помощью clock_gettime можно получить значение времени с большим разрешением,
если система поддерживает такую возможность.
Определить разрешение конкретных системных часов можно с  помощью функции clock_getres.
#include <sys/time.h>
int clock_getres(clockid_t clock_id, struct timespec *tsp);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Функция clock_getres инициализирует структуру timespec, на которую указывает аргумент tsp, сохраняя величину разрешения часов, соответствующих идентификатору в  аргументе clock_id. Например, для разрешения в  1 миллисекунду
в поле tv_sec будет помещено значение 0, а в поле tv_nsec — значение 1 000 000.
Установить время в определенных часах можно вызовом функции clock_settime.
#include <sys/time.h>
int clock_settime(clockid_t clock_id, const struct timespec *tsp);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Для изменения времени в часах необходимо обладать соответствующими привилегиями. При этом некоторые часы недоступны для корректировки.
Исторически в  реализациях, производных от System V, для установки нового времени
использовалась функция stime(2), а в производных от BSD — функция settimeofday(2).

Версия 4 стандарта Single UNIX Specification объявила функцию gettimeofday
устаревшей. Однако многие программы все еще используют ее, потому что она
дает более высокую точность (до микросекунд), чем функция time.
#include <sys/time.h>
int gettimeofday(struct timeval *restrict tp, void *restrict tzp);

Всегда возвращает 0
Единственное допустимое значение аргумента tzp — NULL; любые другие значения
могут привести к непредсказуемым результатам. Некоторые платформы поддерживают передачу часового пояса через аргумент tzp, но это зависит от конкретной
реализации и не определено в Single UNIX Specification.
Функция gettimeofday сохраняет время, прошедшее от начала Эпохи до настоящего момента, по адресу tp. Это время представлено в  виде структуры timeval,
которая хранит секунды и микросекунды.

6.10. Функции даты и времени   

245

После получения целочисленного количества секунд, прошедших с начала Эпохи, как правило, вызывается одна из функций преобразования, которая переведет
числовое значение в удобочитаемые время и дату. На рис. 6.1 показаны взаимоотношения между различными функциями преобразования времени. (Три функции, изображенные на этом рисунке пунктирными линиями, — localtime, mktime
и  strftime,  — учитывают значение переменной окружения TZ, которую мы рассмотрим далее в этом разделе.)
Форматированная строка

Строка

st
rp
ti

me

i
ft

r

me

st

rf

st

l

e_

m
ti

struct tm

timeval

tv_sec

gettimeofday

mktime

localtime

gmtime

время, разложенное на составляющие

time_t

(календарное время)

time

tv_sec

timespec

clock_gettime

Ядро

Рис. 6.1. Взаимоотношения между различными функциями представления времени

Две функции, localtime и gmtime, преобразуют календарное время в структуру tm,
состоящую из следующих элементов:
struct tm {
int tm_sec;
int tm_min;
int tm_hour;
int tm_mday;
int tm_mon;
int tm_year;
int tm_year;
int tm_wday;
int tm_yday;
int tm_isdst;
};

/*
/*
/*
/*
/*
/*
/*
/*
/*
/*
/*

время, разложенное на составляющие */
секунды от начала минуты: [0 – 60] */
минуты от начала часа: [0 – 59] */
часы от полуночи: [0 – 23] */
дни от начала месяца: [1 – 31] */
месяцы с января: [0 – 11] */
годы с 1900 года */
годы с 1900 года */
дни с воскресенья: [0 – 6] */
дни от начала года (1 января): [0 – 365] */
флаг перехода на летнее время: <0, 0, >0 */

Количество секунд может превышать 59, когда для коррекции времени вставляется дополнительная секунда. Обратите внимание, что отсчет всех компонентов,
кроме дня месяца, начинается с  0. Флаг перехода на летнее время представлен
положительным числом, если действует летнее время, 0 — если нет, и отрицательным числом, если данная информация недоступна.

246    Глава 6. Информация о системе и файлы данных
В предыдущих версиях Single UNIX Specification допускалась вставка двух дополнительных секунд. Таким образом, диапазон значений поля tm_sec составлял 0–61. Формальное
определение UTC не допускает вставки двух дополнительных секунд, поэтому сейчас
диапазон представления секунд определяется как 0–60.
#include <time.h>
struct tm *gmtime(const time_t *calptr);
struct tm *localtime(const time_t *calptr);

Обе возвращают указатель на структуру tm, NULL — в случае ошибки
Функции localtime и  gmtime отличаются тем, что первая преобразует календарное время в местное, учитывая при этом часовой пояс и переход на летнее время,
а вторая разбивает календарное время UTC на составляющие.
Функция mktime принимает местное время в виде структуры tm и преобразует его
в значение time_t.
#include <time.h>
time_t mktime(struct tm *tmptr);

Возвращает календарное время в случае успеха, –1 — в случае ошибки
Функция strftime — это printf-подобная функция для представления значений
времени. Она отличается разнообразием аргументов, позволяющих настраивать
возвращаемую строку.
#include <time.h>
size_t strftime(char *restrict buf, size_t maxsize,
const char *restrict format,
const struct tm *restrict tmptr);
size_t strftime_l(char *restrict buf, size_t maxsize,
const char *restrict format,
const struct tm *restrict tmptr, locale_t locale);

Обе возвращают количество символов, записанных в массив, если
в нем достаточно места, в противном случае возвращают 0
Для получения 26-байтной строки, напоминающей результат команды date(1), прежде
можно было использовать две старые функции, asctime и ctime. Однако в настоящее время
они отмечены как устаревшие, так как не ограждают от проблемы переполнения буфера.

Функции strftime и  strftime_l действуют практически одинаково, за исключением того, что функция strftime_l позволяет вызывающей программе передавать

6.10. Функции даты и времени   

247

региональные настройки в аргументе locale. Функция strftime использует региональные настройки в переменной окружения TZ.
Аргумент tmptr — указатель на структуру tm, содержащую время, которое должно
быть представлено в  виде отформатированной строки. Результат форматирования сохраняется в буфере buf, размер которого определяется аргументом maxsize.
Если полученная строка, включая завершающий нулевой символ, умещается в буфере, эти функции возвращают длину строки без завершающего нулевого символа. Иначе возвращается 0.
Аргумент format управляет форматированием значения времени. Как и в случае
с функцией printf, спецификаторы формата начинаются с символа процента, за
которым следуют служебные символы. Все остальные символы в строке format выводятся без изменений. Два символа процента, следующие друг за другом, будут
отображаться как один символ процента. В отличие от функции printf, каждый
спецификатор формата генерирует на выходе строки фиксированного размера —
спецификаторы ширины поля вывода не предусмотрены. В табл. 6.8 перечислены
37 спецификаторов формата, определяемых стандартом ISO C.
Таблица 6.8. Спецификаторы формата функции strftime
Спецификатор
формата

Описание

Пример

%a

Краткое название дня недели

Thu

%A

Полное название дня недели

Thursday

%b

Краткое название месяца

Jan

%B

Полное название месяца

January

%c

Дата и время

Thu Jan 19 21:24:52 2012

%C

Две первые цифры года [00–99]

20

%d

День месяца: [01–31]

19

%D

Дата: [MM/DD/YY]

01/19/12

%e

День месяца (начальный 0 замещается пробелом): [1–31]

19

%F

Дата в формате ISO 8601: [YYYY-MM-DD]

2012-01-19

%g

Последние две цифры года в формате ISO 8601
с учетом номера недели: [00–99]

12

%G

Год в формате ISO 8601 с учетом номера недели

2012

%h

То же, что %b

Jan

%H

Час (в 24-часовом формате): [00–23]

21

%I

Час (в 12-часовом формате): [00–12]

09

%j

День года: [001–366]

019

%m

Номер месяца: [01–12]

01

%M

Минуты: [00–59]

24

248    Глава 6. Информация о системе и файлы данных
Таблица 6.8 (окончание)
Спецификатор
формата

Описание

Пример

%n

Символ перевода строки

%p

AM или PM (до или после полудня)

PM

%r

Местное время в 12-часовом формате

09:24:52 PM

%R

То же, что %H:%M

21:24

%S

Секунды: [00–60]

52

%t

Символ горизонтальной табуляции

%T

То же, что %H:%M:%S

21:24:52

%u

Номер дня недели в формате ISO 8601 [понедельник = 1, 1–7]

4

%U

Номер недели в году, воскресенье — первый день
недели: [01–53]

03

%V

Номер недели в году в формате ISO 8601: [01–53]

03

%w

Номер дня недели [воскресенье = 0, 0–6]

4

%W

Номер недели в году, понедельник — первый день
недели: [00–53]

03

%x

Дата

01/19/12

%X

Время

21:24:52

%y

Последние две цифры года: [00-99]

12

%Y

Год

2012

%z

Разница между поясным временем и UTC

-0500

%Z

Название часового пояса

EST

%%

Символ процента

%

В третьей колонке таблицы приводится вывод функции strftime в Mac OS X, соответствующий времени Thu Jan 19 21:24:52 EST 2012.
Единственные спецификаторы, смысл которых неочевиден: %U, %V и %W. Спецификатор %U представляет номер недели в году, начиная с недели, на которую выпадает
первое воскресенье года. Спецификатор %W представляет номер недели в году, начиная с недели, на которую выпадает первый понедельник года. Действие специ­
фикатора %V зависит от конкретного года. Если неделя, на которую выпадает 1 января, содержит четыре или более дня нового года, она считается первой неделей
года, иначе — последней неделей предыдущего года. В обоих случаях первым днем
недели считается понедельник.
Как и  printf, функция strftime поддерживает модификаторы для некоторых
спецификаторов формата. Модификаторы O и E позволяют получить строку в альтернативном формате, если таковой поддерживается региональными настройками системы.

6.10. Функции даты и времени   

249

Некоторые системы поддерживают дополнительные, нестандартные спецификаторы
формата для функции strftime.

Пример
Программа в листинге 6.2 демонстрирует, как использовать функции для работы
со временем, описанные в этой главе. В частности, она показывает, как с помощью
strftime выводить строки с текущими датой и временем.
Листинг 6.2. Пример использования функции strftime
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
int
main(void)
{
time_t
t;
struct tm *tmp;
char
buf1[16];
char
buf2[64];

}

time(&t);
tmp = localtime(&t);
if (strftime(buf1, 16, "время и дата: %r, %a %b %d, %Y", tmp) == 0)
printf("длина буфера 16 слишком мала\n");
else
printf("%s\n", buf1);
if (strftime(buf2, 64, "время и дата: %r, %a %b %d, %Y", tmp) == 0)
printf("длина буфера 64 слишком мала\n");
else
printf("%s\n", buf2);
exit(0);

Взгляните еще раз на рис. 6.1, где изображены взаимоотношения между различными функциями представления времени. Прежде чем вывести время в удобочитаемом представлении, его необходимо получить и преобразовать в структуру tm.
Пример в листинге 6.2 выводит:
$ ./a.out
длина буфера 16 слишком мала
время и дата: 11:12:35 PM, Thu Jan 19, 2012

Функция strptime — обратная по отношению к  strftime. Она принимает строку
и преобразует ее в структуру tm.
#include <time.h>
char *strptime(const char *restrict buf, const char *restrict format,
struct tm *restrict tmptr);

Возвращает указатель на символ, находящийся за последним
проанализированным символом, NULL — в противном случае

250    Глава 6. Информация о системе и файлы данных
Аргумент format описывает формат строки в  буфере, на который указывает аргумент buf. Спецификаторы формата напоминают спецификаторы, поддерживаемые функцией strftime, хотя и с некоторыми отличиями. Перечень спецификаторов для функции strptime приводится в табл. 6.9.
Таблица 6.9. Спецификаторы формата функции strptime
Спецификатор
формата

Описание

%a

Краткое или полное название дня недели

%A

То же, что %a

%b

Краткое или полное название месяца

%B

То же, что %b

%c

Дата и время

%C

Две первые цифры года

%d

День месяца: [01–31]

%D

Дата: [MM/DD/YY]

%e

То же, что %d

%h

То же, что %b

%H

Час (в 24-часовом формате): [00–23]

%I

Час (в 12-часовом формате): [00–12]

%j

День года: [001–366]

%m

Номер месяца: [01–12]

%M

Минуты: [00–59]

%n

Любой пробельный символ

%p

AM или PM (до или после полудня)

%r

Местное время в 12-часовом формате

%R

То же, что %H:%M

%S

Секунды: [00–60]

%t

Любой пробельный символ

%T

То же, что %H:%M:%S

%U

Номер недели в году, воскресенье — первый день недели: [01–53]

%w

Номер дня недели [воскресенье = 0, 0–6]

%W

Номер недели в году, понедельник — первый день недели: [00–53]

%x

Местная дата

%X

Местное время

%y

Последние две цифры года: [00-99]

%Y

Год

%%

Символ процента

Упражнения   

251

Мы уже упоминали, что три функции, обозначенные на рис. 6.1 пунктирными линиями, учитывают значение переменной окружения TZ — это функции localtime,
mktime и  strftime. Если эта переменная определена, ее значение используется
вместо значения часового пояса по умолчанию. Если переменная определена как
пустая строка, например как TZ=, обычно в  качестве часового пояса используется UTC. Эта переменная часто содержит нечто вроде TZ=EST5EDT, но стандарт
POSIX.1 допускает указывать более детальную информацию. За дополнительными сведениями о переменной окружения TZ обращайтесь к главе «Environment
Variables» стандарта Single UNIX Specification [Open Group, 2010].
Дополнительную информацию о  переменной окружения TZ можно найти на странице
справочного руководства tzset(3).

6.11. Подведение итогов
Все системы UNIX используют файл паролей и файл групп. Мы рассмотрели различные функции для работы с этими файлами, а также обсудили теневые файлы
паролей, использование которых повышает уровень безопасности системы. Поддержка дополнительных групп позволяет включать пользователя сразу в несколько групп. Кроме того, мы рассмотрели ряд функций, предусмотренных большинством систем для работы с  другими файлами данных. Обсудили определяемые
стандартом POSIX.1 функции, которые могут использоваться приложениями
для идентификации системы, в которой они запущены. Глава заканчивается обзором функций для работы с датой и временем, определяемых стандартами ISO C
и Single UNIX Specification.

Упражнения
6.1	

Представьте, что система использует теневой файл паролей и вам необходимо получить пароль в зашифрованном виде. Как это можно сделать?

6.2	

Реализуйте предыдущее упражнение в виде функции, исходя из предположения, что в системе имеется теневой файл паролей и вы обладаете привилегиями суперпользователя.

6.3	

Напишите программу, которая вызывает функцию uname и выводит содержимое всех полей структуры utsname. Сравните получившиеся результаты
с тем, что выводит команда uname(1).

6.4	

Вычислите максимально возможное значение времени, которое может быть
представлено с помощью типа time_t. Что произойдет, когда счетчик времени переполнится?

6.5	

Напишите программу, которая получает текущее время и выводит его с помощью функции strftime, при этом результат должен выглядеть так же, как
вывод команды date(1) по умолчанию. Присвойте переменной окружения
TZ другое значение и проверьте, что произойдет.

7

Окружение процесса

7.1. Введение
Прежде чем перейти к функциям управления процессами, которые будут обсуждаться в следующей главе, исследуем окружение отдельного процесса. В этой главе мы рассмотрим, как вызывается функция main в  момент запуска программы,
как программе передаются аргументы командной строки, как выглядит типичная раскладка памяти, как распределяется дополнительная память, как процесс
может использовать переменные окружения и как завершается работа процесса.
Дополнительно мы исследуем функции longjmp и  setjmp и их взаимодействие со
стеком. И наконец, рассмотрим ограничения на ресурсы процесса.

7.2. Функция main
Программы на языке C начинают работу с вызова функции main. Прототип этой
функции:
int main(int argc, char *argv[]);

где argc — количество аргументов командной строки, а argv — массив указателей
на аргументы. Мы подробно рассмотрим эти аргументы в разделе 7.4.
Когда ядро запускает программу на языке C (с помощью одной из функций семейства exec, которые будут описаны в разделе 8.10), перед вызовом функции main
выполняется специальная процедура начального запуска. Адрес этой процедуры
указывается в выполняемом файле программы как точка входа. Этот адрес определяется редактором связей, который вызывается компилятором языка C. Про­
цедура начального запуска принимает от ядра аргументы командной строки и значения переменных окружения, после чего выполняет вызов функции main.

7.3. Завершение работы процесса
Существует восемь способов завершения работы процесса. Нормальными считаются пять из них.
1.	 Возврат из функции main.
2.	 Вызов функции exit.

7.3. Завершение работы процесса   

253

3.	 Вызов функции _exit или _Exit.
4.	 Возврат из функции запуска последнего потока выполнения (раздел 11.5).
5.	 Вызов функции pthread_exit (раздел 11.5) из последнего потока выполнения.
Ненормальное завершение процесса происходит в следующих случаях.
1.	 При вызове функции abort (раздел 10.17).
2.	 При получении сигнала (раздел 10.2).
3.	 По запросу на завершение последнего потока выполнения (разделы 11.5
и 12.7).
Мы не будем рассматривать способы завершения, связанные с потоками выполнения, до
их обсуждения в главах 11 и 12.

Процедура начального запуска, о  которой мы говорили в  предыдущем разделе,
спроектирована так, что она вызывает функцию exit, когда происходит возврат
из функции main. Если процедура начального запуска написана на C (хотя чаще
всего она написана на языке ассемблера), запуск функции main выглядит примерно так:
exit(main(argc, argv));

Функции семейства exit
Нормальное завершение программы осуществляется тремя функциями: _exit
и  _Exit, сразу же возвращающими управление ядру, и  exit, выполняющей ряд
дополнительных операций и только после этого возвращающей управление ядру.
#include <stdlib.h>
void exit(int status);
void _Exit(int status);
#include <unistd.h>
void _exit(int status);

В разделе 8.5 мы рассмотрим влияние этих функций на другие процессы, например на родителя и потомков завершаемого процесса.
Прототипы функций объявлены в  разных заголовочных файлах потому, что функции
_exit и _Exit определяются стандартом ISO C, а функция exit — стандартом POSIX.1.

Функция exit всегда выполняла корректное закрытие стандартной библиотеки
ввода/вывода, вызывая функцию fclose для всех открытых потоков ввода/вывода. В разделе 5.5 мы уже говорили, что это приводит к сбросу всех буферов (то есть
к записи их содержимого на диск).
Все три функции завершения принимают единственный аргумент целочисленного типа, который называется кодом завершения. Большинство командных оболочек UNIX позволяют узнать код завершения процесса. Код завершения процес-

254    Глава 7. Окружение процесса
са считается неопределенным, если (а) любая из этих функций вызвана без кода
завершения процесса, (б) функция main вызывает оператор return без аргумента
или (в) функция main объявлена как не возвращающая целочисленное значение.
Однако если функция main, объявленная как возвращающая целое число, «неожиданно завершается» (неявный возврат из функции), код завершения процесса
считается равным 0.
Такое поведение было определено стандартом ISO C в  1999 году. Исторически код завершения считался неопределенным, если выход из функции main осуществлялся не через
явное обращение к оператору return или к функции exit.

Возврат целочисленного значения из функции main эквивалентен вызову функции exit с тем же самым значением. То есть
exit(0);

означает то же самое, что
return(0);

Пример
В листинге 7.1 представлен пример классической программы «Привет, МИР!».
Листинг 7.1. Классический пример программы на языке C
#include <stdio.h>
main()
{
printf("Привет, МИР!\n");
}

Если скомпилировать и запустить эту программу, окажется, что она возвращает
случайный код завершения. В разных системах мы почти наверняка получим различные коды завершения в зависимости от содержимого стека и регистров процессора в момент выхода из функции main:
$ gcc hello.c
$ ./a.out
Привет, МИР!
$ echo $?
13

вывести код завершения

Теперь, если включить режим совместимости компилятора с расширением 1999
ISO C, можно увидеть, что код завершения изменился:
$ gcc -std=c99 hello.c
включить расширения 1999 ISO C компилятора gcc
hello.c:4: warning: return type defaults to 'int'
$ ./a.out
Привет, МИР!
$ echo $?
вывести код завершения
0

Обратите внимание на предупреждение компилятора, появившееся после включения
режима совместимости с расширением 1999 ISO C. Это обусловлено тем, что функция

7.3. Завершение работы процесса   

255

main не объявлена явно как возвращающая целочисленное значение. Если добавить это объ-

явление, предупреждение выводиться не будет. Однако если включить вывод всех преду­
преждений компилятора (с помощью флага -Wall), появится еще одно предупреждение
примерно такого содержания: «control reaches end of nonvoid function» («достигнут конец
функции, имеющей возвращаемое значение»).
Объявление функции main как возвращающей целочисленное значение и использование функции exit вместо оператора return приводит к появлению бесполезных предупреждений от
некоторых компиляторов и от программы lint(1). Эти компиляторы не понимают, что
выход из main с помощью функции exit, по сути, то же самое, что обращение к оператору
return. Избавиться от таких предупреждений, которые через некоторое время начинают
раздражать, можно, использовав оператор return вместо вызова exit. Но такое решение лишает нас возможности легко и просто находить все точки выхода из программы
с помощью утилиты grep. Другое возможное решение — объявить функцию main с типом
возвращаемого значения void вместо int и продолжать использовать функцию exit. Это
избавит от надоедливых предупреждений компилятора, но выглядит не очень правильно
(особенно в исходных текстах программы) и, кроме того, может вызвать появление других
предупреждений, поскольку предполагается, что функция main должна возвращать целочисленный результат. В этой книге мы представляем функцию main как возвращающую
целое число, поскольку это определено стандартами ISO C и POSIX.1.
В зависимости от компилятора выводимые предупреждения могут быть более или менее
подробными. Обратите внимание: компилятор GNU C обычно не выдает эти ненужные
сообщения, если не используются дополнительные параметры управления выводом преду­
преждений.

В следующей главе мы увидим, как один процесс может запустить другой, дождаться его завершения и получить код завершения.

Функция atexit
В соответствии со стандартом ISO C процесс может зарегистрировать до 32 функций, которые будут автоматически вызываться функцией exit. Они называются
обработчиками выхода и регистрируются с помощью функции atexit.
#include <stdlib.h>
int atexit(void (*func)(void));

Возвращает 0 в случае успеха, ненулевое значение — в случае ошибки
Это объявление говорит о том, что функции atexit передается аргумент с адресом
функции обработчика. Функции-обработчику при вызове не передается никаких
аргументов и от нее не ожидается возврата значения. Функция exit вызывает обработчики в последовательности, обратной порядку их регистрации. Каждый обработчик вызывается столько раз, сколько раз он был зарегистрирован.
Обработчики выхода впервые появились в стандарте ANSI C в 1989 году. Системы, предшествовавшие этому стандарту, такие как SVR3 и 4.3BSD, не поддерживали обработку
выхода.

256    Глава 7. Окружение процесса
Стандарт ISO C требует, чтобы системы поддерживали возможность регистрации как
минимум 32 обработчиков, но реализации обычно поддерживают больше (см. табл. 2.13).
Максимально возможное количество обработчиков для заданной системы можно определить с помощью функции sysconf (см. табл. 2.11).

В соответствии со стандартами ISO C и POSIX.1 функция exit сначала должна
вызвать все зарегистрированные функции-обработчики и затем закрыть все открытые потоки ввода/вывода (с помощью функции fclose). Стандарт POSIX.1
расширил положения ISO C, указав, что регистрация всех функций-обработчиков аннулируется, если процесс вызывает одну из функций семейства exec.
На рис. 7.1 показано, как запускается и завершается программа, написанная на
языке C.
_exit
или

вызов

или

Функция

main

возврат

_Exit

вызов

_exit

Функции
пользователя
возврат

_Exit

Процедура
начального
запуска

Обработчик
выхода

(н
e
е
уп воз xi
ра вр t
вл ащ
ен а
ие ет
)

exit

(не возвращает
управление)

it

т
ае
ащ ие)
р
зв ен
во вл
е а
(н упр

ex

в

зо

т
ра
зв
во
ов
выз
рат
в
воз

вы

Функция

exit

...
Обработчик
выхода

вы

во

_exit
или

зо
в
зв
ра
т

Пользовательский
процесс

Завершение
операций
ввода/вывода

_Exit

exec
Ядро

Рис. 7.1. Процесс запуска и завершения программы, написанной на языке C

Ядро может запустить программу единственным способом — через вызов одной
из функций семейства exec. Процесс может добровольно завершиться только через вызов функции _exit или _Exit, явно или неявно (с помощью функции exit).
Процесс может также непреднамеренно прекратить работу по сигналу (что не отражено на рис. 7.1).

Пример
Программа в листинге 7.2 демонстрирует использование функции atexit.

7.4. Аргументы командной строки   

257

Листинг 7.2. Пример использования обработчиков выхода
#include "apue.h"
static void my_exit1(void);
static void my_exit2(void);
int
main(void)
{
if (atexit(my_exit2) != 0)
err_sys("невозможно зарегистрировать my_exit2");
if (atexit(my_exit1) !=
err_sys("невозможно
if (atexit(my_exit1) !=
err_sys("невозможно

}

0)
зарегистрировать my_exit1");
0)
зарегистрировать my_exit1");

printf("функция main завершила работу\n");
return(0);

static void
my_exit1(void)
{
printf("первый обработчик выхода\n");
}
static void
my_exit2(void)
{
printf("второй обработчик выхода\n");
}

У нас эта программа дала следующие результаты:
$ ./a.out
функция main завершила работу
первый обработчик выхода
первый обработчик выхода
второй обработчик выхода

Обработчик выхода вызывается столько раз, сколько раз был зарегистрирован.
В программе из листинга 7.2 первый обработчик регистрируется дважды, поэтому
он был вызван два раза. Обратите внимание, что здесь функция exit не вызывается, вместо этого выполняется оператор return.

7.4. Аргументы командной строки
Процесс, запускающий программу вызовом функции exec, может передать ей
аргументы командной строки. Это обычная практика для командных оболочек
UNIX, как мы уже видели на многочисленных примерах из предыдущих глав.

Пример
Программа в листинге 7.3 выводит все аргументы командной строки в стандартный вывод. Обратите внимание, что стандартная утилита echo(1) не выводит нулевой аргумент.

258    Глава 7. Окружение процесса
Листинг 7.3. Вывод всех аргументов командной строки
#include "apue.h"
int
main(int argc, char *argv[])
{
int
i;

}

for (i = 0; i < argc; i++) /* вывести все аргументы командной строки */
printf("argv[%d]: %s\n", i, argv[i]);
exit(0);

Если скомпилировать эту программу и дать выполняемому файлу имя echoarg, ее
можно зепустить, как показано ниже
$ ./echoarg arg1 TEST foo
argv[0]: ./echoarg
argv[1]: arg1
argv[2]: TEST
argv[3]: foo

Согласно стандартам ISO C и POSIX.1, элемент массива argv[argc] должен быть
представлен пустым указателем. Учитывая это, цикл обработки аргументов командной строки можно оформить иначе:
for (i = 0; argv[i] != NULL; i++)

7.5. Список переменных окружения
Каждой программе, помимо аргументов командной строки, передается также список переменных окружения. Подобно списку аргументов командной строки, список переменных окружения доступен как массив указателей, каждый из которых
указывает на строку, завершающуюся нулевым символом. Адрес массива указателей хранится в глобальной переменной environ:
extern char **environ;

Например, среда окружения, насчитывающая пять переменных, будет похожа на
то, что изображено на рис. 7.2. Здесь явно показаны нулевые символы, которыми
завершаются строки. Переменная environ отмечена как указатель на среду окружения, массив указателей — как список среды окружения, а строки, на которые они
указывают, — как строки окружения.
В соответствии с принятыми соглашениями окружение состоит из строк в формате (рис. 7.2):
name=value

Большинство предопределенных имен name состоят из символов верхнего регистра, но это всего лишь традиция.
Исторически в большинстве версий UNIX функции main передается третий аргумент — указатель на среду окружения:
int main(int argc, char *argv[], char *envp[]);

7.6. Организация памяти программы на языке C   

Указатель на среду
окружения

Список среды
окружения

environ:

259

Строки
окружения

HOME=/home/sar\0
PATH=:/bin:/usr/bin\0
SHELL=/bin/bash\0
USER=sar\0
LOGNAME=sar\0
NULL

Рис. 7.2. Процесс запуска и завершения программы, написанной на языке C

Стандарт ISO C определяет только два аргумента функции main, а передача среды окружения через третий аргумент не дает никаких преимуществ перед передачей той же информации через глобальную переменную environ. Поэтому стандарт POSIX.1 указывает, что передача среды окружения должна осуществляться
не через третий аргумент функции main, а через глобальную переменную environ
(если это возможно). Доступ к конкретным переменным окружения обычно осуществляется с помощью функций getenv и  putenv, которые будут описаны в разделе 7.9, а не через глобальную переменную environ. Однако для просмотра всех
переменных окружения следует использовать указатель environ.

7.6. Организация памяти программы
на языке C
Традиционно программы на языке C всегда состояли из следующих частей:
 Сегмент кода с машинными инструкциями, которые выполняются центральным процессором. Обычно сегмент кода является разделяемым, чтобы для
часто используемых программ, таких как текстовые редакторы, компиляторы
языка C, командные оболочки и некоторые другие, в памяти находилась только одна копия сегмента. Кроме того, сегмент кода часто доступен только для
чтения, чтобы предотвратить возможность случайного изменения машинных
инструкций в нем.
 Сегмент инициализированных данных, который обычно называют просто сегментом данных. Содержит переменные, инициализированные определенными
значениями в тексте программы. Например, если где-либо за пределами функции имеется объявление
int maxcount = 99;

указанная переменная будет сохранена вместе со своим значением в сегменте
инициализированных данных.

260    Глава 7. Окружение процесса
 Сегмент неинициализированных данных, часто называемый сегментом «bss».
Это название происходит от древнего оператора языка ассемблера, который
расшифровывается как «block started by symbol» (блок, начинающийся с символа). Перед запуском программы ядро инициализирует данные в  этом сегменте арифметическим нулем или нулевыми указателями. Если где-либо за
пределами функции имеется объявление
long sum[1000];

указанная переменная будет сохранена в  сегменте неинициализированных
данных.
 Сегмент стека (stack), где хранятся переменные с  автоматическим классом
размещения, а  также информация, которая сохраняется при каждом вызове
функции. Каждый раз, когда вызывается функция, в стеке сохраняется адрес
возврата из нее и определенная информация об окружении вызывающей программы, например регистры процессора. После этого вызванная функция резервирует на стеке дополнительное место для автоматических и  временных
переменных. Благодаря такой организации в языке C возможны рекурсивные
вызовы функций. Всякий раз, когда функция рекурсивно вызывает сама себя,
создается новый кадр стека, благодаря чему один набор локальных переменных не накладывается на другой.
 Куча (heap), или область динамической памяти. Традиционно куча располагалась в пространстве между сегментом неинициализированных данных и стеком.
На рис. 7.3 показано типичное размещение этих сегментов. Это логическое представление, как выглядит программа; в  конкретной системе организация памяти
программы не обязательно будет выглядеть именно так. Тем не менее этот рисунок показывает типичный пример организации памяти, которую мы будем обсуждать. В 32-разрядных версиях Linux для микропроцессоров Intel x86 сегмент кода
начинается с адреса 0x8048000, а дно стека расположено ниже адреса 0xC0000000
(на данной аппаратной архитектуре стек растет вниз — от старших адресов к младшим). Неиспользуемое виртуальное адресное пространство между вершиной кучи
и вершиной стека очень велико.
В выполняемом файле a.out существует несколько сегментов дополнительных типов с таблицей идентификаторов, информацией для отладчика, таблицей связи с динамическими
библиотеками и т. п. Эти дополнительные сегменты не загружаются как часть образа
программы, выполняемой процессом.

Обратите внимание, что сегмент неинициализированных данных на рис. 7.3 не хранится в файле программы на диске, так как ядро очищает этот сегмент, прежде чем
запустить программу. Единственные сегменты, которые должны быть сохранены
в файле программы, — это сегмент кода и сегмент инициализированных данных.
Команда size(1) выводит размеры (в байтах) сегментов кода, данных и bss. Например:
$ size /usr/bin/cc /bin/sh
text
data
bss
dec
346919
3576
6680 357175
102134
1776
11272 115182

hex
57337
1c1ee

filename
/usr/bin/cc
/bin/sh

7.7. Разделяемые библиотеки   

Старший адрес

261

Аргументы командной
строки и переменные окружения
Стек

Куча
Неинициализированные
данные (bss)
Инициализированные
данные
Младший адрес

Сегмент кода

Инициализируется
нулями функцией exec

Считываются из файла
программы функцией exec

Рис. 7.3. Типичное размещение сегментов в памяти

В четвертой и пятой колонках выводится общий размер всех трех сегментов в десятичном и шестнадцатеричном представлении соответственно.

7.7. Разделяемые библиотеки
Большинство современных версий UNIX поддерживает разделяемые библиотеки.
В [Arnold, 1986] описана ранняя реализация таких библиотек в System V, в [Gingel
et al., 1987] — реализация в SunOS. Разделяемые библиотеки позволяют изъять из
выполняемого файла библиотечные функции; в результате в памяти системы хранится единственная копия библиотеки, к которой обращаются все процессы. Это
заметно уменьшает размер выполняемых файлов, но может несколько увеличить
нагрузку, когда приложение запускается в первый раз или когда происходит первое обращение к библиотечной функции. Еще одно преимущество разделяемых
библиотек в том, что при обновлении библиотеки не требуется исправлять связи
с  библиотекой в  каждой программе, которая использует эту библиотеку. (Здесь
мы исходим из предположения, что количество и типы аргументов библиотечных
функций не изменились.)
Разные системы предоставляют программам различные способы заявить, что они
используют разделяемые библиотеки. Наиболее типичным является передача параметров командам cc(1) и ld(1). Для демонстрации различий в размерах попробуем собрать выполняемый файл — классическую программу hello.c — сначала
без разделяемых библиотек:
$ gcc -static hello1.c
$ ls -l a.out
-rwxr-xr-x 1 sar

укажем явно, что разделяемые библиотеки
не должны использоваться

879443 Sep 2 10:39 a.out

262    Глава 7. Окружение процесса
$ size a.out
text
data
787775
6128

bss
11272

dec
805175

hex
c4937

filename
a.out

Если теперь скомпилировать программу с  поддержкой разделяемых библиотек,
размеры сегмента кода и данных существенно уменьшатся:
$ gcc hello1.c
$ ls -l a.out
-rwxr-xr-x 1 sar
$ size a.out
text
data
1176
504

по умолчанию gcc использует разделяемые библиотеки
8378 Sep 2 10:39 a.out
bss
16

dec
1696

hex
6a0

filename
a.out

7.8. Распределение памяти
Стандарт ISO C определяет три функции распределения памяти.
1.	 Функция malloc выделяет заданное количество байтов памяти. Выделенная
память не очищается.
2.	 Функция calloc выделяет пространство для заданного количества объектов
определенного размера. Выделенная память заполняется нулевыми байтами.
3.	 Функция realloc перераспределяет выделенную ранее память, увеличивая
или уменьшая ее объем. Увеличение выделенного ранее объема может сопровождаться перемещением участка памяти в новое место. Кроме того, участок
памяти, который оказывается между концом ранее выделенного блока и  новым концом, не инициализируется.
#include <stdlib.h>
void *malloc(size_t size);
void *calloc(size_t nobj, size_t size);
void *realloc(void *ptr, size_t newsize);

Все три возвращают непустой указатель в случае успеха,
NULL — в случае ошибки
void free(void *ptr);

Эти три функции гарантируют возврат указателей с гарантированным выравниванием, подходящим для сохранения любого объекта данных. Например, если
самым сильным ограничением в  конкретной системе является требование размещать объекты типа double в адресах, кратных 8, все указатели, возвращаемые
этими функциями, будут содержать адреса, кратные 8.
Все три функции возвращают нетипизированный указатель void*, поэтому, подключая к  программе заголовочный файл <stdlib.h> (где находятся прототипы
функций), мы не должны выполнять явное приведение типов при присваивании

7.8. Распределение памяти   

263

значений функций типизированным указателям. По умолчанию считается, что
необъявленные функции возвращают значения типа int, поэтому приведение
типа без соответствующего объявления функции может привести к ошибкам в системах, где размер типа int отличается от размера значения, фактически возвращаемого функцией (в данном случае — указателя).
Функция free освобождает выделенную ранее память, на которую указывает аргумент ptr. Освобожденное пространство, как правило, помещается в пул свободной памяти и может быть снова распределено при последующем обращении к одной из трех функций alloc.
Функция realloc позволяет увеличить или уменьшить размер ранее выделенной
области памяти. (Чаще производится увеличение.) Например, если выделяется
участок памяти для массива из 512 элементов и затем в процессе его заполнения
вдруг обнаруживается, что потребуется память для хранения более 512 элементов, можно вызвать функцию realloc. В этом случае, если непосредственно после
выделенной ранее области имеется блок свободной памяти достаточного объема,
функция realloc ничего никуда не переместит, а просто добавит область требуемого объема в конец и вернет тот же самый указатель, который был ей передан. Но
если после выделенной ранее области нет свободной памяти достаточного объема,
функция realloc выделит другую область памяти требуемого объема и скопирует существующий массив из 512 элементов в новое место, после чего освободит
старую область памяти и  вернет указатель на новую область. Поскольку ранее
выделенный объем памяти может перемещаться, не следует использовать другие
указатели на эту область. Упражнение 4.16 и программа в листинге C2 демонстрируют, как можно использовать функцию realloc вместе с  getcwd для обработки
имен файлов любой длины. В листинге 17.28 приводится пример использования
функции realloc для хранения динамических массивов, что позволяет не указывать их размер во время компиляции.
Обратите внимание, что последний аргумент функции realloc определяет новый
размер требуемой области, а не разницу между новым и старым размерами. В особом случае, когда в аргументе ptr передается пустой указатель, realloc действует
как функция malloc и выделяет область размером newsize.
Ранние версии этих функций позволяли снова получить с помощью функции realloc блок,
освобожденный функцией free после последнего обращения к функциям malloc, realloc или
calloc. Эта хитрость существовала еще в Version 7 и использовала свойство стратегии
поиска, реализованной в функции malloc для уплотнения памяти. В Solaris эта особенность сохранилась и поныне, но в других системах — нет. Она не документирована и не
должна использоваться.

Функции распределения памяти обычно реализуются на основе системного вызова sbrk(2). Он расширяет (или усекает) область динамической памяти (кучи)
процесса (см. рис. 7.3). Пример типичной реализации функций malloc и free приводится в разделе 8.7 [Kernighan and Ritchie, 1988].
Хотя системный вызов sbrk(2) может не только увеличивать, но и уменьшать объем памяти процесса, большинство версий malloc и  free никогда не уменьшают
его. Освобождаемое пространство становится доступным для последующего рас-

264    Глава 7. Окружение процесса
пределения и, как правило, не возвращается ядру, а помещается в пул свободной
памяти функции malloc.
Важно понимать, что большинство реализаций выделяют несколько больший
объем памяти, чем требуется, и  используют дополнительное пространство для
хранения служебной информации: размер распределенного блока, указатель на
следующий распределенный блок и т. п. Это означает, что запись за пределы выделенной области может уничтожить служебную информацию в следующем блоке.
Подобного рода ошибки часто носят катастрофический характер и найти их чрезвычайно трудно, потому что они могут не проявлять себя достаточно длительное
время.
Кроме того, существует возможность уничтожить служебную информацию в блоке памяти, если записать данные перед началом распределенной области. Запись
за пределы выделенного блока памяти может уничтожить не только служебную
информацию. Память до и после такого блока может использоваться для хранения других динамических объектов. Эти объекты могут быть не связаны с  разрушающим их участком программы, что еще больше осложняет поиск источника
повреждений.
Другие возможные ошибки, которые могут оказаться фатальными, — попытка освобождения блока памяти, уже освобожденного ранее, и передача функции free
указателя, который не был получен от одной из трех функций распределения
памяти. Если процесс вызывает функцию malloc, но забывает вызвать функцию
free, объем используемой памяти начинает непрерывно увеличиваться; это называют утечкой памяти. Если процесс не будет возвращать ставшие ненужными
блоки памяти вызовом free, объем адресного пространства, занимаемого процессом, будет медленно увеличиваться, пока свободное пространство не закончится.
Это может привести к снижению производительности системы из-за лишних обращений к файлу подкачки.
Поскольку ошибки, связанные с распределением памяти, отыскать очень сложно,
некоторые системы предоставляют версии функций распределения памяти, выполняющие дополнительные проверки при каждом вызове. Эти версии функций
часто характеризуются включением специальной библиотеки редактора связей.
Кроме того, существуют общедоступные исходные тексты, которые можно скомпилировать со специальными флагами, разрешающими проведение дополнительных проверок во время выполнения.
Операционные системы FreeBSD, Mac OS X и Linux поддерживают дополнительные возможности отладки через установку переменных среды. Кроме того, библиотеке FreeBSD
можно передать дополнительные параметры через символическую ссылку /etc/malloc.
conf.

Альтернативные функции распределения памяти
Существует большое количество функций, которые могут служить заменой для
malloc и free. Некоторые системы уже включают библиотеки с альтернативными
реализациями функций распределения памяти. Другие системы поддерживают
только стандартные функции, оставляя программистам право скачивать и  ис-

7.8. Распределение памяти   

265

пользовать альтернативные библиотеки, если они того пожелают. Здесь мы упомянем некоторые из альтернатив.
libmalloc
Системы, основанные на SVR4, такие как Solaris, включают библиотеку libmalloc,
поддерживающую ряд интерфейсов, соответствующих функциям распределения
памяти стандарта ISO C. Библиотека libmalloc включает функцию mallopt, позволяющую процессу установить специальные переменные, управляющие поведением функций распределения памяти. Кроме того, в  библиотеке имеется
функция mallinfo, с помощью которой можно получить статистику по функциям
распределения памяти.
vmalloc
В [Vo, 1996] описывается библиотека функций распределения памяти, которая
позволяет использовать различные приемы для различных областей памяти. В дополнение к специфичным функциям библиотека vmalloc предоставляет функции,
эмулирующие функции распределения памяти стандарта ISO C.
quick-fit
Традиционно в качестве стандартного алгоритма выделения памяти используется
либо метод наилучшего приближения (best-fit), либо метод первого подходящего
(first-fit). Алгоритм quick-fit (быстрого приближения) превосходит по скорости
любой из них, но использует больше памяти. Описание этого алгоритма можно
найти в [Weinstock and Wulf, 1988]. В его основе лежит принцип разделения памяти на блоки разных размеров и размещения их в различных списках свободных
блоков в зависимости от размера. Большинство современных реализаций функций управления памятью основаны на алгоритме quick-fit.
jemalloc
jemalloc — это реализация семейства библиотечных функций malloc, используемая по умолчанию в  FreeBSD 8.0. Она хорошо масштабируется при использовании в  многопоточных приложениях, при выполнении в  многопроцессорных
системах. Описание и оценку производительности этой реализации можно найти
в [Evans, 2006].
TCMalloc
Библиотека TCMalloc проектировалась как замена семейству функций malloc
с целью обеспечить более высокую производительность, масштабируемость и эффективность использования памяти. Чтобы избежать лишних накладных расходов на использование механизма блокировки, она использует локальные пулы
памяти для потоков выполнения, из которых производится выделение памяти
и куда возвращается освобождаемая память. Она также включает встроенные инструменты проверки и  профилирования динамической памяти с  целью помочь
в отладке и анализе особенностей использования динамической памяти. Библиотека TCMalloc распространяется компанией Google в исходных текстах. Краткое
ее описание можно найти в [Ghemawat and Menage, 2005].

266    Глава 7. Окружение процесса
Функция alloca
Это еще одна функция, которая заслуживает внимания. Функция alloca вызывается точно так же, как функция malloc, но выделяет память не в куче, а в кадре
стека текущей функции. Преимущество такого выделения памяти заключается
в  отсутствии необходимости освобождать выделенное пространство  — это происходит автоматически после выхода из функции. Функция alloca увеличивает
размер кадра стека. Главный ее недостаток — она не может использоваться в системах, где невозможно увеличить кадр стека после вызова функции. Тем не менее
она используется во многих программных пакетах, и существуют ее реализации
для большого количества систем.
Все четыре платформы, обсуждаемые в этой книге, поддерживают функцию alloca.

7.9. Переменные окружения
Как уже говорилось выше, строка окружения обычно имеет формат
name=value
Ядро UNIX никогда не обращается к этим строкам; их интерпретация полностью
зависит от самих приложений. Так, например, командные оболочки используют
в  своей работе многочисленные переменные окружения. Некоторые из них, такие как HOME и  USER, устанавливаются автоматически при входе в систему, другие
определяются пользователем. Обычно инициализация переменных окружения
производится в файле начального запуска командной оболочки. Если, например,
установить переменную среды окружения MAILPATH, она будет сообщать командным оболочкам Bourne shell, GNU Bourne-again shell и  Korn shell имя каталога,
в котором хранится электронная почта.
Стандарт ISO C определяет функцию для получения значения любой переменной
окружения, но оговаривает, что содержимое среды окружения зависит от реализации.
#include <stdlib.h>
char *getenv(const char *name);

Возвращает указатель на значение переменной с именем name или
NULL, если переменная не найдена
Обратите внимание, что эта функция возвращает указатель на подстроку value
в  строке name=value. Когда нужно получить значение конкретной переменной
окружения, всегда следует использовать функцию getenv вместо прямого обращения к массиву environ.
Некоторые переменные окружения в  Single UNIX Specification определяются
стандартом POSIX.1, тогда как другие определены только в  системах, которые
поддерживают расширения XSI. В табл. 7.1 перечислены переменные окружения,
определяемые в  Single UNIX Specification, а  также отмечено, какими реализа­

7.9. Переменные окружения   

267

циями они поддерживаются. Переменные окружения, определяемые стандартом
POSIX.1, отмечены галочкой, остальные являются расширениями XSI. В четырех
реализациях, обсуждаемых в данной книге, поддерживается много дополнительных переменных окружения. Обратите внимание, что стандарт ISO C не определяет никаких переменных окружения.
Таблица 7.1. Переменные окружения, определяемые стандартом
Single UNIX Specification
POSIX.1

FreeBSD
8.0

COLUMNS





DATEMSK

XSI

Переменная

Linux
3.2.0

Mac OS X Solaris
10.6.8
10

Описание







Ширина строки терминала







Полный путь к файлу шаблона для функции getdate(3)

HOME











Домашний каталог

LANG











Название локали (региональных настроек)

LC_ALL











Название локали (региональных настроек)

LC_COLLATE











Название локали (региональных настроек) для выполнения сравнения

LC_CTYPE











Название локали (региональных настроек) для классификации символов языка

LC_MESSAGES











Название локали (региональных настроек) для вывода
сообщений

LC_MONETARY











Название локали (региональных настроек) для представления денежных величин

LC_NUMERIC











Название локали (региональных настроек) для представления чисел

LC_TIME











Название локали (региональных настроек) для форматирования даты и времени

LINES











Количество строк терминала

LOGNAME











Имя пользователя

MSGVERB

XSI









Определяет компонент сообщения для вывода функцией fmtmsg(3)

NLSPATH











Шаблон имени каталога с сообщениями

PATH











Список каталогов для поиска
выполняемых файлов

268    Глава 7. Окружение процесса
Таблица 7.1 (окончание)
POSIX.1

FreeBSD
8.0

Linux
3.2.0

PWD











Абсолютный путь к текущему
каталогу

SHELL











Имя командной оболочки,
предпочитаемой пользователем

TERM











Тип терминала

TMPDIR











Путь к каталогу для временных файлов

TZ











Информация о часовом поясе

Переменная

Mac OS X Solaris
10.6.8
10

Описание

Иногда может потребоваться не только получить, но и изменить значение существующей переменной или даже добавить новую. (В следующей главе мы посмотрим, как оказывать влияние на среду окружения текущего процесса и его потомков. Мы не можем изменить среду окружения родительского процесса, который
зачастую является командной оболочкой. Тем не менее было бы удобно иметь
возможность изменять среду окружения текущего процесса.) К сожалению, не все
системы поддерживают эту возможность. В табл. 7.2 приводится список функций,
которые поддерживаются различными стандартами и реализациями.
Таблица 7.2. Различные функции для работы со средой окружения
Функция

ISO C

POSIX.1

FreeBSD 8.0

Linux 3.2.0

Mac OS X 10.6.8

Solaris 10













putenv

XSI









setenv









unsetenv









getenv

clearenv



Функция clearenv не входит в стандарт Single UNIX Specification. Она используется для
удаления всех записей из списка строк окружения.

Ниже приводятся прототипы второй, третьей и четвертой функций из табл. 7.2.
#include <stdlib.h>
int putenv(char *str);

Возвращает 0 в случае успеха, ненулевое значение — в случае ошибки
int setenv(const char *name, const char *value, int rewrite);
int unsetenv(const char *name);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки

7.9. Переменные окружения   

269

Действуют эти функции следующим образом.
 Функция putenv принимает строку в формате name=value и помещает ее в список переменных окружения. Если переменная с именем name уже существует,
она будет удалена перед вставкой новой строки.
 Функция setenv присваивает переменной name значение value. Если переменная name уже существует в среде окружения, тогда: (а) если аргумент rewrite
не равен нулю, существующее определение переменной сначала удаляется из
списка; (б) если аргумент rewrite равен нулю, существующее определение переменной не удаляется, новое значение value не запоминается и функция возвращает управление без признака ошибки.
 Функция unsetenv удаляет определение переменной с именем name. Если заданной переменной не существует, это не считается ошибкой.
Обратите внимание на различия между функциями putenv и setenv. Функция setenv выделяет память, чтобы создать строку name=value из своих аргументов, а putenv просто
вставляет переданную строку непосредственно в список переменных окружения. Многие
реализации действуют именно так, поэтому было бы ошибкой передавать функции putenv
строки, размещенные в стеке, так как память стека еще не раз будет использована после
того, как текущая функция вернет управление в вызывающую программу.

Было бы интересно узнать, какие действия выполняются этими функциями при
изменении списка переменных окружения. Вспомните рис. 7.3: список переменных окружения — это массив указателей на строки в формате name=value, и эти
строки обычно хранятся в верхней части адресного пространства процесса — над
стеком. Операция удаления строки выглядит достаточно просто: нужный указатель отыскивается в массиве и все последующие указатели перемещаются на один
вниз. Но операция добавления новой строки или изменения существующей оказывается более сложной. Пространство над стеком не может быть раздвинуто, потому что эта область часто находится в старших адресах адресного пространства
процесса и не может расти вверх; она также не может расти вниз, потому что ниже
находится стек, который не может быть перемещен.
1.	 Если необходимо изменить значение существующей переменной name:
a)	 если длина подстроки value меньше или равна существующей, новая подстрока просто копируется поверх существующей;
б)	 если длина подстроки value больше существующей, необходимо выделить
память для новой строки с помощью функции malloc, скопировать туда новую строку и затем заменить в массиве старый указатель на новый.
2.	 Если добавляется новая переменная, требуются более сложные действия. Прежде всего нужно вызвать функцию malloc, выделить память для строки в формате name=value и скопировать ее туда:
a)	 затем, если новая переменная добавляется впервые, следует опять вызвать
malloc для выделения памяти под новый массив указателей, скопировать
список указателей в новое место, добавить к нему указатель на новую строку и, разумеется, поместить в  конец списка пустой указатель. Наконец,
записать в  переменную environ адрес нового списка. Обратите внимание:

270    Глава 7. Окружение процесса
если изначально список переменных окружения размещался выше стека (рис.  7.3), то теперь он переместится в  область динамической памяти
(в кучу). Однако большинство указателей в этом списке по-прежнему будут
указывать на строки, размещенные выше стека;
б)	 если добавление переменной производится не в  первый раз, мы уже знаем, что список указателей располагается в  куче. Поэтому нужно вызвать
realloc, чтобы выделить место для еще одного указателя, добавить в список новую строку name=value (на место пустого указателя) и затем записать
пустой указатель в самый конец списка.

7.10. Функции setjmp и longjmp
В языке C нельзя выполнить безусловный переход (оператор goto) к метке в теле
другой функции. В  таких случаях необходимо использовать функции setjmp
и  longjmp. Позже мы увидим, что эти функции очень удобны для обработки
ошибочных ситуаций, когда ошибка происходит в  глубоко вложенном вызове.
Рассмотрим программу-заготовку в  листинге 7.4. Здесь имеется главный цикл,
который читает строки со стандартного ввода и для обработки каждой вызывает
функцию do_line. Эта функция, в свою очередь, обращается к функции get_token,
которая выбирает из входной строки очередную лексему. Предполагается, что
первая лексема строки является некоторой командой, и оператор switch определяет, как обрабатывать каждую из команд. Для единственной показанной здесь
команды вызывается функция cmd_add.
Программа в листинге 7.4 представляет собой типичную заготовку для программ,
которые читают команды, определяют их тип и затем вызывают функции, соответствующие командам. На рис. 7.4 показано, как мог бы выглядеть стек после
вызова функции cmd_add.
Листинг 7.4. Типичная заготовка программы обработки команд
#include "apue.h"
#define TOK_ADD
void
void
int

do_line(char *);
cmd_add(void);
get_token(void);

int
main(void)
{
char

}

5

line[MAXLINE];

while (fgets(line, MAXLINE, stdin) != NULL)
do_line(line);
exit(0);

char *tok_ptr; /* глобальный указатель для get_token() */

7.10. Функции setjmp и longjmp   

271

void
do_line(char *ptr) /* обработка одной строки ввода */
{
int
cmd;

}

tok_ptr = ptr;
while ((cmd = get_token()) > 0) {
switch (cmd) { /* для каждой команды свой оператор case */
case TOK_ADD:
cmd_add();
break;
}
}

void
cmd_add(void)
{
int
token;

}

token = get_token();
/* остальные действия по обработке этой команды */

int
get_token(void)
{
/* получить очередную лексему из строки, на которую указывает tok_ptr */
}

Переменные с автоматическим классом размещения хранятся в пределах кадров
стека каждой из функций. Массив line хранится в  кадре стека функции main,
целочисленная переменная cmd — в кадре стека функции do_line, целочисленная
переменная token — в кадре стека функции cmd_add.
Дно стека

Кадр стека
функции main

Старшие адреса

Кадр стека
функции do_line

Направление
роста стека

Кадр стека
функции cmd_add

Младшие адреса

Рис. 7.4. Состояние стека после вызова функции cmd_add

Как уже говорилось, такая организация стека достаточно типична, но необязательна. Стеки не обязательно должны расти в направлении младших адресов памяти.
В системах, не имеющих аппаратной поддержки механизма стека, его реализация
на языке C могла бы использовать связанный список кадров стека.

272    Глава 7. Окружение процесса
При разработке программ, подобных представленной в  листинге 7.4, часто возникает проблема обработки нефатальных ошибок. Например, если функция cmd_
add встречает ошибку, скажем недопустимое число, может потребоваться вывести
сообщение об ошибке, проигнорировать остальную часть входной строки и вернуться в функцию main, чтобы перейти к обработке следующей строки. Но когда
ошибка возникает в  глубоко вложенной функции, сделать это на C достаточно
трудно. (В этом примере функция cmd_add находится на втором уровне вложенности относительно функции main, но часто точка, из которой требуется вернуться,
находится на пятом уровне вложенности и даже глубже.) Если в каждую функцию
добавлять код, который будет возвращать признак ошибки на один уровень вверх,
исходные тексты станут неудобочитаемыми.
Решение этой проблемы заключается в  использовании нелокальных переходов:
функций setjmp и  longjmp. Определение «нелокальный» означает, что мы не используем обычный оператор перехода языка C, вместо этого мы выполняем обратный переход через кадры стека к некоторой функции, которая находится в цепочке вызовов на пути к текущей функции.
#include <setjmp.h>
int setjmp(jmp_buf env);

Возвращает 0, если вызвана непосредственно, или ненулевое значение,
если возврат произошел в результате обращения к функции longjmp
void longjmp(jmp_buf env, int val);

Функция setjmp вызывается из точки, куда требуется вернуться; в данном примере она находится в функции main. В этом случае setjmp возвращает 0, потому
что это непосредственный вызов функции. Аргумент env функции setjmp имеет
специальный тип jmp_buf. Этот тип данных — своего рода массив, который может
хранить информацию, необходимую для восстановления состояния стека, когда
будет произведен вызов функции longjmp. Обычно переменная env является глобальной, так как она должна быть доступна из других функций.
Когда возникает ошибка, например, в  функции cmd_add, мы вызываем longjmp
с двумя аргументами. Первый — тот самый env, который использовался при обращении к setjmp, а второй — val, значение, отличное от нуля, которое становится
возвращаемым значением функции setjmp. Второй аргумент позволяет вызывать
longjmp более одного раза для каждого setjmp. Например, можно выполнить переход с помощью longjmp из cmd_add со значением аргумента val, равным 1, а из get_
token — со значением val, равным 2. В таком случае setjmp в функции main будет
возвращать либо 1, либо 2, что позволит определить, откуда произведен переход —
из cmd_add или из get_token.
Теперь вернемся к нашему примеру. В листинге 7.5 приводятся функции cmd_add
и main. (Две другие функции, do_line и get_token, остались без изменений.)

7.10. Функции setjmp и longjmp   

273

Листинг 7.5. Пример использования функций setjmp и longjmp
#include "apue.h"
#include <setjmp.h>
#define TOK_ADD

5

jmp_buf jmpbuffer;
int
main(void)
{
char

line[MAXLINE];

if (setjmp(jmpbuffer) != 0)
printf("ошибка");
while (fgets(line, MAXLINE, stdin) != NULL)
do_line(line);
exit(0);

}
...
void
cmd_add(void)
{
int
token;

}

token = get_token();
if (token < 0) /* проверка наличия ошибки */
longjmp(jmpbuffer, 1);
/* остальные действия по обработке этой команды */

Когда начинается выполнение функции main, функция setjmp записывает всю
необходимую информацию в  переменную jmpbuffer и  возвращает 0. Затем вызывается функция do_line, которая, в свою очередь, вызывает функцию cmd_add.
Теперь предположим, что была обнаружена некая ошибка. Перед вызовом функции longjmp из cmd_add стек выглядит, как показано на рис. 7.4. Функция longjmp
«раскручивает» стек в обратную сторону — до кадра функции main, выбрасывая
кадры, созданные во время вызова функций cmd_add и do_line (рис. 7.5). В результате вызова функции longjmp происходит возврат из функции setjmp в main, но на
этот раз возвращаемое значение равно 1 (второй параметр longjmp).
Дно стека

Старшие адреса
Кадр стека
функции main

Направление
роста стека

Младшие адреса

Рис. 7.5. Состояние стека после вызова функции longjmp

274    Глава 7. Окружение процесса

Переменные с классами размещения register,
automatic и volatile
Мы увидели, как выглядит стек после вызова функции longjmp. Следующий
вопрос, на который предстоит ответить: каково состояние автоматических и регистровых переменных в  функции main? Когда в  результате вызова функции
longjmp управление возвращается в функцию main, получают ли эти переменные
значения, которые они имели на момент вызова функции setjmp (то есть «откручиваются» ли их значения назад) или их значения остаются без изменения с момента вызова функции do_line (вызвавшей функцию cmd_add, которая, в свою
очередь, вызвала функцию longjmp)? К сожалению, ответ на этот вопрос: «Зависит от реализации». Большинство реализаций не «откручивают» назад автоматические и регистровые переменные, а стандарты утверждают, что их значения
в этом случае не определены. Если у вас есть автоматические переменные, значения которых не должны «откручиваться» назад, определите их со спецификатором volatile. Вызов функции longjmp не оказывает влияния на глобальные или
статические переменные.

Пример
Программа в листинге 7.6 демонстрирует различия в поведении автоматических,
регистровых, глобальных, статических и  volatile-переменных, наблюдаемые после вызова функции longjmp.
Листинг 7.6. Влияние longjmp на переменные с различными классами размещения
#include "apue.h"
#include <setjmp.h>
static void f1(int, int, int, int);
static void f2(void);
static jmp_buf
static int
int
main(void)
{
int
register int
volatile int
static int

jmpbuffer;
globval;

autoval;
regival;
volaval;
statval;

globval = 1; autoval = 2; regival = 3; volaval = 4; statval = 5;
if (setjmp(jmpbuffer) != 0) {
printf("после вызова longjmp:\n");
printf("globval = %d, autoval = %d, regival = %d,"
" volaval = %d, statval = %d\n",
globval, autoval, regival, volaval, statval);
exit(0);
}
/*

7.10. Функции setjmp и longjmp   

275

* Изменить переменные после вызова setjmp, но до вызова longjmp.
*/
globval = 95; autoval = 96; regival = 97; volaval = 98;
statval = 99;

}

f1(autoval, regival, volaval, statval); /* управление никогда */
/* не вернется в эту точку */
exit(0);

static void
f1(int i, int j, int k, int l)
{
printf("в функции f1():\n");
printf("globval = %d, autoval = %d, regival = %d,"
" volaval = %d, statval = %d\n", globval, i, j, k, l);
f2();
}
static void
f2(void)
{
longjmp(jmpbuffer, 1);
}

Если скомпилировать эту программу с включенной оптимизацией и без оптимизации, мы получим разные результаты:
$ gcc testjmp.c
$ ./a.out
в функции f1():
globval = 95, autoval
после вызова longjmp:
globval = 95, autoval
$ gcc -O testjmp.c
$ ./a.out
в функции f1():
globval = 95, autoval
после вызова longjmp:
globval = 95, autoval

скомпилировать без оптимизации
= 96, regival = 97, volaval = 98, statval = 99
= 96, regival = 97, volaval = 98, statval = 99
скомпилировать с полной оптимизацией
= 96, regival = 97, volaval = 98, statval = 99
= 2, regival = 3, volaval = 98, statval = 99

Обратите внимание, что оптимизация не оказывает влияния на глобальные,
статические переменные и  на переменные, объявленные со спецификатором
volatile; после вызова longjmp эти переменные сохраняют последние присвоенные им значения. Страница справочного руководства setjmp(3) в  одной из
систем заявляет, что переменные, хранящиеся в памяти, будут иметь те же значения, что и  в  момент вызова longjmp, тогда как переменные в  регистрах центрального процессора и  арифметического сопроцессора будут восстановлены
в состояние, соответствующее первому вызову функции setjmp. Это в точности
соответствует тому, что мы наблюдали в экспериментах с программой в листинге 7.6. Когда оптимизация отключена, все пять переменных сохраняются в памяти (спецификатор register для переменной regival игнорируется). Когда оптимизация включена, переменные autoval и  regival перемещаются в регистры
(даже при том, что первая из них не была объявлена как register), а переменная,
объявленная со спецификатором volatile, остается в памяти. Из этого примера

276    Глава 7. Окружение процесса
следует вывод: если вы пишете переносимый код, выполняющий нелокальные
переходы, используйте спецификатор volatile. В зависимости от системы могут обнаружиться и другие отличия.
Некоторые строки в листинге 7.6, содержащие обращения к функции printf, не
умещаются по ширине экрана, что несколько неудобно. Вместо того чтобы многократно повторять вызовы printf, мы полагаемся на возможность конкатенации
строк, предусмотренную стандартом ISO C, когда последовательность
"string1" "string2"

эквивалентна последовательности
"string1string2"

Мы еще вернемся к функциям setjmp и longjmp в главе 10, когда будем обсуждать
обработчики сигналов и версии этих функций для работы с сигналами: sigsetjmp
и siglongjmp.

Возможные проблемы с автоматическими переменными
Рассмотрев порядок работы с  кадрами стека, мы должны обратить ваше внимание на одну потенциальную ошибку, связанную с автоматическими переменными.
Всегда следует придерживаться основного правила — не обращаться к автоматической переменной после того, как функция, в которой она была объявлена, вернула управление. Многочисленные предупреждения об этом встречаются повсюду в справочном руководстве UNIX.
В листинге 7.7 показана функция open_data, которая открывает поток ввода/вывода и выполняет настройку режима его буферизации.
Листинг 7.7. Неправильное использование автоматической переменной
#include <stdio.h>
FILE *
open_data(void)
{
FILE
*fp;
char
databuf[BUFSIZ]; /*setvbuf сделает этот массив буфером ввода/вывода*/

}

if ((fp = fopen("datafile", "r")) == NULL)
return(NULL);
if (setvbuf(fp, databuf, _IOLBF, BUFSIZ) != 0)
return(NULL);
return(fp); /* ошибка */

Проблема в том, что когда функция open_data вернет управление, пространство на
стеке, которое она использовала, будут отдано под кадр стека следующей вызываемой функции. Однако стандартная библиотека ввода/вывода по-прежнему будет
использовать эту часть памяти под буфер потока ввода/вывода. Хаос неминуем.
Чтобы избежать этой проблемы, следует разместить массив databuf в глобальной
памяти, статически (static или extern) или динамически (с помощью одной из
функций распределения памяти).

7.11. Функции getrlimit и setrlimit   

277

7.11. Функции getrlimit и setrlimit
Любой процесс имеет ряд ограничений на использование ресурсов. Некоторые из
этих ограничений можно изменить с помощью функций getrlimit и setrlimit.
#include <sys/resource.h>
int getrlimit(int resource, struct rlimit *rlptr);
int setrlimit(int resource, const struct rlimit *rlptr);

Обе возвращают 0 в случае успеха,
–1 — в случае ошибки
Эти две функции определены стандартом Single UNIX Specification как расширения XSI.
Ограничения на ресурсы для процесса обычно устанавливаются процессом с идентификатором 0 во время инициализации системы и  затем наследуются остальными
процессами. Каждая реализация предлагает собственный способ настройки различных
ограничений.

При обращении к этим функциям им передается ресурс (resource) и указатель на
следующую структуру:
struct rlimit {
rlim_t rlim_cur; /* мягкий предел: текущий предел */
rlim_t rlim_max; /* жесткий предел: максимальное значение для rlim_cur */
};

Изменение пределов ресурсов производится в соответствии со следующими тремя правилами.
1.	 Процесс может изменять значение мягкого предела при условии, что оно не
превышает жесткий предел.
2.	 Процесс может понизить значение жесткого предела вплоть до значения мягкого предела. Операция понижения жесткого предела необратима для рядовых
пользователей.
3.	 Только процесс, обладающий привилегиями суперпользователя, может поднять значение жесткого предела.
Бесконечность предела определяется константой RLIM_INFINITY.
В аргументе resource передается одно из следующих значений.
RLIMIT_AS Максимальный размер доступной процессу памяти (в байтах). Этот
предел оказывает влияние на функции sbrk (раздел 1.11) и mmap (раздел 14.8).
RLIMIT_CORE Максимальный размер файла дампа памяти (core) в байтах. Значение 0 отключает создание таких файлов.
RLIMIT_CPU
Максимальное количество процессорного времени в  секундах. По
достижении мягкого предела процессу будет послан сигнал SIGXCPU.

278    Глава 7. Окружение процесса
Максимальный размер сегмента данных в байтах: сумма размеров
сегментов инициализированных данных, неинициализированных данных и кучи
(см. рис. 7.3).
RLIMIT_FSIZE Максимальный размер создаваемого файла в байтах. По достижении мягкого предела процессу будет послан сигнал SIGXFSZ.
RLIMIT_MEMLOCK Максимальный объем памяти в байтах, которую процесс может
заблокировать с помощью функции mlock(2).
RLIMIT_MSGQUEUE Максимальный объем памяти в байтах, которую процесс может
выделить для очередей сообщений POSIX.
RLIMIT_NICE Максимальный уровень (раздел 8.16), до которого процесс может
поднять свой приоритет.
RLIMIT_NOFILE Максимальное количество одновременно открытых файлов. Изменение этого предела оказывает влияние на значение, возвращаемое функцией
sysconf для аргумента _SC_OPEN_MAX (раздел 2.5.4 и листинг 2.4).
RLIMIT_NPROC Максимальное количество дочерних процессов на реальный идентификатор пользователя. Изменение этого предела оказывает влияние на значение, возвращаемое функцией sysconf для аргумента _SC_CHILD_MAX (раздел 2.5.4).
RLIMIT_NPTS Максимальное количество псевдотерминалов (глава 19), которые
могут быть открыты пользователем одновременно.
RLIMIT_RSS Максимальный объем страниц виртуальной памяти процесса, размещаемых резидентно в оперативной памяти, в байтах. Если физической памяти недостаточно, ядро будет «отнимать» память у процессов, которые превысили этот
предел.
RLIMIT_SBSIZE Максимальный объем буферов сокетов в байтах, который можно
использовать в конкретный момент времени.
RLIMIT_SIGPENDING Максимальное количество сигналов в очереди процесса. Этот
предел устанавливается функцией sigqueue (раздел 10.20).
RLIMIT_STACK Максимальный размер стека в байтах (см. рис. 7.3).
RLIMIT_SWAP Максимальный объем пространства подкачки в байтах, которое может быть занято пользователем.
RLIMIT_VMEM Синоним RLIMIT_AS.
В табл. 7.3 указано, какие ограничения на ресурсы определены стандартом Single
UNIX Specification и какие из них поддерживаются каждой из реализаций.
RLIMIT_DATA

Таблица 7.3. Поддерживаемые ограничения на ресурсы
Предел

XSI

FreeBSD 8.0

Linux 3.2.0

Mac OS X 10.6.8

Solaris 10

RLIMIT_AS







RLIMIT_CORE











RLIMIT_CPU











RLIMIT_DATA











RLIMIT_FSIZE













7.11. Функции getrlimit и setrlimit   

Предел

XSI

RLIMIT_MEMLOCK

FreeBSD 8.0

Linux 3.2.0

Mac OS X 10.6.8







RLIMIT_MSGQUEUE



RLIMIT_NICE



RLIMIT_NOFILE









RLIMIT_NPROC







RLIMIT_NPTS



RLIMIT_RSS







RLIMIT_SBSIZE



RLIMIT_SIGPENDING
RLIMIT_STACK

279

Solaris 10






RLIMIT_SWAP











RLIMIT_VMEM



Предельные значения для ресурсов оказывают влияние на вызывающий процесс
и  наследуются всеми его дочерними процессами. Это означает, что команда изменения ограничений на ресурсы должна быть встроена в командную оболочку,
чтобы воздействовать на все процессы, запускаемые из нее. И  действительно,
в командных оболочках Bourne shell, GNU Bourne-again shell и Korn shell имеется встроенная команда ulimit, а в командной оболочке C shell — команда limit.
(Коман­ды umask и chdir также должны быть встроенными.)

Пример
Программа в листинге 7.8 выводит текущие мягкие и жесткие значения для всех
пределов, поддерживаемых системой. Чтобы скомпилировать эту программу
в  различных реализациях UNIX, мы использовали директивы условной компиляции для подключения заголовочных файлов и обработки констант, имена которых могут различаться в разных системах. Обратите внимание, что некоторые
платформы определяют тип rlim_t как unsigned long long вместо unsigned long.
Более того, определение может отличаться в одной и той же системе в зависимости от типа платформы, 32- или 64-разрядной. Некоторые пределы определяют
размеры файлов, поэтому тип rlim_t должен быть достаточно большим, чтобы
с его помощью можно было представлять предельные значения размеров файлов.
Чтобы избежать предупреждений компилятора о неверных спецификаторах формата в функциях printf, мы сначала копируем значение предела в 64-разрядную
переменную, чтобы затем использовать единый формат.
Листинг 7.8. Вывод значений пределов ресурсов
#include "apue.h"
#include <sys/resource.h>
#define doit(name) pr_limits(#name, name)
static void pr_limits(char *, int);

280    Глава 7. Окружение процесса
int
main(void)
{
#ifdef RLIMIT_AS
doit(RLIMIT_AS);
#endif
doit(RLIMIT_CORE);
doit(RLIMIT_CPU);
doit(RLIMIT_DATA);
doit(RLIMIT_FSIZE);
#ifdef RLIMIT_MEMLOCK
doit(RLIMIT_MEMLOCK);
#endif
#ifdef RLIMIT_MSGQUEUE
doit(RLIMIT_MSGQUEUE);
#endif
#ifdef RLIMIT_NICE
doit(RLIMIT_NICE);
#endif
doit(RLIMIT_NOFILE);
#ifdef RLIMIT_NPROC
doit(RLIMIT_NPROC);
#endif
#ifdef RLIMIT_NPTS
doit(RLIMIT_NPTS);
#endif
#ifdef RLIMIT_RSS
doit(RLIMIT_RSS);
#endif
#ifdef RLIMIT_SBSIZE
doit(RLIMIT_SBSIZE);
#endif
#ifdef RLIMIT_SIGPENDING
doit(RLIMIT_SIGPENDING);
#endif
doit(RLIMIT_STACK);
#ifdef RLIMIT_SWAP
doit(RLIMIT_SWAP);
#endif
#ifdef RLIMIT_VMEM
doit(RLIMIT_VMEM);
#endif
}

exit(0);

static void

7.11. Функции getrlimit и setrlimit   

281

pr_limits(char *name, int resource)
{
struct rlimit
limit;
unsigned long long lim;

}

if (getrlimit(resource, &limit) < 0)
err_sys("ошибка вызова функции getrlimit для %s", name);
printf("%-14s ", name);
if (limit.rlim_cur == RLIM_INFINITY){
printf("(бесконечность)");
} else {
lim = limit.rlim_cur;
printf("%15lld ", lim);
}
if (limit.rlim_max == RLIM_INFINITY){
printf("(бесконечность)");
} else {
lim = limit.rlim_max;
printf("%15lld", lim);
}
putchar((int)'\n');

Обратите внимание, как для получения строки с именем ресурса в макросе doit
мы использовали оператор (#), который предусматривается стандартом ISO C.
Поэтому вызов макроса
doit(RLIMIT_CORE)

препроцессор C развернет в строку
pr_limits("RLIMIT_CORE", RLIMIT_CORE);

Запустив программу в FreeBSD, мы получили следующие результаты:
$ ./a.out
RLIMIT_AS
RLIMIT_CORE
RLIMIT_CPU
RLIMIT_DATA
RLIMIT_FSIZE
RLIMIT_MEMLOCK
RLIMIT_NOFILE
RLIMIT_NPROC
RLIMIT_NPTS
RLIMIT_RSS
RLIMIT_SBSIZE
RLIMIT_STACK
RLIMIT_SWAP
RLIMIT_VMEM

(бесконечность)
(бесконечность)
(бесконечность)
536870912
(бесконечность)
(бесконечность)
3520
1760
(бесконечность)
(бесконечность)
(бесконечность)
67108864
(бесконечность)
(бесконечность)

(бесконечность)
(бесконечность)
(бесконечность)
536870912
(бесконечность)
(бесконечность)
3520
1760
(бесконечность)
(бесконечность)
(бесконечность)
67108864
(бесконечность)
(бесконечность)

(бесконечность)
(бесконечность)
(бесконечность)
(бесконечность)
(бесконечность)
256
8388608
(бесконечность)

(бесконечность)
(бесконечность)
(бесконечность)
(бесконечность)
(бесконечность)
65536
(бесконечность)
(бесконечность)

В Solaris:
$ ./a.out
RLIMIT_AS
RLIMIT_CORE
RLIMIT_CPU
RLIMIT_DATA
RLIMIT_FSIZE
RLIMIT_NOFILE
RLIMIT_STACK
RLIMIT_VMEM

282    Глава 7. Окружение процесса
После знакомства с  сигналами мы продолжим обсуждение пределов ресурсов
в упражнении 10.11.

7.12. Подведение итогов
Понимание особенностей окружения программ, написанных на C, совершенно необходимо для понимания особенностей управления процессами в UNIX. Мы узнали, как запускается процесс, как он может завершиться и как процессу передаются списки аргументов и переменных окружения. Несмотря на то что ядро никак
не анализирует ни тот ни другой список, именно оно передает их новому процессу
от программы, вызвавшей exec.
Мы также исследовали типичную организацию памяти программ, написанных на
C, и  коснулись вопроса динамического распределения и  освобождения памяти.
Детально рассмотрели функции управления окружением, так как они связаны
с распределением памяти. Познакомились с функциями setjmp и longjmp, выполняющими нелокальные переходы в пределах процесса. И в завершение посмотрели, какие ограничения на ресурсы накладывают различные реализации.

Упражнения
7.1	

Если в Linux на аппаратной архитектуре x86 запустить программу «Привет, МИР!», которая не вызывает функцию exit и  не использует оператор  return для выхода из функции main, код завершения программы окажется равным 13 (это легко проверить средствами командной оболочки).
Почему?

7.2	

Когда фактически происходит отображение строк, которые выводятся с помощью функции printf в листинге 7.2?

7.3	

Существует ли способ получить доступ к аргументам командной строки из
функций, вызываемых из функции main, при условии, что (а) аргументы
argc и argv в вызываемую функцию не передаются и (б) их содержимое не
копируется в глобальные переменные?

7.4	

В некоторых реализациях UNIX нулевой адрес в сегменте данных программы преднамеренно делается недоступным. Почему?

7.5	

Попробуйте определить с  помощью typedef новый тип данных Exitfunc
для функции — обработчика выхода. Измените прототип функции atexit
с использованием этого типа.

7.6	

Если разместить массив значений типа long с  помощью функции calloc,
будут ли элементы массива инициализированы нулевыми значениями?
Если разместить массив указателей с помощью функции calloc, будут ли
элементы массива инициализированы как пустые указатели?

7.7	

Почему в конце раздела 7.6 мы не получили размеры стека и кучи от команды size?

Упражнения   

283

7.8	

Почему в разделе 7.7 размеры файлов (879 443 и 8378) не совпадают с суммой размеров их сегментов кода и данных?

7.9	

Почему в  разделе 7.7 при использовании разделяемых библиотек получается такая большая разница в размерах файлов такой простенькой программы?

7.10	 В конце раздела 7.10 мы показали, что функция не может возвращать указатель на локальную переменную с автоматическим классом размещения. Как
вы думаете, будет ли следующий код работать корректно?
int
f1(int val)
{
int
num = 0;
int
*ptr = &num;
if (val == 0) {
int val;
val = 5;
ptr = &val;

}

}
return(*ptr + 1);

8

Управление процессами

8.1. Введение
Теперь перейдем к  обсуждению управления процессами в  UNIX. Сюда относится создание новых процессов, запуск программ и  их завершение. Мы также
рассмотрим различные идентификаторы, определяющие принадлежность процесса,  — реальные, эффективные и  сохраненные идентификаторы пользователя
и группы — и их влияние на элементарные функции управления процессами. Также будут обсуждаться интерпретируемые файлы и функция system. В завершение
речь пойдет о средствах учета использования ресурсов процессами, предоставляемых большинством UNIX-систем. Это позволит взглянуть на функции управления процессами под другим углом.

8.2. Идентификаторы процесса
Любой процесс обладает уникальным идентификатором процесса, который представляет собой целое положительное число. Поскольку идентификатор процесса  — это единственный широко используемый идентификатор, уникальность
которого гарантируется системой, он часто присоединяется к другим идентификаторам для придания им уникальности. Например, приложения иногда включают идентификатор процесса в имена файлов, чтобы обеспечить их уникальность.
Но, несмотря на уникальность, идентификаторы процесса могут использоваться
многократно. По завершении процесса его идентификатор может использоваться
повторно для другого процесса. Однако в большинстве версий UNIX реализованы специальные алгоритмы, позволяющие отложить повторное использование
идентификатора на более позднее время, чтобы вновь созданный процесс не получил идентификатор процесса, завершившегося совсем недавно. Это помогает
избежать ситуации, когда новый процесс по ошибке может быть принят за предыдущий при использовании того же самого идентификатора.
Существует ряд специальных процессов, определяемых конкретной реализацией.
Процесс с идентификатором 0 — это, как правило, процесс-планировщик, который
часто называют swapper (программа подкачки). Этому процессу не соответствует
никакая программа на диске, поскольку он является частью ядра и считается системным процессом. Процесс с  идентификатором 1  — это обычно процесс init,

8.2. Идентификаторы процесса   

285

который запускается ядром в  конце процедуры начальной загрузки. В  старых
версиях UNIX этому процессу соответствует программа /etc/init, в более новых
версиях — /sbin/init. Этот процесс отвечает за запуск операционной системы после загрузки ядра. Обычно init читает системные файлы инициализации — /etc/
rc* или /etc/inittab, а  также файлы, расположенные в  каталоге /etc/init.d,
и переводит систему в некоторое состояние, например в многопользовательский
режим. Процесс init никогда не «умирает». Это обычный пользовательский процесс, он не является системным процессом ядра, как swapper, хотя и обладает привилегиями суперпользователя. Далее в  этой главе мы увидим, как процесс init
становится родительским процессом любого осиротевшего дочернего процесса.
В Mac OS X 10.4 на смену процессу init пришел процесс launchd, выполняющий тот же
комплекс задач, но имеющий более широкие функциональные возможности. Обсуждение
особенностей работы процесса launchd можно найти в разделе 5.10 [Singh, 2006].

Каждая версия UNIX имеет собственный набор процессов ядра, отвечающих за
работу системных служб. Например, в  некоторых реализациях виртуальной памяти UNIX идентификатор 2 соответствует процессу pagedaemon. Этот процесс
отвечает за поддержку страничного обмена системы виртуальной памяти.
В дополнение к  идентификатору процесса каждый процесс обладает еще рядом
идентификаторов. Вот функции, которые возвращают эти идентификаторы:
#include <unistd.h>
pid_t getpid(void);

Возвращает идентификатор вызывающего процесса
pid_t getppid(void);
uid_t getuid(void);

Возвращает идентификатор родительского процесса
Возвращает реальный идентификатор пользователя
вызывающего процесса

uid_t geteuid(void);

Возвращает эффективный идентификатор пользователя
вызывающего процесса
gid_t getgid(void);

Возвращает реальный идентификатор группы
вызывающего процесса
gid_t getegid(void);

Возвращает эффективный идентификатор группы
вызывающего процесса

286    Глава 8. Управление процессами
Примечательно, что ни одна из этих функций не возвращает признак ошибки.
Идентификатор родительского процесса мы рассмотрим в  следующем разделе,
где обсудим функцию fork. С реальным и эффективным идентификаторами пользователя и группы мы уже познакомились в разделе 4.4.

8.3. Функция fork
Любой процесс может создать новый процесс, вызвав функцию fork.
#include <unistd.h>
pid_t fork(void);

Возвращает 0 в дочернем процессе, идентификатор дочернего
процесса — в родительском, –1 — в случае ошибки
Новый процесс, созданный функцией fork, называется дочерним процессом, или
процессом-потомком. Эта функция вызывается один раз, а  управление возвращает дважды, с единственным отличием: в дочернем процессе она возвращает 0,
а  в  родительском  — идентификатор созданного дочернего процесса. Последнее
обстоятельство объясняется тем, что процесс может иметь несколько потомков,
а система не предусматривает функций, с помощью которых можно было бы получить идентификаторы дочерних процессов. В дочернем процессе функция fork
возвращает 0, поскольку дочерний процесс имеет только одного родителя и всегда
может получить его идентификатор с помощью функции getppid. (Идентификатор процесса 0 зарезервирован за ядром, поэтому невозможно получить 0 в качестве идентификатора дочернего процесса.)
И родительский и дочерний процессы продолжают выполнение программы с инструкции, следующей за вызовом функции fork. Процесс-потомок является точной копией родительского процесса. Например, потомок получает копии сегмента
данных, кучи и стека родителя. Обратите внимание, что это именно копии; родительский и  дочерний процессы не используют совместно одни и  те же области
памяти. Но они совместно используют сегмент кода (раздел 7.6).
Современные версии UNIX не производят немедленного полного копирования
сегмента данных, стека и кучи, потому что часто вслед за вызовом fork сразу же
следует вызов exec. Поэтому используется метод, который получил название копирование при записи (copy-on-write, COW). Указанные выше области памяти используются совместно обоими процессами, но ядро делает их доступными только
для чтения. Если один из процессов попытается изменить данные в этих областях,
ядро немедленно создаст копию конкретного участка памяти; обычно это «страница» виртуальной памяти. Более подробно об этом можно прочитать в разделе 9.2
[Bach, 1986] и в разделах 5.6 и 5.7 [McKusick et al., 1996].
Некоторые платформы предоставляют несколько версий функции fork. Все четыре
платформы, обсуждаемые в данной книге, поддерживают функцию vfork(2), которую
мы рассмотрим в следующем разделе.

8.3. Функция fork   

287

Кроме того, Linux 3.2.0 дает возможность создавать новые процессы с помощью системного вызова clone(2). Это более универсальный вариант функции fork, позволяющий
вызывающему процессу определить, что будет совместно использоваться дочерним и родительским процессами.
В FreeBSD 8.0 имеется системный вызов rfork(2), напоминающий системный вызов clone
в Linux и заимствованный из ОС Plan 9 ([Pike et al., 1995]).
В Solaris 10 имеются две библиотеки для работы с потоками выполнения: одна — для потоков POSIX (pthreads) и другая — для потоков Solaris. Поведение функции fork в этих
библиотеках различно. В случае потоков POSIX функция fork создает процесс, содержащий
только вызывающий поток, а в случае потоков Solaris — процесс, содержащий копии всех
потоков вызывающего процесса. В версии Solaris 10 это поведение изменилось; fork создает
дочерний процесс, содержащий только копию вызывающего потока выполнения, независимо
от используемой библиотеки. В Solaris также имеется функция fork1, которая создает
процесс, включающий только копию вызывающего потока выполнения, и функция forkall,
которая создает процесс, включающий копии всех потоков выполнения. Более подробно
потоки выполнения обсуждаются в главах 11 и 12.

Пример
Программа в листинге 8.1 демонстрирует работу с функцией fork и показывает,
что изменение переменных в  дочернем процессе никак не сказывается на переменных в родительском процессе.
Листинг 8.1. Пример работы с функцией fork
#include "apue.h"
int

globvar = 6; /* глобальная переменная в сегменте */
/* инициализированных данных */
char buf[] = "запись в stdout\n";
int
main(void)
{
int
pid_t

var; /* переменная, размещаемая на стеке */
pid;

var = 88;
if (write(STDOUT_FILENO, buf, sizeof(buf)-1) != sizeof(buf)-1)
err_sys("ошибка вызова функции write");
printf("перед вызовом функции fork\n"); /* мы не сбрасываем */
/* буферы stdout */
if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) { /* дочерний процесс */
globvar++;
/* изменить переменные */
var++;
} else {
sleep(2);
/* родительский процесс */
}

}

printf("pid = %ld, globvar = %d, var = %d\n", (long)getpid(), globvar,
var);
exit(0);

288    Глава 8. Управление процессами
После запуска программы мы получим:
$ ./a.out
запись в stdout
перед вызовом функции fork
pid = 430, globvar = 7, var
pid = 429, globvar = 6, var
$ ./a.out > temp.out
$ cat temp.out
запись в stdout
перед вызовом функции fork
pid = 432, globvar = 7, var
перед вызовом функции fork
pid = 431, globvar = 6, var

= 89
= 88

переменные в дочернем процессе были изменены
родительская копия осталась без изменений

= 89
= 88

В общем случае никогда нельзя сказать точно, какой из двух процессов первым
получит управление после вызова функции fork — дочерний или родительский.
Это во многом зависит от алгоритма планирования, используемого ядром. При
необходимости синхронизировать работу родительского и  дочернего процессов
можно воспользоваться каким-либо механизмом взаимодействий. В программе из
листинга 8.1 мы просто приостановили родительский процесс на 2 секунды, чтобы
позволить дочернему процессу выполняться первым. Но нет никакой гарантии,
что этот прием сработает при любых условиях. Об этом и некоторых других видах синхронизации мы поговорим в разделе 8.9, когда будем обсуждать состояние
гонки за ресурсами. В разделе 10.16 мы покажем, как использовать сигналы для
синхронизации родительского и дочернего процессов после возврата из функции
fork.
Записывая данные в стандартный вывод, мы вычитаем 1 из размера buf, чтобы избежать записи завершающего нулевого байта. Несмотря на то что функция strlen
вычисляет длину строки без учета завершающего нулевого байта, sizeof вычисляет размер буфера, который включает завершающий нулевой байт. Другое отличие:
обращение к strlen — это полноценный вызов функции, тогда как sizeof вычисляет размер буфера на этапе компиляции, поскольку буфер инициализирован известной строкой фиксированной длины.
Обратите внимание, как функция fork в программе из листинга 8.1 взаимодействует с  функциями ввода/вывода. В  главе 3 мы уже говорили, что функция
write не буферизуется. Так как функция write вызывается перед fork, она выведет данные в  стандартный вывод только один раз. С  другой стороны, стандартная библиотека ввода/вывода буферизуется. В  разделе 5.12 мы говорили,
что стандартному потоку вывода назначается режим построчной буферизации,
если он связан с терминалом, и режим полной буферизации — в любом другом
случае. Запуская программу в интерактивном режиме, мы получаем только одну
копию строки, выводимой функцией printf, потому что буфер стандартного вывода сбрасывается автоматически, когда встречается символ перевода строки.
Но когда стандартный поток вывода перенаправляется в файл, мы получаем две
копии строки. В этом случае перед обращением к  fork функция printf вызывается один раз, но строка в момент вызова функции fork еще находится в буфере.
В  результате этот буфер будет скопирован в  адресное пространство дочернего
процесса при копировании сегмента данных родителя. Оба процесса, родитель-

8.3. Функция fork   

289

ский и дочерний, получают стандартные буферы ввода/вывода, в которых хранится одна и та же строка. Второй вызов функции printf, который происходит
непосредственно перед вызовом функции exit, лишь добавляет свои данные
в конец существующего буфера. По завершении каждого из процессов его копия
буфера сбрасывается на диск.

Совместное использование файлов
Когда при запуске программы из листинга 8.1 мы перенаправляем стандартный
вывод родительского процесса в  файл, стандартный вывод дочернего процесса также оказывается перенаправленным. Действительно, одна из особенностей
функции fork в  том, что она передает дочернему процессу дубликаты всех дескрипторов, открытых в  родительском процессе. Мы говорим «дубликаты», потому что это действительно копии дескрипторов, подобные тем, что возвращает
функция dup. Родительский и  дочерний процессы совместно используют одни
и те же записи в таблице файлов для каждого из открытых дескрипторов (вспомните рис. 3.3).
Представьте процесс, открывший три файла: стандартного ввода, стандартного
вывода и стандартного вывода сообщений об ошибках. По возвращении из функции fork дескрипторы будут распределены, как показано на рис. 8.1.
Важно заметить, что родительский и дочерний процессы совместно используют
текущую позицию в  файле. Представьте процесс, запустивший дочерний процесс и  ожидающий его завершения. Допустим, что оба процесса в  ходе работы
производят запись в стандартный поток вывода. Если стандартный поток вывода родительского процесса будет перенаправлен в  файл (например, командной
оболочкой), текущая позиция в файле, установленная родительским процессом,
неизбежно будет изменена дочерним процессом, когда он выполнит запись в стандартный поток вывода. В этом случае дочерний процесс может записывать данные
в  стандартный поток вывода, пока родительский процесс ожидает его завершения. По завершении потомка родительский процесс сможет продолжить запись
в стандартный поток вывода, зная, что его данные будут записаны после тех, что
записал дочерний процесс. Если бы текущая позиция в файле различалась у родительского и дочернего процессов, подобного эффекта достичь было бы гораздо
сложнее, и это потребовало бы дополнительных усилий со стороны родительского
процесса.
Если и  родительский и  дочерний процессы пишут в  один и  тот же дескриптор
без какой-либо синхронизации, например, когда родительский процесс не ожидает завершения дочернего процесса, данные их вывода будут перемешаны (если
дескриптор был открыт до вызова функции fork). Хотя это возможно согласно
рис. 8.1, тем не менее такой режим работы не является нормальным.
Существуют два стандартных способа обслуживания дескрипторов после вызова
fork.
1.	 Родительский процесс ожидает, когда потомок завершится. В  этом случае
родительскому процессу ничего не нужно делать со своими дескрипторами.
Когда потомок завершится, текущая позиция в файле любого из разделяемых

290    Глава 8. Управление процессами
дескрипторов, которые использовались им для чтения или записи, изменится
надлежащим образом.
2.	 Оба процесса, родительский и дочерний, продолжают работу независимо друг
от друга. В этом случае после вызова функции fork родительский процесс закрывает дескрипторы, которые ему больше не потребуются, дочерний процесс
делает то же самое. То есть они прекращают совместно использовать одни и те
же дескрипторы. Этот сценарий часто используется в сетевых серверах.
Таблица дескрипторов
родительского процесса

Флаги
дескриптора

Указатель
на запись
в таблице
файлов

fd 0:
fd 1:
fd 2:

Запись в таблице файлов

Запись в таблице
виртуальных узлов

Флаги состояния файла

Информация
виртуального узла

Текущая позиция в файле

v_data

Указатель на виртуальный узел

Информация
индексного узла
Текущий размер файла

...

Флаги состояния файла
Текущая позиция в файле

i_vnode

Указатель на виртуальный узел
Информация
виртуального узла

Таблица дескрипторов
родительского процесса

Флаги
дескриптора
fd 0:
fd 1:
fd 2:
...

Указатель
на запись
в таблице
файлов

v_data
Флаги состояния файла

Информация
индексного узла

Текущая позиция в файле

Текущий размер файла

Указатель на виртуальный узел

i_vnode
Информация
виртуального узла

v_data
Информация
индексного узла
Текущий размер файла

i_vnode

Рис. 8.1. Совместное использование открытых файлов родительским и дочерним
процессами после вызова функции fork

Помимо открытых файлов, есть много других характеристик родительского процесса, которые наследуются дочерним:
 Реальный идентификатор пользователя, реальный идентификатор группы,
эффективный идентификатор пользователя, эффективный идентификатор
группы.

8.3. Функция fork   

291

 Идентификаторы дополнительных групп.
 Идентификатор группы процессов.
 Идентификатор сеанса.
 Управляющий терминал.
 Флаги set-user-ID и set-group-ID.
 Текущий рабочий каталог.
 Корневой каталог.
 Маска режима создания файлов.
 Маска сигналов и их диспозиция.
 Флаги close-on-exec для открытых дескрипторов.
 Окружение.
 Присоединенные сегменты разделяемой памяти.
 Отображения в память.
 Ограничения на ресурсы.
Существуют следующие отличия между родительским и дочерним процессами:
 Функция fork возвращает различные значения.
 Различные идентификаторы процессов.
 Различные идентификаторы родительских процессов: идентификатор родительского процесса в  потомке соответствует идентификатору процесса в  родительском процессе, идентификатор родительского процесса в родительском
процессе остается без изменений.
 Значения tms_utime, tms_stime, tms_cutime и  tms_cstime в дочернем процессе
устанавливаются равными 0.
 Блокировки файлов, установленные в родительском процессе, не наследуются.
 Таймеры, ожидающие срабатывания, в дочернем процессе сбрасываются.
 Набор сигналов, ожидающих обработки, в дочернем процессе очищается.
Многие из этих характеристик еще не обсуждались; мы поговорим о них в следующих главах.
Вызов функции fork терпит неудачу обычно в двух случаях: (а) когда в системе
слишком много действующих процессов, что обычно свидетельствует о неполадках, и  (б) когда общее количество процессов превысило системный предел для
заданного реального идентификатора пользователя. В табл. 2.10 мы уже указывали, что максимальное количество одновременно работающих процессов на один
реальный идентификатор пользователя определяется константой CHILD_MAX.
Два основных случая, когда используется функция fork:
1.	 Когда процесс хочет продублировать себя, чтобы родительский и  дочерний
процессы могли выполнять различные участки программы одновременно. Это
обычно используется в  сетевых серверах. Родительский процесс ожидает запроса от клиента и по его получении вызывает fork и передает обслуживание
запроса дочернему процессу, после чего возвращается к ожиданию следующего
запроса.

292    Глава 8. Управление процессами
2.	 Когда процесс хочет запустить другую программу. Эта ситуация характерна
для командных оболочек. В этом случае дочерний процесс вызывает функцию
exec (которую мы рассмотрим в разделе 8.10), как только функция fork вернет
управление.
Некоторые операционные системы объединяют вызов fork и  следующий за ним
вызов exec в одну операцию, которая называется spawn. UNIX разделяет две операции по той простой причине, что достаточно часто вызов fork не сопровождается
вызовом exec. Кроме того, такое разделение позволяет дочернему процессу между
вызовами fork и  exec изменить некоторые параметры процесса, например перенаправление ввода/вывода, идентификатор пользователя, диспозицию сигналов
и т. д. Многочисленные примеры, иллюстрирующие это, мы увидим в главе 15.
Стандарт Single UNIX Specification включает интерфейсы spawn в группу расширений
реального времени. Однако эти интерфейсы не служат заменой fork и  exec. Они предназначены для систем, в  которых имеются определенные сложности с  эффективной
реализацией функции fork, особенно для тех, в которых отсутствует аппаратная поддержка управления памятью.

8.4. Функция vfork
Порядок вызова и возвращаемые значения функций vfork и  fork одинаковы, но
их семантика различается.
Функция vfork впервые появилась в 2.9BSD. Некоторые считают ее пятном на репутации
UNIX, однако все платформы, обсуждаемые в этой книге, поддерживают ее. Разработчики удалили vfork из версии 4.4BSD, но все дистрибутивы BSD с открытыми исходными
текстами, происходящие от 4.4BSD, восстановили ее поддержку. В третьей версии Single
UNIX Specification функция vfork отмечена как устаревший интерфейс и в четвертой
версии была полностью удалена. Мы включили ее описание только как дань традиции.
Ее не следует использовать в переносимых приложениях.

Функция vfork предназначена для создания новых процессов, когда целью нового процесса является запуск новой программы с помощью функции exec (пункт 2
в конце предыдущего раздела). Программа из листинга 1.5 также относится к программам этого типа. Функция vfork создает новый процесс точно так же, как
fork, но не копирует адресное пространство родительского процесса в  адресное
пространство потомка, поскольку потомок не будет работать с  этим адресным
пространством — он просто вызывает функцию exec (или exit) сразу, как только vfork вернет управление. То есть до вызова exec или exit дочерний процесс
выполняется в  адресном пространстве родительского процесса. Такой подход
более эффективен для некоторых реализаций UNIX, но может приводить к  непредсказуемым результатам, если дочерний процесс изменит какие-либо данные
(исключение составляет переменная, используемая для сохранения значения,
возвращаемого функцией vfork), вызовет другие функции или вернет управление, не вызывая exec или exit. (Как уже упоминалось в предыдущем разделе, для
повышения эффективности работы связки fork/exec многие реализации исполь-

8.4. Функция vfork   

293

зуют технику копирования при записи, но полное отсутствие копирования все же
гораздо эффективнее, чем копирование даже небольших объемов данных.)
Еще одно различие между этими функциями — vfork гарантирует, что дочерний
процесс получит управление первым и  будет удерживать его, пока не вызовет
функцию exec или exit. Когда дочерний процесс вызовет любую из этих функций, родительский процесс возобновит работу. (Это может привести к тупиковой
ситуации, если процесс-потомок зависит от дальнейших действий родительского
процесса, которые должны быть выполнены до вызова любой из этих функций.)

Пример
Программа в листинге 8.2 — это измененная версия программы из листинга 8.1.
Мы заменили функцию fork на vfork и убрали запись в стандартный вывод. Теперь нет необходимости приостанавливать родительский процесс с  помощью
функции sleep, поскольку vfork гарантирует, что он будет приостановлен ядром,
пока дочерний процесс не вызовет exec или exit.
Листинг 8.2. Пример работы с функцией vfork
#include "apue.h"
int globvar = 6; /* глобальная переменная в сегменте инициализированных данных */
int
main(void)
{
int
pid_t

var; /* локальная переменная в стеке */
pid;

var = 88;
printf("перед вызовом функции vfork\n"); /* мы не сбрасываем буферы stdout */
if ((pid = vfork()) < 0) {
err_sys("ошибка вызова функции vfork");
} else if (pid == 0) { /* дочерний процесс */
globvar++;
/* изменить переменные */
var++;
_exit(0);
/* завершение дочернего процесса */
}

}

/*
* Родительский процесс продолжит работу отсюда.
*/
printf("pid = %ld, globvar = %d, var = %d\n", (long)getpid(), globvar, var);
exit(0);

Запуск этой программы дает следующие результаты:
$ ./a.out
перед вызовом функции vfork
pid = 29039, globvar = 7, var = 89

Здесь значения переменных, увеличенные в  дочернем процессе, изменились
и в родительском процессе. Поскольку известно, что дочерний процесс продолжает работу в адресном пространстве родительского процесса, это не стало для нас

294    Глава 8. Управление процессами
сюрпризом. Однако это поведение отличается от того, что мы видели при работе
с функцией fork.
Обратите внимание, что в  программе из листинга 8.2 вместо функции exit используется _exit. Как уже говорилось в разделе 7.3, функция _exit не производит
сброс буферов ввода/вывода. Вызвав функцию exit, мы получили бы несколько
иные результаты. В зависимости от реализации стандартной библиотеки ввода/
вывода мы могли бы и не заметить никаких различий или увидели бы, что пропали данные, выводимые функцией printf в родительском процессе.
Когда дочерний процесс завершает работу вызовом exit, содержимое всех буферов ввода/вывода сбрасывается. Если это единственное действие, которое производится библиотекой, мы не увидим никаких различий по сравнению с вызовом
_exit. Однако если реализация дополнительно закрывает потоки ввода/вывода,
память, в  которой размещается объект FILE стандартного потока вывода, будет
очищена. Поскольку дочерний процесс заимствует адресное пространство родительского процесса, когда родительский процесс возобновит работу и  вызовет
функцию printf, она ничего не сможет вывести и вернет признак ошибки (–1).
Обратите внимание, что дескриптор STDOUT_FILENO родительского процесса все
еще является допустимым, поскольку дочерний процесс получает копию массива
файловых дескрипторов родительского процесса (см. рис. 8.1).
В большинстве современных реализаций функция exit не закрывает потоки ввода/вывода.
Поскольку процесс собирается завершить работу, ядро все равно закроет все открытые
дескрипторы файлов. Закрытие их в библиотеке только увеличивает нагрузку и не несет
никакой выгоды.

Дополнительные сведения о  реализации функций fork и  vfork можно найти
в  [McKusick et al., 1996], раздел 5.6. К  изучению функции vfork мы вернемся
в упражнениях 8.1 и 8.2.

8.5. Функции exit
В разделе 7.3 упоминалось пять способов нормального завершения работы процесса.
1.	 Возврат из функции main. Как уже говорилось в разделе 7.3, это эквивалентно
вызову функции exit.
2.	 Вызов функции exit. Эта функция определена стандартом ISO C, она производит вызов всех функций — обработчиков выхода, зарегистрированных
функцией atexit, и  закрывает все стандартные потоки ввода/вывода. Поскольку стандарт ISO C не затрагивает дескрипторы файлов, многозадачность
(родительский и  дочерний процессы) и  управление заданиями, определение
этой функции для UNIX является неполным.
3.	 Вызов функции _exit или _Exit. Стандарт ISO C определяет функцию _Exit
как способ завершения процесса без запуска функций — обработчиков выхода или обработчиков сигналов. При этом от конкретной реализации зависит,

8.5. Функции exit   

295

­ удут ли буферы ввода/вывода сбрасываться на диск или нет. В системе UNIX
б
имена _exit и _Exit являются синонимами, обе функции не сбрасывают буферы ввода/вывода. Функция _exit вызывается из exit и производит действия,
характерные для UNIX. Функция _exit определена стандартом POSIX.1.
В большинстве версий UNIX exit(3) реализована как библиотечная функция, а _exit(2) —
как системный вызов.

4.	 Возврат из процедуры запуска последнего потока выполнения в процессе. Код
завершения потока при этом не будет использоваться в  качестве кода завершения процесса. Когда последний поток выполнения в процессе вернется из
своей процедуры запуска, процесс завершится с кодом 0.
5.	 Вызов функции pthread_exit из последнего потока выполнения в  процессе.
Как и в предыдущем случае, процесс вернет код завершения 0, аргумент функции pthread_exit при этом игнорируется. Более подробно об этой функции мы
поговорим в разделе 11.5.
Три способа ненормального завершения процесса:
1.	 Вызов функции abort. Это особый случай следующего способа, так как данная
функция генерирует сигнал SIGABRT.
2.	 При получении процессом некоторых сигналов. (Более подробно о  сигналах
рассказывается в главе 10.) Сигнал может сгенерировать сам процесс (например, с помощью функции abort), другие процессы или ядро. К последним относятся сигналы, передаваемые при попытке обратиться к памяти вне адресного пространства процесса или при попытке деления на ноль.
3.	 По запросу на завершение последнего потока выполнения. По умолчанию завершение потока происходит с некоторой задержкой: один поток запрашивает
завершение другого потока, и через какое-то время указанный поток завершается. Мы обсудим запросы на завершение в разделах 11.5 и 12.7.
Независимо от того, как именно завершается процесс, в конечном итоге ядро выполняет один и тот же код. Этот код закрывает все открытые дескрипторы, освобождает занимаемую процессом память и т. д.
Для любого из перечисленных способов завершающийся процесс должен иметь
возможность известить родительский процесс о том, как он завершился. В случае
трех функций выхода (exit, _exit и  _Exit) родительскому процессу через аргумент функции передается код завершения. А в случае ненормального завершения
ядро — не процесс — генерирует код, указывающий причину ненормального завершения процесса. В любом случае родительский процесс может получить код
завершения от функции wait или waitpid (описание этих функций дается в следующем разделе).
Обратите внимание на различие между кодом выхода, который является аргументом одной из трех функций выхода или возвращаемым значением функции main,
и кодом завершения. Ядро преобразует код выхода в код завершения, когда в заключение вызывается функция _exit (рис. 7.1). В табл. 8.1 перечислены способы,
с помощью которых родительский процесс может получить код завершения до-

296    Глава 8. Управление процессами
чернего процесса. Если дочерний процесс завершился нормально, родительский
процесс может получить его код выхода.
Когда мы описывали функцию fork, было очевидно, что родительский процесс
продолжает существовать после вызова функции fork. Сейчас мы говорим о возврате кода завершения родительскому процессу. Но что произойдет, если родительский процесс завершится раньше дочернего? Ответ таков: родителем любого
процесса, родительский процесс которого завершился раньше его самого, становится процесс init. В таком случае мы говорим, что процесс был унаследован процессом init. Обычно при завершении какого-либо процесса ядро проверяет все
активные процессы, чтобы узнать, не является ли завершившийся процесс чьимлибо родителем. Если это так, для процесса, оставшегося активным, идентификатором родительского процесса назначается 1 (идентификатор процесса init).
Благодаря этому удается гарантировать наличие родителя у любого процесса.
Еще один момент, который нужно рассмотреть, — когда дочерний процесс заканчивает работу раньше родительского. Если дочерний процесс полностью исчезнет,
родительский процесс не сможет получить его код завершения, когда это потребуется. Ядро сохраняет некоторый объем информации о каждом завершившемся
процессе, чтобы она была доступна, когда родительский процесс вызовет функцию wait или waitpid. В простейшем случае эта информация состоит из идентификатора процесса, кода завершения и количества процессорного времени, затраченного процессом. Ядро может освободить всю память, занимаемую процессом,
и закрыть его открытые файлы. В терминологии UNIX процесс, который завершился, но при этом его родительский процесс не уловил этого момента, называют
зомби. Команда ps(1) выводит в поле состояния процесса-зомби символ Z. Если
написать долго работающую программу, которая порождает множество дочерних
процессов, они будут превращаться в зомби, если программа не станет дожидаться
получения от них кодов завершения.
В некоторых системах существует возможность предотвратить появление зомби; в разделе 10.7 будет описано, как именно это сделать.

Наконец, рассмотрим случай, когда заканчивается процесс, унаследованный
процессом init. Превращается ли он в  зомби? Нет, потому что init создан так,
что всякий раз, когда один из его потомков завершается, init вызывает одну из
функций wait, чтобы забрать код завершения. Таким способом init препятствует
засорению системы процессами-зомби. Под «потомками процесса init» мы подразумеваем как процессы, запущенные непосредственно процессом init (например, getty, который описывается в разделе 9.2), так и унаследованные, родители
которых завершили работу.

8.6. Функции wait и waitpid
Когда процесс завершается, обычным образом или аварийно, ядро извещает об
этом родительский процесс с помощью сигнала SIGCHLD. Поскольку завершение
дочернего процесса есть событие асинхронное (оно может произойти в любой момент), то и сигнал является асинхронным извещением, посылаемым ядром роди-

8.6. Функции wait и waitpid   

297

тельскому процессу. Родительский процесс может проигнорировать сигнал или
определить функцию, которая будет вызвана по прибытии сигнала, — обработчик
сигнала. По умолчанию процессы игнорируют этот сигнал. Мы обсудим возможные варианты поведения в главе 10. А пока достаточно запомнить, что функции
wait и waitpid, вызванные родительским процессом, могут:
 Заблокировать процесс, если все его дочерние процессы продолжают работу.
 Сразу же вернуть управление с  кодом завершения дочернего процесса, если
он уже закончил работу и ожидает, пока родительский процесс заберет код завершения.
 Сразу же вернуть управление с признаком ошибки, если у вызвавшего процесса нет ни одного дочернего процесса.
Если процесс вызывает wait по получении сигнала SIGCHLD, функция сразу же
вернет управление. Но если wait была вызвана в  любой произвольный момент
времени, она может заблокировать родительский процесс.
#include <sys/wait.h>
pid_t wait(int *statloc);
pid_t waitpid(pid_t pid, int *statloc, int options);

Обе возвращают идентификатор процесса в случае успеха,
–1 — в случае ошибки
Эти функции имеют следующие различия:
 Функция wait может заблокировать вызывающий процесс, пока не завершится дочерний процесс, в то время как функция waitpid дает возможность предотвратить блокировку.
 Функция waitpid не ждет первого завершившегося дочернего процесса — можно указать, завершения какого процесса она должна ожидать.
Если дочерний процесс уже завершился и находится в состоянии зомби, функция
wait сразу же вернет управление и  передаст код его завершения. Иначе она заблокирует вызывающий процесс до момента, пока дочерний процесс не завершит
свою работу. Если у вызывающего процесса имеется несколько дочерних процессов, функция wait вернет управление, когда завершит работу любой из них. Мы
всегда можем узнать, какой из потомков завершился, поскольку функция возвращает идентификатор процесса.
В обеих функциях аргумент statloc является указателем на целое число. Если в аргументе передается непустой указатель, по заданному адресу будет записан код
завершения дочернего процесса. Если код завершения нас не интересует, можно
передать в этом аргументе пустой указатель.
Целочисленный код завершения, возвращаемый этими двумя функциями, традиционно определяется реализацией. В нем несколько битов отводится под код
выхода (в случае нормального завершения работы), несколько битов — под номер
сигнала (в случае аварийного завершения), один бит указывает, был ли создан

298    Глава 8. Управление процессами
файл дампа памяти (файл core), и т. д. Согласно стандарту POSIX.1, в файле <sys/
wait.h> определяются различные макросы, с помощью которых производится извлечение кодов выхода. Определить, как завершился процесс, можно с помощью
четырех взаимоисключающих макросов, имена которых начинаются с префикса
WIF. В зависимости от того, какой из этих четырех макросов возвращает истину,
можно использовать другие макросы, чтобы получить код выхода, номер сигнала
и другую информацию. Все четыре макроопределения приводятся в табл. 8.1.
Таблица 8.1. Макроопределения для проверки кода завершения, возвращаемого
функциями wait и waitpid
Макроопределение
WIFEXITED(status)

Описание

Возвращает true, если код status получен в результате нормального завершения дочернего процесса. В этом случае можно извлечь
младшие 8 бит из аргумента, который был передан функции exit,
_exit или _Exit:
WEXITSTATUS(status)

WIFSIGNALED(status)

Возвращает true, если код status получен в результате ненормального (аварийного) завершения дочернего процесса из-за
сигнала, который не был перехвачен. В этом случае можно узнать
номер сигнала, вызвавшего завершение дочернего процесса:
WTERMSIG(status)

Кроме того, в некоторых реализациях (но не в Single UNIX
Specification) определен макрос
WCOREDUMP(status)

который возвращает true, если в результате аварийного завершения процесса создан файл с дампом памяти (core-файл)
WIFSTOPPED(status)

Возвращает true, если код status получен в результате остановки
дочернего процесса по сигналу. В этом случае можно узнать номер
сигнала, который вызвал остановку процесса, с помощью макроса
WSTOPSIG(status)

WIFCONTINUED(status)

Возвращает true, если код status получен для дочернего процесса, который продолжил работу после остановки (расширение XSI
в стандарте POSIX.1 — только для функции waitpid)

В разделе 9.8, когда речь пойдет об управлении заданиями, мы увидим, как можно
остановить процесс.

Пример
Функция pr_exit в листинге 8.3 использует макросы из табл. 8.1 для вывода сведений, полученных из кода завершения. В этой книге мы будем использовать ее
во многих примерах. Обратите внимание, что эта функция обращается к макросу
WCOREDUMP, если он определен в системе.
Листинг 8.3. Вывод сведений, полученных из кода завершения
#include "apue.h"
#include <sys/wait.h>

8.6. Функции wait и waitpid   

299

void
pr_exit(int status)
{
if (WIFEXITED(status))
printf("нормальное завершение, код выхода = %d\n",
WEXITSTATUS(status));
else if (WIFSIGNALED(status))
printf("аварийное завершение, номер сигнала = %d%s\n",
WTERMSIG(status),
#ifdef WCOREDUMP
WCOREDUMP(status) ? " (создан файл core)" : "");
#else
"");
#endif
else if (WIFSTOPPED(status))
printf("дочерний процесс остановлен, номер сигнала = %d\n",
WSTOPSIG(status));
}

FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 и Solaris 10 поддерживают макроопределение
WCOREDUMP. Но некоторые платформы скрывают его определение, если определена константа _POSIX_C_SOURCE (раздел 2.7).

Программа в  листинге 8.4 демонстрирует интерпретацию различных значений
кода завершения с помощью функции pr_exit. Запустив ее, мы получим следующие результаты:
$ ./a.out
нормальное завершение, код выхода = 7
аварийное завершение, номер сигнала = 6 (создан файл core)
аварийное завершение, номер сигнала = 8 (создан файл core)

Сейчас мы получаем номер сигнала от WTERMSIG. Чтобы убедиться, что сигнал
SIGABRT имеет значение 6, а сигнал SIGFPE — значение 8, можно заглянуть в файл
<signal.h>. Переносимый способ отображения номера сигнала в  описательное
имя будет представлен в разделе 10.22.
Как уже говорилось выше, если родительский процесс имеет несколько процессов-потомков, функция wait вернет управление по завершении любого из них.
А что делать, если требуется дождаться завершения конкретного дочернего процесса (при условии, что известен его идентификатор)? В ранних версиях UNIX
приходилось вызывать функцию wait и сравнивать возвращаемый ею идентификатор процесса с  интересующим. Если завершившийся процесс оказывался не
тем, который мы ожидали, приходилось сохранять идентификатор процесса и код
его завершения в отдельном списке и снова вызывать функцию wait. Эту операцию надо было повторять до тех пор, пока не завершится желаемый процесс. Если
после этого нужно было дождаться завершения другого процесса, мы вынуждены были сначала просмотреть список уже завершившихся процессов, и если его
в этом списке не было, вызывать функцию wait. Таким образом, возникла потребность в  функции, которая ожидала бы завершения конкретного процесса. Эта
функциональность (и даже больше) заложена в функцию waitpid, которая определена стандартом POSIX.1.

300    Глава 8. Управление процессами
Листинг 8.4. Интерпретация различных кодов завершения
#include "apue.h"
#include <sys/wait.h>
int
main(void)
{
pid_t
int

pid;
status;

if ((pid = fork()) < 0)
err_sys("ошибка вызова функции fork");
else if (pid == 0)
/* дочерний процесс */
exit(7);
if (wait(&status) != pid) /* дождаться завершения дочернего процесса */
err_sys("ошибка вызова функции wait");
pr_exit(status);
/* и вывести код завершения */
if ((pid = fork()) < 0)
err_sys("ошибка вызова функции fork");
else if (pid == 0)
/* дочерний процесс */
abort();
/* послать сигнал SIGABRT */
if (wait(&status) != pid) /* дождаться завершения дочернего процесса */
err_sys("ошибка вызова функции wait");
pr_exit(status);
/* и вывести код завершения */
if ((pid = fork()) < 0)
err_sys("ошибка вызова функции fork");
else if (pid == 0)
/* дочерний процесс */
status /= 0;
/* деление на 0 сгенерирует сигнал SIGFPE */
if (wait(&status) != pid) /* дождаться завершения дочернего процесса */
err_sys("ошибка вызова функции wait");
pr_exit(status);
/* и вывести код завершения */
}

exit(0);

Интерпретация аргумента pid функцией waitpid зависит от его значения:
pid == -1	Ожидает завершения любого дочернего процесса. В  данном случае
функция waitpid эквивалентна функции wait.
pid > 0 	
Ожидает завершения процесса с идентификатором, равным pid.
pid == 0 	Ожидает завершения любого дочернего процесса с тем же идентификатором группы процессов, что и  у  вызывающего процесса (группы
процессов обсуждаются в разделе 9.4).
pid < -1 	Ожидает завершения любого дочернего процесса с идентификатором
группы процессов, совпадающим с pid.
Функция waitpid возвращает идентификатор завершившегося дочернего процесса и  сохраняет его код завершения по адресу в  аргументе statloc. Функция wait
может вернуть признак ошибки, только когда процесс не имеет потомков. (Еще
одна ошибочная ситуация возможна, если выполнение функции было прервано

8.6. Функции wait и waitpid   

301

сигналом. Мы обсудим этот вариант в главе 10.) Но функция waitpid может завершиться ошибкой также, если заданный процесс или группа процессов не существуют или не являются потомками вызывающего процесса.
Аргумент options позволяет управлять поведением функции waitpid. Он может
содержать 0 или значение, полученное в результате поразрядной операции ИЛИ
(OR) из констант, перечисленных в табл. 8.2.
FreeBSD 8.0 и Solaris 10 поддерживают одну дополнительную, нестандартную, константу
для аргумента options. WNOWAIT вынуждает систему сохранить процесс, код завершения
которого возвращается функцией waitpid, благодаря чему его можно получить повторно.
Таблица 8.2. Константы для аргумента options функции waitpid
Константа

Описание

WCONTINUED

Если реализация поддерживает управление заданиями, функция waitpid
вернет код состояния потомка, определяемого аргументом pid, который
возобновил работу после остановки и чей код состояния еще не был получен
(расширение XSI стандарта POSIX.1)

WNOHANG

Функция waitpid не блокирует вызывающий процесс, если потомок, определяемый аргументом pid, еще не изменил свое состояние. В этом случае
функция вернет 0

WUNTRACED

Если реализация поддерживает управление заданиями, функция waitpid
вернет код состояния дочернего процесса, определяемого аргументом pid,
который был остановлен и код состояния которого еще не был получен. Макрокоманда WIFSTOPPED позволяет определить, соответствует ли возвращаемое
значение остановленному дочернему процессу

Функция waitpid предоставляет три возможности, которых лишена функция
wait.
1.	 Функция waitpid позволяет указать процесс, завершения которого необходимо дождаться, в  то время как wait возвращает код состояния первого завершившегося процесса-потомка. Мы вернемся к обсуждению этой возможности,
когда будем рассказывать о функции popen.
2.	 Функция waitpid дает возможность предотвратить блокировку, когда требуется лишь узнать состояние дочернего процесса и нежелательно, чтобы вызывающий процесс заблокировался.
3.	 Функция waitpid поддерживает управление заданиями с  помощью констант
WUNTRACED и WCONTINUED.

Пример
Вернемся к обсуждению процессов-зомби, начатому в разделе 8.5. Если необходимо, чтобы процесс, создавший потомка с помощью функции fork, не дожидался
его завершения и при этом процесс-потомок не превращался в зомби до завершения родительского процесса, функцию fork следует вызвать дважды. Этот прием
использует программа в листинге 8.5.

302    Глава 8. Управление процессами
Листинг 8.5. Предотвращение появления зомби за счет двойного вызова
функции fork
#include "apue.h"
#include <sys/wait.h>
int
main(void)
{
pid_t

pid;

if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) { /* первый потомок */
if ((pid = fork()) < 0)
err_sys("ошибка вызова функции fork");
else if (pid > 0)
exit(0);
/* первый потомок, он же */
/* родительский процесс для второго потомка */
/*
* Здесь продолжает работу второй потомок, для которого родительским
* стал процесс init, поскольку настоящий родительский процесс
* вызвал функцию exit() чуть выше.
* Теперь можно продолжить работу, зная, что когда процесс завершится,
* его код завершения получит процесс init.
*/
sleep(2);
printf("второй потомок, идентификатор родительского процесса = %ld\n",
(long)getppid());
exit(0);
}
if (waitpid(pid, NULL, 0) != pid) /* ждать завершения первого потомка */
err_sys("ошибка вызова функции waitpid");

}

/*
* Здесь продолжает работу родительский (первоначальный) процесс,
* поскольку он не является родительским процессом для второго потомка.
*/
exit(0);

Мы приостановили работу второго потомка на две секунды, чтобы гарантировать,
что первый потомок завершит свою работу до того, как будет выведен идентификатор родительского процесса. Функция fork вернет управление как родительскому,
так и дочернему процессу, но мы никогда заранее не знаем, кто из них будет первым.
Если бы второй дочерний процесс не был приостановлен и после вызова функции
fork получил бы управление первым, идентификатор процесса, функция printf,
вывела бы идентификатор первичного родительского процесса, а не процесса init.
Запустив программу из листинга 8.5, мы получили
$ ./a.out
$ второй потомок, идентификатор родительского процесса = 1

Обратите внимание, что командная оболочка вывела приглашение (символ $), как
только первичный процесс завершился, то есть еще до того, как второй потомок
вывел идентификатор своего родительского процесса.

8.7. Функция waitid   

303

8.7. Функция waitid
Расширения XSI стандарта Single UNIX Specification включают дополнительную
функцию, которая может получить код выхода процесса. Функция waitid очень
похожа на функцию waitpid, но обладает дополнительными возможностями.
#include <sys/wait.h>
int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Подобно waitpid, функция waitid позволяет процессу указать на потомка, завершения которого необходимо дождаться. Вместо того чтобы передавать эту
информацию вместе с идентификатором процесса или группы процессов в закодированном виде через единственный аргумент, функция waitid предоставляет
два отдельных аргумента. Значение аргумента id интерпретируется в зависимости
от значения аргумента idtype. Возможные значения этого аргумента приводятся
в табл. 8.3.
Таблица 8.3. Возможные значения аргумента idtype функции waitid
Константа

Описание

P_PID

Ждать завершения конкретного процесса. Аргумент id содержит его идентификатор

P_PGID

Ждать завершения дочернего процесса, принадлежащего к указанной группе
процессов. Аргумент id содержит идентификатор группы процессов

P_ALL

Ждать завершения любого дочернего процесса. Содержимое аргумента id
игнорируется

Аргумент options содержит результат поразрядной операции ИЛИ (OR) из констант, перечисленных в табл. 8.4. Эти константы определяют, какие изменения состояния дочернего процесса интересуют вызывающий процесс.
Таблица 8.4. Константы для аргумента options функции waitid
Константа

Описание

WCONTINUED

Ждать завершения процесса, который возобновил работу после остановки
и код состояния которого еще не был получен

WEXITED

Получить информацию о состоянии завершившегося процесса

WNOHANG

Сразу же вернуть управление и не блокировать вызывающий процесс, если
код выхода дочернего процесса недоступен

WNOWAIT

Не уничтожать информацию о состоянии дочернего процесса, чтобы затем ее
можно было получить с помощью функции wait, waitpid или waitid

WSTOPPED

Ждать завершения процесса, который был остановлен и код состояния которого еще не был получен

304    Глава 8. Управление процессами
В аргументе options должна быть указана хотя бы одна из констант: WCONTINUED,
WEXITED или WSTOPPED.
Аргумент infop — указатель на структуру siginfo с подробной информацией о сигнале, вызвавшем изменение состояния дочернего процесса. Структура siginfo будет рассмотрена в разделе 10.14.
Из четырех платформ, обсуждаемых в данной книге, только Linux 3.2.0, Mac OS X 10.6.8
и Solaris 10 поддерживают функцию waitid. Но имейте в виду, что в Mac OS X 10.6.8 эта
функция возвращает в структуре siginfo не всю информацию, которую можно было бы
ожидать.

8.8. Функции wait3 и wait4
Большинство реализаций UNIX поддерживают две дополнительные функции:
wait3 и wait4. Они впервые появились в ветке BSD. Единственное их преимущество перед wait, waitid и waitpid заключается в дополнительном аргументе, через
который ядро может вернуть краткую справку о ресурсах, использованных завершившимся процессом и всеми его дочерними процессами.
#include
#include
#include
#include

<sys/types.h>
<sys/wait.h>
<sys/time.h>
<sys/resource.h>

pid_t wait3(int *statloc, int options, struct rusage *rusage);
pid_t wait4(pid_t pid, int *statloc, int options, struct rusage *rusage);

Обе возвращают идентификатор процесса в случае успеха,
0 или –1 — в случае ошибки
Информация об использованных ресурсах включает такие сведения, как количество процессорного времени (пользовательского и  системного), неудачных по­
пыток обращений к страницам виртуальной памяти, принятых сигналов и т. п. За
подробностями обращайтесь к  странице справочного руководства getrusage(2).
(Эта информация о ресурсах отличается от ограничений на ресурсы, которые обсуждались в разделе 7.11.) В табл. 8.5 приводится информация о различных аргументах, поддерживаемых функциями семейства wait.
Таблица 8.5. Аргументы, поддерживаемые функциями семейства wait
на различных платформах
Функция pid options rusage POSIX.1 FreeBSD 8.0 Linux 3.2.0 Mac OS X 10.6.8 Solaris 10
wait



waitid





waitpid





wait3
wait4




















































8.9. Гонка за ресурсами   

305

Функция wait3 была включена в  ранние версии стандарта Single UNIX Specification.
Во второй версии стандарта она переведена в разряд устаревших, а в третьей версии
вообще исключена из стандарта.

8.9. Гонка за ресурсами
Мы будем называть гонкой за ресурсами состояние, возникающее, когда несколько процессов пытаются одновременно производить некоторые действия
с совместно используемыми данными и конечный результат зависит от порядка,
в котором эти процессы выполняются. Функция fork являет собой яркий пример потенциального источника проблем, связанных с гонкой за ресурсами, если
логика выполнения программы явно или неявно зависит от того, кто первым
получит управление — родительский процесс или дочерний. В общем случае это
невозможно предсказать заранее, но даже если бы мы знали наверняка, какой
процесс первым получит управление, все равно дальнейшая работа процесса зависит от степени нагрузки на систему и алгоритма планирования, заложенного
в ядре.
Мы уже встречались с  потенциальной ситуацией гонки за ресурсами в  программе из листинга 8.5, когда второй потомок выводил идентификатор родительского процесса. Если второй потомок получит управление раньше первого,
его родительским процессом станет первый потомок. Но если сначала получит
управление первый потомок и  у  него будет достаточно времени, чтобы успеть
завершиться, родительским процессом для второго потомка станет процесс init.
Даже вызов функции sleep, который использовался в нашем примере, не может
гарантировать выполнения процессов в заданном порядке. Если система сильно
загружена, даже после двухсекундной задержки второй потомок может получить управление раньше, чем первому потомку удастся завершиться. Проблемы
такого рода очень сложны в отладке, потому что в большинстве случаев не проявляются.
Чтобы дождаться завершения потомка, достаточно вызвать одну из функций семейства wait. Чтобы дождаться завершения родительского процесса, как в  программе из листинга 8.5, можно воспользоваться примерно таким циклом:
while (getppid() != 1)
sleep(1);

Однако этот цикл, который называется опросом (polling), порождает еще одну
проблему. Дело в  том, что процесс непроизводительно расходует процессорное
время, так как возобновляет работу каждую секунду, чтобы проверить истинность
условия.
Чтобы не попасть в состояние гонки за ресурсами и избежать применения опроса, необходимо нечто вроде обмена сигналами между процессами. Для этой цели
можно использовать сигналы, и один такой способ будет описан в разделе 10.16.
Также могут использоваться различные виды межпроцессных взаимодействий
(Interprocess Communication, IPC). Некоторые из них мы рассмотрим в  главах 15 и 17.

306    Глава 8. Управление процессами
Для организации взаимоотношений между родительским и дочерним процессами
часто используется следующий сценарий. После вызова функции fork оба процесса, родительский и дочерний, выполняют некоторые действия. Например, родительский процесс может добавить запись с идентификатором потомка в файл
журнала, а потомок может создать файл для родительского процесса. В таком случае требуется, чтобы каждый из процессов имел возможность известить другой
процесс о завершении определенных начальных операций и дождался бы завершения этих операций другим процессом, прежде чем продолжить работу. Следующий код иллюстрирует этот сценарий:
#include "apue.h"
TELL_WAIT(); /* выполнить подготовительные операции для TELL_xxx и WAIT_xxx */
if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) { /* дочерний процесс */
/* дочерний процесс выполняет необходимые действия ... */
TELL_PARENT(getppid()); /* сообщить родительскому процессу */
/* о завершении подготовительных операций */
WAIT_PARENT();
/* и дождаться ответа родительского процесса */
/* потомок продолжает работу самостоятельно ... */
}

exit(0);

/* родительский процесс выполняет необходимые действия ... */
TELL_CHILD(pid); /* сообщить дочернему процессу */
/* о завершении подготовительных операций */
WAIT_CHILD();
/* и дождаться ответа дочернего процесса */
/* родительский процесс продолжает работу самостоятельно ... */
exit(0);

Здесь мы исходим из предположения, что все необходимые определения находятся в заголовочном файле apue.h. Пять процедур — TELL_WAIT, TELL_PARENT, TELL_
CHILD, WAIT_PARENT и WAIT_CHILD — должны быть оформлены в виде функций или
макроопределений.
Мы покажем различные варианты реализации процедур TELL и  WAIT в  последующих главах: в  разделе 10.16 будет продемонстрирована реализация на основе
сигналов, а в листинге 15.3 — на основе неименованных каналов. А теперь рассмотрим пример, где используются эти пять процедур.

Пример
Программа в листинге 8.6 выводит две строки: одна формируется дочерним процессом, а другая — родительским. Программа подвержена гонке за ресурсами, по-

8.9. Гонка за ресурсами   

307

тому что порядок вывода символов строк зависит от того, какой процесс получает
управление и как долго он работает.
Листинг 8.6. Программа, содержащая гонку за ресурсами
#include "apue.h"
static void charatatime(char *);
int
main(void)
{
pid_t

}

pid;

if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) {
charatatime("от дочернего процесса\n");
} else {
charatatime("от родительского процесса\n");
}
exit(0);

static void
charatatime(char *str)
{
char
*ptr;
int
c;

}

setbuf(stdout, NULL); /* установить небуферизованный режим */
for (ptr = str; (c = *ptr++) != 0; )
putc(c, stdout);

Мы установили небуферизованный режим для стандартного потока вывода, чтобы запись каждого символа сопровождалась вызовом функции write. Это сделано, чтобы ядро могло производить переключение процессов настолько часто, насколько это возможно. Таким способом создается ситуация гонки за ресурсами.
(Если этого не сделать, то, быть может, мы никогда и не увидим результатов, показанных ниже. Но если мы их не видим, это не значит, что гонки за ресурсами не
существует; это значит лишь, что мы не наблюдаем ее в данной конкретной системе.) Ниже приводится вывод, действительно полученный от программы:
$ ./a.out
оот дочернего процесса
т родительского процесса
$ ./a.out
оот дочернего процесса
т родительского процесса
$ ./a.out
от дочернего процесса
от родительского процесса

А теперь изменим программу в листинге 8.6 так, чтобы она использовала функции
TELL и WAIT. Эти изменения представлены в листинге 8.7. Добавленные строки отмечены символом «+».

308    Глава 8. Управление процессами
Листинг 8.7. Модификация программы из листинга 8.6, позволяющая избежать гонки
за ресурсами
#include "apue.h"
static void charatatime(char *);
int
main(void)
{
pid_t
+
+

pid;

TELL_WAIT();

+

+
}

if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) {
WAIT_PARENT(); /* родительский процесс стартует первым */
charatatime("от дочернего процесса\n");
} else {
charatatime("от родительского процесса\n");
TELL_CHILD(pid);
}
exit(0);

static void
charatatime(char *str)
{
char
*ptr;
int
c;

}

setbuf(stdout, NULL); /* установить небуферизованный режим */
for (ptr = str; (c = *ptr++) != 0; )
putc(c, stdout);

Запустив эту программу, мы получим то, что и ожидали, — символы, выводимые
двумя процессами, более не смешиваются.
В программе из листинга 8.7 родительский процесс стартует первым. Если требуется, чтобы первым стартовал дочерний процесс, нужно изменить строки, следующие за вызовом fork:
} else if (pid == 0) {
charatatime("от дочернего процесса\n");
TELL_PARENT(getppid());
} else {
WAIT_CHILD(); /* дочерний процесс стартует первым */
charatatime("от родительского процесса\n");
}

Обсуждение этого примера будет продолжено в упражнении 8.4.

8.10. Функции exec
Мы уже говорили в  разделе 8.3, что функция fork часто используется для создания нового процесса, который затем запускает другую программу с  помощью
одной из функций семейства exec. Когда процесс вызывает одну из функций exeс,

8.10. Функции exec   

309

он полностью замещается другой программой, и  эта новая программа начинает
выполнение собственной функции main. Идентификатор процесса при этом не изменяется, поскольку функция exec не создает новый процесс, она просто замещает текущий процесс — его сегмент кода, сегмент данных, динамическую область
памяти и сегмент стека — другой программой.
Существует семь различных функций exec, но мы обычно будем говорить просто о «функции exec», подразумевая любую из них. Эти семь функций завершают
список примитивов UNIX, предназначенных для управления процессами. С помощью функции fork можно создавать новые процессы, с  помощью функций
exec — запускать новые программы. Функция exit и функции семейства wait обслуживают процедуры выхода и ожидания завершения. Эти примитивы — все, что
необходимо для управления процессами. Мы будем использовать их в последующих разделах для создания дополнительных функций, таких как popen и  system.
#include <unistd.h>
int execl(const char *pathname, const char *arg0, ... /* (char *)0 */ );
int execv(const char *pathname, char *const argv[]);
int execle(const char *pathname, const char *arg0, ...
/* (char *)0, char *const envp[] */ );
int execve(const char *pathname, char *const argv[], char *const envp[]);
int execlp(const char *filename, const char *arg0, ... /* (char *)0 */ );
int execvp(const char *filename, char *const argv[]);
int fexecve(int fd, char *const argv[], char *const envp[]);

Все семь функций возвращают –1 в случае ошибки,
не возвращают управление в случае успеха
Одно из отличий между этими функциями заключается в том, что первые четыре принимают полный путь к файлу, следующие две — только имя файла и последняя — дескриптор файла. Аргумент filename интерпретируется следующим
образом:
 если аргумент filename содержит символ слеша, он интерпретируется как полный путь к файлу;
 иначе производится поиск выполняемого файла в  каталогах, перечисленных
в переменной окружения PATH.
Переменная окружения PATH содержит список каталогов, разделенных двоеточиями; они называются префиксами пути. Например, строка окружения в формате
name=value
PATH=/bin:/usr/bin:/usr/local/bin/:.

определяет четыре каталога, в которых будет производиться поиск выполняемых
файлов. Последним указан текущий каталог. (Пустой префикс также означает те-

310    Глава 8. Управление процессами
кущий каталог. Он может быть определен двоеточием в начале, двумя двоеточиями в середине или двоеточием в конце подстроки value.)
По причинам, связанным с безопасностью системы, никогда не включайте текущий каталог
в переменную окружения PATH. Подробности в [Garfinkel et al., 2003].

Если функция execlp или execvp находит выполняемый файл, используя один из
префиксов пути, но этот файл не является двоичным выполняемым файлом, сгенерированным редактором связей, функция предположит, что найденный файл
является сценарием командной оболочки, и попытается вызывать /bin/sh с именем файла в качестве аргумента.
Функция fexecve вообще перекладывает задачу поиска выполняемого файла на
вызывающую программу. Используя файловый дескриптор, вызывающая программа может проверить, действительно ли файл является тем, который требуется
выполнить, и запустить его. Иначе злоумышленник с соответствующими привилегиями мог бы подменить выполняемый файл (или часть пути к  выполняемому файлу) после того, как он будет найден и проверен, но до того, как программа
запустит его (вспомните обсуждение ошибок «проверка перед использованием»
(time-of-check-to-timeof-use, TOCTTOU) в разделе 3.3).
Следующее различие касается передачи списка аргументов (символ l в имени означает список (list), v — вектор, или массив (vector)). Функции требуют, чтобы
каждый из аргументов командной строки новой программы был оформлен в виде
отдельного аргумента функции. Конец списка аргументов отмечается пустым указателем. Для других четырех функций (execv, execvp, execve и fexecve) необходимо сформировать массив указателей на аргументы командной строки и передать
адрес этого массива в качестве аргумента.
До появления прототипов ISO C было принято показывать аргументы командной
строки, передаваемые функциям execl, execlp и execle, так:
char *arg0, char *arg1, ..., char *argn, (char *)0

В таком прототипе ясно видно, что заключительный аргумент функции является
пустым указателем. Если этот пустой указатель задается как 0, мы должны явно
привести его к типу указателя; если этого не сделать, он будет интерпретироваться как целочисленный аргумент. Если при этом размер целочисленного типа не
будет совпадать с размером типа char *, то фактически функция exec получит неверные аргументы.
И последнее различие — передача списка переменных окружения новой программе. Три функции, имена которых оканчиваются на e (execle, execve и  fexecve),
позволяют передать массив указателей на строки окружения. Остальные четыре функции для передачи копии среды окружения новой программе используют переменную environ вызывающего процесса. (Вспомните обсуждение строк
окружения в разделе 7.9 и загляните в табл. 7.2. Там мы упоминали, что если система поддерживает функции setenv и  putenv, можно изменить текущую среду
окружения и  среду окружения любых дочерних процессов, но нельзя изменить
среду окружения родительского процесса.) Обычно окружение процесса передается дочерним процессам без изменения, но иногда требуется создать особую

8.10. Функции exec   

311

среду для дочернего процесса. Пример такого случая — программа login, которая
инициализирует новую командную оболочку. Обычно программа login создает
определенное окружение с небольшим количеством переменных и позволяет нам
через файл начального запуска командной оболочки добавить свои переменные
окружения при входе в систему.
До появления прототипов ISO C аргументы функции execle принято было показывать так:
char *pathname, char *arg0, ..., char *argn, (char *)0, char *envp[]

В таком прототипе ясно видно, что заключительный аргумент функции является
адресом массива указателей на строки окружения. Прототипы стандарта ISO C
не показывают этого, в  них все аргументы командной строки, пустой указатель
и указатель envp заменяются многоточием (...).
Аргументы всех семи функций семейства exec достаточно сложно запомнить. Но
буквы в именах функций немного помогают в этом. Буква p означает, что функция принимает аргумент filename и использует переменную окружения PATH, чтобы найти выполняемый файл. Буква l означает, что функция принимает список
аргументов, а буква v — что она принимает массив (вектор) argv[]. Наконец, буква e означает, что функция принимает массив envp[] вместо текущего окружения.
В табл. 8.6 показаны различия между этими семью функциями.
Таблица 8.6. Различия между семью функциями семейства exec
Функция
execl

pathname



execle



execv



execvp

Список
аргументов

argv[]

environ














fexecve
буква в имени

fd



execlp

execve

filename


p

f

l

envp[]


















v

e

Каждая система накладывает свои ограничения на размер списков с аргументами командной строки и  переменными окружения. Из раздела 2.5.2 и  табл. 2.9
следует, что этот предел задается с помощью константы ARG_MAX. Для POSIX.1совместимых систем его значение должно быть не менее 4096 байт. Иногда приходится сталкиваться с  этим пределом при использовании масок командного
интерпретатора для создания списка файлов. Например, в некоторых системах
команда
grep getrlimit /usr/share/man/*/*

312    Глава 8. Управление процессами
может выдать сообщение об ошибке
Argument list too long

то есть «список аргументов слишком велик».
В ранних версиях System V этот предел составлял 5120 байт. Ранние версии BSD имели
предел 20 480 байт. В современных системах этот предел намного выше. (См. данные
вывода программы из листинга 2.2, приведенные в табл. 2.13.)

Чтобы обойти ограничение на размер списка, можно воспользоваться командой
xargs(1), которая способна обрабатывать списки аргументов большого размера.
Например, чтобы отыскать все вхождения слова getrlimit в страницах справочного руководства вашей системы, можно использовать такую команду:
find /usr/share/man -type f -print | xargs grep getrlimit

Однако если файлы со страницами справочного руководства сжаты, лучше попробовать так:
find /usr/share/man -type f -print | xargs bzgrep getrlimit

Мы использовали параметр -type f команды find, чтобы ограничить список обычными файлами, поскольку команды grep не способны производить поиск по шаблону в каталогах и мы хотим избежать ненужных сообщений об ошибках.
Уже отмечалось, что идентификатор процесса не изменяется после вызова функции exec. Кроме того, новая программа наследует от вызывающего процесса ряд
дополнительных характеристик:
 идентификатор процесса и идентификатор родительского процесса;
 реальный идентификатор пользователя и реальный идентификатор группы;
 идентификаторы дополнительных групп;
 идентификатор группы процессов;
 идентификатор сеанса;
 управляющий терминал;
 время, оставшееся до срабатывания таймера;
 текущий рабочий каталог;
 корневой каталог;
 маску режима создания файлов;
 блокировки файлов;
 маску сигналов процесса;
 сигналы, ожидающие обработки;
 ограничения на ресурсы;
 значение приоритета (в XSI-совместимых системах, как описывается в разделе 8.16);
 значения tms_utime, tms_stime, tms_cutime и tms_cstime.

8.10. Функции exec   

313

Судьба открытых файлов зависит от значения флага close-on-exec (закрытьпри-вызове-exec) в  их дескрипторах. Вспомните рис. 3.1 и  упоминание о  флаге
FD_CLOEXEC в  разделе 3.14. Там мы говорили, что каждый дескриптор, открытый
процессом, имеет флаг close-on-exec. Если этот флаг установлен, дескриптор закрывается функцией exec. Иначе дескриптор остается открытым. По умолчанию
после вызова exec дескриптор остается открытым, если флаг close-on-exec не был
специально установлен с помощью функции fcntl.
Стандарт POSIX.1 требует, чтобы открытые каталоги (вспомните функцию
opendir из раздела 4.22) обязательно закрывались при вызове функции exec.
Обычно это обеспечивает функция opendir, которая вызывает fcntl, чтобы установить флаг close-on-exec для дескриптора, соответствующего открытому файлу
каталога.
Обратите внимание, что реальные идентификаторы пользователя и группы не изменяются при вызове функции exec, но эффективные идентификаторы могут измениться в  зависимости от состояния битов set-user-ID и  set-group-ID файла запускаемой программы. Если бит set-user-ID установлен, в качестве эффективного
идентификатора пользователя процесса принимается идентификатор владельца
файла программы. В противном случае эффективный идентификатор пользователя
не изменяется (он не устанавливается равным реальному идентификатору пользователя). Эффективный идентификатор группы устанавливается аналогично.
В большинстве реализаций UNIX только одна из этих семи функций, execve, является системным вызовом. Остальные шесть — обычные библиотечные функции,
которые в  конечном счете обращаются к  этому системному вызову. На рис.  8.2
изображена схема взаимоотношений между семью функциями exec.
execl

execlp

execle

создание
массива argv

execvp

создание
массива argv

поиск в каталогах
из переменной

PATH

execv

передача переменной

environ

execve

(системный вызов)

создание пути
из псевдонима
/proc/self/fd

fexecve

Рис. 8.2. Взаимоотношения между семью функциями exec

В соответствии с этой схемой библиотечные функции execlp и  execvp обрабатывают переменную окружения PATH в поисках первого каталога, содержащего выполняемый файл filename. Для преобразования дескриптора файла в строку пути
к нему, чтобы затем передать ее системному вызову execve для запуска программы, библиотечная функция fexecve использует /proc.

314    Глава 8. Управление процессами
Так реализована функция fexecve в ОС FreeBSD 8.0 и Linux 3.2.0. В других системах может использоваться иной подход. Например, системы, не имеющие /proc или /dev/fd,
могли бы реализовать fexecve как системный вызов, транслирующий дескриптор файла
в индексный узел (i-node), execve — как системный вызов, транслирующий строку пути
к файлу в индексный узел, а весь остальной код exec, общий для execve и fexecve, — в отдельную функцию, принимающую индексный узел файла, который требуется выполнить.

Пример
Программа в листинге 8.8 демонстрирует работу с функциями exec.
Листинг 8.8. Пример использования функций exec
#include "apue.h"
#include <sys/wait.h>
char

*env_init[] = { "USER=unknown", "PATH=/tmp", NULL };

int
main(void)
{
pid_t

pid;

if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) { /* задать полный путь к файлу и среду окружения */
if (execle("/home/sar/bin/echoall", "echoall", "myarg1",
"MY ARG2", (char *)0, env_init) < 0)
err_sys("ошибка вызова функции execle");
}
if (waitpid(pid, NULL, 0) < 0)
err_sys("ошибка вызова функции wait");
if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) { /* задать имя файла, наследовать среду окружения */
if (execlp("echoall", "echoall", "только 1 аргумент", (char *)0) < 0)
err_sys("ошибка вызова функции execlp");
}
}

exit(0);

Сначала программа вызывает функцию execle, которая требует указать полный
путь к  файлу и  среду окружения. Далее вызывается функция execlp, которой
передается имя файла, а среда окружения наследуется новой программой от вызывающего процесса. В данном примере обращение к функции execlp не завершается ошибкой только потому, что каталог /home/sar/bin входит в переменную
PATH. Кроме того, обратите внимание, что в качестве первого аргумента (argv[0])
командной строки новой программы мы передаем только имя файла. Некоторые
командные оболочки передают в этом аргументе полный путь к файлу. Но это просто соглашение, на самом деле в  argv[0] можно записать любую строку. Коман­
да login именно так и поступает, когда запускает командную оболочку. Перед ее
запуском login добавляет в  начало строки argv[0] дефис, тем самым сообщая

8.11. Изменение идентификаторов пользователя и группы   

315

командной оболочке, что она вызывается как оболочка входа в  систему. В  этом
случае она производит запуск команд начальной настройки, в то время как при
обычном вызове командная оболочка этого не делает.
Программа echoall, дважды запускаемая программой из листинга 8.8, приведена в листинге 8.9. Эта простенькая программа выводит все аргументы командной
строки и список переменных окружения.
Листинг 8.9. Выводит все аргументы командной строки и переменные окружения
#include "apue.h"
int
main(int argc, char *argv[])
{
int
i;
char
**ptr;
extern char **environ;
for (i = 0; i < argc; i++) /* вывести все аргументы командной строки */
printf("argv[%d]: %s\n", i, argv[i]);
for (ptr = environ; *ptr != 0; ptr++) /* и все переменные окружения */
printf("%s\n", *ptr);
}

exit(0);

После запуска программы из листинга 8.9 мы получили следующие результаты:
$ ./a.out
argv[0]: echoall
argv[1]: myarg1
argv[2]: MY ARG2
USER=unknown
PATH=/tmp
$ argv[0]: echoall
argv[1]: только 1 аргумент
USER=sar
LOGNAME=sar
SHELL=/bin/bash
HOME=/home/sar

еще 47 строк здесь не показаны

Обратите внимание, что перед выводом значения argv[0] для второго вызова
функции exec появилось приглашение командной оболочки. Произошло это потому, что родительский процесс не стал ждать, пока этот потомок завершит свою
работу.

8.11. Изменение идентификаторов
пользователя и группы
В системе UNIX предоставление привилегий (таких, как возможность изменять
текущую дату) и управление доступом к файлам (например, право на чтение или
запись) основаны на идентификаторах пользователя и группы. Когда программе

316    Глава 8. Управление процессами
необходимы дополнительные привилегии, чтобы получить доступ к ресурсам, недоступным в настоящее время, она должна изменить свой идентификатор пользователя или группы на идентификатор, который имеет соответствующие привилегии. Точно так же, чтобы понизить свои привилегии или предотвратить доступ
к некоторым ресурсам, программа должна изменить идентификатор пользователя
или группы на идентификатор, не обладающий указанными привилегиями или
достаточными правами для обращения к ресурсу.
Вообще при разработке приложений следует использовать принцип наименьших
привилегий. Следуя этому принципу, приложения должны использовать минимальный набор привилегий, необходимый для решения своих задач. Это уменьшает вероятность, что злоумышленник сможет «обмануть» систему безопасности,
используя программы и их привилегии непредусмотренным способом.
Изменить реальный и эффективный идентификаторы пользователя можно с помощью функции setuid. Аналогично с помощью функции setgid можно изменить
реальный и эффективный идентификаторы группы.
#include <unistd.h>
int setuid(uid_t uid);
int setgid(gid_t gid);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Существуют определенные правила, согласно которым изменяются идентификаторы. Рассмотрим их на примере идентификатора пользователя. (Все перечисленное ниже в равной степени относится к идентификатору группы.)
1.	 Если процесс обладает привилегиями суперпользователя, функция setuid
устанавливает реальный, эффективный и сохраненный идентификаторы пользователя в соответствии с аргументом uid.
2.	 Если процесс не обладает привилегиями суперпользователя, но аргумент
uid совпадает с  реальным или сохраненным идентификатором пользователя,
функция setuid изменяет только эффективный идентификатор. Реальный
и сохраненный идентификаторы не меняются.
3.	 Если ни одно из этих условий не соблюдено, setuid возвращает значение –1
и записывает в переменную errno код ошибки EPERM.
Здесь предполагается, что конфигурационный параметр _POSIX_SAVED_IDS имеет
значение true. Если эта функциональная возможность не предоставляется вашей
системой, исключите из вышеприведенных правил упоминание о  сохраненном
идентификаторе.
Сохраненные идентификаторы стали обязательными для реализации в версии POSIX.1
от 2001 года. В более ранних версиях POSIX эта функциональная особенность относилась
к разряду необязательных. Чтобы узнать, поддерживается ли она системой, приложение
может проверить константу _POSIX_SAVED_IDS во время компиляции или вызвать функцию
sysconf с аргументом _SC_SAVED_IDS во время выполнения.

8.11. Изменение идентификаторов пользователя и группы   

317

Можно сформулировать несколько правил относительно трех идентификаторов
пользователя.
1.	 Изменить реальный идентификатор пользователя может только процесс, обладающий привилегиями суперпользователя. Как правило, реальный идентификатор пользователя устанавливается программой login(1) при входе в систему
и никогда не изменяется. Поскольку login является процессом, обладающим
привилегиями суперпользователя, с помощью функции setuid он устанавливает все три идентификатора пользователя.
2.	 Эффективный идентификатор пользователя устанавливается функцией exec,
только когда файл программы имеет установленный бит set-user-ID. Если этот
бит не установлен, функция exec не изменяет эффективный идентификатор
пользователя. В любой момент времени можно вызвать функцию setuid, чтобы установить эффективный идентификатор равным реальному или сохраненному идентификатору. Но, как правило, нельзя установить эффективный
идентификатор пользователя в произвольное значение.
3.	 Функция exec копирует эффективный идентификатор пользователя в сохраненный. Если файл программы имеет установленный бит set-user-ID, эта копия сохраняется после того, как функция exec установит эффективный идентификатор равным идентификатору владельца файла.
В табл. 8.7 обобщаются возможные варианты изменения этих трех идентификаторов.
Таблица 8.7. Варианты изменения идентификаторов пользователя
exec

setuid(uid)

Идентификатор

Бит set-user-ID
выключен

Бит set-user-ID
включен

Суперпользователь

Реальный

Не изменяется

Не изменяется

Устанавливается
в соответствии
с uid

Эффективный

Не изменяется

Устанавливается в соответствии с идентификатором
владельца
файла программы

Устанавливается
в соответствии
с uid

Сохраненный

Копия эффективного идентификатора

Копия эффективного идентификатора

Устанавливается
в соответствии
с uid

Непривилегированный пользователь

Не изменяется

Не изменяется

Обратите внимание, что с помощью функций getuid и  geteuid, описанных в разделе 8.2, можно получить только текущие значения реального и  эффективного
идентификаторов пользователя. У нас нет возможности получить текущее значение сохраненного идентификатора.

318    Глава 8. Управление процессами
FreeBSD 8.0 и Linux 3.2.0 предоставляют функции getresuid и  getresgid для получения
сохраненных идентификаторов пользователя и группы соответственно.

Функции setreuid и setregid
BSD-системы традиционно поддерживают возможность менять местами реальный и эффективный идентификаторы пользователя с помощью функции setreuid.
#include <unistd.h>
int setreuid(uid_t ruid, uid_t euid);
int setregid(gid_t rgid, gid_t egid);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
В любом из аргументов можно передать значение –1, чтобы указать, что соответствующий идентификатор должен остаться неизменным.
Правило использования этих функций очень простое: непривилегированный
пользователь всегда может поменять местами реальный и эффективный идентификаторы. Это позволяет программам с установленным битом set-user-ID переходить к привилегиям обычного пользователя и затем возвращаться к привилегиям
владельца файла программы. Когда в стандарте POSIX.1 появились сохраненные
идентификаторы, это правило было расширено, чтобы позволить непривилегированному процессу также устанавливать эффективный идентификатор пользователя равным сохраненному идентификатору.
Обе функции, setreuid и  setregid, являются расширениями XSI стандарта POSIX.1,
поэтому предполагается, что все версии UNIX должны обеспечивать поддержку этих
функций.
В версии 4.3BSD отсутствовало понятие сохраненных идентификаторов, описанное выше.
Вместо этого использовались функции setreuid и setregid. Это позволяло непривилегированному пользователю свободно переключаться между двумя идентификаторами. Однако
когда программа, использовавшая эту возможность, запускала командную оболочку, она
должна была перед вызовом функции exec установить реальный идентификатор пользователя равным идентификатору обычного пользователя. Если этого не сделать, реальный
идентификатор может оказаться принадлежащим привилегированному пользователю
(как результат вызова функции setreuid) и процесс, запущенный из такой командной
оболочки, сможет с  помощью setreuid поменять идентификаторы и  получить более
высокие привилегии. В  качестве меры предосторожности и  реальный и  эффективный
идентификаторы перед вызовом функции exec в  дочернем процессе устанавливались
равными идентификатору обычного пользователя.

Функции seteuid и setegid
Стандарт POSIX.1 включает еще две функции: seteuid и  setegid. Они очень похожи на функции setuid и  setgid, но изменяют только эффективный идентификатор пользователя и группы.

8.11. Изменение идентификаторов пользователя и группы   

319

#include <unistd.h>
int seteuid(uid_t uid);
int setegid(gid_t gid);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Непривилегированный пользователь может установить свой эффективный идентификатор равным реальному или сохраненному идентификатору. Для привилегированного пользователя функция seteuid устанавливает только эффективный
идентификатор равным значению uid. (Этим она отличается от setuid, изменяющей все три идентификатора пользователя.)
Рисунок 8.3 наглядно описывает все функции, предназначенные для изменения
трех идентификаторов пользователя.
Вызов с правами
суперпользователя
setreuid (ruid,euid)

eui

d

euid

Вызов с правами
суперпользователя
setuid (uid)

uid

ruid

Реальный
идентификатор
пользователя

Непривилегированный
вызов

setreuid

Вызов с правами
суперпользователя
setuid (uid)

uid

uid

uid

Эффективный
идентификатор
пользователя

Непривилегированный
вызов

setreuid

Эффективный
идентификатор
пользователя

Запуск программы
с установленным битом
set-user-ID
Непривилегированный
вызов setuid или seteuid

Непривилегированный
вызов setuid или seteuid

Рис. 8.3. Функции для изменения различных идентификаторов пользователя

Идентификаторы группы
Все, о чем мы говорили в этом разделе, в равной степени относится и к идентификаторам группы. Функции setgid, setregid и  setegid не оказывают влияния на
идентификаторы дополнительных групп.

Пример
Чтобы увидеть, где может пригодиться сохраненный идентификатор пользователя, рассмотрим программу, которая его использует. В качестве примера возьмем
утилиту at(1), которую можно использовать для планирования запуска команд
в некоторый момент времени в будущем.

320    Глава 8. Управление процессами
В Linux 3.2.0 программа at имеет установленный бит set-user-ID и принадлежит пользователю daemon. В FreeBSD 8.0, Mac OS X 10.6.8 и Solaris 10 программа at имеет установленный бит set-user-ID и принадлежит пользователю root. Это дает команде at возможность выполнять запись в привилегированные файлы, принадлежащие демону, который
будет выполнять требуемые команды от имени пользователя, запустившего команду at.
В Linux 3.2.0 программы выполняются демоном atd(8), в FreeBSD 8.0 и Solaris 10 — демоном
cron(1M), в Mac OS X 10.6.8 — демоном launchd(8).

Чтобы предотвратить возможность запуска программ, на выполнение которых
пользователь не имеет привилегий, или запись в файлы, недоступные пользователю, команда at и демон, в конечном счете выполняющий команды от имени пользователя, должны переключаться между наборами привилегий: пользовательских
и тех, которыми обладает демон. Вот как это происходит:
1.	 Допустим, что выполняемый файл at имеет установленный бит set-user-ID и его
владельцем является пользователь root. Запустив эту программу, мы получили:
реальный идентификатор
пользователя
эффективный идентификатор
пользователя
сохраненный идентификатор
пользователя

=
=
=

идентификатор пользователя, запустившего
программу (не изменился)
root
root

2.	 Первое, что делает команда at, — понижает свои привилегии до уровня привилегий вызвавшего ее пользователя. Для этого она вызывает seteuid, чтобы
установить эффективный идентификатор пользователя равным реальному
идентификатору пользователя. После чего мы получили:
реальный идентификатор
пользователя
эффективный идентификатор
пользователя
сохраненный идентификатор
пользователя

=
=
=

идентификатор пользователя, запустившего
программу (не изменился)
идентификатор пользователя, запустившего
программу (не изменился)
root (не изменился)

3.	 Программа at продолжает выполнение с  пользовательскими привилегиями,
пока ей не потребуется обратиться к конфигурационным файлам, чтобы сохранить команду, которую требуется выполнить, и время ее запуска. Владельцем
этих файлов является демон, выполняющий запуск команд от имени пользователя. Команда at вызывает seteuid, чтобы установить эффективный идентификатор пользователя равным идентификатору пользователя root. Это вполне
допустимый вызов, потому что аргумент функции seteuid равен сохраненному
идентификатору пользователя. (Именно для этого и нужен сохраненный идентификатор.) После чего получили:
реальный идентификатор
пользователя
эффективный идентификатор
пользователя
сохраненный идентификатор
пользователя

=
=
=

идентификатор пользователя, запустившего
программу (не изменился)
root

root (не изменился)

8.12. Интерпретируемые файлы   

321

Так как эффективный идентификатор пользователя соответствует идентификатору пользователя root, доступ к файлам разрешается.
4.	 После записи в конфигурационные файлы названия команды, которую требуется запустить, и времени запуска программа at вновь понижает свои привилегии вызовом seteuid, устанавливая эффективный идентификатор пользователя равным идентификатору пользователя, вызвавшего ее. Это предотвращает
возможность неправильного использования повышенных привилегий. В этот
момент мы получили:
реальный идентификатор = идентификатор пользователя, запустившего
пользователя
программу (не изменился)
эффективный идентификатор = идентификатор пользователя, запустившего
пользователя
программу
сохраненный идентификатор = root (не изменился)
пользователя

5.	 Демон запускается с привилегиями пользователя root. Чтобы выполнить запланированную команду от имени пользователя, он вызывает функцию fork,
и дочерний процесс вызывает setuid, чтобы изменить идентификатор пользователя процесса. Поскольку дочерний процесс выполняется с  привилегиями
root, изменяются все три идентификатора. Мы получили:
реальный идентификатор = идентификатор пользователя, запустившего
пользователя
программу
эффективный идентификатор = идентификатор пользователя, запустившего
пользователя
программу
сохраненный идентификатор = идентификатор пользователя, запустившего
пользователя
программу

Теперь демон может безопасно выполнить команду от имени пользователя, потому что она будет иметь доступ только к файлам, и так доступным этому пользователю. Никаких дополнительных привилегий команда не получает.
Используя сохраненный идентификатор пользователя подобным образом, можно пользоваться повышенными привилегиями, которые даются установкой бита
set-user-ID для файла программы, только когда они действительно необходимы,
а в любой другой момент времени пользоваться обычными привилегиями пользователя, запустившего программу. Если бы у нас отсутствовала возможность переключиться обратно на использование сохраненного идентификатора пользователя, процесс был бы вынужден выполняться с  повышенными привилегиями все
время (напрашиваясь тем самым на неприятности).

8.12. Интерпретируемые файлы
Все современные версии UNIX поддерживают интерпретируемые файлы. Это
обычные текстовые файлы, которые начинаются со строки вида
#! pathname [optional-argument]

322    Глава 8. Управление процессами
Пробел между восклицательным знаком и  параметром pathname необязателен.
Чаще всего интерпретируемые файлы начинаются со строки
#!/bin/sh

В pathname обычно указывается абсолютный путь к выполняемому файлу интерпретатора, поскольку никаких дополнительных операций над ней не производится (то есть переменная PATH не используется). Распознавание интерпретируемых
файлов производится ядром в  процессе выполнения системного вызова exec.
В  действительности ядро запускает на выполнение не сам интерпретируемый
файл, а программу, указанную в параметре pathname, в первой строке. Необходимо понимать разницу между интерпретируемым файлом — обычным текстовым
файлом, начинающимся с  последовательности #!  — и  интерпретатором, то есть
выполняемым файлом, путь к которому указывается в первой строке интерпретируемого файла.
Помните, что существует ограничение на размер первой строки интерпретируемого файла. Это ограничение включает последовательность символов #!, параметр pathname, необязательные аргументы optional-argument, завершающий символ перевода строки и все пробельные символы.
В FreeBSD 8.0 длина первой строки ограничивается 4097 байтами, в Mac OS X 10.6.8 —
513 байтами, в Linux 3.2.0 — 128 байтами, а в Solaris 10 — 1024 байтами.

Пример
Рассмотрим на примере, что делает ядро с  параметрами функции exec, если запускаемый файл является интерпретируемым файлом и в первой его строке имеется дополнительный аргумент. Программа в листинге 8.10 осуществляет запуск
интерпретируемого файла.
Листинг 8.10. Программа, запускающая интерпретируемый файл
#include "apue.h"
#include <sys/wait.h>
int
main(void)
{
pid_t

}

pid;

if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) { /* дочерний процесс */
if (execl("/home/sar/bin/testinterp",
"testinterp", "myarg1", "MY ARG2", (char *)0) < 0)
err_sys("ошибка вызова функции execl");
}
if (waitpid(pid, NULL, 0) < 0) /* родительский процесс */
err_sys("waitpid error");
exit(0);

Ниже приводится содержимое интерпретируемого файла, запускаемого программой из листинга 8.10, и результаты работы программы.

8.12. Интерпретируемые файлы   

323

$ cat /home/sar/bin/testinterp
#!/home/sar/bin/echoarg foo
$ ./a.out
argv[0]: /home/sar/bin/echoarg
argv[1]: foo
argv[2]: /home/sar/bin/testinterp
argv[3]: myarg1
argv[4]: MY ARG2

Программа echoarg (интерпретатор) просто выводит все аргументы, переданные
ей в командной строке (это программа из листинга 7.3). Обратите внимание, что
когда ядро запускает интерпретатор, в argv[0] предается полный путь к выполняемому файлу интерпретатора, argv[1] — необязательный аргумент, взятый из
интерпретируемого файла, argv[2] — полный путь к файлу программы (/home/
sar/bin/testinterp), а argv[3] и argv[4] — это второй и третий аргументы функции execl (myarg1 и  MY ARG2). Оба аргумента функции execl, argv[1] и  argv[2],
смещаются вправо на две позиции. Обратите внимание: ядро берет аргумент
pathname из вызова функции execl вместо первого аргумента (testinterp), исходя из предположения, что pathname содержит больше информации, чем первый аргумент.

Пример
Часто в  качестве необязательного аргумента, следующего за именем интерпретатора, передается флаг -f для программ, которые его поддерживают. Например,
программу awk(1) можно запустить как
awk -f myfile

Таким способом ей сообщается, что текст программы на языке awk находится
в файле myfile.
Системы, производные от System V, часто содержат две версии языка awk. В этих системах
awk часто называется «old awk» (старый awk) и соответствует оригинальной версии, распространявшейся в составе Version 7. В противоположность ему nawk (new awk — новый
awk) содержит многочисленные расширения и соответствует языку, описанному в [Aho,
Kernighan, and Weinberger, 1988]. Эта новая версия предоставляет доступ к аргументам
командной строки. ОС Solaris 10 поддерживает обе версии.
Программа awk — это одна из утилит, включенных POSIX в стандарт 1003.2 (теперь
это часть базовых спецификаций POSIX.1 в стандарте Single UNIX Specification). Она
также основывается на языке, описанном в книге [Aho, Kernighan, and Weinberger, 1988].
Версия awk в Mac OS X 10.6.8 основана на версии Bell Laboratories, которую компания Lucent
сделала свободно распространяемой. В составе FreeBSD 8.0 и в некоторых дистрибутивах
Linux распространяется утилита GNU awk, называемая gawk. В этих системах awk является символической ссылкой на gawk. Утилита gawk соответствует стандарту POSIX,
но при этом также включает ряд дополнительных расширений. Поскольку awk от Bell
Laboratories и gawk представляют собой более современные версии, им следует отдавать
предпочтение перед nawk или «старым awk». (Версия awk от Bell Laboratories доступна
по адресу http://cm.bell-labs.com/cm/cs/awkbook/index.html.)

324    Глава 8. Управление процессами
Флаг -f позволяет оформлять интерпретируемый файл так:
#!/bin/awk -f
(далее следует программа на языке awk)

Например, в  листинге 8.11 приводится содержимое интерпретируемого файла
/usr/local/bin/awkexample.
Листинг 8.11. Интерпретируемый файл с программой на языке awk
#!/bin/awk -f
# Примечание: в ОС Solaris следует использовать nawk
BEGIN {
for (i = 0; i < ARGC; i++)
printf "ARGV[%d] = %s\n", i, ARGV[i]
exit
}

Если включить каталог /usr/local/bin в  переменную окружения PATH, мы сможем запустить программу из листинга 8.11 (при условии, что у нас есть право на
выполнение), как показано ниже.
$ awkexample file1 FILENAME2 f3
ARGV[0] = awk
ARGV[1] = file1
ARGV[2] = FILENAME2
ARGV[3] = f3

При запуске программа /bin/awk получит следующие аргументы командной
строки:
/bin/awk -f /usr/local/bin/awkexample file1 FILENAME2 f3

Интерпретатору передается полный путь к  интерпретируемому файлу (/usr/
local/bin/awkexample). Простого имени файла (которое мы набрали в командной
строке) недостаточно, поскольку не предполагается, что интерпретатор (в данном
случае /bin/awk) сможет определить местонахождение файла, используя переменную окружения PATH. Когда awk начинает разбирать интерпретируемый файл,
он игнорирует первую строку, так как в языке awk символ # означает начало комментария.
Мы можем проверить аргументы командной строки с  помощью следующей последовательности команд:
$ /bin/su
Password:
# mv /bin/awk /bin/awk.save
# cp /home/sar/bin/echoarg /bin/awk
# suspend
[1] + Stopped /bin/su
$ awkexample file1 FILENAME2 f3
argv[0]: /bin/awk
argv[1]: -f
argv[2]: /usr/local/bin/awkexample
argv[3]: file1
argv[4]: FILENAME2

получаем привилегии суперпользователя
вводим пароль суперпользователя
сохраним оригинальный файл программы
и заменим его на время
приостановим работу командной оболочки
суперпользователя

8.12. Интерпретируемые файлы   

argv[5]: f3
$ fg
/bin/su
# mv /bin/awk.save /bin/awk
# exit

325

возобновим работу командной оболочки
суперпользователя
восстановим оригинальный файл программы
и покинем командную оболочку

В этом примере флаг -f совершенно необходим интерпретатору. Как уже говорилось, он сообщает awk, где находится текст программы на языке awk. Если убрать
этот флаг из интерпретируемого файла, при его запуске мы получим сообщение
об ошибке. Точный текст сообщения зависит от местонахождения интерпретируемого файла и от того, представляют ли остальные аргументы существующие файлы. Это происходит потому, что аргументы командной строки приобретают вид
/bin/awk /usr/local/bin/awkexample file1 FILENAME2 f3

и в результате awk пытается интерпретировать строку /usr/local/bin/awkexample
как текст программы на языке awk. Если бы отсутствовала возможность передавать хотя бы один необязательный аргумент интерпретатору (в данном случае -f),
интерпретируемые файлы были бы пригодны к использованию только с командными оболочками.
Действительно ли так необходимы интерпретируемые файлы? На самом деле нет.
Но они дают массу удобств для пользователей, хотя и за счет некоторого увеличения нагрузки на ядро (поскольку именно ядро их распознает и запускает указанный интерпретатор). Интерпретируемые файлы удобны по следующим причинам.
1.	 Они скрывают тот факт, что программа фактически является сценарием на том
или ином языке. Так, например, запустить программу из листинга 8.11 можно
с помощью такой команды:
awkexample необязательные-аргументы

Совсем не обязательно помнить, что программа в действительности является
сценарием на языке awk, который пришлось бы запускать командой
awk -f awkexample необязательные-аргументы

2.	 Интерпретируемые сценарии дают выигрыш в  эффективности. Вернемся
к предыдущему примеру. Мы можем скрыть, что файл является сценарием на
языке awk, заключив текст программы в сценарий командной оболочки:
awk 'BEGIN {
for (i = 0; i < ARGC; i++)
printf "ARGV[%d] = %s\n", i, ARGV[i]
exit
}’ $*

Но такой подход требует от системы дополнительной работы. Прежде всего командная оболочка прочитает команду и попытается выполнить ее с помощью
функции execlp. Поскольку сценарий командной оболочки является выполняемым файлом, но не содержит машинных инструкций, возвращается признак
ошибки, и execlp предположит, что это файл сценария (как это и есть на самом
деле). Тогда запустится программа /bin/sh, которой в качестве аргумента пере-

326    Глава 8. Управление процессами
дается имя файла сценария. Командная оболочка запустит сценарий, но чтобы
запустить awk, она вызовет функции fork, exec и wait. Поэтому «обертывание»
сценариев на других языках в сценарии командной оболочки приводит к увеличению нагрузки.
3.	 Интерпретируемые файлы позволяют писать сценарии на языках других
команд­ных оболочек, отличных от /bin/sh. Когда функция execlp обнаруживает, что выполняемый файл не содержит машинных инструкций, она вызывает командную оболочку, и это всегда /bin/sh. Однако, используя возможность
указания интерпретатора в  первой строке интерпретируемого файла, мы можем просто написать
#!/bin/csh
(далее следует текст сценария на языке командной оболочки C shell)

Опять же, этот код можно завернуть в сценарий командной оболочки /bin/sh
(которая вызовет C shell), как показано немного выше, но это повлечет за собой
дополнительную нагрузку.
Ни один из указанных приемов не работал бы, если бы эти три командные оболочки и awk не использовали символ # в качестве знака комментария.

8.13. Функция system
Функция system дает удобный способ выполнения команд внутри программы.
Например, допустим, что требуется записать строку с датой и временем в некоторый файл. Для этого можно было бы использовать функции, описанные в разделе 6.10: получить текущее календарное время с помощью функции time, затем
преобразовать его в структуру tm с помощью функции localtime, сформировать
строку с помощью функции strftime и записать результат в файл. Однако гораздо
проще сделать так:
system("date > file");

Функция system определяется стандартом ISO C, но порядок взаимодействия
с ней зависит от системы. Стандарт POSIX.1 включает интерфейс system, расширяя определение ISO C, чтобы уточнить поведение функции в среде POSIX.
#include <stdlib.h>
int system(const char *cmdstring);

Возвращает: см. ниже
Если в аргументе cmdstring передается пустой указатель, функция system возвращает ненулевое значение, только если командный процессор доступен. Таким способом можно проверить, поддерживается ли функция system в  данной системе.
В системах UNIX она поддерживается всегда.

8.13. Функция system   

327

Поскольку функция system реализована на основе функций fork, exec и  waitpid,
она может возвращать значения трех типов.
1.	 Если функция fork терпит неудачу или функция waitpid возвращает код
ошибки, отличный от EINTR, функция system возвращает значение –1.
2.	 Если функция exec терпит неудачу, это означает, что командная оболочка не
может быть запущена, и функция system возвращает значение, как если бы командная оболочка вызвала функцию exit(127).
3.	 Когда обращение ко всем трем функциям — fork, exec и waitpid — заканчивается успехом, функция system возвращает код завершения командной оболочки в формате, предназначенном для функции waitpid.
Некоторые старые реализации функции system возвращали код ошибки EINTR, если выполнение функции waitpid было прервано сигналом. Поскольку нет достаточно ясной
стратегии восстановления после такой ошибки (так как идентификатор дочернего процесса скрыт от вызывающей программы), стандарт POSIX позднее добавил требование,
чтобы функция system не возвращала в этом случае код ошибки. (Прерывание системных
вызовов рассматривается в разделе 10.5.)

В листинге 8.12 приводится пример реализации функции system. Единственный
ее недостаток — отсутствие возможности обработки сигналов. Эту возможность
мы добавим в разделе 10.18.
Флаг -c сообщает командной оболочке, что следующий за ней аргумент  — это
коман­да, которую нужно выполнить. Командная оболочка анализирует эту строку и разбивает ее на отдельные аргументы. Аргумент cmdstring может содержать
любую допустимую команду оболочки. Например, для перенаправления ввода/
вывода можно использовать операторы < и >.
Чтобы выполнить команду, не прибегая к услугам командной оболочки, потребовались бы значительные усилия. Прежде всего пришлось бы вызвать функцию
execlp вместо execl, чтобы использовать переменную окружения PATH подобно
командной оболочке. Также пришлось бы разбивать командную строку на отдельные аргументы, чтобы передать их функции execlp. И наконец, мы не смогли бы
воспользоваться метасимволами командной оболочки.
Обратите внимание, что вместо функции exit мы вызвали функцию _exit. Сделано это для предотвращения сброса буферов ввода/вывода, которые могли быть
унаследованы дочерним процессом от родительского при вызове функции fork.
Листинг 8.12. Функция system без обработки сигналов
#include <sys/wait.h>
#include <errno.h>
#include <unistd.h>
int
system(const char *cmdstring) /* версия без обработки сигналов */
{
pid_t
pid;
int
status;

328    Глава 8. Управление процессами
if (cmdstring == NULL)
return(1); /* UNIX всегда поддерживает командный процессор */
if ((pid = fork()) < 0) {
status = -1; /* превышено максимальное количество процессов */
} else if (pid == 0) { /* дочерний процесс */
execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);
_exit(127);
/* ошибка вызова функции execl */
} else {
/* родительский процесс */
while (waitpid(pid, &status, 0) < 0) {
if (errno != EINTR) {
status = -1; /* waitpid вернула ошибку, отличную от EINTR */
break;
}
}
}
}

return(status);

Мы можем протестировать нашу версию функции system с помощью программы
в листинге 8.13. (Исходный код функции pr_exit вы найдете в листинге 8.3.)
Листинг 8.13. Вызов функции system
#include "apue.h"
#include <sys/wait.h>
int
main(void)
{
int

status;

if ((status = system("date")) < 0)
err_sys("ошибка вызова функции system()");
pr_exit(status);
if ((status = system("nosuchcommand")) < 0)
err_sys("ошибка вызова функции system()");
pr_exit(status);
if ((status = system("who; exit 44")) < 0)
err_sys("ошибка вызова функции system()");
pr_exit(status);
}

exit(0);

Запуск программы из листинга 8.13 дал следующие результаты:
$ ./a.out
Sat Feb 25 19:36:59 EST 2012
нормальное завершение, код выхода = 0
sh: nosuchcommand: command not found
нормальное завершение, код выхода = 127
sar
console Jan 1 14:59
sar
ttys000 Feb 7 19:08

команда date
команда nosuchcommand

8.13. Функция system   

sar
ttys001 Jan 15 15:28
sar
ttys002 Jan 15 21:50
sar
ttys003 Jan 21 16:02
нормальное завершение, код выхода = 44

329

команда exit

Основное преимущество использования функции system вместо прямого обращения к функциям fork и exec в том, что она производит все необходимые действия
по обработке ошибочных ситуаций, а  также (в нашей следующей версии этой
функции, в разделе 10.18) по обработке сигналов.
Ранние версии UNIX, включая SVR3.2 и 4.3BSD, не имели функции waitpid. Вместо этого родительский процесс дожидался завершения работы потомка с помощью примерно такой инструкции:
while ((lastpid = wait(&status)) != pid && lastpid != -1)
;

Однако в этом случае возникает проблема, если у процесса уже имеются дочерние
процессы, запущенные до обращения к функции system. Поскольку показанный
выше цикл while продолжает работу, пока не завершится дочерний процесс, созданный функцией system, если какой-либо из дочерних процессов, запущенных
ранее, завершится до процесса, указанного в переменной pid, его идентификатор
и код завершения будут утеряны в цикле while. Эта неспособность функции wait
ждать завершения определенного дочернего процесса — одна из причин добавления функции waitpid, приводимых в обосновании «POSIX.1 Rationale». В разделе 15.3 мы увидим, что та же проблема возникает при работе с функциями popen
и pclose, если система не поддерживает функцию waitpid.

Программы с установленным битом set-user-ID
Что произойдет, если вызвать функцию system из программы с установленным
битом set-user-ID? Такой вызов создает брешь в  системе безопасности, и  этого  нельзя допускать никогда. В  листинге 8.14 приводится программа, которая
просто вызывает функцию system для обработки своих аргументов командной
строки.
Листинг 8.14. Обработка аргументов командной строки с помощью функции system
#include "apue.h"
int
main(int argc, char *argv[])
{
int
status;
if (argc < 2)
err_quit("требуется хотя бы один аргумент командной строки");
if ((status = system(argv[1])) < 0)
err_sys("ошибка вызова функции system()");
pr_exit(status);
}

exit(0);

330    Глава 8. Управление процессами
Скомпилируем эту программу в выполняемый файл tsys.
В листинге 8.15 приводится другая простая программа, которая выводит значения
реального и эффективного идентификаторов пользователя.
Листинг 8.15. Вывод реального и эффективного идентификаторов пользователя
#include "apue.h"
int
main(void)
{
printf("реальный uid = %d, эффективный uid = %d\n", getuid(), geteuid());
exit(0);
}

Скомпилируем эту программу в выполняемый файл printuids. Запуск обеих программ дал следующие результаты:
$ tsys printuids
обычный запуск без дополнительных привилегий
реальный uid = 205, эффективный uid = 205
нормальное завершение, код выхода = 0
$ su
получаем права суперпользователя
Password:
вводим пароль суперпользователя
# chown root tsys
меняем владельца файла
# chmod u+s tsys
устанавливаем бит set-user-ID
# ls -l tsys
проверяем владельца и права доступа
-rwsrwxr-x 1 root
7888 Feb 25 22:13 tsys
# exit
покидаем командную оболочку суперпользователя
$ tsys printuids
реальный uid = 205, эффективный uid = 0
вот она, брешь в системе безопасности
нормальное завершение, код выхода = 0

Привилегии суперпользователя, которые мы дали программе tsys, сохранились
после вызовов функций fork и exec, которые производит функция system.
Некоторые реализации закрывают эту брешь в системе безопасности, изменяя командную
оболочку /bin/sh так, чтобы она устанавливала эффективный идентификатор пользователя равным реальному, если они не совпадают. В таких системах данный пример
будет работать не так, как показано выше. Вместо этого будет выводиться одно и то
же значение эффективного идентификатора пользователя, независимо от значения бита
set-user-ID у файла программы, вызываемой функцией system.

Если предполагается, что программа будет работать с повышенными привилегиями — с установленными битами set-user-ID или set-group-ID — и порождать другие процессы, она должна делать это непосредственно с помощью функций fork
и  exec, выполняя переход к  привилегиям обычного пользователя после вызова
fork и перед вызовом exec. Функция system никогда не должна использоваться
в программах с установленными битами set-user-ID или set-group-ID.
Еще одна из причин заключается в том, что функция system вызывает командную оболочку для разбора аргументов командной строки, а сама оболочка использует значение
переменной окружения IFS в качестве разделителя полей во входной строке. Ранние версии

8.14. Учет использования ресурсов процессами   

331

командной оболочки при запуске не сбрасывали эту переменную к стандартному набору
символов. Это позволяло злоумышленнику изменить значение переменной окружения IFS
до вызова функции system и заставить ее выполнить совсем другую команду.

8.14. Учет использования ресурсов
процессами
Большинство версий UNIX дают возможность вести учет использования ресурсов
процессами. Когда режим учета включен, ядро создает запись всякий раз, когда
процесс завершает работу. Обычно это небольшой блок двоичных данных, в котором хранится имя команды, количество использованного процессорного времени,
идентификаторы пользователя и группы, время запуска и т. п. В этом разделе мы
поближе рассмотрим записи учета, поскольку это дает возможность взглянуть на
процессы с другой стороны, используя для этого функцию fread из раздела 5.9.
Возможность учета использования ресурсов процессами не определяется ни одним из стандартов. Поэтому все реализации имеют существенные различия. Например, учет ввода/
вывода в ОС Solaris 10 производится в байтах, тогда как в FreeBSD 8.0 и Mac OS X 10.6.8 —
в  блоках, хотя при этом не делается никаких различий между размерами блоков, что
делает такой учет достаточно бесполезным. С  другой стороны, Linux 3.2.0 вообще не
поддерживает учет операций ввода/вывода.
Кроме того, каждая реализация имеет собственный набор административных команд
для работы с учетной информацией. Например, Solaris предоставляет для сбора, обработки и вывода учетных сведений команды runacct(1m) и  acctcom(1), а FreeBSD —
команду sa(8).

Функция, о которой пока ничего не рассказывалось (acct), включает и выключает
режим сбора статистической информации о  процессах. Эта функция используется в единственной программе — accton(8) (она, к счастью, на всех платформах
называется одинаково). Чтобы включить режим учета, суперпользователь должен
запустить команду accton с аргументом командной строки, в котором передается
полный путь к файлу для записи учетной информации, обычно /var/account/acct
в  FreeBSD и  Mac OS X, /var/log/account/pacct  — в  Linux и  /var/adm/pacct  —
в Solaris. Учет выключается, когда команда accton запускается без параметров.
Структура записи с  учетной информацией определена в  заголовочном файле
<sys/acct.h> и выглядит, как показано ниже, хотя в разных системах могут быть
некоторые отличия:
typedef u_short comp_t; /* 3-битная, по основанию 8, экспонента;
/* 13 бит — мантисса */
struct acct
{
char ac_flag;
/* флаг (табл. 8.8) */
char ac_stat;
/* код завершения (только номер сигнала */
/* и признак создания файла core) (только в Solaris) */
uid_t ac_uid;
/* реальный идентификатор пользователя */
gid_t ac_gid;
/* реальный идентификатор группы */
dev_t ac_tty;
/* управляющий терминал */

332    Глава 8. Управление процессами
time_t
comp_t
comp_t
comp_t
comp_t
comp_t

};

ac_btime;
ac_utime;
ac_stime;
ac_etime;
ac_mem;
ac_io;

/*
/*
/*
/*
/*
/*
/*
comp_t ac_rw;
/*
/*
char ac_comm[8]; /*
/*

календарное время запуска */
пользовательское время */
системное время */
общее время работы */
средний расход памяти */
количество переданных байтов (функции read и write) */
в "блоках" для BSD-систем */
количество прочитанных и записанных блоков */
(отсутствует в BSD-системах) */
имя команды: [8] в Solaris, */
[10] в Mac OS X, [16] в FreeBSD и [17] в Linux */

Значения времени в  большинстве платформ хранятся в  тактах, кроме FreeBSD,
где время хранится в микросекундах. В поле ac_flag заносится информация о некоторых событиях, зафиксированных во время работы процесса. Эти события
перечислены в табл. 8.8.
Все необходимые данные, такие как количество использованного процессорного
времени или объем операций ввода/вывода, хранятся в таблице процессов и инициализируются при создании нового процесса после вызова функции fork. Каждая запись формируется и записывается в файл в момент завершения процесса.
Эта особенность имеет два следствия.
Во-первых, мы не сможем получить учетную информацию для процессов, которые никогда не завершаются. Процессы, такие как init, выполняющиеся от запуска до завершения системы, не генерируют записи с учетной информацией. То же
относится и к демонам ядра, которые обычно не завершают работу.
Во-вторых, записи в файле следуют в порядке завершения процессов, а не в порядке запуска. Чтобы определить порядок запуска, придется просмотреть файл
с  учетной информацией и  отсортировать его по календарному времени запуска
процессов. Но это даст не совсем точный порядок запуска, так как календарное
время измеряется в секундах (раздел 1.10), а на протяжении одной секунды может быть запущено несколько процессов. С другой стороны, общее время работы
дается в тактах системных часов (обычно от 60 до 128 тактов в секунду). Но мы
не знаем точное время окончания работы процесса; все, что у нас есть, — это время запуска и порядок завершения процессов. Это означает, что даже при том, что
общее время работы процесса измеряется более точно, чем время запуска, мы все
еще не в состоянии определить точный порядок запуска процессов по тем данным,
которые имеются в файле учета.
Каждая запись с учетной информацией соответствует процессу, а не программе.
Новая запись создается ядром только при создании нового дочернего процесса
вызовом функции fork, а не в момент, когда запускается новая программа. Хотя
вызов функции exec и не приводит к созданию новой записи, тем не менее имя
команды изменяется и поэтому сбрасывается флаг AFORK. Это означает, что если
программа A запускает B, B запускает C и после этого C завершает работу, то такой последовательности запущенных программ будет соответствовать всего одна
запись с учетной информацией. Имя команды в этой записи будет соответствовать программе C, но процессорное время будет представлять сумму времени, потраченного всеми тремя программами.

8.14. Учет использования ресурсов процессами   

333

Таблица 8.8. Значения флага ac_flag структуры acct
ac_flag

Описание

FreeBSD
8.0

Linux
3.2.0

Mac OS X
10.6.8

Solaris
10















AFORK

Процесс порожден функцией fork, но без
вызова функции exec

ASU

Процесс использовал привилегии суперпользователя

ACORE

Был создан файл с дампом памяти процесса (core)







AXSIG

Процесс завершился по сигналу







AEXPND

Расширенная запись с учетными данными

ANVER

Новый формат записи




Пример
Чтобы получить некоторый объем данных для исследования, создадим тестовую
программу, которая реализует следующую схему действий (рис. 8.4).
Родительский процесс
sleep(2)
exit(2)

for

k

Первый дочерний процесс
sleep(4)
abort()

for

k

Второй дочерний процесс

for

k

Третий дочерний процесс
sleep(8)

execl

exit(0)

for
k

Четвертый дочерний процесс
sleep(6)
kill()

/bin/dd

Рис. 8.4. Структура процесса, на примере которого будет рассматриваться
учетная информация

Исходный текст программы приводится в листинге 8.16. Эта программа вызывает
функцию fork четыре раза. Каждый из дочерних процессов выполняет некоторые
действия и завершает работу.
Листинг 8.16. Программа генерации учетной информации
#include "apue.h"
int
main(void)
{
pid_t

pid;

if ((pid = fork()) < 0)

334    Глава 8. Управление процессами
err_sys("ошибка вызова функции fork");
else if (pid != 0) { /* родительский процесс */
sleep(2);
exit(2);
/* завершение с кодом 2 */
}
if ((pid = fork()) < 0)
err_sys("ошибка вызова функции fork");
else if (pid != 0) { /* первый дочерний процесс */
sleep(4);
abort();
/* завершение с созданием файла core */
}
if ((pid = fork()) < 0)
err_sys("ошибка вызова функции fork");
else if (pid != 0) { /* второй дочерний процесс */
execl("/bin/dd", "dd", "if=/etc/passwd", "of=/dev/null", NULL);
exit(7);
/* программа не должна доходить до этой точки */
}
if ((pid = fork()) < 0)
err_sys("ошибка вызова функции fork");
else if (pid != 0) { /* третий дочерний процесс */
sleep(8);
exit(0);
/* нормальный выход */
}

}

sleep(6);
/* четвертый дочерний процесс */
kill(getpid(),SIGKILL); /* завершить по сигналу без создания файла core */
exit(6);
/* программа не должна доходить до этой точки */

Запустим эту программу в  Solaris и  затем выведем учетную информацию с  по­
мощью программы из листинга 8.17.
Листинг 8.17. Вывод учетной информации из системного файла учетных данных
#include "apue.h"
#include <sys/acct.h>
#if defined(BSD) /* В FreeBSD структура определена иначе */
#define acct acctv2
#define ac_flag ac_trailer.ac_flag
#define FMT "%-*.*s e = %.0f, chars = %.0f, %c %c %c %c\n"
#elif defined(HAS_SA_STAT)
#define FMT "%-*.*s e = %6ld, chars = %7ld, stat = %3u: %c %c %c %c\n"
#else
#define FMT "%-*.*s e = %6ld, chars = %7ld, %c %c %c %c\n"
#endif
#if defined(LINUX)
#define acct acct_v3 /* В ОС Linux структура определена иначе */
#endif
#if !defined(HAS_ACORE)
#define ACORE 0
#endif
#if !defined(HAS_AXSIG)
#define AXSIG 0
#endif
#if !defined(BSD)

8.14. Учет использования ресурсов процессами   

335

static unsigned long
compt2ulong(comp_t comptime) /* преобразовать comp_t в unsigned long */
{
unsigned long val;
int
exp;
val = comptime & 0x1fff;
/* 13 бит – мантисса */
exp = (comptime >> 13) & 7; /* 3 бита – экспонента (0-7) */
while (exp-- > 0)
val *= 8;
return(val);

}
#endif

int
main(int argc, char *argv[])
{
struct acct
acdata;
FILE
*fp;
if (argc != 2)
err_quit("Использование: pracct имя_файла");
if ((fp = fopen(argv[1], "r")) == NULL)
err_sys("невозможно открыть %s", argv[1]);
while (fread(&acdata, sizeof(acdata), 1, fp) == 1) {
printf(FMT, (int)sizeof(acdata.ac_comm),
(int)sizeof(acdata.ac_comm), acdata.ac_comm,
#if defined(BSD)
acdata.ac_etime, acdata.ac_io,
#else
compt2ulong(acdata.ac_etime), compt2ulong(acdata.ac_io),
#endif
#if defined(HAS_AC_STAT)
(unsigned char) acdata.ac_stat,
#endif
acdata.ac_flag & ACORE ? 'D' : ' ',
acdata.ac_flag & AXSIG ? 'X' : ' ',
acdata.ac_flag & AFORK ? 'F' : ' ',
acdata.ac_flag & ASU ? 'S' : ' ');
}
if (ferror(fp))
err_sys("ошибка вызова функции read");
exit(0);
}

На платформах, производных от BSD, поле ac_stat в структуре acct не поддерживается, поэтому мы определили константу HAS_SA_STAT для платформ, которые
поддерживают это поле. Использование константы с  именем, соответствующим
функциональной особенности вместо имени платформы, дает более удобочитаемый исходный текст программы и позволяет легко модифицировать ее простым
добавлением дополнительных определений в строку команды компиляции. В качестве альтернативы можно было бы использовать в тексте программы
#if !defined(BSD) || !defined(MACOS)

что по мере переноса программы на другие платформы делает ее все более громоздкой.

336    Глава 8. Управление процессами
Мы определили аналогичные константы, чтобы установить факт поддержки платформой флагов ACORE и  AXSIG. Мы не можем использовать просто имена флагов,
потому что в Linux они определены в виде перечисления enum и их нельзя использовать в выражении #ifdef.
Для тестирования нам необходимо:
1.	 Обладая привилегиями суперпользователя, включить сбор информации
коман­дой accton. Обратите внимание, что к моменту, когда команда accton завершится, сбор информации уже должен быть включен; поэтому первая запись
в учетном файле должна относиться к этой команде.
2.	 Выйти из командной оболочки суперпользователя и запустить программу из
листинга 8.16. В результате в файле учета должно появиться шесть дополнительных записей: одна соответствует завершившейся командной оболочке,
в которой мы работали с привилегиями суперпользователя, одна — родительскому процессу тестовой программы и четыре — дочерним процессам, порожденным тестовой программой.
Второй дочерний процесс не создает новый процесс с помощью функции execl.
Поэтому ему будет соответствовать одна запись в файле учета.
3.	 Получить привилегии суперпользователя и отключить сбор информации. Поскольку к моменту завершения команды accton сбор информации уже должен
быть выключен, в  файле учета не должно появиться новой записи, соответствующей этой команде.
4.	 Запустить программу из листинга 8.17, которая выведет информацию, собранную в учетном файле.
Ниже приводится вывод программы, полученный на шаге 4. Для последующего
обсуждения в конце некоторых строк добавлено описание процесса (курсивом).
accton
sh
dd
a.out
a.out
a.out
a.out

e
e
e
e
e
e
e

=
=
=
=
=
=
=

1,
1550,
2,
202,
420,
600,
801,

chars
chars
chars
chars
chars
chars
chars

=
=
=
=
=
=
=

336,
20168,
1585,
0,
0,
0,
0,

stat
stat
stat
stat
stat
stat
stat

=
0:
=
0:
=
0:
=
0:
= 134:
=
9:
=
0:

S
S
F
F
F

второй потомок
родительский процесс
первый потомок
четвертый потомок
третий потомок

Для данной системы общее затраченное время измеряется в тактах системных часов. В табл. 2.12 показано, что частота хода системных часов составляет 100 тактов в секунду. Например, вызов sleep(2) в родительском процессе соответствует
202 тактам системных часов. Первый потомок на выполнение функции sleep(4)
затратил 420 тактов системных часов. Обратите внимание, что время, на которое
процесс был приостановлен функцией sleep, измеряется не совсем точно. (Мы
вернемся к этой функции в главе 10.) Вызовы функций fork и exit также занимают некоторое количество времени.
Обратите также внимание, что поле ac_stat соответствует не действительному
коду завершения процесса, а  той его части, которая обсуждалась в  разделе  8.6.
Единственная информация, которая хранится в  этом поле,  — номер сигнала
(обычно младшие семь разрядов) и признак создания файла core (обычно старший бит), если процесс завершился аварийно. Если процесс завершился нормаль-

8.15. Идентификация пользователя   

337

но, мы не сможем получить код выхода из файла учета. Для первого потомка код
завершения имеет значение 128+6, где 128  — это признак создания файла core,
а 6 — номер сигнала SIGABRT для данной системы, который генерируется функцией abort. Значение кода завершения 9 четвертого потомка соответствует номеру
сигнала SIGKILL. Данный набор учетной информации ничего не сообщает о том,
что код выхода (аргумент функции exit) родительского процесса равен числу 2,
а аргумент функции exit в третьем потомке равен 0.
Размер файла /etc/passwd, который был скопирован процессом dd во втором потомке, составляет 777 байт. Объем операций ввода/вывода в два раза превышает
это значение, поскольку 777 байт сначала читаются и затем те же 777 байт записываются. Даже несмотря на то, что вывод производится в пустое устройство, эти
байты все равно учитываются. Дополнительные 31 байт — это длина сообщения,
выводимого командой dd в stdout.
Значения поля ac_flag в  точности соответствуют нашим ожиданиям. Флаг F
установлен у всех дочерних процессов, за исключением второго, который вызвал
функцию execl. Флаг F отсутствует у родительского процесса, поскольку командная оболочка, запустившая его, вызвала функцию fork, а  затем exec для файла
a.out. Первый дочерний процесс вызвал функцию abort, которая сгенерировала
сигнал SIGABRT, что вызвало создание файла core. Обратите внимание, что в полученных результатах отсутствуют флаги D и  X, поскольку они не поддерживаются в Solaris; информацию, которую они представляют, можно извлечь из поля
ac_stat. Четвертый дочерний процесс также завершился по сигналу, но сигнал
SIGKILL не вызывает создание файла core, он просто завершает процесс.
И последнее замечание: первый дочерний процесс имеет нулевой объем операций ввода/вывода, хотя завершился созданием файла core. Это говорит о том, что
объем операций ввода/вывода, который требуется для создания файла core, не
учитывается ядром.

8.15. Идентификация пользователя
Любой процесс может узнать свои реальные и  эффективные идентификаторы
пользователя и  группы. Но иногда требуется узнать имя пользователя, запустившего программу. Для этой цели можно было бы вызвать getpwuid(getuid()), но что
делать, если один и тот же пользователь имеет несколько учетных записей с разными именами, но с одним и тем же числовым идентификатором? (В файле паролей
может быть несколько записей с одинаковым числовым идентификатором, чтобы
пользователь мог запускать различные командные оболочки при входе в систему.)
Как правило, система отслеживает имена, под которыми осуществлялся вход (раздел 6.8), и позволяет получить имя пользователя с помощью функции getlogin.
#include <unistd.h>
char *getlogin(void);

Возвращает указатель на строку с именем пользователя в случае
успеха, NULL — в случае ошибки

338    Глава 8. Управление процессами
Эта функция может завершиться неудачей, если процесс не присоединен к терминалу, с которого произведен вход пользователя в систему. Такие процессы обычно
называются демонами. Они будут обсуждаться в главе 13.
Получив имя пользователя, можно с помощью функции getpwnam найти соответствующую запись в файле паролей, чтобы, например, определить тип командной
оболочки.
Чтобы найти имя пользователя, операционные системы UNIX традиционно вызывали
функцию ttyname (раздел 18.9) и затем пытались отыскать соответствующую запись
в файле utmp (раздел 6.8). FreeBSD и Mac OS X сохраняют имя пользователя в структуре
сеанса, связанного с записью в таблице процессов, и предоставляют системные вызовы
для получения и сохранения этого имени.
ОС System V поддерживала функцию cuserid, с помощью которой можно получить имя
пользователя. Эта функция вызывала getlogin или, в случае ее неудачи, getpwuid(getuid()).
Стандарт IEEE 1003.11988 определял функцию cuserid, но для получения имени она использовала эффективный, а не реальный идентификатор пользователя. Функция cuserid
была исключена в версии стандарта POSIX.1 1990 года.
Программа login(1) обычно записывает имя пользователя в  переменную окружения
LOGNAME, которая наследуется командной оболочкой после входа в систему. Однако следует
помнить, что пользователь может изменить значение этой переменной окружения, поэтому на нее нельзя полагаться при проверке имени пользователя. Вместо этого должна
использоваться функция getlogin.

8.16. Планирование процессов
Традиционно системами UNIX поддерживается лишь очень грубая настройка
приоритетов процессов для планирования. Политика планирования и поддержки
приоритетов определяется ядром. Процесс может понизить свой приоритет, изменив так называемый коэффициент уступчивости (то есть изменив значение «коэффициента уступчивости» («nice»), процесс может стать более «уступчивым»
и уменьшить выделяемую ему долю процессорного времени). Только привилегированные процессы могут увеличивать свой приоритет.
Расширения реального времени в стандарте POSIX добавляют интерфейсы, позволяющие выбирать из множества классов планирования и  производить подстройку их поведения. Здесь мы рассмотрим только интерфейсы, используемые
для изменения приоритета процесса; они являются частью расширений XSI
в  POSIX.1. Дополнительную информацию по расширениям реального времени
можно найти в [Gallmeister, 1995].
Согласно стандарту Single UNIX Specification, значения коэффициента уступчивости изменяются в  диапазоне от 0 до (2*NZERO)–1, хотя некоторые реализации
поддерживают диапазон от 0 до 2*NZERO. Более низкие значения коэффициента
уступчивости соответствуют более высокому приоритету. Кому-то такое соответствие может показаться странным, но в нем есть определенный смысл: чем более
уступчив процесс, тем ниже его приоритет. Константа NZERO определяет значение
по умолчанию для коэффициента уступчивости в данной системе.

8.16. Планирование процессов   

339

Помните, что в разных системах константа NZERO определяется в разных заголовочных
файлах. Кроме того, в Linux 3.2.0 значение NZERO можно получить не только из заголовочного файла, но и вызвав функцию sysconf с нестандартным аргументом _SC_NZERO.

Процесс может получать и изменять свой коэффициент уступчивости с помощью
функции nice. Эта функция позволяет процессу воздействовать только на собственный коэффициент уступчивости  — ее нельзя использовать для изменения
коэффициента уступчивости другого процесса.
#include <unistd.h>
int nice(int incr);

Возвращает новое значение коэффициента уступчивости –NZERO
в случае успеха, –1 — в случае ошибки
Аргумент incr определяет значение, которое будет добавлено к  коэффициенту уступчивости вызывающего процесса. Если значение incr окажется слишком
большим, система просто уменьшит его до максимально допустимого. Аналогично, если значение incr окажется слишком маленьким, система увеличит его до минимально допустимого. Так как –1 является допустимым возвращаемым значением, перед вызовом функции nice следует очистить переменную errno и проверить
ее после вызова, если nice вернет –1. Если nice выполнилась успешно и вернула
–1, в переменной errno сохранится нулевое значение. Если errno будет содержать
ненулевое значение, следовательно, вызов nice потерпел неудачу.
Функция getpriority, как и  nice, позволяет получить значение коэффициента
уступчивости процесса. Но помимо этого getpriority может также вернуть значение коэффициента уступчивости для группы родственных процессов.
#include <sys/resource.h>
int getpriority(int which, id_t who);

Возвращает значение коэффициента уступчивости между –NZERO
и NZERO–1 в случае успеха, –1 — в случае ошибки
Аргумент which может принимать одно из трех значений: PRIO_PROCESS, если операция выполняется для процесса; PRIO_PGRP, если операция выполняется для
группы процессов; и  PRIO_USER, если операция выполняется для пользователя.
Аргумент which управляет интерпретацией аргумента who, который, в свою очередь, определяет порядок выбора процесса или процессов. Если в аргументе who
передать 0, операция выполнится для текущего процесса, группы процессов или
пользователя (в зависимости от значения аргумента which). Когда в  аргументе
which передается PRIO_USER, а в аргументе who — 0, выбор процессов производится
по реальному идентификатору пользователя текущего процесса. Если аргумент
which соответствует более чем одному процессу, возвращается наивысший прио­
ритет (наименьшее значение) из всех выбранных процессов.

340    Глава 8. Управление процессами
Для изменения приоритета процесса, группы процессов или всех процессов,
принадлежащих определенному пользователю, можно использовать функцию
setpriority.
#include <sys/resource.h>
int setpriority(int which, id_t who, int value);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Назначение аргументов which и  who в  точности соответствует назначению одно­
именных аргументов функции getpriority. К значению value добавляется константа NZERO, и результат становится новым значением коэффициента уступчивости.
Системный вызов nice появился в ранних версиях Research UNIX System для PDP11. Функции getpriority и setpriority появились в 4.2BSD.

Стандарт Single UNIX Specification оставляет за реализациями определение порядка наследования коэффициента уступчивости дочерними приложениями после вызова fork. Однако XSI-совместимые системы должны сохранять коэффициент уступчивости после вызова exec.
Во всех четырех обсуждаемых платформах — FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8
и  Solaris 10  — дочерний процесс наследует значение коэффициента уступчивости от
своего родителя.

Пример
Программа в  листинге 8.18 измеряет эффект изменения приоритета процесса.
Два процесса, выполняющиеся одновременно, наращивают свои счетчики. Родительский процесс выполняется с  коэффициентом уступчивости по умолчанию,
а дочерний изменяет свой коэффициент в соответствии с параметром командной
строки. По истечении 10 секунд оба процесса выводят значения своих счетчиков
и завершаются. Сравнивая значения счетчиков, полученные процессами с разными приоритетами, можно примерно судить, как значение коэффициента уступчивости влияет на планирование процесса системой.
Листинг 8.18. Определение эффекта влияния изменения коэффициента уступчивости
#include "apue.h"
#include <errno.h>
#include <sys/time.h>
#if defined(MACOS)
#include <sys/syslimits.h>
#elif defined(SOLARIS)
#include <limits.h>
#elif defined(BSD)
#include <sys/param.h>
#endif
unsigned long long count;

8.16. Планирование процессов   

341

struct timeval end;
void
checktime(char *str)
{
struct timeval tv;

}

gettimeofday(&tv, NULL);
if (tv.tv_sec >= end.tv_sec && tv.tv_usec >= end.tv_usec) {
printf("%s счетчик = %lld\n", str, count);
exit(0);
}

int
main(int argc, char *argv[])
{
pid_t
pid;
char
*s;
int
nzero, ret;
int
adj = 0;
setbuf(stdout, NULL);
#if defined(NZERO)
nzero = NZERO;
#elif defined(_SC_NZERO)
nzero = sysconf(_SC_NZERO);
#else
#error NZERO undefined
#endif
printf("NZERO = %d\n", nzero);
if (argc == 2)
adj = strtol(argv[1], NULL, 10);
gettimeofday(&end, NULL);
end.tv_sec += 10; /* выполняться в течение 10 секунд */

}

if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) { /* дочерний процесс */
s = "потомок";
printf("текущий коэфф. уступчивости в потомке %d, изменяется на %d\n",
nice(0)+nzero, adj);
errno = 0;
if ((ret = nice(adj)) == -1 && errno != 0)
err_sys("ошибка изменения приоритета в потомке");
printf("сейчас коэфф. уступчивости в потомке %d\n", ret+nzero);
} else {
/* родительский процесс */
s = "родитель";
printf("текущий коэфф. уступчивости в родителе %d\n", nice(0)+nzero);
}
for(;;) {
if (++count == 0)
err_quit("%s переполнение счетчика", s);
checktime(s);
}

Мы запустили программу дважды: один раз — с приоритетом по умолчанию и второй раз  — с  максимально допустимым значением коэффициента уступчивости

342    Глава 8. Управление процессами
(низший приоритет). Тестирование производилось в однопроцессорной системе
Linux, чтобы показать, как планировщик делит процессорное время между процессами с разными приоритетами. В многопроцессорной и ненагруженной системе (или в системе с многоядерным процессором) оба процесса могли бы выполняться на разных процессорах, не мешая друг другу, и разница между процессами
с разными приоритетами была бы не так очевидна.
$ ./a.out
NZERO = 20
текущий коэфф. уступчивости в родителе 20
текущий коэфф. уступчивости в потомке 20, изменяется на 0
сейчас коэфф. уступчивости в потомке 20
потомок счетчик = 1859362
родитель счетчик = 1845338
$ ./a.out 20
NZERO = 20
текущий коэфф. уступчивости в родителе 20
текущий коэфф. уступчивости в потомке 20, изменяется на 20
сейчас коэфф. уступчивости в потомке 39
родитель счетчик = 3595709
потомок счетчик = 52111

Когда оба процесса имели одинаковый приоритет, родительский процесс получил
50,2% процессорного времени, а потомок — 49,8%. То есть оба получили практически одинаковое количество процессорного времени. Небольшая разница объясняется некоторой неточностью в процедуре планирования, а также тем, что родительский и дочерний процессы выполняют разное количество операций между
моментом, когда вычисляется время завершения, и моментом, когда начинается
цикл увеличения счетчика.
Напротив, когда коэффициент уступчивости дочернего процесса был увеличен
до максимального значения (получил минимальный приоритет), родительскому
процессу было отдано 98,5% процессорного времени, а  дочернему — всего 1,5%.
Эти результаты могут отличаться в разных системах UNIX, в зависимости от особенностей использования коэффициента планировщиком процессов.

8.17. Временные характеристики процесса
В разделе 1.10 описывались три временные характеристики, которые можно измерить: общее время выполнения, пользовательское время и системное время. Любой процесс может вызвать функцию times, чтобы получить эти три значения для
себя самого и для любого из завершивших работу потомков.
#include <sys/times.h>
clock_t times(struct tms *buf);

Возвращает количество тактов общего времени выполнения процесса
в случае успеха, –1 — в случае ошибки

8.17. Временные характеристики процесса   

343

Эта функция заполняет структуру tms, адрес которой передается в аргументе buf:
struct tms {
clock_t
clock_t
clock_t
clock_t

};

tms_utime;
tms_stime;
tms_cutime;
tms_cstime;

/*
/*
/*
/*

пользовательское время */
системное время */
пользовательское время для завершившегося потомка */
системное время для завершившегося потомка */

Обратите внимание, что структура не содержит общего времени выполнения. Мы
получаем его в  виде возвращаемого значения. Это время отмеряется от произвольного момента в прошлом, поэтому вместо абсолютных следует использовать
относительные значения. Например, вызвать функцию times и сохранить возвращаемое значение. Через какое-то время еще раз вызвать функцию times и вычесть
сохраненное ранее значение из нового значения. Разница будет определять время,
прошедшее между двумя вызовами функции times. (Вполне возможно, хотя и маловероятно, что у  долгоживущего процесса произойдет переполнение счетчика
общего времени, см. упражнение 1.5.)
Два поля структуры отводятся для хранения временных характеристик дочернего
процесса, но только того, завершение которого ожидалось с  помощью функции
wait, waitid или waitpid.
Все значения типа clock_t, возвращаемые функцией, можно преобразовать в секунды путем деления на количество тактов системных часов в секунду — значение
параметра _SC_CLK_TCK, возвращаемое функцией sysconf (раздел 2.5.4).
Большинство реализаций предоставляют функцию getrusage(2). Она возвращает затраченное процессорное время и еще 14 значений, характеризующих использование различных ресурсов. Исторически эта функция происходит из ОС BSD, поэтому все системы,
производные от BSD, как правило, поддерживают большее количество полей, чем другие
реализации.

Пример
Программа в листинге 8.19 запускает команды оболочки, переданные ей в аргументах, засекает время их выполнения и выводит значения полей структуры tms.
Листинг 8.19. Запуск команд и определение времени их работы
#include "apue.h"
#include <sys/times.h>
static void pr_times(clock_t, struct tms *, struct tms *);
static void do_cmd(char *);
int
main(int argc, char *argv[])
{
int
i;
setbuf(stdout, NULL);
for (i = 1; i < argc; i++)
do_cmd(argv[i]); /* один раз для каждого аргумента командной строки */
exit(0);

344    Глава 8. Управление процессами
}
static void
do_cmd(char *cmd) /* запускает и измеряет время работы "cmd" */
{
struct tms tmsstart, tmsend;
clock_t
start, end;
int
status;
printf("\nкоманда: %s\n", cmd);
if ((start = times(&tmsstart)) == -1) /* начальные значения */
err_sys("ошибка вызова функции times");
if ((status = system(cmd)) < 0)
/* запустить команду */
err_sys("ошибка вызова функции system()");
if ((end = times(&tmsend)) == -1)
/* конечные значения */
err_sys("ошибка вызова функции times");

}

pr_times(end - start, &tmsstart, &tmsend);
pr_exit(status);

static void
pr_times(clock_t real, struct tms *tmsstart, struct tms *tmsend)
{
static long
clktck = 0;
if (clktck == 0) /* получить количество тактов в сек. в первый раз*/
if ((clktck = sysconf(_SC_CLK_TCK)) < 0)
err_sys("ошибка вызова функции sysconf");

}

printf(" real: %7.2f\n", real / (double) clktck);
printf(" user: %7.2f\n",
(tmsend->tms_utime – tmsstart->tms_utime) / (double) clktck);
printf(" sys: %7.2f\n",
(tmsend->tms_stime – tmsstart->tms_stime) / (double) clktck);
printf(" child user: %7.2f\n",
(tmsend->tms_cutime – tmsstart->tms_cutime) / (double) clktck);
printf(" child sys: %7.2f\n",
(tmsend->tms_cstime – tmsstart->tms_cstime) / (double) clktck);

Запустив эту программу, мы получили
$ ./a.out "sleep 5" "date" "man bash >/dev/null"
команда: sleep 5
real: 5.01
user: 0.00
sys: 0.00
child user: 0.00
child sys: 0.00
нормальное завершение, код выхода = 0
команда: date
Sun Feb 26 18:39:23 EST 2012
real: 0.00

Упражнения   

345

user: 0.00
sys: 0.00
child user: 0.00
child sys: 0.00
нормальное завершение, код выхода = 0
команда: man bash >/dev/null
real: 1.46
user: 0.00
sys: 0.00
child user: 1.32
child sys: 0.07
нормальное завершение, код выхода = 0

Первые две команды выполняются слишком быстро, чтобы с имеющейся точностью можно было определить затраченное процессорное время. Но третья действует достаточно долго, чтобы заметить, что все затраченное процессорное время
относится к дочернему процессу, которым является командная оболочка, запускающая команду.

8.18. Подведение итогов
Глубокое понимание механизма управления процессами в UNIX совершенно необходимо для профессионального программирования в этой операционной системе. Для этого нужно освоить лишь несколько функций: fork, семейство функций
exec, _exit, wait и waitpid. Эти примитивы широко используются во многих приложениях. Кроме всего прочего, функция fork дала нам возможность увидеть ситуацию гонки за ресурсами.
Изучение функции system и возможностей учета расходования ресурсов процессами помогло нам посмотреть на функции управления процессами под другим
углом. Мы также рассмотрели еще одну возможность функции exec — интерпретацию файлов и  то, как эта интерпретация выполняется. Понимание различий
между различными идентификаторами пользователя и группы — реальным, эффективным и сохраненным идентификаторами — особенно важно для обеспечения безопасности программ с установленным битом set-user-ID.
Обладая новыми знаниями о функционировании отдельного процесса и его потомков, мы рассмотрим в  следующей главе взаимоотношения между разными
процессами — сеансы и управление заданиями. Затем в главе 10 завершим тему
процессов описанием сигналов.

Упражнения
8.1	

При обсуждении программы из листинга 8.2 мы говорили, что если вызов
функции _exit заменить на exit, стандартный поток вывода может оказаться закрытым и функция printf вернет признак ошибки — число –1. Измените программу, чтобы проверить, присуще ли такое поведение вашей реализации. Если нет, как эту ситуацию можно смоделировать?

346    Глава 8. Управление процессами
8.2	

Вспомните типичную организацию памяти процесса, изображенную на
рис. 7.3. Каждому вызову функции обычно соответствует свой кадр стека,
но поскольку после вызова функции vfork дочерний процесс продолжает
работать в адресном пространстве родительского процесса, что может произойти, если обращение к  vfork производится не из функции main, а  из
другой функции и при этом дочерний процесс выполняет возврат из этой
функции после вызова vfork? Напишите тестовую программу для проверки
этой ситуации и нарисуйте схему происходящего.

8.3	

Перепишите программу в листинге 8.4, чтобы вместо wait она использовала
waitpid. Не прибегая к  функции pr_exit, определите эквивалентную информацию из структуры siginfo.

8.4	

Запустив программу из листинга 8.7 один раз:
$ ./a.out

результаты не выглядят необычными. Но если запустить ее несколько раз
подряд:
$ ./a.out ; ./a.out ; ./a.out
от родительского процесса
оот родительского процесса
ото дтроочернего процесса
дительского процесса
от дочернего процесса
чернего процесса

8.5	

вывод не будет соответствовать нашим ожиданиям. Почему? Как это можно
исправить? Останется ли эта проблема, если дочерний процесс будет
производить вывод первым?
В программе из листинга 8.10 мы вызывали функцию execl, которой передавали полный путь к  интерпретируемому файлу. Если вместо этого
использовать функцию execlp, передав ей только имя файла testinterp,
и если каталог /home/sar/bin указан в переменной окружения PATH, что выведет программа в качестве argv[2]?

8.6	

Напишите программу, которая создает процесс-зомби и  затем с  помощью
функции system запускает команду ps(1), чтобы проверить, действительно
ли процесс превратился в зомби.

8.7	

Как было отмечено в разделе 8.10, стандарт POSIX.1 требует, чтобы все открытые каталоги закрывались при вызове функции exec. Проверить это
можно так: откройте корневой каталог с помощью функции opendir, уточните содержимое структуры DIR в  своей системе и  выведите состояние
флага close-on-exec. Затем откройте тот же каталог для чтения с помощью
функции open и выведите состояние флага close-on-exec.

9

Взаимоотношения
между процессами

9.1. Введение
В предыдущей главе мы узнали, что процессы связаны определенными взаимоотношениями. Прежде всего, каждый процесс имеет «родителя» (начальный процесс уровня ядра обычно сам является собственным родителем). Когда дочерний
процесс завершает работу, родительский процесс извещается об этом и может получить код выхода своего потомка. Мы также упоминали группы процессов, когда описывали функцию waitpid (раздел 8.6), которая может ожидать завершения
любого процесса из указанной группы.
В этой главе мы более подробно рассмотрим группы процессов, а также коснемся
понятия сеансов, введенного стандартом POSIX.1. Также мы рассмотрим отношения между командной оболочкой входа, которая запускается во время входа
в систему, и всеми процессами, запускаемыми из этой оболочки.
Невозможно говорить о взаимоотношениях процессов без упоминания сигналов,
а чтобы обсуждать сигналы, необходимо иметь представление о понятиях, рассматриваемых в этой главе. Если вы совершенно не знакомы с механизмом сигналов
UNIX, вероятно, стоит сначала просмотреть главу 10.

9.2. Вход с терминала
Для начала рассмотрим программы, которые запускаются при входе пользователя
в систему UNIX. Во времена ранних версий UNIX, таких как Version 7, пользователи входили в систему через терминалы ввода/вывода, соединенные кабелем
с главным компьютером. Терминалы могли быть локальными (связанными непосредственно с  компьютером) и  удаленными (связанными с  компьютером через
модем). И в том и в другом случае вход в систему осуществлялся через драйвер
устройства терминала в  ядре. Например, наиболее типичными терминальными
устройствами на PDP-11 были DH-11 и  DZ-11. Машина имела фиксированное
количество таких устройств, поэтому заранее было известно максимальное количество пользователей, которые могли одновременно войти в систему.
После появления графических терминалов были разработаны системы с оконным
графическим интерфейсом, чтобы дать пользователю новый, более удобный способ взаимодействия с компьютером. Для эмуляции алфавитно-цифровых терми-

348    Глава 9. Взаимоотношения между процессами
налов стали разрабатываться приложения, которые создавали «окно терминала»,
что позволяло пользователю взаимодействовать с главной машиной привычным
способом (то есть через командную строку).
В настоящее время некоторые системы дают возможность запустить оконный интерфейс после входа, а другие запускают его автоматически. В последнем случае
вам, возможно, все равно придется вводить имя и пароль — в зависимости от конфигурации оконной системы (в некоторых системах может быть настроен автоматический вход).
Процедура, которую мы сейчас описываем, используется для входа в  систему
UNIX посредством терминала. Она не зависит от типа терминала — это может
быть алфавитно-цифровой терминал, графический терминал, эмулирующий
простой алфавитно-цифровой терминал или графический терминал с оконной
системой.

Вход в систему с терминала в BSD-системах
Эта процедура практически не изменилась за последние 40 лет. Системный администратор создает файл, обычно /etc/ttys, в котором каждая строка соответствует одному терминальному устройству. В каждой строке определяется имя устройства и  другие параметры для программы getty  — например, скорость передачи
данных. Во время загрузки системы ядро создает процесс с идентификатором 1, то
есть процесс init, который переводит систему в многопользовательский режим.
Процесс init читает файл /etc/ttys и для каждого терминала запускает программу getty с помощью функций fork и exec. Это дает нам схему процессов, изображенную на рис. 9.1.
Процесс
с идентификатором 1

init
fork

По дочернему процессу
на каждый терминал

init
exec

Каждый дочерний процесс
запускает программу getty

getty

Рис. 9.1. Процессы, порождаемые init, чтобы разрешить вход в систему с терминалов

Все процессы, изображенные на рис. 9.1, имеют реальный и эффективный идентификатор пользователя 0 (то есть обладают привилегиями суперпользователя).
Кроме того, процесс init запускает программу getty с пустым окружением.
Программа getty с помощью функции open открывает устройство терминала на
чтение и на запись. Если устройство является модемом, функция open может отра-

9.2. Вход с терминала   

349

ботать с некоторой задержкой внутри драйвера устройства, пока модем набирает
номер и устанавливает соединение. Когда устройство открыто, ему назначаются
файловые дескрипторы с номерами 0, 1 и 2. Далее getty выводит некоторую строку, например login:, и ожидает ввода имени пользователя. Если терминал поддерживает обмен данными на разных скоростях, программа getty в  состоянии распознать специальные управляющие последовательности, которые указывают ей
изменить скорость передачи. За дополнительными сведениями о программе getty
и файлах данных (gettytab), управляющих ее действиями, обращайтесь к справочному руководству по вашей операционной системе.
После ввода имени пользователя программа getty завершает работу и  передает
управление программе login примерно так:
execle("/bin/login", "login", "-p", username, (char *)0, envp);

(Файл gettytab может содержать ссылки на другие программы, но по умолчанию
вызывается программа login.) Процесс init запускает программу getty с пустым
окружением, а  getty создает для программы login (аргумент envp) окружение
с именем терминала (что-нибудь вроде TERM=foo, где foo — тип терминала, который берется из файла gettytab) и другими переменными окружения, определенными в файле gettytab. Флаг -p сообщает программе login, что она должна сохранить предыдущую среду окружения и добавить к ней новую среду, не заменяя
существующую. На рис. 9.2 показано состояние процессов сразу после запуска
программы login.
Процесс
с идентификатором 1

init

Читает файл /etc/ttys,
создает по дочернему процессу
для каждого терминала,
создает пустое окружение

fork
init
exec
getty
exec

Открывает устройство терминала
(дескрипторы 0, 1, 2),
читает имя пользователя,
настраивает окружение

login

Рис. 9.2. Состояние процессов после запуска программы login

Все процессы на рис. 9.2 наследуют привилегии суперпользователя от первоначального процесса init. Три последних процесса получают одинаковые идентификаторы, потому что exec не изменяет идентификатор процесса. Кроме того, все процессы, кроме первоначального init, имеют идентификатор родительского процесса 1.
Программа login выполняет множество различных действий. Поскольку у  нее
уже есть имя пользователя, она может вызвать функцию getpwnam, чтобы полу-

350    Глава 9. Взаимоотношения между процессами
чить строку учетной записи из файла паролей. Затем программа login вызывает
функцию getpass(3), чтобы вывести приглашение к вводу Password: и прочитать
пароль (при этом, разумеется, отображение вводимых символов отключено). Далее вызывается функция crypt(3), которая шифрует введенный пароль, и полученный результат сравнивается с полем pw_passwd из записи в теневом файле паролей. Если попытка входа в систему не удалась из-за неверно введенного пароля
(после нескольких попыток), login вызывает функцию exit с аргументом 1. Такое
завершение программы login будет замечено родительским процессом (init),
и он с помощью функций fork и exec снова запустит программу getty для возобновления процедуры входа на данном терминале.
Это традиционная процедура аутентификации, используемая в  UNIX. Современные системы UNIX поддерживают большое количество других процедур. Например, FreeBSD, Linux, MacOS X и  Solaris поддерживают более гибкую схему,
известную как PAM (Pluggable Authentication Modules — сменные модули аутентификации). Эта схема позволяет системным администраторам настраивать методы аутентификации для обращения к  службам, которые разработаны для использования с библиотекой PAM.
Если приложение требует проверки прав пользователя на выполнение определенных задач, можно либо жестко зашить механизм аутентификации в код приложения, либо создать аналогичную функциональность, используя библиотеку PAM.
Преимущество PAM в том, что администратор может настроить разные способы
аутентификации пользователей для выполнения различных задач, основываясь
на локальной политике безопасности.
Если вход в систему выполнен корректно, программа login:
 изменит домашний каталог (chdir);
 изменит владельца терминала (chown);
 изменит права доступа к устройству терминала, чтобы дать возможность производить операции чтения и записи;
 установит идентификатор группы вызовом функций setgid и initgroups;
 инициализирует окружение той информацией, которой располагает программа login: это домашний каталог пользователя (HOME), командная оболочка
(SHELL), имя пользователя (USER или LOGNAME) и список каталогов для поиска
выполняемых файлов (PATH);
 изменит идентификатор пользователя (setuid) и запустит командную оболочку входа в систему
execl("/bin/sh", "-sh", (char *)0);

Символ «–» в качестве первого символа argv[0] сообщает командной оболочке, что она
запущена как оболочка входа в систему. Командная оболочка, обнаружив этот признак,
может соответственно изменить перечень действий, выполняемых при запуске.

На самом деле программа login выполняет гораздо больше действий. Она, например, может выводить так называемое сообщение дня, проверять поступление

9.2. Вход с терминала   

351

новой почты и выполнять ряд других задач. Но сейчас нас интересует только та
функциональность, которую мы описали.
В разделе 8.11, при обсуждении функции setuid, мы говорили, что при вызове
с привилегиями суперпользователя она изменяет все три идентификатора пользователя — реальный, эффективный и сохраненный. Вызов функции setgid, который производится программой login чуть раньше, так же воздействует на все три
идентификатора группы.
Итак, оболочка входа запущена. Ее родителем является процесс init (с идентификатором 1), то есть когда командная оболочка завершит работу, процесс init
получит уведомление (сигнал SIGCHLD) и сможет снова запустить процедуру входа
на данном терминале. Файловые дескрипторы 0, 1 и 2 в командной оболочке входа
связаны с терминальным устройством. Это состояние изображено на рис. 9.3.
Процесс
с идентификатором 1

init
Через getty и login
Командная
оболочка входа
fd 0, 1, 2
Драйвер устройства
терминала
Cоединяющий кабель
Терминал
пользователя

Рис. 9.3. Состояние процессов после входа пользователя в систему с терминала

Далее оболочка входа читает файлы начальной загрузки (.profile для Bourne
shell и  Korn shell; .bash_profile, .bash_login или .profile для GNU Bourneagain shell; .cshrc и  .login для C shell). В  них обычно изменяются значения
некоторых переменных окружения и  добавляется множество новых. Например, большинство пользователей создают свой список каталогов поиска (PATH)
и  устанавливают правильный тип терминала (TERM). Когда файлы начального
запуска обработаны, мы наконец видим приглашение командной оболочки и можем вводить команды.

Вход в систему с терминала в Mac OS X
В Mac OS X вход в систему осуществляется так же, как в BSD, поскольку Mac OS X
частично основана на FreeBSD, но имеет некоторые отличия:

352    Глава 9. Взаимоотношения между процессами
 работу процесса init выполняет процесс launchd;
 вся процедура входа выполняется через графический интерфейс.

Вход в систему с терминала в Linux
Процедура входа в  Linux очень напоминает процедуру входа в  BSD-системах.
И действительно, команда login в Linux является производной от команды login
в 4.3BSD. Главное отличие между процедурами входа в Linux и BSD заключается
в способе настройки терминала.
Некоторые дистрибутивы Linux распространяются с  версией программы init,
использующей конфигурационные файлы в формате, подобном формату файлов
для программы init в System V. В этих системах конфигурационная информация,
определяющая терминальные устройства, для которых должна вызываться программа getty, хранится в файле /etc/inittab.
Другие дистрибутивы Linux, такие как Ubuntu, распространяются с версией программы init, известной под названием «Upstart». Она использует конфигурационные файлы с именами вида *.conf, которые хранятся в каталоге /etc/init. Например, настройки для запуска getty на устройстве /dev/tty1 находятся в файле
/etc/init/tty1.conf.
В зависимости от используемой версии getty характеристики терминалов указываются либо в командной строке (команда getty), либо в файле /etc/gettydefs
(команда mgetty).

Вход в систему с терминала в Solaris
Solaris поддерживает два вида входа в систему с терминала: (а) с помощью getty,
как описано выше для BSD-систем, и (б) с помощью ttymon — возможности, появившейся в SVR4. Как правило, для входа с консоли используется getty, а для
входа с других терминальных устройств — ttymon.
Команда ttymon является частью большого программного механизма, называемого SAF  — Service Access Facility (механизм доступа к  службам). Основная цель
SAF — обеспечить единый механизм управления службами, предоставляющими
доступ к системе. (За дополнительной информацией обращайтесь к главе 6 [Rago,
1993].) В  нашем случае конечный результат действия этого механизма соответствует тому, что изображено на рис. 9.3, однако между процессом init и запуском
оболочки входа выполняются несколько иные действия. Процесс init является
родительским для процесса sac (service access controller  — контроллер доступа
к службам), который с помощью fork и  exec запускает программу ttymon, когда
система переходит в  многопользовательский режим. Программа ttymon контролирует все терминальные порты, перечисленные в  конфигурационном файле,
и  запускает дочерний процесс после ввода имени пользователя. Этот дочерний
процесс с  помощью функции exec запускает программу login, а  уже она запрашивает пароль. После ввода пароля login запускает командную оболочку входа,
и  система приходит в  состояние, изображенное на рис. 9.3. Единственное отличие — родителем для командной оболочки становится процесс ttymon, а в схеме
с использованием программы getty — процесс init.

9.3. Вход в систему через сетевое соединение   

353

9.3. Вход в систему через сетевое соединение
Главное физическое отличие между входом в систему с терминала, соединенного
с главной машиной последовательным кабелем, и через сетевое соединение состоит в том, что сетевое соединение не построено по принципу «точка-точка». В данном случае login — это просто служба, подобная другим сетевым службам, таким
как FTP или SMTP.
В ситуациях, описанных в  предыдущем разделе, процесс init знает, с  каких
устройств разрешен вход, и  порождает процесс getty для каждого из них. Но
в случае входа в систему через сетевое соединение все запросы поступают через
драйвер сетевого интерфейса (например, драйвер Ethernet) и мы заранее не знаем,
сколько таких запросов поступит. Вместо запуска отдельного процесса для каждого возможного запроса на вход в систему мы теперь ожидаем прибытия запросов
на соединение.
Чтобы одно и то же программное обеспечение могло обрабатывать вход в систему
с терминала и через сетевые соединения, используется программный драйвер, который называется псевдотерминалом. Этот драйвер эмулирует поведение обычного терминала, отображая операции с терминалом в сетевые операции и наоборот.
(Подробнее о псевдотерминалах мы поговорим в главе 19.)

Вход в систему через сетевое соединение в BSD
В системах BSD большинство сетевых соединений устанавливается с  помощью
единственного процесса  — inetd, который иногда называют Internet superserver.
В этом разделе мы рассмотрим последовательность действий, которая выполняется при входе в BSD-систему через сетевое соединение. Нас не интересуют все
подробности программной реализации этих процессов — их вы найдете в [Stevens,
Fenner, and Rudoff, 2004].
Во время запуска системы процесс init вызывает командный интерпретатор, который выполняет сценарий командной оболочки /etc/rc. Одним из демонов, запускаемых этим сценарием, является inetd. По окончании работы сценария родительским процессом для inetd становится процесс init. Процесс inetd ожидает
запросов на соединение по протоколу TCP/IP. Когда поступает очередной запрос,
демон inetd с  помощью функций fork и  exec запускает соответствующую программу для его обработки.
Предположим, что по адресу сервера TELNET пришел запрос на TCP-соединение.
TELNET — это служба удаленного входа в систему, которая использует протокол
TCP. Пользователь, находящийся за другим компьютером (соединенным с сервером сетью) или за тем же самым компьютером, инициирует вход в систему, запустив клиент TELNET:
telnet hostname

Клиент открывает TCP-соединение с  узлом сети hostname, и  на стороне сервера запускается программа, которая называется сервером TELNET. После этого
клиент и сервер начинают обмен данными по прикладному протоколу TELNET.
Таким способом пользователь, запустивший клиентскую программу, выполняет

354    Глава 9. Взаимоотношения между процессами
вход в систему на сервере. (Разумеется, лишь в том случае, если у пользователя
имеется учетная запись на сервере.) На рис. 9.4 показана последовательность процессов, сопутствующих запуску сервера TELNET с именем telnetd.
Процесс
с идентификатором 1

init
Запуск /bin/sh,
которая выполнит сценарий /etc/rc
при входе системы
в многопользовательский режим

Запрос на соединение
от клиента TELNET

inetd
fork

После получения запроса
на соединение от клиента TELNET

inetd
exec
telnetd

Рис. 9.4. Последовательность действий, приводящая к запуску сервера TELNET
Процесс
с идентификатором 1

init
Через inetd, telnetd и login
Командная
оболочка входа
fd 0, 1, 2
Драйвер устройства
псевдотерминала
Сетевое соединение через
сервер telnetd и клиент telnet
Терминал
пользователя

Рис. 9.5. Состояние процессов после входа пользователя через сетевое соединение

Затем процесс telnetd открывает устройство псевдотерминала и  с  помощью
функции fork разделяется на два процесса. Родительский процесс продолжает обслуживать сетевое соединение, а дочерний запускает программу login. Родительский процесс связан с дочерним через псевдотерминал. Перед вызовом функции
exec дочерний процесс присоединяет файловые дескрипторы 0, 1 и 2 к псевдотерминалу. В случае удачного входа в систему программа login выполняет действия,

9.3. Вход в систему через сетевое соединение   

355

описанные в  разделе 9.2: она делает текущим домашний каталог пользователя,
устанавливает идентификаторы пользователя и группы и инициализирует окружение. Затем программа login замещает себя командной оболочкой входа посредством функции exec. На рис. 9.5 показано состояние процессов в этот момент.
Очевидно, что между драйвером псевдотерминала и пользовательским терминалом действует еще множество процессов. Мы рассмотрим их в главе 19, когда будем говорить о псевдотерминалах более подробно.
Важно понимать, что независимо от того, входим мы в  систему через терминал
(см. рис. 9.3) или через сетевое соединение (см. рис. 9.5), мы получаем командную
оболочку входа со стандартным вводом, стандартным выводом и стандартным выводом сообщений об ошибках, которые связаны либо с  устройством терминала,
либо с  устройством псевдотерминала. В  последующих разделах мы увидим, что
оболочка входа открывает сеанс POSIX.1, а терминал или псевдотерминал становится управляющим терминалом сеанса.

Вход в систему через сетевое соединение в Mac OS X
В Mac OS X процедура входа в систему через сетевое соединение совпадает с процедурой в BSD, поскольку Mac OS X частично основана на FreeBSD. Только в Mac
OS X демон telnet запускается из launchd.
По умолчанию в  Mac OS X демон telnet отключен (но его можно включить командой
launchctl(1)). Для входа в систему через сетевое соединение в Mac OS X предпочтительнее
использовать ssh, защищенную командную оболочку.

Вход в систему через сетевое соединение в Linux
Процедура входа через сетевое соединение в  Linux практически такая же, как
в  BSD, только вместо процесса inetd используется его альтернатива  — xinetd
(extended Internet services daemon — расширенный демон сетевых служб). Демон
xinetd дает возможность более точного управления запуском сетевых служб по
сравнению с inetd.

Вход в систему через сетевое соединение в Solaris
Сценарий входа через сетевое соединение в Solaris по большей части идентичен
соответствующим сценариям в BSD и Linux. В Solaris, как и в BSD, используется
сервер inetd, но версия в  Solaris выполняется механизмом управления службами (Service Management Facility, SMF) как рестартер (restarter). Рестартер — это
демон, ответственный за запуск других демонов и  повторный их запуск, когда
они завершаются по ошибке. Хотя сервер inetd запускается главным рестартером (master restarter) в SMF, сам главный рестартер запускается процессом init,
и в результате мы приходим к состоянию, изображенному на рис. 9.5.
Механизм управления службами (Service Management Facility) в Solaris — это целая инфраструктура управления системными службами, поддерживающая возможность их
возобновления в случае отказов. За дополнительной информацией о механизме управления
службами обращайтесь к  [Adams, 2005] и  страницам smf(5) и  inetd(1M) справочного
руководства в Solaris.

356    Глава 9. Взаимоотношения между процессами

9.4. Группы процессов
Каждый процесс не только имеет идентификатор процесса, но и  принадлежит
к определенной группе процессов. Мы еще будем встречаться с группами процессов при обсуждении сигналов в главе 10.
Группа процессов — это коллекция из одного или более процессов, обычно связанных с выполнением одного и того же задания (управление заданиями рассматривается в разделе 9.8), которые могут принимать сигналы от одного и того же
терминала. Каждая группа процессов имеет уникальный идентификатор. Идентификатор группы процессов напоминает идентификатор процесса: это целое положительное число, которое может храниться в переменной типа pid_t. Функция
getpgrp возвращает идентификатор группы процессов вызывающего процесса.
#include <unistd.h>
pid_t getpgrp(void);

Возвращает идентификатор группы процессов вызывающего процесса
В ранних версиях BSD-систем функция getpgrp принимала аргумент pid и  возвращала группу процессов для заданного процесса. Стандарт Single UNIX
Specification определил в  качестве расширения XSI функцию getpgid, которая
имитирует это поведение.
#include <unistd.h>
pid_t getpgid(pid_t pid);

Возвращает идентификатор группы процессов в случае успеха,
–1 — в случае ошибки
Если в аргументе pid передать 0, функция вернет групповой идентификатор вызывающего процесса. То есть вызов
getpgid(0);

эквивалентен вызову
getpgrp();

Каждая группа процессов может иметь лидера. Идентификатор группы процессов
лидера группы совпадает с его идентификатором процесса.
Вполне допустима ситуация, когда лидер группы создает группу процессов, затем запускает процессы в этой группе и завершается. Группа процессов продолжит существовать, пока в ней остается хотя бы один процесс, вне зависимости от
того, завершил работу лидер группы или нет. Период от момента создания группы
и до момента, когда последний процесс в группе покинет ее, называется временем
жизни группы процессов. Последний оставшийся в  группе процесс может либо
завершиться, либо войти в состав другой группы процессов.

9.5. Сеансы   

357

Процесс может присоединиться к  группе или создать новую группу процессов
с  помощью функции setpgid. (В следующем разделе мы увидим, что функция
setsid также создает новую группу процессов.)
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Эта функция устанавливает для процесса с идентификатором pid идентификатор
группы процессов pgid. Если аргументы имеют одинаковые значения, процесс, заданный идентификатором pid, становится лидером группы процессов. Если в аргументе pid передается 0, в качестве идентификатора процесса используется идентификатор вызывающего процесса. Если в аргументе pgid передается 0, в качестве
идентификатора группы процессов используется значение аргумента pid.
Процесс может установить идентификатор группы только для себя самого и для
своих дочерних процессов. Но процесс не может изменить идентификатор группы процессов дочернего процесса, который вызвал одну из функций семейства exec.
В большинстве командных оболочек, поддерживающих управление заданиями,
функция setpgid вызывается после fork, чтобы родительский процесс мог назначить идентификатор группы процессов дочернему процессу, а дочерний процесс — установить свой собственный идентификатор группы процессов.
Один из этих вызовов является излишним, но, выполняя оба, мы гарантируем, что
дочерний процесс будет помещен в  его собственную группу процессов в  любом
случае. Иначе мы столкнулись бы с  ситуацией гонки за ресурсами, когда членство дочернего процесса зависело бы от того, какой из процессов первым получит
управление.
При обсуждении сигналов мы увидим, как послать сигнал отдельному процессу
(по идентификатору процесса) или группе процессов (по идентификатору группы процессов). Аналогично функция waitpid позволяет дождаться завершения
конкретного процесса или одного из процессов в заданной группе.

9.5. Сеансы
Сеанс — это коллекция из одной или более групп процессов. Рассмотрим в качестве примера ситуацию, изображенную на рис. 9.6. Здесь мы имеем три группы
процессов в одном сеансе.
Процессы обычно помещаются в группу командной оболочкой при конвейерной
обработке данных. Например, состояния процессов, изображенного на рис. 9.6,
можно достигнуть следующей последовательностью команд:
proc1 | proc2 &
proc3 | proc4 | proc5

358    Глава 9. Взаимоотношения между процессами

Командная
оболочка входа

proc1

Группа процессов

proc2

proc3

proc4

Группа процессов

proc5
Группа процессов

Сеанс

Рис. 9.6. Распределение процессов по группам процессов и сеансам

Создание нового сеанса производится с помощью вызова функции setsid.
#include <unistd.h>
pid_t setsid(void);

Возвращает идентификатор группы процессов в случае успеха,
–1 — в случае ошибки
Если вызывающий процесс не является лидером группы, функция создает новый
сеанс. При этом происходит следующее.
1.	 Процесс становится лидером нового сеанса. (Лидер сеанса — это процесс, который создает сеанс.) Этот процесс — единственный в новом сеансе.
2.	 Процесс становится лидером новой группы процессов. Идентификатором новой группы процессов становится идентификатор вызывающего процесса.
3.	 Процесс теряет управляющий терминал. (Управляющие терминалы обсуждаются в  следующем разделе.) Если у  процесса был управляющий терминал
перед вызовом функции setsid, связь с ним разрывается.
Эта функция возвращает признак ошибки, если вызывающий процесс уже является лидером группы. Чтобы избежать этой ошибки, обычно вызывают функцию
fork, затем родительский процесс завершается, а  дочерний процесс продолжает
работу. В  этом случае можно гарантировать, что дочерний процесс не будет лидером группы, поскольку его идентификатор группы процессов наследуется
от родительского процесса, но сам он получит новый идентификатор процесса.
Соответственно идентификатор дочернего процесса никогда не будет совпадать
с унаследованным идентификатором группы процессов.
Стандарт Single UNIX Specification оговаривает только определение лидера сеанса, но в нем нет определения идентификатора сеанса. Очевидно, что лидер сеанса — это отдельный процесс, имеющий уникальный идентификатор процесса,
поэтому можно утверждать, что идентификатор сеанса — это идентификатор процесса, являющегося лидером сеанса. Такое понимание идентификатора сеанса

9.6. Управляющий терминал   

359

было введено в SVR4. Традиционно BSD-системы не поддерживали это понятие,
но впоследствии положение изменилось.
Некоторые реализации, такие как Solaris, следуя Single UNIX Specification, избегают понятия «идентификатор сеанса»; вместо этого они используют термин «идентификатор
группы процессов лидера сеанса». Эти два понятия эквивалентны, так как лидер сеанса
всегда является лидером группы процессов.

Функция getsid возвращает идентификатор группы процессов лидера сеанса.
#include <unistd.h>
pid_t getsid(pid_t pid);

Возвращает идентификатор группы процессов лидера сессии
в случае успеха, –1 — в случае ошибки
Если в  аргументе pid передать 0, getsid вернет идентификатор группы процессов лидера сеанса, которой принадлежит вызывающий процесс. Из соображений
безопасности некоторые реализации могут ограничивать возможность получения
идентификатора группы процессов лидера сеанса, если в аргументе pid передается
идентификатор процесса, не принадлежащего тому же сеансу, что и вызывающий
процесс.

9.6. Управляющий терминал
Сеансы и группы процессов обладают еще некоторыми характеристиками.
 Сеанс может иметь только один управляющий терминал. Обычно это устройство терминала (в случае входа в систему с терминала) или устройство псевдотерминала (в случае входа в систему через сетевое соединение), с которого был
произведен вход в систему.
 Лидер сеанса, который устанавливает соединение с  управляющим терминалом, называется управляющим процессом.
 Группы процессов в  пределах одного сеанса могут подразделяться на единственную группу процессов переднего плана и  одну или более групп фоновых
процессов.
 Если сеанс имеет управляющий терминал, в нем будет одна группа процессов
переднего плана, а все остальные группы процессов в сеансе будут группами
фоновых процессов.
 Когда мы вводим с клавиатуры терминала символ прерывания (обычно DELETE
или Control-C), всем процессам в группе процессов переднего плана посылается
сигнал прерывания.
 Когда мы вводим с  клавиатуры терминала символ завершения (обычно
Control-\), всем процессам в группе процессов переднего плана посылается сигнал завершения.

360    Глава 9. Взаимоотношения между процессами
 Если интерфейс терминала обнаруживает разрыв связи с модемом или сетью,
управляющему процессу (лидеру сеанса) посылается сигнал, оповещающий
о разрыве связи.
Эти характеристики показаны на рис. 9.7.
Сеанс

Командная
оболочка входа
Группа фоновых процессов

proc1

proc2

proc3

proc4

Группа фоновых процессов

лидер сеанса =
управляющий процесс

proc5

я
ни
не
я)
ди
ни
ое
не
вс
ди
ое
зры
ра
ас
ыв
азр
лр
гна
(си

Группа процессов переднего плана

ы,
ал
игн
м
о
л
л
на
на
ми
ми
р
р
е
т
те
ые
дс
ем
вво
ла
ы
с
по
с
аи

Управляющий
терминал

Рис. 9.7. Группы процессов, сеансы и управляющий терминал

Обычно не приходится беспокоиться об управляющем терминале — он устанавливается автоматически после входа в систему.
Стандарт POSIX.1 оставляет выбор механизма размещения управляющего терминала за
конкретной реализацией. Фактические действия мы будем рассматривать в разделе 19.4.
Системы, производные от System V, размещают управляющий терминал сеанса в тот
момент, когда лидер сеанса открывает первое устройство терминала, еще не связанное
с  сеансом. Это предполагает, что лидер сеанса, вызывая функцию open, не указывает
флаг O_NOCTTY (раздел 3.3).
Системы, основанные на BSD, размещают управляющий терминал сеанса, когда лидер
сеанса вызывает функцию ioctl, передавая ей в аргументе request значение TIOCSCTTY
(третий аргумент — пустой указатель). Чтобы вызов завершился успехом, сеанс не
должен иметь управляющего терминала. (Обычно вызов функции ioctl следует за
вызовом функции setsid  — это гарантирует, что процесс является лидером сеанса
без управляющего терминала.) Флаг O_NOCTTY функции open не используется в BSDсистемах, за исключением случаев, когда необходима поддержка совместимости с другими системами.
В табл. 9.1 перечислены способы размещения управляющих терминалов в  каждой из
систем, обсуждаемых в этой книге. Обратите внимание: хотя Mac OS X 10.6.8 ведет
свою родословную от BSD, она действует как System V, когда размещает управляющий
терминал.

9.7. Функции tcgetpgrp, tcsetpgrp и tcgetsid   

361

Таблица 9.1. Размещение управляющих терминалов в различных реализациях
Метод

FreeBSD 8.0

open без флага O_NOCTTY

передача команды TIOCSCTTY
системному вызову ioctl



Linux 3.2.0

Mac OS X 10.6.8

Solaris 10













Иногда возникают ситуации, когда программа должна произвести обмен данными
с управляющим терминалом, даже когда стандартные потоки ввода/вывода перенаправлены. Чтобы обеспечить возможность такого обмена, необходимо вызовом
функции open открыть файл /dev/tty. Этот специальный файл является синонимом управляющего терминала в ядре. Разумеется, если программа не имеет управляющего терминала, попытка открыть его окончится неудачей.
Классический пример  — функция getpass(3), которая читает пароль при вводе
с клавиатуры (естественно, при отключенном отображении вводимых символов).
Эта функция вызывается программой crypt(1) и может быть использована в конвейере с другими командами. Например, команда
crypt < salaries | lpr

расшифрует содержимое файла salaries и  отправит результат на принтер. Поскольку программа crypt читает входной файл со стандартного ввода, он не может
использоваться для ввода пароля. Кроме того, программа crypt спроектирована
так, что при каждом вызове она заставляет нас снова вводить пароль и не дает сохранить его в файле (иначе это стало бы лазейкой в системе безопасности).
Существуют способы, позволяющие взломать шифр, используемый программой
crypt. За дополнительной информацией о  шифровании файлов обращайтесь
к [Garfinkel et al., 2003].

9.7. Функции tcgetpgrp, tcsetpgrp и tcgetsid
Теперь нам нужен способ сообщить ядру, какая группа процессов является группой переднего плана, чтобы драйвер терминала знал, какому процессу передавать
ввод с терминала и кому отправлять сигналы (рис. 9.7).
#include <unistd.h>
pid_t tcgetpgrp(int fd);

Возвращает идентификатор группы процессов переднего плана
в случае успеха, –1 — в случае ошибки
int tcsetpgrp(int fd, pid_t pgrpid);

Возвращает 0 в случае успеха, –1 — в случае ошибки

362    Глава 9. Взаимоотношения между процессами
Функция tcgetpgrp возвращает идентификатор группы процессов переднего плана, связанной с открытым файловым дескриптором терминала fd.
Если процесс обладает управляющим терминалом, он может вызвать функцию
tcsetpgrp, чтобы назначить группу процессов с идентификатором pgrpid группой
процессов переднего плана. Значение аргумента pgrpid должно быть идентификатором группы процессов в том же сеансе, а аргумент fd должен быть дескриптором
управляющего терминала сеанса.
Большинство приложений не вызывают эти две функции напрямую. Обычно они
вызываются командными оболочками, которые поддерживают управление заданиями.
Функция tcgetsid позволяет приложению получить идентификатор группы процессов лидера сеанса по заданному файловому дескриптору управляющего терминала.
#include <termios.h>
pid_t tcgetsid(int fd);

Возвращает идентификатор группы процессов лидера сеанса в случае
успеха, –1 — в случае ошибки
Приложения, которым необходимо взаимодействовать с управляющим терминалом, могут использовать функцию tcgetsid, чтобы получить идентификатор сеанса для лидера сеанса, владеющего управляющим терминалом (что эквивалентно идентификатору группы процессов лидера сеанса).

9.8. Управление заданиями
Возможность управления заданиями была добавлена в BSD около 1980 года.
Она позволяет запустить несколько заданий (групп процессов) с одного терминала и определить, какие из них получат доступ к терминалу, а какие будут выполняться в  фоновом режиме. Управление заданиями поддерживается, если соблюдаются следующие условия.
1.	 Командная оболочка должна поддерживать управление заданиями.
2.	 Драйвер терминала в ядре должен поддерживать управление заданиями.
3.	 Ядро должно поддерживать ряд сигналов, с помощью которых осуществляется
управление заданиями.
В SVR3 имелась возможность управления заданиями в иной форме, которая называлась
уровнями командной оболочки (shell layers). Однако стандарт POSIX.1 выбрал форму
управления заданиями, реализованную в BSD; именно она здесь и описывается. В ранних
версиях стандарта поддержка управления заданиями была необязательной, однако те-

9.8. Управление заданиями   

363

перь POSIX.1 требует, чтобы все POSIX-совместимые платформы поддерживали эту
возможность.

Для нас сейчас важно, что возможность управления заданиями позволяет запустить задание на переднем плане или в фоновом режиме. Задание — это просто
набор процессов, часто объединенных в конвейер. Например, команда
vi main.c

запустит задание, содержащее один процесс переднего плана. Команды
pr *.c | lpr &
make all &

запустят два фоновых задания. Все процессы, запускаемые в рамках этих заданий,
являются фоновыми.
Как уже говорилось, чтобы пользоваться управлением заданиями, необходима
командная оболочка, поддерживающая эту возможность. Довольно просто перечислить командные оболочки, которые поддерживали управление заданиями
в старых системах. Так, C shell имела поддержку управления заданиями, Bourne
shell — нет, а Korn shell — в зависимости от того, поддерживала ли управление
заданиями сама платформа. Но позднее командная оболочка C shell была перенесена на системы, которые не поддерживали управление заданиями (например,
ранние версии System V), а в SVR4 можно было включить поддержку управления заданиями в  командной оболочке Bourne shell, запустив ее командой jsh
вместо sh. В настоящее время возможность управления заданиями в Korn shell
зависит от того, поддерживает ли эту возможность сама система. Командная
оболочка Bourne-again shell поддерживает управление заданиями. Далее мы будем просто упоминать, что командная оболочка поддерживает управление заданиями в противоположность оболочке, которая не имеет такой поддержки, если
различия между конкретными оболочками для нас несущественны.
При запуске задания в  фоновом режиме командная оболочка присваивает ему
идентификатор задания и выводит один или более идентификаторов процессов.
Ниже показано, как это делает командная оболочка Korn shell:
$ make all > Make.out &
[1] 1475
$ pr *.c | lpr &
[2] 1490
$ просто нажмите клавишу Enter
[2] + Done pr *.c | lpr &
[1] + Done make all > Make.out &

Задание с  номером 1 представлено программой make, а  соответствующий ей
процесс имеет идентификатор 1475. Задание с  номером 2 представлено конвейером, в котором первый процесс имеет идентификатор 1490. По завершении
заданий, после нажатия клавиши Enter, командная оболочка сообщает, какие задания завершились. Она не выводит сообщений об изменении состояния фоновых заданий по своей инициативе — только перед тем, как выведет приглашение, которое позволяет вводить новые команды. Иначе сообщения оболочки

364    Глава 9. Взаимоотношения между процессами
могли бы смешиваться с  вводимыми символами. Поэтому чтобы вызвать сообщение о состоянии фоновых заданий, после появления приглашения нужно
нажать клавишу Enter.
Управление заданием переднего плана через драйвер терминала осуществляется
с помощью ввода специальных символов, например символа приостановки (обычно Control-Z). Ввод этого символа заставляет драйвер послать сигнал SIGTSTP всем
процессам группы переднего плана. Задания, выполняемые в  фоновом режиме,
при этом не затрагиваются. Драйвер терминала посылает сигналы процессам переднего плана при вводе трех специальных символов.
 ввод символа прерывания (обычно DELETE или Control-C) порождает сигнал
SIGINT;
 ввод символа завершения (обычно Control-\) порождает сигнал SIGQUIT;
 ввод символа приостановки (обычно Control-Z) порождает сигнал SIGTSTP.
В главе 18 мы увидим, как привязать эту функциональность к любым другим символам и как запретить обработку этих специальных символов драйвером терминала.
Драйверу терминала приходится обрабатывать и  другие ситуации, связанные
с управлением заданиями. Так как у нас может быть одно задание переднего плана
и одно или более фоновых заданий, необходимо разобраться, какие из них будут
получать символы, вводимые с терминала. Ввод с терминала получает только задание переднего плана. Попытка прочитать ввод с терминала в фоновом задании
не считается ошибкой, но будет обнаружена драйвером, который пошлет специальный сигнал SIGTTIN фоновому заданию. Этот сигнал обычно приводит к остановке фонового задания, командная оболочка выводит сообщение об этом, и мы
можем перевести задание на передний план, чтобы оно получило возможность
прочитать ввод с терминала, например:
$ cat > temp.foo & программа запущена в фоновом режиме, но пытается
читать со стандартного ввода
[1] 1681
$ нажимаем клавишу Enter
[1] + Stopped (SIGTTIN) cat > temp.foo &
$ fg %1 переводим задание с номером 1 на передний план
cat > temp.foo оболочка сообщает, какое задание находится
на переднем плане
hello, world вводим одну строку
^D вводим символ EOF (конец файла)
$ cat temp.foo проверяем, попала ли введенная строка в файл
hello, world

Обратите внимание, что данный пример не работает в Mac OS X 10.6.8. При попытке
перевести команду cat на передний план вызов функции read в ней завершается с ошибкой
EINTR в errno. Так как Mac OS X основана на FreeBSD, а FreeBSD работает в соответствии
с ожиданиями, такое поведение, скорее всего, обусловлено ошибкой в Mac OS X.

Командная оболочка запускает в  фоновом режиме процесс cat, который пытается прочитать символы со стандартного ввода (управляющий терминал).
Драйвер терминала знает, что это фоновое задание, и  посылает ему сигнал

9.8. Управление заданиями   

365

SIGTTIN. Командная оболочка определяет изменение состояния своего дочернего процесса (вспомните обсуждение функций wait и  waitpid в  разделе 8.6)

и  сообщает, что задание приостановлено. После этого мы с  помощью команды fg перемещаем приостановленное задание на передний план. (За дополнительной информацией о командах управления заданиями, таких как fg или bg,
и способах идентификации заданий обращайтесь к страницам справочного руководства по командной оболочке.) В результате оболочка переместила задание
в группу процессов переднего плана (tcsetpgrp) и послала группе сигнал продолжения работы (SIGCONT). Поскольку теперь задание принадлежит к группе
процессов переднего плана, оно получает возможность читать данные с управляющего терминала.
А что произойдет, если фоновое задание попытается вывести что-нибудь на терминал? Мы можем разрешить или запретить эту возможность, обычно для этого
используется команда stty(1). (В главе 18 мы покажем, как управлять этой возможностью из программы.) Например:
$ cat temp.foo & запустить в фоновом режиме
[1] 1719
$ hello, world вывод фонового задания появляется после приглашения
командной оболочки; нажимаем клавишу Enter
[1] + Done cat temp.foo &
$ stty tostop запретить фоновым заданиям вывод в терминал
$ cat temp.foo & попробуем еще раз запустить команду в фоновом режиме
[1] 1721
$ нажимаем Enter и обнаруживаем, что задание приостановлено
[1] + Stopped(SIGTTOU) cat temp.foo &
$ fg %1 возобновим работу задания на переднем плане
cat temp.foo оболочка сообщила, какое из заданий выполняется
на переднем плане
hello, world а это вывод задания

Когда мы запретили возможность вывода в терминал для фоновых заданий, утилита cat была заблокирована при попытке записи в стандартный вывод, так как
драйвер терминала определил, что запись производится из фонового процесса, и передал ему сигнал SIGTTOU. Как и в предыдущем примере, мы с помощью
коман­ды fg перевели задание на передний план, благодаря чему оно получило
возможность успешно отработать.
На рис. 9.8 изображена схема управления заданиями, описанная выше. Сплошные линии внутри драйвера терминала означают, что ввод/вывод на терминал
и  сигналы, посылаемые терминалом, всегда связаны с  группой процессов переднего плана. Пунктирная линия, соответствующая сигналу SIGTTOU, означает,
что возможность вывода на терминал для фоновых процессов может отсутст­
вовать.
Является ли управление заданиями необходимым или только желательным?
Изначально управление заданиями было спроектировано и  реализовано еще
до появления и  широкого распространения терминалов, предоставляющих
многооконный интерфейс. Одни берут на себя смелость утверждать, что хорошо продуманная многооконная система ликвидирует потребность в управлении
заданиями. Другие выражают недовольство чрезмерно сложной реализацией

366    Глава 9. Взаимоотношения между процессами
управления заданиями, которое должно поддерживаться ядром, драйвером терминала, командной оболочкой и отдельными приложениями. Третьи используют и управление заданиями, и многооконную систему, утверждая, что обе возможности одинаково необходимы. Однако, независимо от вашего мнения, эта
функциональность является обязательной для реализации согласно стандарту
POSIX.1.
init, inetd или launchd

getty

или telnetd
вызов exec после setsid
и создание управляющего терминала

login
exec

из
м
до ен
че ен
se
рн ие
ег со
tp
о
gi
пр сто
оц ян
d
ес ия
са

те

(S

IG

во
д
од
/вы

си

гн
ал
ы

и
ст
ве U
ри
TO
тп
GT
же
мо
SI
л
а
на
ал
ет
ми игн
с
ва
ер
зы
вт
ию
вы
сь лен
а
в
пи
N
ал
за поя
TI
ин
к
рм IGT
те
S
из ал
гн
си

ие

ен

чт

рм
ин
ал
а
по
IN
сы
T,
ла
S
IG
гр ем
уп ы
QU
пе е
IT
пр тер
,S
оц ми
IT
ес на
со ло STP
),
в
м

Группа процессов
переднего плана

вв

Группа(ы) процессов
заднего плана

которая будет владеть управляющим терминалом

ия
ян а
то есс
с
со оц
ие пр
id
ен его
pg
н
е
t
н
р
м
se
из оче
д

Вызов tcsetpgrp для назначения группы процессов,
владеющей управляющим терминалом

Командная оболочка входа

Драйвер
терминала

Пользовательский
терминал

Сеанс

Рис. 9.8. Схема взаимодействия заданий переднего плана и фонового режима
с драйвером терминала

9.9. Выполнение программ командной оболочкой   

367

9.9. Выполнение программ
командной оболочкой
Рассмотрим, как командная оболочка запускает программы и  как это связано
с понятиями группы процессов, управляющего терминала и сеанса. Для этого воспользуемся командой ps.
Для начала возьмем командную оболочку, которая не поддерживает управление
заданиями,  — это классическая Bourne shell под управлением Solaris. Запустив
­команду
ps -o pid,ppid,pgid,sid,comm

мы получим
PID PPID PGID SID COMMAND
949 947 949 949 sh
1774 949 949 949 ps

Как мы и ожидали, родительским процессом для ps является командная оболочка. И командная оболочка, и команда ps находятся в одном сеансе и принадлежат
одной группе процессов переднего плана (949). Мы говорим, что число 949 представляет группу процессов переднего плана, потому что в командных оболочках
без поддержки управления заданиями мы получаем именно группу процессов.
На некоторых платформах команда ps может выводить идентификатор группы процессов, связанный с управляющим терминалом сеанса. Это значение отображается в столбце TPGID. К сожалению, вывод команды ps часто различается в разных версиях UNIX.
Например, Solaris 10 не поддерживает такую возможность. В FreeBSD 8.0, Linux 3.2.0
и Mac OS X 10.6.8 команда
ps -o pid,ppid,pgid,sid,tpgid,comm

выведет то, что нам необходимо.
Обратите внимание: было бы неправильно ассоциировать процесс с идентификатором
группы процессов терминала (столбец TPGID — terminal process group ID). У процесса нет
такого признака, как группа процессов терминала. Процесс принадлежит группе процессов, а группа процессов принадлежит сеансу. Сеанс может иметь управляющий терминал,
а может не иметь. Если сеанс имеет управляющий терминал, то терминальное устройство
знает идентификатор группы процессов переднего плана. Это значение можно установить
в драйвере терминала с помощью функции tcsetpgrp, как это видно на рис. 9.8. Идентификатор группы процессов переднего плана — это атрибут терминала, а не процесса. Значение,
выводимое командой ps в колонке TPGID, берется из драйвера терминала. Если окажется, что
сеанс не имеет управляющего терминала, команда ps выведет в этой колонке значение –1.

Если запустить команду в фоновом режиме:
ps -o pid,ppid,pgid,sid,comm &

единственное, что изменится, — это идентификатор процесса команды:
PID PPID PGID SID COMMAND
949 947 949 949 sh
1812 949 949 949 ps

368    Глава 9. Взаимоотношения между процессами
Эта командная оболочка не поддерживает управление заданиями, поэтому фоновое задание не помещается в собственную группу процессов и не теряет связь
с управляющим терминалом.
А теперь посмотрим, как Bourne shell обслуживает конвейеры. После запуска
­команды
ps -o pid,ppid,pgid,sid,comm | cat1

мы получаем
PID PPID PGID SID COMMAND
949 947 949 949 sh
1823 949 949 949 cat1
1824 1823 949 949 ps

(Программа cat1  — это просто копия программы cat, сохраненная под другим
именем. У нас есть еще одна копия программы cat под именем cat2, которую мы
используем чуть позже в этом же разделе. Запуск двух копий программы cat в одном конвейере дает нам возможность различать их.) Обратите внимание, что последний процесс в конвейере является дочерним процессом командной оболочки,
а первый — дочерним по отношению к последнему. Похоже, что командная оболочка создала собственную копию, которая затем в обратном порядке породила
каждый из процессов в конвейере.
Если запустить ту же команду в фоновом режиме:
ps -o pid,ppid,pgid,sid,comm | cat1 &

изменятся только идентификаторы процессов. Поскольку командная оболочка
поддерживает управление заданиями, идентификатор группы процессов фонового режима сохраняет значение 949, равно как и идентификатор сеанса.
Что произойдет, если в  этой оболочке фоновый процесс попытается прочитать
ввод из управляющего терминала? Например, предположим, что мы запустили
такую команду:
cat > temp.foo &

При наличии поддержки управления заданиями, если фоновое задание, находящееся в группе процессов фонового режима, попытается произвести чтение из управляющего терминала, ему будет послан сигнал SIGTTIN. При отсутствии поддержки
управления заданиями командная оболочка автоматически перенаправляет стандартный ввод фонового процесса в устройство /dev/null, если процесс не перенаправит его самостоятельно. При попытке чтения из устройства /dev/null приложение получает признак конца файла. Это означает, что фоновый процесс cat сразу же
прочитает признак конца файла и завершит работу нормальным образом.
Предыдущий абзац описывает случай, когда фоновый процесс обращается
к  управляющему терминалу через стандартный ввод, но что произойдет, если
фоновый процесс попытается открыть устройство /dev/tty и прочитать входные
данные из него? Ответ: «Это зависит от реализации», но, наверное, это не то, что
нам нужно. Например, команда
crypt < salaries | lpr &

9.9. Выполнение программ командной оболочкой   

369

является таким конвейером. Мы запускаем эту команду в  фоновом режиме, но
программа crypt открывает /dev/tty, изменяет характеристики терминала (запрещает отображение вводимых символов), читает из устройства и восстанавливает характеристики терминала. Если запустить такой конвейер в фоновом режиме, на экране появится приглашение Password:, но введенный нами пароль для
шифрования будет прочитан командной оболочкой, которая воспримет введенную строку как команду и попытается ее запустить. Следующая строка, введенная
в командной оболочке, будет воспринята как пароль, в результате файл будет расшифрован неправильно и на принтер будет отправлен бессмысленный набор символов. Здесь присутствуют два процесса, которые одновременно пытаются читать
из одного и того же устройства, и конечный результат таких попыток зависит от
системы. Управление заданиями, как было описано ранее, позволяет лучше организовать совместное использование одного терминала несколькими процессами.
Вернемся к примеру с Bourne shell, запустим три процесса в конвейере и посмотрим, как эта оболочка осуществляет управление процессами:
ps -o pid,ppid,pgid,sid,comm | cat1 | cat2

Эта команда выведет следующее:
PID PPID PGID SID COMMAND
949 947 949 949 sh
1988 949 949 949 cat2
1989 1988 949 949 ps
1990 1988 949 949 cat1

Пусть вас не тревожит, если в вашей системе вы получите неверные имена команд. Иногда
можно получить примерно такой результат:
PID PPID PGID SID COMMAND
949 947 949 949 sh
1831 949 949 949 sh
1832 1831 949 949 ps
1833 1831 949 949 sh

Дело в том, что процесс ps конкурирует с командной оболочкой за обладание процессором,
когда та запускает команды cat с помощью функций fork и exec. В ситуации, показанной
выше, командная оболочка еще не успела завершить вызовы функции exec, а команда ps
уже вывела список процессов.

И опять последний процесс является дочерним процессом командной оболочки,
а все предыдущие процессы — дочерними процессами последнего процесса. Рисунок 9.9 показывает смысл происходящего.
Так как последний процесс в конвейере (cat2) является дочерним по отношению
к командной оболочке, она получит извещение о его завершении.
Теперь исследуем те же самые примеры, но уже в Linux с командной оболочкой,
поддерживающей управление заданиями, и  посмотрим, как эти командные оболочки обслуживают фоновые задания. В  этой серии экспериментов мы использовали оболочку Bourne-again shell; результаты в других оболочках практически
идентичны. Команда
ps -o pid,ppid,pgrp,sid,tpgid,comm

370    Глава 9. Взаимоотношения между процессами
выводит следующее:
PID PPID PGRP SID TPGID COMMAND
2837 2818 2837 2837 5796 bash
5796 2837 5796 2837 5796 ps

sh

rk

exec

(1989)

ps

(1989)

fo
sh

fork

(949)

sh

(1988)

конвейер

fo

из

rk

ве

sh

ие

ес
оц

ен

пр

щ

exec

(1990)

cat1

(1990)

ро

са

exec

о

ии

го

ен

о
ск

рш

ль

ве

те

за

ди

ер

вей

кон

cat2

(1988)

Рис. 9.9. Процессы в конвейере ps | cat1 | cat2, запущенном в оболочке Bourne shell

(Начиная с  этого примера мы будем отмечать группу процессов переднего плана жирным шрифтом.) Здесь сразу же видны отличия от Bourne shell. Оболочка
Bourne-again shell помещает задание переднего плана (ps) в собственную группу
(5796). Команда ps  — лидер группы процессов и  единственный процесс в  этой
группе. Кроме того, эта группа является группой процессов переднего плана, так
как имеет управляющий терминал. На время выполнения команды ps командная
оболочка становится группой фоновых процессов. Но обратите внимание, что обе
группы процессов, 2837 и 5796, принадлежат одному сеансу. В примерах в этом
разделе мы увидим, что сеанс никогда не изменяется.
Запуск этой же команды в фоновом режиме:
ps -o pid,ppid,pgrp,sid,tpgid,comm &

дает
PID PPID PGRP SID TPGID COMMAND
2837 2818 2837 2837 2837 bash
5797 2837 5797 2837 2837 ps

И опять команда ps была помещена в собственную группу процессов (5797), но на
этот раз она уже не является группой процессов переднего плана. Теперь это группа фоновых процессов. Значение TPGID (2837) указывает, что группа процессов
переднего плана соответствует командной оболочке.
Запуск двух команд в конвейере:
ps -o pid,ppid,pgrp,sid,tpgid,comm | cat1

9.10. Осиротевшие группы процессов   

371

дает
PID PPID PGRP SID TPGID COMMAND
2837 2818 2837 2837 5799 bash
5799 2837 5799 2837 5799 ps
5800 2837 5799 2837 5799 cat1

Оба процесса, ps и cat1, теперь помещены в отдельную группу процессов (5799) —
группу процессов переднего плана. Здесь также имеются отличия от аналогичного примера для Bourne shell. Командная оболочка Bourne shell первым запускала последний процесс в  конвейере, и  этот процесс становился родительским по
отношению к первому процессу в конвейере. Здесь же родительским процессом
для обеих команд становится Bourne-again shell. Если этот же конвейер запустить
в фоновом режиме:
ps -o pid,ppid,pgrp,sid,tpgid,comm | cat1 &

результаты будут похожими, но на этот раз ps и  cat1 окажутся в  одной группе
фоновых процессов:
PID PPID PGRP SID TPGID COMMAND
2837 2818 2837 2837 2837 bash
5801 2837 5801 2837 2837 ps
5802 2837 5801 2837 2837 cat1

Обратите внимание, что порядок, в котором создаются процессы, может зависеть
от выбранной командной оболочки.

9.10. Осиротевшие группы процессов
Мы уже говорили, что процесс, родитель которого завершился, называется осиротевшим и наследуется процессом init. Теперь посмотрим, что произойдет, если
осиротеет вся группа процессов, и как стандарт POSIX.1 регламентирует эту ситуацию.

Пример
Рассмотрим процесс, который порождает дочерний процесс и завершает работу.
В этом нет ничего необычного (такое случается постоянно), тем не менее что произойдет, если дочерний процесс будет приостановлен (с помощью управления заданиями), а родительский в это время завершится? Как возобновить работу дочернего процесса и узнает ли он, что осиротел? Эта ситуация показана на рис. 9.10:
родительский процесс порождает дочерний, затем потомок приостанавливается,
а родительский процесс завершается.
Программа, создающая эту ситуацию, приводится в листинге 9.1. В ней имеется
ряд новых для нас особенностей. Мы подразумеваем, что она будет выполняться
под управлением командной оболочки, поддерживающей управление заданиями.
В предыдущем разделе уже говорилось, что командная оболочка помещает процесс переднего плана в его собственную группу (в данном примере — 6099), а сама

372    Глава 9. Взаимоотношения между процессами

Группа процессов 2837
Командная оболочка
входа (PID 2837)

fork/exec
Cеанс

Родитель (PID 6099)

fo

rk

Потомок (PID 6100)

Группа процессов 6099

Рис. 9.10. Пример осиротевшей группы процессов

остается в своей группе (2837). Дочерний процесс наследует группу процессов от
родителя (6099). Итак, после вызова функции fork:
 Родительский процесс приостанавливается на 5 секунд. Это наш (пусть и несовершенный) способ позволить дочернему процессу первым продолжить работу, прежде чем родительский завершится.
 Дочерний процесс устанавливает обработчик сигнала SIGHUP. Так мы сможем
узнать, посылается ли сигнал SIGHUP дочернему процессу. (Обработчики сигналов будут обсуждаться в главе 10.)
 Дочерний процесс с  помощью функции kill посылает самому себе сигнал
SIGTSTP. Благодаря этому дочерний процесс приостанавливается точно так же,
как приостанавливается задание переднего плана при вводе символа остановки (Control-Z).
 Когда родительский процесс завершается, дочерний становится «сиротой»
и обретает себе родителя в лице процесса init с идентификатором 1.
 С этого момента дочерний процесс становится членом осиротевшей группы процессов. Стандарт POSIX.1 определяет осиротевшую группу процессов как группу, в  которой родительский процесс любого члена группы либо сам является
членом группы, либо не является членом сеанса, которому принадлежит группа.
Другими словами, группа процессов не считается осиротевшей, пока в  группе
есть процесс, который имеет родителя в другой группе процессов, но в том же
сеансе. Если группа процессов не является осиротевшей, есть шанс, что один из
родительских процессов, расположенных в других группах процессов, но в том
же самом сеансе, перезапустит приостановленный дочерний процесс. В нашем
же случае родитель каждого процесса в  группе принадлежит другому сеансу
(так, для процесса 6100 родительским является процесс с идентификатором 1).
 Поскольку группа процессов оказывается осиротевшей, когда завершается
родительский процесс, каждому приостановленному процессу в  этой группе
(как наш дочерний процесс) посылается сигнал SIGHUP и вслед за ним сигнал
SIGCONT, как того требует стандарт POSIX.1.

9.10. Осиротевшие группы процессов   

373

 Это приводит к  тому, что дочерний процесс возобновляет работу после обработки сигнала SIGHUP. Реакция по умолчанию на этот сигнал — завершение
процесса, поэтому мы должны предусмотреть функцию-обработчик, чтобы
перехватить его. Соответственно мы предполагаем, что вызов функции printf
сначала будет произведен в функции sig_hup, а затем в функции pr_ids.
Листинг 9.1. Создание осиротевшей группы процессов
#include "apue.h"
#include <errno.h>
static void
sig_hup(int signo)
{
printf("принят сигнал SIGHUP, pid = %ld\n", (long)getpid());
}
static void
pr_ids(char *name)
{
printf("%s: pid = %ld, ppid = %ld, pgrp = %ld, tpgrp = %ld\n",
name, (long)getpid(), (long)getppid(), (long)getpgrp(),
(long)tcgetpgrp(STDIN_FILENO));
fflush(stdout);
}
int
main(void)
{
char c;
pid_t pid;
pr_ids("родитель");
if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid > 0) { /* родительский процесс */
sleep(5); /* приостановиться, чтобы дать потомку отработать первым */
} else { /* дочерний процесс */
pr_ids("потомок");
signal(SIGHUP, sig_hup); /* установить обработчик сигнала */
kill(getpid(), SIGTSTP); /* остановить самого себя */
pr_ids("потомок"); /* вывести данные, */
/* когда процесс будет возобновлен */
if (read(STDIN_FILENO, &c, 1) != 1)
printf("ошибка чтения из управляющего TTY, errno = %d\n",
errno);
}
exit(0);
}

Вот результаты работы программы из листинга 9.1:
$ ./a.out
родитель: pid = 6099, ppid = 2837, pgrp = 6099, tpgrp = 6099
потомок: pid = 6100, ppid = 6099, pgrp = 6099, tpgrp = 6099
$ принят сигнал SIGHUP, pid = 6100
потомок: pid = 6100, ppid = 1, pgrp = 6099, tpgrp = 2837
ошибка чтения из управляющего TTY, errno = 5

Обратите внимание, что среди строк, выводимых дочерним процессом, появилось
приглашение командной оболочки. Произошло это потому, что вывод на терми-

374    Глава 9. Взаимоотношения между процессами
нал осуществляют два процесса — командная оболочка и дочерний процесс. Как
мы и ожидали, родителем стал процесс с идентификатором 1.
После вызова функции pr_ids в дочернем процессе производится попытка чтения
со стандартного ввода. Как уже говорилось выше в этой главе, когда процесс из
группы фоновых процессов пытается читать из управляющего терминала, группе
передается сигнал SIGTTIN. Но здесь мы имеем дело с осиротевшей группой процессов; если ядро остановит этим сигналом процесс из такой группы, он, скорее
всего, никогда не будет возобновлен. Стандарт POSIX.1 требует, чтобы в  такой
ситуации функция read возвращала признак ошибки с  кодом EIO в  переменной
errno (в данной системе этот код имеет значение 5).
Наконец, обратите внимание, что дочерний процесс был помещен в  группу фоновых процессов, когда его родительский процесс завершился, так как родитель
выполнялся командной оболочкой как задание переднего плана.
В разделе 19.5 мы увидим другой пример осиротевших групп процессов, когда будем рассматривать программу pty.

9.11. Реализация в FreeBSD
Теперь, когда мы поговорили о различных атрибутах процесса, группах процессов,
сеансах и управляющих терминалах, настало время посмотреть, как все это может
быть реализовано. Мы коротко рассмотрим реализацию в  FreeBSD. Некоторые
подробности реализации в SVR4 вы сможете найти в [Williams, 1989]. На рис. 9.11
показаны различные структуры данных, используемые в FreeBSD.
Рассмотрим все показанные поля структур, начиная со структуры session. Для
каждого сеанса в  памяти размещается отдельная структура session (это происходит, например, при обращении к функции setsid).
 s_count — количество групп процессов в сеансе. Когда этот счетчик обнуляется, память, занимаемая структурой, освобождается.
 s_leader — указатель на структуру proc лидера сеанса.
 s_ttyvp — указатель на структуру vnode управляющего терминала.
 s_ttyp — указатель на структуру tty управляющего терминала.
 s_sid — идентификатор сеанса. Помните, что понятие идентификатора сеанса
не определяется стандартом Single UNIX Specification.
Во время вызова функции setsid в  памяти ядра размещается новая структура
session. Значение поля s_count устанавливается равным 1, в поле s_leader заносится указатель на структуру proc вызывающего процесса, в поле s_sid заносится
идентификатор процесса и в поля s_ttyvp и s_ttyp — пустые указатели, поскольку
новый сеанс не имеет управляющего терминала.
Теперь перейдем к  структуре tty. Для каждого устройства терминала или псевдотерминала в памяти ядра размещается одна такая структура. (Более подробно
о псевдотерминалах мы поговорим в главе 19.)
 t_session — указатель на структуру session, для которой этот терминал является управляющим. (Обратите внимание, что структура tty содержит указа-

9.11. Реализация в FreeBSD   

375

Структура session
Структура tty

s_count
s_leader
s_ttyvp
s_ttyp

t_session
t_pgrp
t_termios

гру
п
пер па пр
о
ед
нег цесс
о
оп
ла в
на

Cтруктура vnode

s_sid
Структура pgrp

v_data

t_winsize
pg_id
cвязанный список членов
группы процессов
Структура proc

pg_session
pg_members
Структура proc

Структура proc

p_pglist

p_pglist

p_pglist

p_pid

p_pid

p_pid

p_pptr

p_pptr

p_pptr

p_pgrp

p_pgrp

p_pgrp

Рис. 9.11. Реализация сеансов и групп процессов в FreeBSD

тель на структуру session, а не наоборот.) Этот указатель используется терминалом для передачи сигнала SIGHUP лидеру сеанса, когда система теряет связь
с терминалом (см. рис. 9.7).
 t_pgrp — указатель на структуру pgrp группы процессов переднего плана. Он
используется терминалом для передачи сигналов группе процессов переднего
плана. Это те самые три сигнала, которые генерируются в результате ввода специальных символов (сигнал прерывания, завершения и остановки).
 t_termios — структура, которая содержит все специальные символы и дополнительную информацию о  данном терминале, такую как скорость передачи
данных, отображение вводимых символов (включено или выключено) и т. п.
Мы еще вернемся к этой структуре в главе 18.
 t_winsize — структура winsize, которая содержит текущие размеры окна терминала. При изменении размеров окна терминала группе процессов переднего плана передается сигнал SIGWINCH. В разделе 18.12 мы покажем, как узнать
и изменить размеры окна терминала.

376    Глава 9. Взаимоотношения между процессами
Поиск группы процессов переднего плана для заданного сеанса ядро начинает
со структуры session. Следуя по указателю s_ttyp, ядро находит структуру tty
управляющего терминала, а затем по указателю t_pgrp отыскивает структуру pgrp
группы процессов переднего плана. Структура pgrp содержит все необходимые
сведения о заданной группе процессов переднего плана.
 pg_id — идентификатор группы процессов.
 pg_session — указатель на структуру session для сеанса, которому принадлежит данная группа процессов.
 pg_members — указатель на список структур proc, соответствующих процессам,
входящим в состав данной группы. Структура p_pglist, входящая в структуру
proc, содержит два поля — указатели на предыдущую и следующую структуры proc — для организации двусвязного списка процессов в группе. Структура
proc содержит всю информацию о процессе.
 p_pid — идентификатор процесса.
 p_pptr — указатель на структуру proc родительского процесса.
 p_pgrp — указатель на структуру pgrp группы, которой принадлежит процесс.
 p_pglist — структура, которая содержит указатели на предыдущий и следующий процессы в группе.
И наконец, структура vnode. Эта структура размещается в памяти в момент открытия устройства управляющего терминала. Все обращения к устройству /dev/tty
из процесса проходят через структуру vnode.

9.12. Подведение итогов
В этой главе были описаны взаимоотношения между группами процессов — сеансы, которые состоят из групп процессов. Управление заданиями в  настоящее
время поддерживается большинством версий UNIX, и мы показали, как оно осуществляется в командной оболочке, которая поддерживает эту функциональную
возможность. Понятие управляющего терминала также связано со взаимоотношениями между процессами.
Мы много раз упоминали сигналы, которые широко используются для организации взаимодействий между процессами. В следующей главе обсуждение сигналов
будет продолжено и мы подробно рассмотрим все сигналы системы UNIX.

Упражнения
9.1	

Вспомните обсуждение файлов utmp и  wtmp в разделе 6.8 и ответьте на вопрос: почему запись о  выходе из системы производится процессом init?
Происходит ли то же самое в  случае завершения сеанса, открытого через
сетевое соединение?

9.2	

Напишите программу, которая с помощью функции fork порождает дочерний
процесс, создающий, в свою очередь, новый сеанс. Проверьте, становится ли
дочерний процесс лидером группы и теряет ли он управляющий терминал.

10

Сигналы

10.1. Введение
Сигналы — это программные прерывания. Большинство серьезных приложений
опираются на работу с  сигналами. Сигналы дают возможность обработки асинхронных событий  — например, когда пользователь вводит символ прерывания,
чтобы остановить программу, или когда одна из программ в конвейере завершается аварийно.
Сигналы появились в самых ранних версиях UNIX, но модель сигналов, которую
предоставляли такие системы, как Version 7, была недостаточно надежна. Сигналы
могли теряться, и процессу было довольно сложно отключить отдельные сигналы
на время выполнения критических фрагментов кода. Существенные изменения
в модель сигналов внесли 4.3BSD и SVR3, в этих версиях были добавлены так называемые надежные сигналы. Но изменения, сделанные в Беркли и в AT&T, оказались несовместимы между собой. К счастью, POSIX.1 стандартизировал функции
обслуживания надежных сигналов, и именно их мы обсудим.
Эта глава начинается с  краткого обзора, где описывается назначение каждого
сигнала. Затем мы рассмотрим проблемы, имевшие место в ранних реализациях.
Чтобы разобраться во всех тонкостях, иногда очень важно понять, какие проблемы были связаны с реализацией. В этой главе приводится большое количество
примеров, которые не совсем корректны, и обсуждаются имеющиеся в них недочеты.

10.2. Концепция сигналов
Прежде всего, каждый сигнал имеет собственное имя. Имена всех сигналов начинаются с  последовательности SIG. Например, SIGABRT  — это сигнал прерывания, который генерируется, когда процесс вызывает функцию abort. Сигнал
SIGALRM генерируется, когда таймер, установленный функцией alarm, отмерит
указанный промежуток времени. В Version 7 было 15 различных сигналов, в SVR4
и 4.4BSD — уже 31 сигнал. FreeBSD 8.0 поддерживает 32 разных сигнала, Mac OC
X 10.6.8 и Linux 3.2.0 — 31 сигнал, а Solaris 10 — 40 различных сигналов. Кроме
того, FreeBSD, Linux и  Solaris поддерживают дополнительные сигналы, определяемые приложениями в  виде расширений реального времени (расширения ре-

378    Глава 10. Сигналы
ального времени POSIX не рассматриваются в данной книге, поэтому за дополнительной информацией обращайтесь к [Gallmeister, 1995]).
Все имена сигналов определены как константы с  положительными числовыми
значениями (номерами сигналов) в заголовочном файле <signal.h>.
Фактически реализации определяют сигналы в отдельных заголовочных файлах, которые
подключаются файлом <signal.h>. Вообще, считается дурным тоном в исходных текстах
ядра подключать заголовочные файлы, предназначенные для приложений пользовательского уровня. Поэтому если и приложение и ядро нуждаются в одних и тех же определениях,
информация размещается в  заголовочном файле ядра, который затем подключается
в заголовочном файле пользовательского уровня. Так, FreeBSD 8.0 и Mac OS X 10.6.8 определяют сигналы в файле <sys/signal.h>. Linux 3.2.0 определяет сигналы в файле <bits/
signum.h>, а Solaris 10 — в файле <sys/iso/signal_iso.h>.

Сигнала с номером 0 не существует. В разделе 10.9 мы увидим, что функция kill
использует номер сигнала 0 в особых случаях. Стандарт POSIX.1 называет такой
сигнал null signal (пустой сигнал).
Сигналы могут порождаться различными условиями.
 Сигналы, генерируемые терминалом, возникают, когда пользователь вводит
определенные символы. Нажатие клавиши DELETE (или Control-C — в большинстве систем) порождает сигнал прерывания (SIGINT). Таким способом можно
прервать выполнение программы, вышедшей из-под контроля. (В главе 18 мы
увидим, что этот сигнал можно привязать к любой клавише на клавиатуре.)
 Аппаратные ошибки — деление на 0, ошибка доступа к памяти и прочее — также приводят к генерации сигналов. Эти ошибки обычно обнаруживаются аппаратным обеспечением, которое извещает ядро об их появлении. После этого
ядро генерирует соответствующий сигнал и  передает его процессу, который
выполнялся в момент появления ошибки. Например, сигнал SIGSEGV посылается процессу при попытке обратиться к неверному адресу в памяти.
 Функция kill(2) позволяет процессу передать любой сигнал другому процессу или группе процессов. Естественно, здесь существуют свои ограничения:
необходимо быть владельцем процесса, которому посылается сигнал, или обладать привилегиями суперпользователя.
 Команда kill(1) позволяет передавать сигналы другим процессам. Эта программа является простым интерфейсом к функции kill. Зачастую эта команда
используется для принудительного завершения вышедших из-под контроля
фоновых процессов.
 Сигналы могут порождаться при условиях, определяемых программно, например, когда нужно известить приложение о  наступлении некоторого события. Эти условия определяются не аппаратурой (как, например, деление
на 0), а программным обеспечением. Примерами таких сигналов могут служить SIGURG (посылается, когда через сетевое соединение приходят экстренные (out-of-band) данные), SIGPIPE (посылается пишущему процессу, когда
он пытается записать данные в канал после завершения процесса, читающего
из канала) и SIGALRM (посылается процессу по истечении установленного им
таймера).

10.2. Концепция сигналов   

379

Сигналы являют собой классический пример асинхронных событий. Сигнал может быть передан процессу в любой момент. Чтобы выяснить причину, породившую сигнал, процесс не может просто проверить некоторую переменную (как, например, errno), вместо этого он должен обратиться к ядру с предложением: «если
появится этот сигнал — сделай то-то и то-то».
В случае появления сигнала можно запросить ядро произвести одно из трех действий. Они называются диспозициями сигнала, или действиями, связанными
с сигналом.
1.	 Игнорировать сигнал. Это действие возможно для большинства сигналов, но
два сигнала, SIGKILL и SIGSTOP, нельзя игнорировать. Причина, почему эти два
сигнала не могут быть проигнорированы, заключается в том, что ядру и суперпользователю необходима возможность завершить или остановить любой процесс. Кроме того, если проигнорировать некоторые из сигналов, возникающих
в результате аппаратных ошибок (таких, как деление на 0 или попытка обращения к  несуществующей памяти), поведение процесса может стать непредсказуемым.
2.	 Перехватить сигнал. Для этого нужно сообщить ядру адрес функции, которая
будет обрабатывать сигнал. В этой функции можно предусмотреть действия по
обработке условия, породившего сигнал. Например, создавая командный интерпретатор, можно предусмотреть в нем прерывание выполняемой команды,
запущенной пользователем, и  возврат к  главному циклу, когда пользователь
пошлет сигнал прерывания. Если пойман сигнал SIGCHLD, который означает
завершение дочернего процесса, функция, перехватившая сигнал, может вызвать функцию waitpid, чтобы получить идентификатор дочернего процесса и  код его завершения. Еще один пример: если процесс создает временные
файлы, имеет смысл написать функцию обработки сигнала SIGTERM (сигнал
завершения, посылаемый командой kill по умолчанию), которая будет удалять временные файлы. Имейте в виду, что сигналы SIGKILL и  SIGSTOP нельзя
перехватить.
3.	 Применить действие по умолчанию. Каждому сигналу поставлено в соответствие некоторое действие по умолчанию (перечислены в табл. 10.1). Заметьте,
что для большинства сигналов действие по умолчанию заключается в завершении процесса.
В табл. 10.1 перечислены имена всех сигналов и указано, какими системами они
поддерживаются и  каково действие по умолчанию для каждого сигнала. Если
в колонке SUS (Single UNIX Specification) стоит галочка, значит, сигнал определен как часть базовой спецификации POSIX.1, а если указана аббревиатура XSI —
сигнал определен как расширение XSI.
Если в  колонке «Действие по умолчанию» указано «завершить + core», это означает, что образ памяти процесса сохраняется в файле core в текущем рабочем
каталоге процесса. (Имя файла core наглядно демонстрирует, как давно эта функциональная особенность появилась в UNIX.) Большинство отладчиков могут использовать этот файл для выяснения причин, породивших преждевременное завершение процесса.

380    Глава 10. Сигналы
Таблица 10.1. Сигналы UNIX
Имя

Описание

SIGABRT

Аварийное завершение (abort)

SIGALRM

ISO C SUS

FreeBSD Linux Mac OS X Solaris
8.0
3.2.0
10.6.8
10

Действие
по умолчанию











Завершить +
core

Истекло время
таймера (alarm)











Завершить

SIGBUS

Аппаратная
ошибка











Завершить +
core

SIGCANCEL

Для внутреннего
использования
библиотекой



Игнорировать

SIGCHLD

Изменение состояния дочернего
процесса











Игнорировать

SIGCONT

Возобновить работу приостановленного процесса











Продолжить/
игнорировать

SIGEMT

Аппаратная
ошибка









Завершить +
core

SIGFPE

Арифметическая
ошибка









Завершить +
core

SIGFREEZE

Закрепление контрольной точки



Игнорировать

SIGHUP

Обрыв связи

SIGILL

Недопустимая
инструкция

SIGINFO

Запрос состояния
с клавиатуры

SIGINT

С терминала
введен символ
прерывания

SIGIO

Асинхронный
ввод/вывод



threads

















Завершить











Завершить +
core






Игнорировать











Завершить









Завершить/
игнорировать

10.2. Концепция сигналов   

Имя

Описание

SIGIOT

Аппаратная
ошибка

SIGJVM1

ISO C SUS

FreeBSD Linux Mac OS X Solaris
8.0
3.2.0
10.6.8
10

381

Действие
по умолчанию



Завершить +
core

Для внутреннего
использования
виртуальной
машиной Java



Игнорировать

SIGJVM2

Для внутреннего
использования
виртуальной
машиной Java



Игнорировать

SIGKILL

Завершение



Завершить

SIGLOST

Ресурс потерян



Завершить

SIGLWP

Для внутреннего
использования
библиотекой



Завершить/
игнорировать



Завершить



Завершить



Завершить



Завершить/
игнорировать

















threads
SIGPIPE

Запись в канал, из
которого никто не
читает

SIGPOLL

Событие опроса
(poll)

SIGPROF

Истекло время
профилирующего таймера
(setitimer)

SIGPWR

Падение напряжения питания/
перезапуск

SIGQUIT

С терминала
введен символ
завершения

SIGSEGV

Ошибка доступа
к памяти

SIGSTKFLT

Ошибка, связанная со стеком
сопроцессора






























Завершить +
core











Завершить +
core



Завершить

382    Глава 10. Сигналы
Таблица 10.1 (продолжение)
Имя

Описание

SIGSTOP

Приостановить
процесс

SIGSYS

Неверный системный вызов

SIGTERM

Завершение

SIGTHAW

Освобождение
контрольной
точки

SIGTHR

Для внутреннего
использования
библиотекой

ISO C SUS



FreeBSD Linux Mac OS X Solaris
8.0
3.2.0
10.6.8
10

Действие
по умолчанию











Остановить
процесс

XSI









Завершить +
core











Завершить



Игнорировать
Завершить



threads
SIGTRAP

Аппаратная
ошибка

SIGTSTP

XSI









Завершить +
core

С терминала
введен символ
приостановки











Остановить
процесс

SIGTTIN

Чтение из управляющего терминала фоновым
процессом











Остановить
процесс

SIGTTOU

Запись в управляющий терминал
фоновым процессом











Остановить
процесс

SIGURG

Экстренное событие (сокеты)











Игнорировать

SIGUSR1

Определяемый
пользователем
сигнал











Завершить

SIGUSR2

Определяемый
пользователем
сигнал











Завершить

SIGVTALRM

Истекло время
виртуального таймера (setitimer)

XSI









Завершить

10.2. Концепция сигналов   

Имя

Описание

ISO C SUS

FreeBSD Linux Mac OS X Solaris
8.0
3.2.0
10.6.8
10

SIGWAITING Для внутреннего

383

Действие
по умолчанию



Игнорировать

использования
библиотекой
threads
SIGWINCH

Изменение размеров окна терминала

SIGXCPU

Исчерпан лимит
процессорного времени
(setrlimit)

SIGXFSZ

Превышено
ограничение на
размер файла
(setrlimit)

SIGXRES

Превышено
ограничение на
использование
ресурса









Игнорировать

XSI









Завершить/завершить +
core

XSI









Завершить/завершить +
core



Завершить
+ core/
игнорировать

Возможность создания файла core — функциональная особенность, присущая большинству
версий UNIX. Хотя она и не является частью POSIX.1, тем не менее она упоминается
в  расширении XSI стандарта Single UNIX Specification как возможное, зависящее от
реализации действие.
Имя core-файла варьируется в разных реализациях. В FreeBSD 8.0, например, core-файл
получает имя cmdname.core, где cmdname — имя команды, соответствующей процессу,
получившему сигнал. В Mac OS X 10.6.8 файл core получает имя core.pid, где pid — идентификатор процесса, получившего сигнал. (Эти системы позволяют настроить правила
именования файлов core через параметр sysctl. В Linux 3.2.0 имя настраивается через
файл /proc/sys/kernel/core_pattern.)
Большинство реализаций сохраняют файл core в текущем рабочем каталоге соответствующего процесса, но Mac OS X помещает все файлы core в каталог /cores.

Файл core не создается, если (а) файл программы имеет установленный бит
set-user-ID, а текущий пользователь не является его владельцем; (б) файл программы имеет установленный бит set-group-ID, а текущий пользователь не принадлежит к группе владельца файла; (в) пользователь не имеет права на запись
в текущий каталог; (г) файл уже существует и пользователь не имеет права на
запись в него; (д) файл слишком велик (вспомните предел RLIMIT_CORE из раздела 7.11). Файл core (если он еще не существует) обычно создается с правами
на запись и на чтение для владельца, хотя в Mac OS X выдается только право на
чтение для владельца.

384    Глава 10. Сигналы
В табл. 10.1 сигналы с описанием «аппаратная ошибка» соответствуют зависящим от реализации аппаратным ошибкам. Многие из них взяты из оригинальной реализации UNIX для PDP-11. Проверьте справочное руководство по вашей
операционной системе и  уточните, каким именно ошибкам соответствуют эти
сигналы.
А теперь опишем каждый сигнал подробнее.
SIGABRT Генерируется вызовом функции abort (раздел 10.17). Процесс завершается аварийно.
SIGALRM
Генерируется по истечении таймера, установленного функцией alarm
(раздел 10.10). Также генерируется по истечении таймера, установленного функцией setitimer(2).
SIGBUS Соответствует аппаратной ошибке, определяемой реализацией. Обычно
этот сигнал генерируется в случае некоторых ошибок, связанных с памятью, которые мы рассмотрим в разделе 14.8.
SIGCANCEL
Используется библиотекой threads в  Solaris. Не предназначен для
общего использования.
SIGCHLD
Когда процесс завершается или останавливается, родительскому процессу посылается сигнал SIGCHLD. По умолчанию этот сигнал игнорируется, но
родительский процесс может перехватить его, если желает получать извещения
об изменении состояния дочерних процессов. Функция, перехватывающая этот
сигнал, обычно вызывает одну из функций семейства wait, чтобы получить идентификатор дочернего процесса и код завершения.
В ранних версиях System V имелся похожий сигнал с именем SIGCLD (без H). Семантика этого сигнала отличалась от семантики других сигналов, и еще справочное руководство SVR2 рекомендовало не использовать его в новых программах.
(Как ни странно, в SVR3 и SVR4 из справочного руководства это предупреждение
исчезло.) Приложения должны использовать сигнал SIGCHLD, но нужно знать, что
многие версии UNIX определяют сигнал SIGCLD, идентичный сигналу SIGCHLD, для
сохранения обратной совместимости. Если вам понадобится определить семантику сигнала SIGCLD в своей системе, обратитесь к страницам справочного руководства. Эти два сигнала мы обсудим в разделе 10.7.
SIGCONT
Посылается остановленным процессам, чтобы возобновить их работу.
Действие по умолчанию заключается в  продолжении работы процесса, если он
был остановлен, — для работающего процесса сигнал игнорируется. Полноэкранный редактор, например, может перехватывать этот сигнал, чтобы использовать
функцию-обработчик для перерисовки экрана. Дополнительная информация об
этом сигнале приводится в разделе 10.21.
SIGEMT Соответствует аппаратной ошибке, определяемой реализацией. Имя EMT
происходит от инструкции PDP11 — «emulator trap» (ловушка эмулятора). Этот
сигнал поддерживается не всеми платформами. В  Linux, например, этот сигнал
поддерживается только для некоторых аппаратных архитектур, таких как SPARC,
MIPS и PARISC.
SIGFPE Свидетельствует об арифметической ошибке, такой как деление на 0 или
переполнение числа с плавающей точкой.

10.2. Концепция сигналов   

385

Определен только в Solaris. Используется для извещения процессов,
которые должны предпринять дополнительные действия перед фиксацией состояния системы, что обычно происходит, когда система уходит в спящий или в ждущий режим.
SIGHUP Посылается управляющему процессу (лидеру сеанса), связанному с управляющим терминалом, если обнаружен обрыв связи с  терминалом. На рис.  9.11
видно, что сигнал посылается процессу, на который указывает поле s_leader
в структуре session. Этот сигнал генерируется, только если сброшен флаг терминала CLOCAL. (Флаг CLOCAL устанавливается для локального терминала. Этот флаг
сообщает драйверу, что он должен игнорировать все управляющие сигналы модема. В главе 18 мы расскажем, как устанавливается этот флаг.)
Обратите внимание, что лидер сеанса, которому передается сигнал, может быть
фоновым процессом (см. рис. 9.7). Это отличает данный сигнал от других сигналов, генерируемых терминалом (прерывание, завершение и останов), которые
всегда посылаются группе процессов переднего плана.
Этот сигнал также генерируется в случае завершения лидера сеанса. В такой ситуации сигнал посылается всем процессам из группы процессов переднего плана.
Нередко этот сигнал используется для извещения процессов-демонов (глава 13)
о необходимости перечитать конфигурационные файлы. Причина, по которой для
этой цели выбирается именно сигнал SIGHUP, заключается в том, что если не послать этот сигнал явно, демоны никогда не примут его, поскольку у них нет управляющего терминала.
SIGILL
Указывает, что процесс выполнил недопустимую машинную инструкцию. В 4.3BSD этот сигнал генерировался функцией abort. Теперь она генерирует
сигнал SIGABRT.
SIGINFO Этот BSD-сигнал генерируется драйвером терминала при нажатии клавиши запроса состояния (часто — Control-T). Посылается всем процессам из группы процессов переднего плана (см. рис. 9.8). Обычно этот сигнал используется для
вывода информации о состоянии процессов в группе процессов переднего плана.
SIGFREEZE

Linux не поддерживает сигнал SIGINFO, за исключением платформы Alpha, где он определен
с тем же номером, что и сигнал SIGPWR. Эта поддержка была добавлена для совместимости
с программным обеспечением, разработанным для OSF/1.

Генерируется драйвером терминала при нажатии клавиши прерывания
(часто — DELETE или Control-C). Посылается всем процессам из группы процессов
переднего плана (см. рис. 9.8). Этот сигнал часто используется для прерывания
выполнения приложений, вышедших из-под контроля, особенно когда они начинают выводить ненужную информацию на экран.
SIGIO Указывает на событие асинхронной операции ввода/вывода. Мы обсудим
его в разделе 14.6.2.
SIGINT

В табл. 10.1 указано, что действие по умолчанию для сигнала SIGIO — завершить процесс
либо игнорировать. К сожалению, выбор действия по умолчанию зависит от реализации.
В System V сигнал SIGIO идентичен сигналу SIGPOLL, поэтому по умолчанию он завершает
процесс. В BSD этот сигнал по умолчанию игнорируется.

386    Глава 10. Сигналы
Linux 3.2.0 и Solaris 10 определяют сигнал SIGIO с тем же номером, что и  SIGPOLL, поэтому по умолчанию он завершает процесс. FreeBSD 8.0 и Mac OS X 10.6.8 по умолчанию
игнорируют этот сигнал.
SIGIOT

Соответствует аппаратной ошибке, определяемой реализацией.

Имя IOT происходит от мнемоники инструкции PDP11 — «input/output TRAP» (ловушка
ввода/вывода). В  ранних версиях System V этот сигнал генерировался функцией abort.
Теперь она генерирует сигнал SIGABRT.
В FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 и Solaris 10 сигнал SIGIOT определен с тем же
номером, что и сигнал SIGABRT.

Сигнал, зарезервированный в Solaris для использования виртуальной
машиной Java.
SIGJVM2 Еще один сигнал, зарезервированный в Solaris для использования виртуальной машиной Java.
SIGKILL Один из двух сигналов, которые нельзя перехватить или игнорировать
в  приложении. Дает возможность системному администратору уничтожить любой процесс.
SIGLOST Применяется в Solaris для извещения клиентов NFSv4 (сетевой файловой системы) об ошибке повторного приобретения блокировки при попытке восстановления.
SIGLWP Используется библиотекой threads в Solaris и недоступен для общего использования. В FreeBSD сигнал SIGLWP определен как псевдоним сигнала SIGTHR.
SIGPIPE  Посылается процессу, который предпринял попытку записи в  канал,
когда процесс, производивший чтение из канала, уже завершился. Мы обсудим
каналы в разделе 15.2. Этот сигнал также генерируется при попытке выполнить
запись в сокет типа SOCK_STREAM, когда соединение уже разорвано. Сокеты обсуждаются в главе 16.
SIGPOLL Отмечен как устаревший в SUSv4 и может быть удален в следующих
версиях стандарта. Может генерироваться при наступлении определенного события в опрашиваемом устройстве. Мы рассмотрим этот сигнал при обсуждении
функции poll в  разделе 14.4.2. Сигнал SIGPOLL появился в  SVR3 и  в  некоторой
степени соответствует сигналам SIGIO и SIGURG в BSD.
SIGJVM1

В Linux и Solaris сигнал SIGPOLL определен с тем же номером, что и сигнал SIGIO.

Отмечен как устаревший в SUSv4 и может быть удален в следующих
версиях стандарта. Генерируется по истечении интервала времени профилирующего таймера, установленного функцией setitimer(2).
SIGPWR Реализация этого сигнала зависит от системы. В основном он используется в системах, снабженных источником бесперебойного питания (UPS). Обнаружив сбой в  электросети, источник бесперебойного питания извещает об этом
систему и принимает на себя обеспечение питания системы. Пока ничего более не
предпринимается, так как система продолжает питаться от аккумуляторных батарей. Но когда напряжение в сети отсутствует продолжительное время и напряжение аккумуляторов падает ниже определенного уровня, программное обеспечение
SIGPROF

10.2. Концепция сигналов   

387

обычно извещается об этом повторно, и с этого момента у системы остается примерно 15–30 секунд, чтобы корректно завершить работу. В этот момент посылается сигнал SIGPWR. В большинстве систем имеется процесс, который получает извещение о падении напряжения аккумуляторов и посылает сигнал SIGPWR процессу
init, а init берет на себя заботу об остановке системы.
Для этих целей в  Solaris 10 и  в  некоторых дистрибутивах Linux предусматриваются
специальные записи в inittab: powerfail и powerwait (или powerokwait).
В табл. 10.1 указано, что по умолчанию сигнал SIGPWR завершает процесс или игнорируется.
К сожалению, действие по умолчанию зависит от реализации. В Linux по умолчанию этот
сигнал завершает процесс, в Solaris — игнорируется.
SIGQUIT Генерируется драйвером терминала при вводе символа завершения (часто Control-\). Посылается всем процессам из группы процессов переднего плана

(см. рис. 9.8). При этом происходит не только завершение группы процессов переднего плана (как в случае сигнала SIGINT), но и создание файла core.
SIGSEGV Показывает, что процесс обратился к недопустимому адресу в памяти
(что обычно служит признаком ошибки в  программе, такой как разыменование
пустого указателя).
Имя SEGV происходит от фразы «segmentation violation» (нарушение правил сегментации).

Определен только в Linux. Появился в самых ранних версиях Linux
и предназначался для обнаружения ошибок, связанных со стеком арифметического сопроцессора. Этот сигнал не генерируется ядром, но остается для сохранения
обратной совместимости.
SIGSTOP Останавливает процесс. Похож на сигнал SIGTSTP, порождаемый драйвером терминала, но в отличие от него SIGSTOP нельзя перехватить или игнорировать.
SIGSYS Свидетельствует о неверном системном вызове. Каким-то образом процесс выполнил машинную инструкцию, которая была воспринята ядром как системный вызов, но параметр инструкции указывал на неверный тип системного
вызова. Это может произойти, если скомпилировать программу, использующую
недавно появившийся системный вызов, и  попытаться запустить двоичный выполняемый файл в более старой версии системы, которая этот системный вызов
не поддерживает.
SIGTERM Сигнал завершения процесса, который посылается командой kill(1) по
умолчанию. Так как его можно перехватить, обработка сигнала SIGTERM дает программам возможность корректно завершить работу, освободив занятые ресурсы
(в противоположность сигналу SIGKILL, который нельзя перехватить или игнорировать).
SIGTHAW
Определен только в  Solaris и  используется для извещения процессов
о том, что они должны предпринять определенные действия после выхода системы из ждущего или спящего режима.
SIGTHR Используется библиотекой threads в FreeBSD. Определен с тем же номером, что и сигнал SIGLWP.
SIGTRAP Соответствует аппаратной ошибке, определяемой реализацией.
SIGSTKFLT

388    Глава 10. Сигналы
Имя сигнала произошло от инструкции PDP11  — TRAP (ловушка). Реализации часто
используют его для передачи управления отладчикам по достижении точки останова.

Этот сигнал приостановки генерируется драйвером терминала при вводе символа приостановки (часто Control-Z). Посылается всем процессам из группы
процессов переднего плана (рис. 9.8).
SIGTSTP

К сожалению, термин «приостановка» может иметь несколько смыслов. Когда обсуждалась возможность управления заданиями, мы говорили о приостановке и возобновлении
работы. Однако если речь идет о драйвере терминала, для обозначения остановки и возобновления вывода на терминал с помощью клавиш Control-S и Control-Q традиционно
используется термин «останов». Таким образом, в случае драйвера терминала символ,
который приводит к генерации сигнала SIGTSTP, называется символом приостановки,
а не останова.

Генерируется драйвером терминала, когда фоновый процесс пытается
выполнить операцию чтения из управляющего терминала (раздел 9.8). В особых
случаях  — если (а) процесс, выполняющий чтение, игнорирует или блокирует
этот сигнал или (б) группа процессов, в  которой находится читающий процесс,
является осиротевшей, — сигнал не генерируется; вместо этого операция чтения
завершается с признаком ошибки и в переменную errno записывается код EIO.
SIGTTOU Генерируется драйвером терминала, когда фоновый процесс пытается
выполнить запись в управляющий терминал (раздел 9.8). В отличие от только что
описанного сигнала SIGTTIN, в данном случае процесс может разрешить фоновым
процессам запись в  управляющий терминал. Эту возможность мы рассмотрим
в главе 18.
Если запись в терминал для фоновых процессов запрещена, то, как и в случае сигнала SIGTTIN, возможны два особых случая: когда (а) пишущий процесс игнорирует или блокирует этот сигнал или (б) группа пишущего процесса является осиротевшей. В этих случаях сигнал не генерируется, а в случае (б) операция записи
завершается с признаком ошибки и в переменную errno записывается код EIO.
Независимо от того, разрешено ли фоновому процессу выполнять запись в терминал, некоторые другие операции с терминалом также могут генерировать сигнал
SIGTTOU: tcsetattr, tcsendbreak, tcdrain, tcflush, tcflow и  tcsetpgrp. Эти операции рассматриваются в главе 18.
SIGTTIN

Cообщает процессу, что произошло экстренное событие. Может генерироваться при поступлении экстренных (out-of-band) данных через сетевое соединение.
SIGURG

Определяется пользователем и предназначен для внутреннего использования в приложениях.
SIGUSR1

SIGUSR2   Еще один сигнал, определяемый пользователем. Подобно сигналу SIGUSR1, также предназначен для внутреннего применения в приложениях.

Генерируется по истечении периода времени, назначенного виртуальному таймеру функцией setitimer(2).
SIGVTALRM

SIGWAITING

в Solaris.

Предназначен для внутреннего использования в библиотеке threads

10.3. Функция signal   

389

SIGWINCH Ядро управляет изменением размера окна, связанного с каждым терми-

налом или псевдотерминалом. Процесс может получить и изменить размер окна
с помощью функции ioctl, которую мы рассмотрим в разделе 18.12. Если процесс
изменяет размер окна с помощью команды set-window-size функции ioctl, ядро
посылает сигнал SIGWINCH группе процессов переднего плана.
SIGXCPU Стандарт Single UNIX Specification поддерживает как расширение XSI
идею ограничений ресурсов (раздел 7.11). Если процесс достигает мягкого предела на использование центрального процессора, ему посылается сигнал SIGXCPU.
В табл. 10.1 указано, что по умолчанию сигнал SIGXCPU завершает процесс или завершает
с  созданием файла core. Действие по умолчанию зависит от реализации. В  Linux 3.2.0
и Solaris 10 по умолчанию этот сигнал завершает процесс и создает файл core, тогда как
в FreeBSD 8.0 и Mac OS X 10.6.8 он завершает процесс без создания файла core. Стандарт
Single UNIX Specification требует, чтобы по умолчанию происходило аварийное завершение
процесса. Создавать ли при этом файл core, каждая из реализаций может определять
самостоятельно.

Посылается процессу, который превысил мягкий предел на размер файла (раздел 7.11).
SIGXFSZ

Так же как в случае с сигналом SIGXCPU, действие по умолчанию зависит от операционной
системы. В Linux 3.2.0 и Solaris 10 по умолчанию процесс завершается с созданием файла
core, тогда как в FreeBSD 8.0 и Mac OS X 10.6.8 процесс завершается без создания файла
core. Стандарт Single UNIX Specification требует, чтобы по умолчанию происходило
аварийное завершение процесса. Создавать ли при этом файл core, каждая из реализаций
может определять самостоятельно.

Определен только в Solaris. Может применяться для извещения процессов о  превышении предустановленного ограничения на использование ресурса.
Механизм управления ресурсами в Solaris дает возможность управлять ресурсами, разделяемыми между несколькими независимыми приложениями.
SIGXRES

10.3. Функция signal
Функция signal — это простейший интерфейс к сигналам UNIX.
#include <signal.h>
void (*signal(int signo, void (*func)(int)))(int);

Возвращает предыдущую диспозицию сигнала (см. далее) в случае
успеха, SIG_ERR — в случае ошибки
Функция signal определена стандартом ISO C, который ничего не говорит о многозадачности, группах процессов, терминальном вводе/выводе и т. п. Поэтому определение
сигналов в этом стандарте практически бесполезно для систем UNIX.
Реализации, происходящие от System V, поддерживают функцию signal, но она предоставляет устаревшую семантику механизма ненадежных сигналов (которая описана

390    Глава 10. Сигналы
в разделе 10.4). Эта функция обеспечивает обратную совместимость с приложениями,
требующими устаревшей семантики. Новые приложения не должны использовать ненадежные сигналы.
4.4BSD также поддерживает функцию signal, но она реализована в терминах функции
sigaction (которая описана в разделе 10.14), то есть функция signal в 4.4BSD предоставляет новую семантику надежных сигналов. Большинство современных систем следуют
этой стратегии, но Solaris 10 следует семантике, принятой в System V.
Поскольку семантика функции signal различается в  разных реализациях, вместо нее
следует использовать функцию sigaction. В разделе 10.14 мы представим реализацию
функции signal на основе sigaction. Все примеры в этой книге используют функцию signal
из листинга 10.12, обеспечивающую единство семантики работы с сигналами независимо
от конкретной платформы.

Аргумент signo — это имя сигнала из табл. 10.1. В качестве аргумента func можно
передать (а) константу SIG_IGN, или (б) константу SIG_DFL, или (в) адрес функции, которая будет вызвана при получении сигнала. Константа SIG_IGN сообщает системе, что сигнал должен игнорироваться. (Не забывайте, что два сигнала,
SIGKILL и  SIGSTOP, не могут игнорироваться.) Если указана константа SIG_DFL,
с сигналом связывается действие по умолчанию (последняя колонка в табл. 10.1).
Если указан адрес функции, она будет вызываться при получении сигнала, то есть
будет «перехватывать» сигнал. Такие функции называются обработчиками или
перехватчиками сигналов.
Прототип функции signal показывает, что она принимает два аргумента и  возвращает указатель на функцию, которая не имеет возвращаемого значения (void).
Первый аргумент функции signal, signo, представляет собой целое число. Второй
аргумент — указатель на функцию, которая не возвращает значение и принимает единственный целочисленный аргумент. Функция, адрес которой возвращает
функция signal, также принимает один целочисленный аргумент (последний
(int)). Проще говоря, функции — обработчику сигнала передается единственный
аргумент (целое число — номер сигнала), и она ничего не возвращает. Когда функция signal вызывается, чтобы установить обработчик сигнала, второй аргумент
должен быть указателем на функцию. Возвращаемое значение функции signal —
указатель на предыдущий обработчик сигнала.
Большинство систем вызывают обработчик сигнала с дополнительными, зависящими от
реализации, аргументами. Этот вопрос мы рассмотрим в разделе 10.14.

Довольно сложный для восприятия прототип функции signal, приведенный в начале раздела, можно определить проще, через использование следующей инструкции typedef [Plauger, 1992]:
typedef void Sigfunc(int);

Тогда прототип самой функции signal будет выглядеть так:
Sigfunc *signal(int, Sigfunc *);

Мы включили это определение в заголовочный файл apue.h (приложение B) и будем использовать его в наших примерах.

10.3. Функция signal   

391

Заглянув в файл <signal.h>, можно обнаружить следующие объявления:
#define SIG_ERR (void (*)())-1
#define SIG_DFL (void (*)())0
#define SIG_IGN (void (*)())1

Эти константы можно использовать вместо «указателя на функцию, которая
принимает один целочисленный аргумент и ничего не возвращает» — это второй
аргумент функции signal и  одновременно ее возвращаемое значение. Значения
констант не обязательно должны быть –1, 0 и  1. Но они должны быть такими,
чтобы их нельзя было принять за адреса функций. В большинстве реализаций используются значения, приведенные выше.

Пример
В листинге 10.1 показан простейший обработчик сигнала, который перехватывает
два сигнала, определяемые пользователем, и выводит их номера. Функцию pause
мы рассмотрим в  разделе 10.10, она просто приостанавливает процесс до получения сигнала.
Листинг 10.1. Простейшая программа, которая перехватывает сигналы SIGUSR1
и SIGUSR2
#include "apue.h"
static void sig_usr(int); /* один обработчик для двух сигналов */
int
main(void)
{
if (signal(SIGUSR1, sig_usr) == SIG_ERR)
err_sys("невозможно перехватить сигнал SIGUSR1");
if (signal(SIGUSR2, sig_usr) == SIG_ERR)
err_sys("невозможно перехватить сигнал SIGUSR2");
for ( ; ; )
pause();
}
static void
sig_usr(int signo) /* аргумент — номер сигнала */
{
if (signo == SIGUSR1)
printf("принят сигнал SIGUSR1\n");
else if (signo == SIGUSR2)
printf("принят сигнал SIGUSR2\n");
else
err_dump("принят сигнал %d\n", signo);
}

Мы запускали эту программу как фоновый процесс и с помощью команды kill(1)
посылали ей сигналы. Обратите внимание, что термин kill (уничтожить) в UNIX
представляет пример не вполне корректного именования. Команда kill(1)
и функция kill(2) просто посылают сигнал процессу или группе процессов. Завершится процесс при получении сигнала или нет, зависит от того, какой сигнал
был послан и перехватывается ли этот сигнал процессом.

392    Глава 10. Сигналы
$ ./a.out &
[1]
7216
$ kill -USR1 7216
принят сигнал SIGUSR1
$ kill -USR2 7216
принят сигнал SIGUSR2
$ kill 7216
[1]+ Terminated ./a.out

запустить процесс в фоновом режиме
командная оболочка вывела номер задания
и идентификатор процесса
послать сигнал SIGUSR1
послать сигнал SIGUSR2
теперь послать сигнал SIGTERM

Когда был послан сигнал SIGTERM, процесс завершился, поскольку он не перехватывает этот сигнал, а по умолчанию он завершает процесс.

Запуск программы
В момент запуска программы всем сигналам назначаются действия по умолчанию
или сигналы игнорируются. Обычно для всех сигналов назначаются действия по
умолчанию, если только процесс, вызвавший функцию exec, не игнорирует какие-либо сигналы. Фактически функции семейства exec изменяют диспозицию
тех сигналов, которые перехватываются, на действия по умолчанию и оставляют
без изменения все остальные. (Это вполне естественно, поскольку сигнал, который перехватывается процессом, вызвавшим функцию exec, не может быть перехвачен той же функцией в новой программе, так как адрес функции-перехватчика
в вызывающей программе наверняка потеряет смысл в новой программе.)
Вот один характерный пример, как интерактивная командная оболочка обращается с сигналами SIGINT и SIGQUIT фонового процесса. Если командная оболочка
не поддерживает управление заданиями, то при запуске фонового процесса, например
cc main.c &

командная оболочка автоматически установит диспозицию этих сигналов для фонового процесса в значение SIG_IGN, поэтому ввод символа прерывания не оказывает никакого влияния на фоновый процесс. Если бы этого не было сделано, при
вводе символа прерывания завершился бы не только процесс переднего плана, но
и все фоновые процессы.
Многие интерактивные программы, перехватывающие эти два сигнала, содержат
примерно такой код:
void sig_int(int), sig_quit(int);
if (signal(SIGINT, SIG_IGN) != SIG_IGN)
signal(SIGINT, sig_int);
if (signal(SIGQUIT, SIG_IGN) != SIG_IGN)
signal(SIGQUIT, sig_quit);

Этот код устанавливает перехватчик сигнала, только если сигнал не игнори­
руется.
Эти два вызова наглядно демонстрируют недостаток функции signal  — отсутствие возможности определить текущую диспозицию сигнала без ее изменения.
Далее в этой главе мы увидим, что функция sigaction предоставляет такую возможность.

10.4. Ненадежные сигналы   

393

Создание процесса
Когда процесс вызывает функцию fork, дочерний процесс наследует диспозиции
сигналов от родительского процесса. В данном случае, поскольку дочерний процесс представляет собой полную копию родительского процесса, адреса функцийобработчиков не теряют своего смысла в дочернем процессе.

10.4. Ненадежные сигналы
В ранних версиях UNIX (таких, как Version 7) сигналы были ненадежными. То
есть сигналы могли теряться: иными словами, процесс мог не получить посланный ему сигнал. Кроме того, процесс имел весьма ограниченные возможности
управления сигналами: он мог либо перехватить сигнал, либо игнорировать его.
Иногда может возникнуть потребность заблокировать сигнал, то есть не игнорировать его, а просто отложить посылку сигнала до момента, когда приложение будет готово принять его.
Такое положение дел было исправлено в 4.2BSD, когда появились так называемые надежные сигналы. Затем ряд других изменений, также обеспечивающих поддержку надежных
сигналов, был внесен в SVR3. Стандарт POSIX.1 в качестве образца выбрал модель BSD.

Одна из проблем, связанных с ранними версиями, заключалась в том, что действие
сигнала сбрасывалось в значение по умолчанию после передачи сигнала. (В предыдущем примере, когда мы запускали программу из листинга 10.1, эта проблема
не возникала, поскольку сигнал перехватывался всего один раз.) Классический
пример из книг по программированию, описывающий обработку сигнала прерывания в ранних версиях UNIX, обычно выглядит примерно так:
int sig_int();
...
signal(SIGINT, sig_int);
...
sig_int()
{
signal(SIGINT, sig_int);
...
}

/* функция-обработчик */
/* установить функцию-обработчик */

/* переустановить функцию-обработчик */
/* обработка сигнала ... */

(Функция-обработчик объявлена как возвращающая целое число потому, что
в ранних версиях UNIX отсутствовала поддержка типа void стандарта ISO C.)
Этот пример также не лишен недостатков. Проблема здесь в том, что существует
некоторый промежуток времени между моментом посылки сигнала и моментом
вызова функции signal в функции-обработчике, когда сигнал SIGINT может быть
послан повторно. Этот повторный сигнал может вызвать выполнение действия
по умолчанию — завершение процесса. Это один из примеров, когда все работает
правильно большую часть времени, заставляя нас думать, что все в порядке, хотя
на самом деле это не так.
Еще одна проблема в ранних версиях UNIX состояла в том, что процесс был не
в состоянии отключить сигнал на время, когда его появление нежелательно. Про-

394    Глава 10. Сигналы
цесс мог полностью игнорировать сигнал, но он не мог сообщить системе: «Следующие сигналы не должны поступать ко мне, но система должна запомнить, что
они были посланы». Классический пример, демонстрирующий этот недостаток,
представлен фрагментом кода, который перехватывает сигнал и  устанавливает
флаг, отмечающий появление сигнала:
int sig_int();
int sig_int_flag;

/* функция-обработчик сигнала */
/* ненулевое значение, если был получен сигнал */

main()
{
signal(SIGINT, sig_int); /* установить функцию-обработчик */
...
while (sig_int_flag == 0)
pause();
/* приостановить работу в ожидании сигнала */
...
}
sig_int()
{
signal(SIGINT, sig_int); /* переустановить функцию-обработчик */
sig_int_flag = 1;
/* установить флаг для проверки в основной программе
*/
}

Здесь процесс вызывает функцию pause, ожидая, пока сигнал не будет перехвачен. При получении сигнала функция-обработчик просто устанавливает флаг
sig_int_flag в  ненулевое значение. Ядро автоматически возобновляет работу
процесса после выхода из функции-обработчика, после чего процесс обнаруживает взведенный флаг и выполняет все необходимые действия. Но здесь опять же
существует промежуток времени, когда все может пойти не так, как мы ожидаем.
Если сигнал будет послан в промежутке времени между проверкой флага sig_int_
flag и вызовом функции pause, процесс рискует приостановиться навсегда (при
условии, что сигнал больше никогда не будет послан). В данной ситуации сигнал
будет потерян. Это еще один пример, когда ошибочный код корректно работает
большую часть времени. Обнаружение и отладка подобных ошибок — чрезвычайно сложная задача.

10.5. Прерванные системные вызовы
Ранние версии UNIX обладали одним свойством: если процесс, заблокированный
в «медленном» системном вызове, перехватывал сигнал, выполнение системного
вызова прерывалось. В этом случае системный вызов возвращал признак ошибки
с  кодом EINTR в  переменной errno. Так было сделано в  предположении, что раз
сигнал был послан и процесс перехватил его, возможно, произошло что-то, из-за
чего системный вызов должен прервать ожидание и вернуть управление процессу.
Здесь следует понимать разницу между системными вызовами и обычными функциями.
Имеется в виду, что при перехвате сигнала прерывается выполнение именно системного
вызова в ядре.

10.5. Прерванные системные вызовы   

395

Для поддержки такого поведения системные вызовы были разделены на «медленные» и все остальные. Медленные системные вызовы — это такие вызовы, которые могут заблокировать процесс навсегда. В эту категорию попали:
 Операция чтения, которая может навсегда заблокировать вызывающий процесс при отсутствии данных в  файлах некоторых типов (каналы, устройства
терминалов и сетевые устройства).
 Операция записи, которая может навсегда заблокировать вызывающий процесс, если записываемые данные не могут быть немедленно отправлены в файлы перечисленных выше типов.
 Операция открытия, которая может заблокировать вызывающий процесс, пока
не будут выполнены некоторые условия при открытии файлов определенных
типов (таких, как устройства терминалов, которые ожидают установления модемного соединения).
 Функция pause (которая по определению приостанавливает выполнение процесса до получения сигнала) и функция wait.
 Некоторые операции функции ioctl.
 Некоторые функции межпроцессного взаимодействия (глава 15).
Известное исключение составляют операции ввода/вывода с дисковыми устройствами. Несмотря на то что операции чтения и  записи на дисковое устройство
могут временно заблокировать выполнение процесса (пока драйвер дискового
устройства ставит запрос в очередь, чтобы затем выполнить его), тем не менее при
отсутствии аппаратных ошибок операции ввода/вывода всегда завершаются достаточно быстро и разблокируют вызывающий процесс.
Один из случаев, которые могут привести к  прерыванию системного вызова,  —
когда процесс инициирует операцию чтения из терминала, а пользователь в это
время уходит на неопределенно долгое время. В этом случае процесс может быть
заблокирован на многие часы или даже дни и оставаться в таком состоянии, если
система не будет остановлена.
Семантика прерванных системных вызовов read и write была изменена в версии стандарта POSIX.1 2001 года. Предшествующие версии стандарта оставляли за реализацией выбор, как обрабатывать операции чтения и записи, которые уже частично
передали некоторый объем данных. Если вызов read прочитал данные и поместил их
в буфер приложения, но к моменту прерывания был получен не весь объем запрошенных
данных, тогда решение вопроса, завершить ли системный вызов с кодом ошибки EINTR
или позволить ему завершиться без признака ошибки и вернуть частично полученные
данные, оставлялось на усмотрение операционной системы. Точно так же, если операция
записи была прервана после передачи некоторого объема данных из буфера приложения,
система могла завершить системный вызов с кодом ошибки EINTR или позволить ему
завершиться без признака ошибки и  вернуть информацию о  количестве записанных
данных. Исторически сложилось так, что реализации, происходящие от System V, завершают системный вызов с признаком ошибки, тогда как реализации, производные
от BSD, возвращают управление без признака ошибки с информацией о фактически
выполненной работе. Начиная с версии 2001 года стандарт POSIX.1 требует соблюдения BSD-подобной семантики.

396    Глава 10. Сигналы
Проблема с прерванными системными вызовами заключается в том, что приходится явно обрабатывать возможные ошибочные ситуации. Типичная последовательность инструкций (в случае операции чтения, когда необходимо прочитать
полный объем данных, даже если операция чтения была прервана) может быть
следующей:
again:
if ((n = read(fd, buf, BUFFSIZE)) < 0) {
if (errno == EINTR)
goto again; /* просто прерванный системный вызов */
/* обработать другие возможные ошибки */
}

Чтобы избавить приложения от необходимости обрабатывать ситуации прерванных системных вызовов, в  4.2BSD было введено понятие автоматического перезапуска прерванных системных вызовов. К  системным вызовам, которые перезапускаются автоматически, были отнесены ioctl, read, readv, write,
writev, wait и  waitpid. Как мы уже упоминали, первые пять вызовов прерываются сигналами, только если они взаимодействуют с  медленными устройствами. Системные вызовы wait и  waitpid всегда прерываются перехваченными
сигналами. Так как это породило другую проблему для приложений, которые
не желали, чтобы системный вызов автоматически перезапускался в случае его
прерывания, в 4.3BSD у процессов появилась возможность изменить такое поведение для отдельных сигналов.
Стандарт POSIX.1 требует от реализаций перезапускать системные вызовы, только
когда для прерывающего сигнала действует флаг SA_RESTART. Как будет показано в разделе 10.14, этот флаг используется с функцией sigaction, чтобы позволить приложениям
запрашивать перезапуск прерванных системных вызовов.
Исторически, когда для установки обработчиков сигналов использовалась функция signal,
разные реализации по-разному обрабатывали прерванные системные вызовы. По умолчанию
System V никогда не перезапускала их. С другой стороны, BSD перезапускает их, если они
были прерваны сигналами. По умолчанию FreeBSD 8.0, Linux 3.2.0 и Mac OS X 10.6.8 перезапускают системные вызовы, прерванные сигналами. Однако в Solaris 10 по умолчанию
должна возвращаться ошибка (EINTR). Используя собственную версию функции signal
(из листинга 10.12), мы можем избавиться от этих различий.

Одна из причин, почему в 4.2BSD был введен автоматический перезапуск, заключается в том, что иногда мы просто не знаем, является ли устройство ввода/вывода медленным устройством. Если мы пишем программу, которая может работать
в интерактивном режиме, ей, вероятно, придется работать с медленным устройством, так как терминалы относятся к этой категории. Если эта программа перехватывает сигналы, то в случае, когда система не поддерживает возможность перезапуска системных вызовов, пришлось бы выполнять проверку каждой операции
чтения и записи на предмет появления ошибки EINTR и возобновлять прерванную
операцию.
В табл. 10.2 перечислены функции, предназначенные для работы с  сигналами,
и их семантика для некоторых реализаций.

10.6. Реентерабельные функции   

397

Таблица 10.2. Функции, предоставляемые различными реализациями

Функция
signal

Система

ISO C, POSIX.1

Обработчик
сигнала остается установленным

Не определено

Возможность блокировать
сигналы

Не определено

V7, SVR2, SVR3, SVR4,
Solaris

sigaction

Автоматический
перезапуск
прерванных
системных вызовов

Не определено
Никогда

4.2BSD





Всегда

4.3BSD, 4.4BSD, FreeBSD,
Linux, Mac OS X





По умолчанию

POSIX.1, 4.4BSD, SVR4,
FreeBSD, Mac OS X, Linux,
Solaris





По выбору

Имейте в  виду, что версии UNIX от других производителей могут иметь значения, отличные от перечисленных в  таблице. Например, функция sigaction
в  SunOS  4.1.2 по умолчанию перезапускает прерванные системные вызовы, что
отличает ее от платформ, представленных в табл. 10.2.
В листинге 10.12 приводится наша версия функции signal, которая автоматически пытается перезапустить прерванные системные вызовы (за исключением
сигнала SIGALRM). Другая функция, signal_intr, которая приводится в  листинге 10.13, никогда не пытается выполнить перезапуск.
Мы еще будем говорить о прерванных системных вызовах в разделе 14.4, при обсуждении функций select и poll.

10.6. Реентерабельные функции
Когда процесс обрабатывает перехваченный сигнал, нормальная последовательность выполнения инструкций временно нарушается обработчиком сигнала. После этого процесс продолжает работу, но выполняет инструкции уже в функцииобработчике. Если обработчик сигнала возвращает управление (а не вызывает,
например, функцию exit или longjmp), процесс продолжает выполнение нормальной последовательности инструкций, прерванной перехваченным сигналом.
(Это напоминает ситуацию, когда работа приложения прерывается аппаратным
прерыванием.) Но, находясь внутри обработчика сигнала, мы не можем определить, в каком месте процесса произошло прерывание. А что, если процесс вызвал
функцию malloc, чтобы распределить дополнительную память, и обработчик сигнала также вызвал функцию malloc? Или если процесс произвел вызов функции,
такой как getpwnam (раздел 6.2), сохраняющей результат статически, и обработчик
сигнала также вызвал ту же самую функцию? В случае функции malloc результаты такого вызова могут оказаться разрушительными для приложения, поскольку обычно функция malloc поддерживает связанный список всех выделенных ею

398    Глава 10. Сигналы
областей памяти и вызов из обработчика сигнала может произойти как раз в тот
момент, когда она вносит изменения в этот список. В случае с функцией getpwnam
информация, записанная по запросу процесса, может оказаться затертой информацией, запрошенной из обработчика сигнала.
Стандарт Single UNIX Specification определяет перечень функций, которые должны обеспечивать безопасность вызова из обработчиков сигналов. Эти функции
являются реентерабельными и  в  стандарте Single UNIX Specification называются безопасными для использования в  обработчиках асинхронных сигналов. Помимо обеспечения реентерабельности, они блокируют доставку любых сигналов
до своего завершения, если это может вызвать нарушения в работе приложения.
Эти функции перечислены в  табл. 10.3. Большинство функций, отсутствующих
в  табл.  10.3, не были внесены в  список либо потому, что (а) известно, что они
Таблица 10.3. Реентерабельные функции, которые можно вызывать
из обработчиков сигналов
abort

faccessat

linkat

select

socketpair

accept

fchmod

listen

sem_post

stat

access

fchmodat

lseek

send

symlink

aio_error

fchown

lstat

sendmsg

symlinkat

aio_return

fchownat

mkdir

sendto

tcdrain

aio_suspend

fcntl

mkdirat

setgid

tcflow

alarm

fdatasync

mkfifo

setpgid

tcflush

bind

fexecve

mkfifoat

setsid

tcgetattr

cfgetispeed

fork

mknod

setsockopt

tcgetpgrp

cfgetospeed

fstat

mknodat

setuid

tcsendbreak

cfsetispeed

fstatat

open

shutdown

tcsetattr

cfsetospeed

fsync

openat

sigaction

tcsetpgrp

chdir

ftruncate

pause

sigaddset

time

chmod

futimens

pipe

sigdelset

timer_getoverrun

chown

getegid

poll

sigemptyset

timer_gettime

clock_gettime

geteuid

posix_trace_event

sigfillset

timer_settime

close

getgid

pselect

sigismember

times

connect

getgroups

raise

signal

umask

creat

getpeername

read

sigpause

uname

dup

getpgrp

readlink

sigpending

unlink

dup2

getpid

readlinkat

sigprocmask

unlinkat

execl

getppid

recv

sigqueue

utime

execle

getsockname

recvfrom

sigset

utimensat

execv

getsockopt

recvmsg

sigsuspend

utimes

execve

getuid

rename

sleep

wait

_Exit

kill

renameat

sockatmark

waitpid

_exit

link

rmdir

socket

write

10.6. Реентерабельные функции   

399

используют структуры данных, размещаемые статически, либо (б) они вызывают функцию malloc или free, либо (в) входят в стандартную библиотеку ввода/
вывода. Большинство реализаций стандартной библиотеки ввода/вывода используют глобальные структуры данных способом, исключающим реентерабельность.
Обратите внимание, что хотя мы вызываем функцию printf из обработчиков сигналов в  некоторых наших примерах, нельзя гарантировать, что этот вызов даст
предсказуемый результат, так как обработчик сигнала может быть вызван в процессе работы функции printf, вызванной в другом месте программы.
Имейте также в  виду, что даже если вызов одной из функций, перечисленных
в табл. 10.3, производится из обработчика сигнала, для каждого из потоков управления существует единственная переменная errno (вспомните раздел 1.7) и  мы
можем изменить ее значение. Например, обработчик сигнала может быть вызван
сразу же после того, как код ошибки был записан в переменную errno в главной
программе. Если обработчик сигнала вызывает, например, функцию read, она может изменить значение этой переменной, затерев значение, только что записанное
в  главной программе. Поэтому при вызове функций из табл. 10.3 всегда сохраняйте значение переменной errno в  начале обработчика и  восстанавливайте перед возвратом в главную программу. (Чаще всего при перехвате сигнала SIGCHLD
функция-обработчик обращается к одной из функций wait, которая может изменить значение переменной errno.)
Обратите внимание на отсутствие функций longjmp (раздел 7.10) и  siglongjmp
(раздел 10.15) в табл. 10.3, поскольку обработчик сигнала может быть вызван как
раз в  тот момент, когда эти функции выполняют обновление структур данных
нереентерабельным способом. Эти структуры данных могут оказаться обновленными частично, если вместо обычного возврата из функции-обработчика вызвать
функцию siglongjmp. Если необходимо сделать что-то с глобальными структурами данных в то время, когда может быть вызван обработчик сигнала, вызывающий
функцию siglongjmp, приложение должно блокировать сигналы на время обновления этих данных.

Пример
В листинге 10.2 представлена программа, которая обращается к нереентерабельной функции getpwnam из обработчика сигнала, вызываемого один раз в секунду.
Функцию alarm мы рассмотрим в разделе 10.10. Мы использовали ее для генерации сигнала SIGALRM каждую секунду.
Листинг 10.2. Вызов нереентерабельной функции из обработчика сигнала
#include "apue.h"
#include <pwd.h>
static void
my_alarm(int signo)
{
struct passwd *rootptr;
printf("внутри обработчика сигнала\n");
if ((rootptr = getpwnam("root")) == NULL)
err_sys("ошибка вызова функции getpwnam(root)");

400    Глава 10. Сигналы

}

alarm(1);

int
main(void)
{
struct passwd

}

*ptr;

signal(SIGALRM, my_alarm);
alarm(1);
for ( ; ; ) {
if ((ptr = getpwnam("sar")) == NULL)
err_sys("ошибка вызова функции getpwnam");
if (strcmp(ptr->pw_name, "sar") != 0)
printf("возвращаемое значение повреждено!, pw_name = %s\n",
ptr->pw_name);
}

Когда мы запустили эту программу, она начала выдавать совершенно непредсказуемые результаты. Обычно программа завершалась по сигналу SIGSEGV, когда обработчик сигнала возвращал управление после нескольких итераций. Исследование файла core показало, что проблема возникала, когда main вызывала функцию getpwnam,
которая, в  свою очередь, вызывает функцию free, и  в  этот момент происходило
прерывание — обработчик сигнала также вызывал функцию getpwnam, которая обращается к  функции free. В  результате структуры данных, которыми управляют
функции malloc и  free, оказывались поврежденными. Иногда программе удавалось проработать несколько секунд, прежде чем она получала сигнал SIGSEGV. Когда
функция main работала вполне корректно после вызова обработчика сигнала, возвращаемое значение getpwnam иногда оказывалось поврежденным, а иногда — нет.
Как показывает этот пример, вызов нереентерабельных функций из обработчиков
сигналов может дать самые непредсказуемые результаты.

10.7. Семантика сигнала SIGCLD
Два сигнала, которые продолжают вносить сумятицу в  умы программистов,  —
SIGCLD и  SIGCHLD. Прежде всего, SIGCLD (без H) — это имя сигнала, пришедшее из
System V. Семантика этого сигнала отличается от семантики BSD-сигнала с именем SIGCHLD. Соответствующий сигнал из стандарта POSIX.1 также получил имя
SIGCHLD.
Семантика сигнала SIGCHLD подобна семантике всех остальных сигналов. Когда
изменяется состояние дочернего процесса, генерируется сигнал SIGCHLD, и  мы
должны вызвать одну из функций семейства wait, чтобы узнать, что произошло.
Однако System V традиционно обслуживает сигнал SIGCLD иначе, чем остальные
сигналы. Системы, основанные на SVR4, продолжают эту сомнительную (в смысле совместимости) традицию, если диспозиция этого сигнала устанавливается
функциями signal или sigset (устаревшие SVR3-совместимые функции, предназначенные для изменения диспозиции сигнала). Этот способ обслуживания сигнала SIGCLD заключается в следующем:

10.7. Семантика сигнала SIGCLD   

401

1.	 Если процесс установит его диспозицию в значение SIG_IGN, дочерние процессы
не будут порождать процессы-зомби. Обратите внимание: это действие отличается от действия по умолчанию SIG_DFL, которое, в соответствии с табл. 10.1,
просто игнорирует сигнал. Вместо этого по завершении дочернего процесса его
код завершения просто теряется. Если затем вызвать одну из функций wait, вызывающий процесс окажется заблокированным, пока все его дочерние процессы
не завершат работу, после чего wait вернет значение –1 с кодом ECHILD в переменной errno. (Диспозиция сигнала по умолчанию — игнорировать сигнал, но
это не означает, что его семантика будет следовать семантике SIG_IGN. Поэтому
мы должны явно установить диспозицию сигнала в значение SIG_IGN.)
Стандарт POSIX.1 не определяет поведение системы в  случае, когда сигнал SIGCHLD
игнорируется, поэтому подобное поведение вполне допустимо. Расширение XSI требует,
чтобы такое поведение поддерживалось для сигнала SIGCHLD.
В 4.4BSD, если сигнал SIGCHLD игнорируется, это всегда приводит к созданию зомби. Чтобы
избежать появления зомби, мы должны вызывать функцию wait для дочерних процессов.
Если в SVR4 вызывается функция signal или sigset, чтобы установить диспозицию сигнала SIGCHLD в значение SIG_IGN, зомби никогда не появляются. Все четыре платформы,
описываемые в этой книге, в своем поведении следуют за SVR4.
При использовании функции sigaction можно установить флаг SA_NOCLDWAIT (табл. 10.5),
чтобы избежать появления зомби. Это поведение также поддерживается всеми четырьмя
платформами.

2.	 Если для сигнала SIGCLD назначена функция-обработчик, ядро сразу же проверяет наличие дочерних процессов и вызывает обработчик сигнала SIGCLD, если
такие процессы имеются. Пункт 2 меняет алгоритм обработчика сигнала, как
показано в следующем примере.

Пример
Как уже говорилось в  разделе 10.4, первое, что нужно сделать на входе в  обработчик сигнала,  — переустановить его с  помощью функции signal. (Тем самым
минимизировав интервал времени, когда сигнал может быть потерян в  результате временного сброса диспозиции в  значение по умолчанию.) Этот прием демонстрируется в листинге 10.3. Данная программа не работает на традиционных
платформах System V. Она будет выводить непрерывный поток сообщений принят
сигнал SIGCLD, пока, наконец, процесс не завершится аварийно в результате исчерпания пространства, отведенного под стек.
В FreeBSD 8.0 и Mac OS X 10.6.8 эта проблема не проявляется, потому что системы,
основанные на BSD, вообще не поддерживают семантику System V для сигнала SIGCLD.
Linux 3.2.0 также лишена этого недостатка, потому что не вызывает обработчик сигнала SIGCHLD сразу после его установки — даже при том, что сигналы SIGCLD и  SIGCHLD
определены с одним и тем же номером. С другой стороны, в Solaris 10 обработчик сигнала
в такой ситуации действительно вызывается, но в ядро включен дополнительный код,
который помогает избежать описанной проблемы.
Хотя все четыре рассматриваемые в этой книге платформы разрешили данную проблему,
тем не менее есть такие системы (например, AIX), в которых она все еще существует.

402    Глава 10. Сигналы
Листинг 10.3. Обработчик сигнала SIGCLD из System V, который не работает
#include "apue.h"
#include <sys/wait.h>
static void sig_cld(int);
int
main()
{
pid_t

pid;

if (signal(SIGCLD, sig_cld) == SIG_ERR)
perror("ошибка вызова функции signal");
if ((pid = fork()) < 0) {
perror("ошибка вызова функции fork");
} else if (pid == 0) { /* дочерний процесс */
sleep(2);
_exit(0);
}

}

pause(); /* родительский процесс */
exit(0);

static void
sig_cld(int signo) /* прерывает функцию pause() */
{
pid_t
pid;
int
status;
printf("принят сигнал SIGCLD\n");
if (signal(SIGCLD, sig_cld) == SIG_ERR) /* переустановить обработчик */
perror("ошибка вызова функции signal");
if ((pid = wait(&status)) < 0) /* получить состояние дочернего процесса */
perror("ошибка вызова функции wait");
}

printf("pid = %d\n", pid);

Проблема этой программы в том, что она вызывает функцию signal в самом начале функции-обработчика, и  это приводит к  тому, что ядро проверяет наличие
дочерних процессов (а дочерний процесс имеется, поскольку мы уже находимся
в обработчике сигнала SIGCLD), что, в свою очередь, приводит к очередному вызову обработчика сигнала. Функция-обработчик опять вызывает функцию signal,
и цикл повторяется.
Чтобы исправить ошибку, нужно поместить вызов signal после вызова функции
wait. Благодаря этому вызов функции signal будет производиться после получения кода завершения дочернего процесса, и в следующий раз сигнал будет сгенерирован ядром, только если завершится один из дочерних процессов.
Формулировка стандарта POSIX.1 не определяет, должен ли генерироваться сигнал,
когда к  моменту установки обработчика сигнала SIGCHLD существует завершившийся
дочерний процесс, код завершения которого еще не был получен. Это допускает реализа-

10.8. Надежные сигналы. Терминология и семантика   

403

цию поведения, описанного выше. Но поскольку стандарт POSIX.1 не предполагает сброс
диспозиции сигнала в значение по умолчанию после его появления (здесь мы предполагаем,
что для изменения диспозиции сигнала используется функция POSIX.1 — sigaction), то
и нет никакой потребности в том, чтобы переустанавливать обработчик сигнала SIGCHLD
в теле функции-обработчика.

Поинтересуйтесь семантикой сигнала SIGCHLD в вашей системе. В особенности обратите внимание на определение, которое в одних системах выглядит как #define
SIGCHLD SIGCLD, а в других — наоборот. Изменение имени сигнала может устранить
проблемы при сборке программы, которая была написана для другой системы, но
если эта программа зависит от конкретной семантики, возможно, что она не будет
работать.
На четырех платформах, обсуждаемых в данной книге, сигнал SIGCLD эквивалентен сигналу SIGCHLD.

10.8. Надежные сигналы.
Терминология и семантика
Мы должны определить некоторые термины, используемые при обсуждении сигналов. Прежде всего для процесса генерируется (или процессу посылается) сигнал, когда происходит некоторое событие. Таким событием может быть аппаратная ошибка (например, деление на 0), программное событие (например, истечение
интервала времени, отмеряемого таймером), сигнал, сгенерированный терминалом, или вызов функции kill. Когда генерируется сигнал, ядро, как правило, устанавливает некий флаг в таблице процессов.
Когда выполняется действие, предусмотренное для сигнала, мы говорим, что сигнал доставлен процессу. Интервал времени между генерацией сигнала и  его доставкой называется периодом ожидания обработки.
Процесс может заблокировать доставку сигнала. Если процессу посылается сигнал, который был заблокирован, и при этом для сигнала установлено либо действие по умолчанию, либо перехват, сигнал остается в состоянии ожидания обработки, пока процесс (а) не разблокирует сигнал или (б) не установит диспозицию
сигнала в значение SIG_IGN. Что делать с сигналом, определяется системой в момент доставки, но не в момент генерации. Это позволяет процессам изменить диспозицию сигнала до того, как он будет доставлен. Процесс может получить перечень ожидающих или заблокированных сигналов с помощью функции sigpending
(раздел 10.13).
Что произойдет, если заблокированный сигнал будет сгенерирован несколько раз,
прежде чем процесс разблокирует его? Стандарт POSIX.1 допускает доставку как
единственного сигнала, так и  всех сгенерированных сигналов. Если система доставляет процессу все сгенерированные сигналы, мы говорим, что сигналы ставятся в очередь. Однако большинство версий UNIX при отсутствии расширений
реального времени POSIX.1 не ставят сигналы в очередь, то есть ядро доставляет
единственный сигнал.

404    Глава 10. Сигналы
В SUSv4 определение поддержки сигналов реального времени было перемещено из раздела
расширений в раздел базовых спецификаций. С течением времени все больше систем будут
поддерживать очереди сигналов, даже если они не поддерживают расширения реального
времени. Очереди сигналов мы обсудим ниже, в разделе 10.20.
Справочное руководство SVR2 утверждало, что сигнал SIGCLD ставится в очередь, если
процесс в данный момент выполняет функцию обработки сигнала SIGCLD. Возможно, это
было истинно только на концептуальном уровне, поскольку фактическая реализация была
иной. На самом деле ядро повторно генерировало сигнал, как было описано в разделе 10.7.
В  SVR3 текст справочного руководства претерпел некоторые изменения: сообщается, что в  момент обработки сигнала SIGCLD последующие его доставки игнорируются.
В справочном руководстве SVR4 вообще исчезло любое упоминание о том, что происходит
с сигналом SIGCLD, полученным в то время, когда процесс выполняет код функции — обработчика этого сигнала.
Страница справочного руководства SVR4 к функции sigaction(2) в [AT&T, 1990e] утверждает, что существует надежный способ поставить сигнал в очередь с помощью флага
SA_SIGINFO (табл. 10.5). Это не соответствует истине. Очевидно, такая возможность
была частично реализована в ядре, но она не используется в SVR4. Любопытно, что руководство SVID не делает подобных заявлений.

Что произойдет, если сразу несколько сигналов одновременно будут готовы к доставке? Стандарт POSIX.1 не определяет порядок доставки сигналов. Однако
POSIX.1 Rationale предлагает в  первую очередь доставлять сигналы, которые
имеют отношение к  текущему состоянию процесса (один из таких сигналов  —
SIGSEGV).
Каждый процесс имеет маску сигналов, с помощью которой определяется множество блокируемых сигналов. Ее можно представлять как битовую маску, в которой каждый бит соответствует отдельному сигналу. Если некоторый бит включен,
доставка соответствующего ему сигнала блокируется. Процесс может проверить
и изменить маску с помощью функции sigprocmask, которая будет описана в разделе 10.12.
Поскольку существует вероятность, что количество сигналов превысит количество битов в целочисленном типе, стандарт POSIX.1 предусматривает специальный тип данных sigset_t для хранения набора сигналов. В разделе 10.11 мы рассмотрим пять функций, предназначенных для работы с наборами сигналов.

10.9. Функции kill и raise
Функция kill посылает сигнал процессу или группе процессов. Функция raise
позволяет процессу послать сигнал себе самому.
Изначально функция raise была определена стандартом ISO C. Стандарт POSIX.1
включает эту функцию, чтобы соблюсти соответствие со стандартом ISO C, однако
он расширяет ее спецификацию для обеспечения работы с потоками выполнения (взаимодействие потоков с сигналами мы обсудим в разделе 12.8). Поскольку стандарт ISO C
ничего не говорит о  многозадачности, в  нем отсутствует определение функции kill,
которая требует передачи идентификатора процесса в качестве одного из аргументов.

10.9. Функции kill и raise   

405

#include <signal.h>
int kill(pid_t pid, int signo);
int raise(int signo);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Вызов
raise(signo);

эквивалентен вызову
kill(getpid(), signo);

Интерпретация аргумента pid функции kill производится в соответствии со следующими правилами.
pid > 0  Сигнал посылается процессу с идентификатором pid.
pid == 0  Сигнал посылается всем процессам с идентификатором группы процессов, равным идентификатору группы процессов посылающего процесса, которым
данный процесс имеет право посылать сигналы. Обратите внимание, что в понятие всем процессам не входят системные процессы, определяемые реализацией.
В большинстве версий UNIX под системными понимаются процессы ядра и процесс init (идентификатор процесса 1).
pid < 0  Сигнал посылается всем процессам с идентификатором группы процессов, равным абсолютному значению pid, которым данный процесс имеет право
посылать сигналы. Опять же в понятие всем процессам не входят системные процессы, определяемые реализацией.
pid == -1  Сигнал посылается всем процессам в системе, которым посылающий
процесс имеет право посылать сигналы. Здесь точно так же из понятия всем процессам исключаются некоторые системные процессы.
Как уже упоминалось, процесс должен обладать определенными правами, чтобы посылать сигналы другим процессам. Так, суперпользователь может послать
сигнал любому процессу. В  остальных случаях должно соблюдаться основное
правило  — реальный или эффективный идентификатор пользователя процесса,
посылающего сигнал, должен совпадать с реальным или эффективным идентификатором пользователя процесса, принимающего сигнал. Если реализация поддерживает возможность _POSIX_SAVED_IDS (которая ныне считается обязательной),
вместо эффективного идентификатора пользователя проверяется сохраненный
идентификатор пользователя. Из этого правила существует одно исключение:
сигнал SIGCONT можно послать любому другому процессу, принадлежащему тому
же сеансу.
Стандарт POSIX.1 определяет сигнал с номером 0 как пустой сигнал. Если аргумент signo имеет значение 0, функция kill выполнит обычную проверку на наличие ошибок, но сам сигнал не пошлет. Это часто используется, чтобы определить,
существует ли еще некоторый процесс. Если несуществующему процессу послать

406    Глава 10. Сигналы
пустой сигнал, функция kill вернет –1 и код ошибки ESRCH в переменной errno.
Однако следует иметь в виду, что через некоторый промежуток времени идентификаторы процессов могут использоваться повторно, поэтому наличие процесса
с заданным идентификатором вовсе не означает, что это тот самый процесс, который вам нужен.
Кроме того, проверка существования процесса не является атомарной операцией. К моменту, когда функция kill вернет управление в вызывающую программу,
проверяемый процесс уже может завершиться, что сильно ограничивает область
применения такого приема.
Если в  результате вызова функции kill генерируется сигнал для вызывающего
процесса и при этом сигнал не заблокирован, тогда либо сигнал с номером signo,
либо другой ожидающий обработки сигнал будет доставлен процессу еще до того,
как функция kill вернет управление. (В случае использования нескольких потоков выполнения возникает ряд дополнительных вариантов; за информацией обращайтесь к разделу 12.8.)

10.10. Функции alarm и pause
Функция alarm позволяет установить таймер, который по истечении заданного
времени сгенерирует сигнал SIGALRM. Если этот сигнал не игнорируется и не перехватывается приложением, он вызывает завершение процесса.
#include <unistd.h>
unsigned int alarm(unsigned int seconds);

Возвращает 0 или количество секунд до истечения периода времени,
установленного ранее
Аргумент seconds определяет количество секунд, через которое должен быть сгенерирован сигнал. Следует помнить, что между моментом генерации сигнала
и моментом его доставки приложению пройдет некоторое время.
В ранних версиях UNIX оговаривалось, что сигнал может быть сгенерирован чуть раньше
(на секунду или менее). Стандарт POSIX.1 не допускает этого.

Каждый процесс может обладать только одним таким таймером. Если функция
alarm вызывается до истечения таймера, установленного ранее, она возвращает
количество оставшихся секунд, а ранее установленный интервал времени заменяется новым.
Если ранее установленный интервал времени еще не истек и в аргументе seconds
передается значение 0, взведенный таймер останавливается, а функция возвращает количество секунд, оставшихся до истечения таймера.
По умолчанию сигнал SIGALRM завершает процесс, но большинство приложений
перехватывают его. Если в результате получения этого сигнала приложение должно завершить работу, оно может выполнить все необходимые заключительные

10.10. Функции alarm и pause   

407

операции перед выходом. Если предполагается перехват сигнала SIGALRM, необходимо установить обработчик сигнала до вызова функции alarm. Если функцию
alarm вызвать первой и она успеет сгенерировать сигнал до установки обработчика сигнала, процесс завершится.
Функция pause приостанавливает вызывающий процесс, пока не будет перехвачен сигнал.
#include <unistd.h>
int pause(void);

Возвращает значение –1 с кодом ошибки EINTR в переменной errno
Функция pause возвращает управление, только когда отработает функция — обработчик сигнала. В этом случае она возвращает значение –1 с кодом ошибки EINTR
в переменной errno.

Пример
С помощью функций alarm и  pause можно приостановить процесс на определенный промежуток времени. На первый взгляд функция sleep1 из листинга 10.4
выполняет эту задачу, однако в ней кроется ряд ошибок, о которых мы вскоре поговорим.
Листинг 10.4. Простейшая, но не полная реализация функции sleep
#include <signal.h>
#include <unistd.h>
static void
sig_alrm(int signo)
{
/* ничего не делаем, просто возвращаем управление */
}
unsigned int
sleep1(unsigned int seconds)
{
if (signal(SIGALRM, sig_alrm) == SIG_ERR)
return(seconds);
alarm(seconds);
/* запустить таймер */
pause();
/* следующий перехваченный сигнал возобновит работу процесса
*/
return(alarm(0)); /* выключить таймер и вернуть время, */
/* оставшееся до его истечения */
}

Эта функция напоминает функцию sleep, которая будет описана в разделе 10.19,
но в данной реализации кроются три проблемы.
1.	 Если вызывающий процесс уже установил таймер, его значение будет затерто
первым вызовом функции alarm. Мы можем исправить эту ошибку, проанализировав возвращаемое функцией значение. Если оставшееся количество секунд меньше значения аргумента seconds, мы должны оставить прежнее значение таймера. Если значение таймера больше значения аргумента seconds, после

408    Глава 10. Сигналы
того, как таймер сработает через заданное количество секунд, мы должны переустановить его, чтобы он повторно сработал в указанное ранее время.
2.	 Наша функция изменяет диспозицию сигнала SIGALRM. Если мы предполагаем
использовать функцию в  других приложениях, то должны сохранять диспозицию сигнала при вызове функции и восстанавливать ее по завершении. Эту
ошибку можно исправить, сохраняя возвращаемое значение функции signal
и восстанавливая прежнюю диспозицию перед выходом.
3.	 Между первым вызовом функции alarm и  вызовом функции pause возникает состояние гонки за ресурсами. При значительной нагрузке на систему есть
вероятность, что таймер сработает и функция-обработчик будет вызвана еще
до вызова функции pause. В этом случае вызывающий процесс навсегда приостановится в функции pause (если, конечно, он не перехватит какой-нибудь
другой сигнал).
Ранние реализации функции sleep выглядели подобно нашей программе, но
ошибки 1 и  2 были исправлены, как описано выше. Для исправления третьей
ошибки существует два пути. Первый — использовать функцию setjmp, этот подход мы продемонстрируем в следующем примере. Второй — использовать функции sigprocmask и sigsuspend, которые мы рассмотрим в разделе 10.19.

Пример
В SVR2 реализация функции sleep, во избежание гонки за ресурсами, использовала функции setjmp и  longjmp (раздел 7.10). Простейшая версия этой функции,
которую мы назвали sleep2, приводится в листинге 10.5. (Чтобы сократить размер
листинга, мы не включили устранение ошибок 1 и 2.)
Листинг 10.5. Другая (неполная) реализация функции sleep
#include <setjmp.h>
#include <signal.h>
#include <unistd.h>
static jmp_buf env_alrm;
static void
sig_alrm(int signo)
{
longjmp(env_alrm, 1);
}
unsigned int
sleep2(unsigned int seconds)
{
if (signal(SIGALRM, sig_alrm) == SIG_ERR)
return(seconds);
if (setjmp(env_alrm) == 0) {
alarm(seconds); /* запустить таймер */
pause();
/* следующий же перехваченный сигнал */
/* возобновить работу процесса */
}
return(alarm(0));
/* выключить таймер и вернуть время, */
/* оставшееся до его истечения */
}

10.10. Функции alarm и pause   

409

В функции sleep2 исключается возможность попасть в состояние гонки за ресурсами. Даже если функция pause никогда не будет вызвана, sleep2 все равно вернет
управление после доставки сигнала SIGALRM.
В данной версии существует еще одна малозаметная ошибка, которая связана с взаимодействием с другими сигналами. Если сигнал SIGALRM будет получен при выполнении функции — обработчика другого сигнала, вызов функции longjmp оборвет обработку этого сигнала. Программа из листинга 10.6 демонстрирует такое развитие
событий. Цикл в обработчике сигнала SIGINT построен так, что в операционной системе, которую использовал автор книги, он выполняется дольше 5 секунд. Это нужно, чтобы время работы обработчика было больше, чем значение аргумента функции
sleep2. Переменная k объявлена со спецификатором volatile, чтобы предотвратить
нарушение цикла в результате оптимизации, которую выполняет компилятор.
Листинг 10.6. Вызов функции sleep2 из программы, которая перехватывает
другие сигналы
#include "apue.h"
unsigned int
static void

sleep2(unsigned int);
sig_int(int);

int
main(void)
{
unsigned int

}

if (signal(SIGINT, sig_int) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGINT)");
unslept = sleep2(5);
printf("функция sleep2 вернула значение: %u\n", unslept);
exit(0);

static void
sig_int(int signo)
{
int
volatile int

}

unslept;

i, j;
k;

/*
* Настройте параметры циклов так, чтобы они выполнялись
* дольше 5 секунд в системе, где запускается программа.
*/
printf("\nфункция sig_int начала обработку\n");
for (i = 0; i < 300000; i++)
for (j = 0; j < 4000; j++)
k += i * j;
printf("функция sig_int закончила обработку\n");

Запустив программу из листинга 10.6 и прервав ее вводом символа прерывания,
мы получили результаты:
$ ./a.out
^C
введен символ прерывания
функция sig_int начала обработку
функция sleep2 вернула значение: 0

410    Глава 10. Сигналы
Как видите, вызов longjmp из sleep2 оборвал работу другого обработчика сигнала
(sig_int), не дав ему завершиться. С этим вы столкнетесь, если будете смешивать
использование функции sleep с обработкой других сигналов (упражнение 10.3).
Цель этих двух примеров функций sleep1 и  sleep2 в том, чтобы продемонстрировать возможные проблемы при работе с  сигналами. В следующем разделе мы
покажем приемы, помогающие избежать этих проблем и  надежно обрабатывать
сигналы, не вступая в конфликт с другими участками кода.

Пример
Часто функция alarm используется в  паре с  функцией pause, чтобы установить
предельное время выполнения некоторых операций, которые могут блокировать
процесс. Например, если выполняется операция чтения из «медленного» устройства (раздел 10.5), которая может заблокировать процесс, у нас может появиться
желание ограничить время работы функции read некоторым промежутком времени. Программа из листинга 10.7 читает данные со стандартного ввода и выводит
их на стандартный вывод, ограничивая при этом время операции чтения.
Листинг 10.7. Вызов функции read с тайм-аутом
#include "apue.h"
static void sig_alrm(int);
int
main(void)
{
int
char

n;
line[MAXLINE];

if (signal(SIGALRM, sig_alrm) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGALRM)");
alarm(10);
if ((n = read(STDIN_FILENO, line, MAXLINE)) < 0)
err_sys("ошибка вызова функции read");
alarm(0);

}

write(STDOUT_FILENO, line, n);
exit(0);

static void
sig_alrm(int signo)
{
/* ничего не делать, просто прервать работу функции read */
}

Такая последовательность инструкций — обычное дело для приложений в UNIX,
но в этой программе кроются две проблемы.
1.	 Программа из листинга 10.7 имеет один из недостатков, присущих программе
из листинга 10.4: вероятность попасть в состояние гонки за ресурсами между
первым вызовом функции alarm и  вызовом функции read. Если ядро успеет

10.10. Функции alarm и pause   

411

заблокировать процесс между этими двумя вызовами на больший период, чем
период срабатывания таймера, процесс рискует оказаться навсегда заблокированным в функции read. В большинстве подобных случаев используются длительные тайм-ауты, порядка минуты или больше, но тем не менее вероятность
попасть в состояние гонки за ресурсами все равно сохраняется.
2.	 Если системные вызовы перезапускаются автоматически, выполнение функции read не будет прервано после выхода из обработчика сигнала SIGALRM.
В этом случае установка тайм-аута ничего не даст.
Здесь нам требуется прервать медленный системный вызов. Более переносимый
способ будет представлен в разделе 10.14.

Пример
Давайте перепишем предыдущий пример так, чтобы он использовал функцию
longjmp. Это позволит прервать работу медленного системного вызова в  любом
случае.
Листинг 10.8. Вызов функции read с тайм-аутом с использованием функции longjmp
#include "apue.h"
#include <setjmp.h>
static void sig_alrm(int);
static jmp_buf env_alrm;
int
main(void)
{
int
char

n;
line[MAXLINE];

if (signal(SIGALRM, sig_alrm) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGALRM)");
if (setjmp(env_alrm) != 0)
err_quit("работа функции read прервана по тайм-ауту");
alarm(10);
if ((n = read(STDIN_FILENO, line, MAXLINE)) < 0)
err_sys("ошибка вызова функции read");
alarm(0);

}

write(STDOUT_FILENO, line, n);
exit(0);

static void
sig_alrm(int signo)
{
longjmp(env_alrm, 1);
}

Эта версия работает так, как мы и ожидали, независимо от того, перезапускает система прерванные системные вызовы или нет. Но не забывайте, что эта версия все
еще подвержена проблеме, связанной с обработкой других сигналов.

412    Глава 10. Сигналы
Если требуется ограничить время выполнения операций ввода/вывода, следует использовать функцию longjmp, как показано выше, но при этом не забывать
о  возможных конфликтах с  другими обработчиками сигналов. Другой способ
ограничения выполнения операций по времени предоставляют функции select
и poll, которые будут рассматриваться в разделах 14.4.1 и 14.4.2.

10.11. Наборы сигналов
Для представления множества сигналов нам необходим специальный тип данных  — набор сигналов. Он используется такими функциями, как sigprocmask
(описывается в  следующем разделе), чтобы передать ядру набор сигналов, которые должны быть заблокированы. Как уже говорилось выше, количество различных сигналов может превышать количество битов в  целочисленном типе,
поэтому в большинстве случаев нельзя использовать тип int для представления
набора сигналов, в котором каждому сигналу отводится отдельный бит. Стандарт
POSIX.1 определяет для этих целей специальный тип sigset_t, который может
хранить набор сигналов и с которым работают следующие пять функций.
#include <signal.h>
int sigemptyset(sigset_t *set);
int sigfillset(sigset_t *set);
int sigaddset(sigset_t *set, int signo);
int sigdelset(sigset_t *set, int signo);

Все четыре возвращают 0 в случае успеха, –1 — в случае ошибки
int sigismember(const sigset_t *set, int signo);

Возвращает 1 (истина), 0 (ложь), –1 — в случае ошибки
Функция sigemptyset инициализирует пустой набор сигналов, на который указывает аргумент set. Функция sigfillset инициализирует набор сигналов, в который включены все сигналы. Все приложения должны вызывать функцию
sigemptyset или sigfillset для каждого набора сигналов перед его использованием, потому что нельзя предполагать, что инициализация глобальных или статических переменных, выполняемая языком C, соответствует реализации сигналов
в заданной системе.
После инициализации в набор сигналов можно добавлять или удалять из него сигналы. Добавление одного сигнала в существующий набор производится функцией sigaddset, а удаление сигнала из набора — функцией sigdelset. Все функции,
которым передается набор сигналов, в виде аргумента всегда получают указатель
на набор сигналов.

Реализация
Если количество сигналов в реализации меньше количества разрядов в целочисленном типе, набор сигналов может быть реализован на основе этого типа и пред-

10.11. Наборы сигналов   

413

ставлять каждый сигнал отдельным битом. Далее в этом разделе мы будем исходить
из предположения, что реализация насчитывает 31 сигнал, а для представления
целых чисел используется 32 разряда. Таким образом, функция sigemptyset обнуляет целое число, а функция sigfillset — взводит все биты в целом числе. Эти
две функции могут быть реализованы в виде макроопределений в заголовочном
файле <signal.h>:
#define sigemptyset(ptr) (*(ptr) = 0)
#define sigfillset(ptr) (*(ptr) = ~(sigset_t)0, 0)

Обратите внимание: поскольку функция sigfillset должна устанавливать все
биты в наборе сигналов и возвращать значение 0, в данном определении использован оператор языка C «запятая», возвращающий в качестве общего результата
значение, стоящее после запятой.
В такой реализации функция sigaddset включает, а функция sigdelset выключает один разряд в наборе. Функция sigismember проверяет состояние указанного
разряда. Поскольку сигнал с номером 0 отсутствует, при определении номера разряда из номера сигнала вычитается 1. В листинге 10.9 показана реализация этих
функций.
Листинг 10.9. Реализация функций sigaddset, sigdelset и sigismember
#include <signal.h>
#include <errno.h>
/*
* Обычно в файле <signal.h> имеется определение константы NSIG,
* которая учитывает сигнал с номером 0.
*/
#define SIGBAD(signo) ((signo) <= 0 || (signo) >= NSIG)
int
sigaddset(sigset_t *set, int signo)
{
if (SIGBAD(signo)) {
errno = EINVAL;
return(-1);
}
*set |= 1 << (signo - 1); /* включить бит */
return(0);
}
int
sigdelset(sigset_t *set, int signo)
{
if (SIGBAD(signo)) {
errno = EINVAL;
return(-1);
}
*set &= .(1 << (signo - 1)); /* выключить бит */
return(0);
}
int
sigismember(const sigset_t *set, int signo)
{

414    Глава 10. Сигналы

}

if (SIGBAD(signo)) {
errno = EINVAL;
return(-1);
}
return((*set & (1 << (signo - 1))) != 0);

У нас может возникнуть желание реализовать эти функции в виде коротких макроопределений в  заголовочном файле <signal.h>, но стандарт POSIX.1 требует проверки аргумента с номером сигнала, чтобы в случае недопустимого номера
устанавливалась переменная errno. В  функции сделать это гораздо проще, чем
в макроопределении.

10.12. Функция sigprocmask
В разделе 10.8 мы говорили, что маска сигналов процесса — это набор сигналов,
доставка которых процессу в текущий момент заблокирована. Процесс может получить текущее значение маски, изменить маску или выполнить сразу обе операции с помощью следующей функции.
#include <signal.h>
int sigprocmask(int how, const sigset_t *restrict set,
sigset_t *restrict oset);

Возвращает 0 в случае успеха, –1 — в случае ошибки

Прежде всего, если в аргументе oset передается непустой указатель, через него возвращается текущая маска сигналов процесса.
Далее, если в аргументе set передается непустой указатель, то значение аргумента
how определяет, как должна измениться маска сигналов. В табл. 10.4 приводятся
возможные значения аргумента how. Операция SIG_BLOCK представляет логическую операцию включающего ИЛИ, тогда как SIG_SETMASK  — обычное присваивание. Обратите внимание, что сигналы SIGKILL и SIGSTOP нельзя заблокировать.
Таблица 10.4. Способы изменения текущего значения маски сигналов с помощью
функции sigprocmask
how

Описание

SIG_BLOCK

Новая маска сигналов является объединением текущей маски сигналов
с набором, на который указывает аргумент set. Это означает, что аргумент set
содержит дополнительные сигналы, которые требуется заблокировать.

SIG_UNBLOCK

Новая маска сигналов является пересечением текущей маски сигналов с набором, на который указывает аргумент set. Это означает, что аргумент set
содержит сигналы, которые требуется разблокировать.

SIG_SETMASK

Новая маска сигналов в аргументе set замещает текущую маску сигналов.

Если в аргументе set передается пустой указатель, маска сигналов процесса не изменяется и значение аргумента how игнорируется.

10.13. Функция sigpending   

415

После вызова функции sigprocmask, если имеются какие-либо разблокированные
сигналы, ожидающие обработки, по меньшей мере один из них будет доставлен
приложению перед возвратом из функции.
Функция sigprocmask определена только для однопоточных процессов. Для работы с масками сигналов в  многопоточных приложениях предоставляются отдельные функции.
Мы обсудим их в разделе 12.8.

Пример
В листинге 10.10 приводится функция, которая выводит имена сигналов, составляющих маску сигналов вызывающего процесса. Мы будем использовать эту
функцию в листингах 10.14 и 10.15.
Листинг 10.10. Вывод маски сигналов процесса
#include "apue.h"
#include <errno.h>
void
pr_mask(const char *str)
{
sigset_t
sigset;
int
errno_save;
errno_save = errno;/* функция может вызываться из обработчиков сигналов */
if (sigprocmask(0, NULL, &sigset) < 0)
err_ret("ошибка вызова функции sigprocmask");
} else {
printf("%s", str);
if (sigismember(&sigset, SIGINT))
printf(" SIGINT ");
if (sigismember(&sigset, SIGQUIT))
printf(" SIGQUIT ");
if (sigismember(&sigset, SIGUSR1))
printf(" SIGUSR1 ");
if (sigismember(&sigset, SIGALRM))
printf(" SIGALRM ");

}
}

/* здесь можно продолжить список сигналов */
printf("\n");

errno = errno_save; /* восстановить errno */

Чтобы не «раздувать» листинг, мы не выполняем проверку наличия в маске сигналов каждого сигнала из табл. 10.1 (см. упражнение 10.9).

10.13. Функция sigpending
Функция sigpending возвращает набор сигналов, доставка которых заблокирована и которые в данный момент ожидают обработки. Набор сигналов возвращается
через аргумент set.

416    Глава 10. Сигналы

#include <signal.h>
int sigpending(sigset_t *set);

Возвращает 0 в случае успеха, –1 — в случае ошибки

Пример
Программа в листинге 10.11 демонстрирует многие из описанных выше возможностей сигналов.
Листинг 10.11. Пример работы с наборами сигналов и с функцией sigprocmask
#include "apue.h"
static void sig_quit(int);
int
main(void)
{
sigset_t

newmask, oldmask, pendmask;

if (signal(SIGQUIT, sig_quit) == SIG_ERR)
err_sys("невозможно перехватить сигнал SIGQUIT");
/*
* Заблокировать SIGQUIT и сохранить маску сигналов.
*/
sigemptyset(&newmask);
sigaddset(&newmask, SIGQUIT);
if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
err_sys("ошибка вызова sigprocmask с аргументом SIG_BLOCK");
sleep(5); /* здесь SIGQUIT останется в ожидании обработки */
if (sigpending(&pendmask) < 0)
err_sys("ошибка вызова функции sigpending");
if (sigismember(&pendmask, SIGQUIT))
printf("\nсигнал SIGQUIT ожидает обработки\n");
/*
* Восстановить маску сигналов, которая разблокирует SIGQUIT.
*/
if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
err_sys("ошибка вызова sigprocmask с аргументом SIG_SETMASK");
printf("сигнал SIGQUIT разблокирован\n");

}

sleep(5); /* здесь SIGQUIT завершит приложение с созданием файла core */
exit(0);

static void
sig_quit(int signo)
{
printf("перехвачен сигнал SIGQUIT\n");
if (signal(SIGQUIT, SIG_DFL) == SIG_ERR)
err_sys("невозможно переустановить диспозицию сигнала SIGQUIT");
}

10.13. Функция sigpending   

417

Процесс блокирует сигнал SIGQUIT, предварительно сохранив текущую маску
сигналов для последующего восстановления, и затем приостанавливается на 5 секунд. Любой сигнал SIGQUIT, сгенерированный в  этот промежуток времени, заблокируется и не будет доставлен процессу, пока не окажется разблокированным.
Перед последней 5-секундной приостановкой проверяется наличие ожидающего
обработки сигнала SIGQUIT, после чего блокировка сигнала снимается.
Обратите внимание, что сначала мы сохранили маску сигналов, а затем заблокировали сигнал. Чтобы разблокировать его, мы воспользовались операцией SIG_
SETMASK, с  помощью которой восстановили прежнее значение маски сигналов.
Как вариант, можно было бы использовать для разблокирования сигнала операцию SIG_UNBLOCK. Однако необходимо понимать, что если мы пишем функцию,
которая может быть использована в других приложениях, и в этой функции мы
должны заблокировать некоторый сигнал, мы не можем использовать операцию
SIG_UNBLOCK для разблокирования сигнала. В таких случаях для восстановления
первоначального значения маски следует использовать операцию SET_SIGMASK,
потому что возможно, что перед обращением к функции вызывающая программа
уже заблокировала этот сигнал. Мы увидим это на примере функции system в разделе 10.18.
Если сигнал SIGQUIT будет сгенерирован во время этой приостановки, ожидающий обработки сигнал окажется разблокированным и  будет доставлен процессу перед возвратом из функции sigprocmask. Мы обнаружим это, так как вызов
функции printf в обработчике сигнала произойдет раньше, чем вызов функции
printf, следующий за вызовом sigprocmask.
После этого процесс приостановится еще на 5 секунд. Если в течение этого периода будет сгенерирован сигнал SIGQUIT, он завершит процесс, поскольку в момент
перехвата сигнала мы переустановили его диспозицию в значение по умолчанию.
В следующем ниже выводе символы ^\ показаны там, где мы нажимали комбинацию клавиш Control-\ — терминальный символ завершения процесса.
$ ./a.out
^\
сигнал SIGQUIT ожидает обработки
перехвачен сигнал SIGQUIT
сигнал SIGQUIT разблокирован
^\Quit(coredump)
$ ./a.out
^\^\^\^\^\^\^\^\^\^\
сигнал SIGQUIT ожидает обработки
перехвачен сигнал SIGQUIT
сигнал SIGQUIT разблокирован
^\Quit(coredump)

сгенерировать сигнал SIGQUIT
(до завершения 5-секундной задержки)
по окончании задержки
в обработчике сигнала
после выхода из sigprocmask
повторная генерация сигнала SIGQUIT
сгенерировать сигнал SIGQUIT 10 раз
(до завершения 5-секундной задержки)
доставлен только один сигнал
повторная генерация сигнала SIGQUIT

Сообщение Quit(coredump) выводится командной оболочкой, когда она обнаруживает аварийное завершение дочернего процесса. Обратите внимание, что, запустив программу повторно, мы десять раз сгенерировали сигнал SIGQUIT, а когда разблокировали его, процессу был доставлен только один сигнал. Это говорит
о том, что в данной системе сигналы не помещаются в очередь.

418    Глава 10. Сигналы

10.14. Функция sigaction
Функция sigaction позволяет проверить действие, связанное с  определенным
сигналом, изменить его или выполнить обе эти операции. Эта функция служит
заменой функции signal из ранних версий UNIX. В конце этого раздела мы продемонстрируем реализацию функции signal на основе sigaction.
#include <signal.h>
int sigaction(int signo, const struct sigaction *restrict act,
struct sigaction *restrict oact);

Возвращает 0 в случае успеха, –1 — в случае ошибки
Через аргумент signo передается номер сигнала, диспозицию которого требуется
получить или изменить. Если в аргументе act передается непустой указатель, диспозиция сигнала изменяется. Если в  аргументе oact передается непустой указатель, функция возвращает предыдущее значение диспозиции сигнала, помещая
его по указанному в oact адресу. Эта функция использует следующую структуру:
struct sigaction {
void
(*sa_handler)(int); /*
/*
sigset_t sa_mask;
/*
int
sa_flags;
/*

адрес функции — обработчика сигнала, */
или SIG_IGN, или SIG_DFL */
дополнительные блокируемые сигналы */
флаги, табл.10.5 */

/* альтернативный обработчик сигнала */
void
(*sa_sigaction)(int, siginfo_t *, void *);

};

Если при изменении диспозиции сигнала поле sa_handler содержит адрес функции-обработчика (а не константы SIG_IGN или SIG_DEL), поле sa_mask определяет
набор сигналов, которые будут добавлены к  маске сигналов процесса перед вызовом функции-обработчика. Перед возвратом из обработчика сигнала маска сигналов будет автоматически восстановлена в прежнее состояние. Таким способом
можно блокировать определенные сигналы на время работы функции-обработчика. Перед доставкой сигнала, когда вызывается функция-обработчик, сам сигнал
также включается в маску сигналов; тем самым блокируется доставка того же самого сигнала на время выполнения обработчика. В разделе 10.8 уже говорилось,
что заблокированные сигналы обычно не помещаются в очередь. Если сигнал был
сгенерирован пять раз за период времени, когда он был заблокирован, функцияобработчик, как правило, вызывается только один раз.
После установки диспозиции сигнала она остается неизменной, пока явно не изменится вызовом функции sigaction. В отличие от ранних версий UNIX с их ненадежными сигналами, стандарт POSIX.1 требует, чтобы действие сигнала оставалось неизменным, пока явно не будет изменено программой.
Поле sa_flags структуры act определяет различные параметры обработки этого
сигнала. В  табл. 10.5 приводится подробное описание всех возможных флагов.
Если в колонке SUS стоит галочка, соответствующий флаг определен как часть

10.14. Функция sigaction   

419

базовых спецификаций стандарта POSIX.1. Если в этой колонке стоит аббревиатура XSI, флаг определен как расширение XSI.
Поле sa_sigaction представляет альтернативную функцию обработки сигнала
при использовании флага SA_SIGINFO. Реализации могут использовать для хранения указателей из полей sa_handler и sa_sigaction одну и ту же область памяти,
поэтому приложения должны заполнять только одно из них.
Таблица 10.5. Флаги (sa_flags) обработки каждого сигнала
Флаг

SUS

FreeBSD
8.0

SA_INTERRUPT

Linux Mac OS X Solaris
3.2.0
10.6.8
10

Описание

Системный вызов, прерываемый
сигналом, не должен перезапускаться автоматически (в XSI —
по умолчанию для sigaction).
Дополнительная информация
в разделе 10.5



SA_NOCLDSTOP











Для сигнала SIGCHLD — не
генерировать этот сигнал при
приостановке дочернего процесса. Разумеется, при завершении
дочернего процесса этот сигнал
все равно будет сгенерирован
(но обратите внимание на флаг
SA_NOCLDWAIT ниже). Если установлен этот флаг, сигнал SIGCHLD
также не будет генерироваться
и при возобновлении работы
дочернего процесса после приостановки

SA_NOCLDWAIT











Для сигнала SIGCHLD — предотвращает создание процессовзомби по завершении дочерних
процессов. Если родительский
процесс впоследствии вызовет
функцию wait, он окажется заблокированным, пока последний
дочерний процесс не завершится, после чего wait вернет
значение –1 и код ошибки ECHLD
в переменной errno (раздел 10.7)

SA_NODEFER











Не блокировать сигнал автоматически при вызове функции-обработчика (если, конечно, сигнал
не включен в маску sa_mask).
Заметьте, что такое поведение
соответствует поведению ненадежных сигналов в ранних
версиях UNIX

420    Глава 10. Сигналы
Таблица 10.5 (окончание)
Флаг
SA_ONSTACK

SA_RESETHAND

SUS

FreeBSD
8.0

Linux Mac OS X Solaris
3.2.0
10.6.8
10

XSI









Доставлять сигнал на альтернативном стеке, если таковой был
объявлен обращением к функции sigaltstack(2)











На входе в функцию-обработчик
установить диспозицию сигнала
в значение SIG_DFL и сбросить
флаг SA_SIGINFO. Обратите
внимание, что такое поведение
соответствует поведению ненадежных сигналов в ранних
версиях UNIX. Однако диспозицию сигналов SIGILL и SIGTRAP
нельзя переустановить автоматически. При наличии этого флага
функция sigaction ведет себя,
как если бы был установлен флаг

Описание

SA_NODEFER
SA_RESTART











Производить автоматический
перезапуск системных вызовов,
прерванных данным сигналом
(раздел 10.5)

SA_SIGINFO











По этому флагу в обработчик
сигнала передается дополнительная информация: указатели
на структуру siginfo и контекст
процесса

Обычно прототип функции — обработчика сигнала выглядит так:
void handler(int signo);

но если установлен флаг SA_SIGINFO, прототип функции-обработчика выглядит
иначе:
void handler(int signo, siginfo_t *info, void *context);

Структура siginfo_t хранит информацию о  причинах появления сигнала. Пример определения структуры приводится ниже. Все POSIX-совместимые реализации должны включать в эту структуру как минимум поля si_signo и si_code. Дополнительно XSI-совместимые реализации должны включать в состав структуры
следующие поля:
struct siginfo {
int
si_signo;

/* номер сигнала */

10.14. Функция sigaction   

int
int
pid_t
uid_t

421

si_errno;
si_code;
si_pid;
si_uid;

/* если не 0, то значение errno из <errno.h> */
/* дополнительная информация (зависит от сигнала) */
/* идентификатор процесса-отправителя */
/* реальный идентификатор пользователя */
/* процесса-отправителя */
void
*si_addr; /* адрес, где возникла ошибка */
int
si_status; /* код завершения или номер сигнала */
union sigval si_value; /* значение, зависящее от приложения */
/* далее могут быть определены дополнительные поля */

};

Объединение sigval содержит следующие поля:
int
sival_int;
void *sival_ptr;

При доставке сигнала приложение передает целое число в поле si_value.sival_
int или указатель в поле si_value.sival_ptr.
В табл. 10.6 перечислены значения поля si_code для различных сигналов, определяемых стандартом Single UNIX Specification. Обратите внимание, что реализации могут определять дополнительные значения.
Для сигнала SIGCHLD устанавливаются значения полей si_pid, si_status и si_uid.
Для сигналов SIGBUS, SIGILL, SIGFPE и SIGSEGV в поле si_addr заносится адрес обнаруженной ошибки, хотя адрес может быть неточным. Поле si_errno содержит
код ошибки, который соответствует ситуации, вызвавшей появление сигнала,
хотя это во многом зависит от реализации.
В аргументе context обработчику сигнала передается нетипизированный указатель, который можно привести к  типу struct ucontext_t, идентифицирующему
контекст процесса в  момент доставки сигнала. Эта структура содержит следующие поля:
ucontext_t *uc_link;
sigset_t
stack_t
mcontext_t

/*
/*
uc_sigmask; /*
uc_stack;
/*
uc_mcontext; /*

указатель на контекст, который будет */
восстановлен при выходе из текущего контекста */
хранит сигналы, блокируемые в данном контексте */
стек, используемый данным контекстом */
аппаратное представление сохраненного контекста */

Поле uc_stack описывает стек, используемый текущим контекстом. Оно содержит по меньшей мере следующие поля:
void
*ss_sp;
/* указатель на дно стека */
size_t ss_size; /* размер стека */
int
ss_flags; /* флаги */

Если реализация поддерживает расширения сигналов реального времени, установка обработчика сигнала с  флагом SA_SIGINFO гарантирует, что сигналы будут ставиться
в очередь. Для приложений реального времени зарезервирован отдельный диапазон сигналов.
Через структуру siginfo можно передавать данные приложения при условии, что сигнал
будет генерироваться функцией sigqueue (раздел 10.20).

422    Глава 10. Сигналы
Таблица 10.6. Значения кодов в структуре siginfo_t
Сигнал
SIGILL

SIGFPE

SIGSEGV
SIGBUS

SIGTRAP
SIGCHLD

Любой
сигнал

Код

Значение

ILL_ILLOPC

Недопустимая инструкция

ILL_ILLOPN

Недопустимый операнд

ILL_ILLADR

Недопустимый режим адресации

ILL_ILLTRP

Некорректная ловушка

ILL_PRVOPC

Привилегированная операция

ILL_PRVREG

Привилегированный регистр

ILL_COPROC

Ошибка сопроцессора

ILL_BADSTK

Внутренняя ошибка стека

FPE_INTDIV

Деление на ноль при работе с целыми числами

FPE_INTOVF

Переполнение при работе с целыми числами

FPE_FLTDIV

Деление на ноль при работе с вещественными числами

FPE_FLTOVF

Переполнение при работе с вещественными числами

FPE_FLTUND

Нехватка значащих разрядов при работе с вещественными
числами

FPE_FLTRES

Потеря точности при работе с вещественными числами

FPE_FLTINV

Неверная операция при работе с вещественными числами

FPE_FLTSUB

Выход индекса за границы диапазона

SEGV_MAPPER

Адрес не соответствует объекту

SEGV_ACCERR

Недостаточно прав для доступа к объекту

BUS_ADRALN

Неправильное выравнивание адреса

BUS_ADRERR

Несуществующий физический адрес

BUS_OBJERR

Аппаратная ошибка, специфичная для объекта

TRAP_BRKPT

Точка останова процесса

TRAP_TRACE

Ловушка трассировки процесса

CLD_EXITED

Дочерний процесс завершился

CLD_KILLED

Дочерний процесс завершился аварийно (без файла core)

CLD_DUMPED

Дочерний процесс завершился с созданием файла core

CLD_TRAPPED

Сработала ловушка в отлаживаемом дочернем процессе

CLD_STOPPED

Дочерний процесс приостановлен

CLD_CONTINUED

Приостановленный дочерний процесс продолжил выполнение

SI_USER

Сигнал послан функцией kill

SI_QUEUE

Сигнал послан функцией sigqueue

SI_TIMER

Истекло время таймера, установленного функцией timer_

SI_ASYNCIO

Завершено выполнение запрошенной асинхронной операции
ввода/вывода

SI_MESGQ

В очередь сообщений поступило новое сообщение (расширение
реального времени)

settime

10.14. Функция sigaction   

423

Пример — функция signal
Теперь перейдем к  реализации функции signal на основе функции sigaction.
Такую реализацию предусматривают многие платформы (POSIX.1 Rationale утверждает, что это и  было замыслом стандарта POSIX). С  другой стороны, операционные системы с ограниченной совместимостью на уровне двоичных кодов
могут предоставлять функцию signal, поддерживающую устаревшую семантику
ненадежных сигналов. Если вам не требуется поддержка устаревшей семантики
(например, для сохранения обратной совместимости), используйте приводимую
ниже реализацию функции signal или непосредственно функцию sigaction. (Как
вы уже наверняка догадались, чтобы вернуться к  устаревшей семантике, нужно
вызывать функцию sigaction с флагами SA_RESETHAND и  SA_NODEFER.) Все примеры в этой книге, которые обращаются к функции signal, используют функцию,
представленную в листинге 10.12.
Листинг 10.12. Реализация функции signal на основе функции sigaction
#include "apue.h"
/* Надежная версия функции signal() с использованием функции sigaction() */
/* стандарта POSIX. */
Sigfunc *
signal(int signo, Sigfunc *func)
{
struct sigaction
act, oact;
act.sa_handler = func;
sigemptyset(&act.sa_mask);
act.sa_flags = 0;
if (signo == SIGALRM) {
#ifdef SA_INTERRUPT
act.sa_flags |= SA_INTERRUPT;
#endif
} else {
act.sa_flags |= SA_RESTART;
}
if (sigaction(signo, &act, &oact) < 0)
return(SIG_ERR);
return(oact.sa_handler);
}

Обратите внимание, что для инициализации поля sa_mask следует использовать
функцию sigemptyset. Нельзя гарантировать, что act.sa_mask = 0; сделает то же
самое.
Мы преднамеренно пробуем установить флаг SA_RESTART для всех сигналов, кроме
SIGALRM, что дает возможность автоматически перезапускать системные вызовы,
прерванные другими сигналами. Сигнал SIGALRM исключен из этого списка по той
причине, что нам понадобится задавать тайм-ауты для операций ввода/вывода
(лис­тинг 10.7).
В некоторых старых системах, таких как SunOS, определен флаг SA_INTERRUPT.
В  этих системах перезапуск прерванных системных вызовов производится по
умолчанию, поэтому установка этого флага предотвратит автоматический перезапуск прерванных системных вызовов. Linux определяет флаг SA_INTERRUPT

424    Глава 10. Сигналы
для совместимости с  приложениями, использующими его, но в  ней системные
вызовы не перезапускаются по умолчанию, если обработчик установлен функцией sigaction. Стандарт Single UNIX Specification оговаривает, что функция
sigaction не должна перезапускать прерванные системные вызовы, если явно не
указан флаг SA_RESTART.

Пример — функция signal_intr
В листинге 10.13 приводится версия функции signal, которая пытается предотвратить перезапуск любого прерванного системного вызова.
Листинг 10.13. Функция signal_intr
#include "apue.h"
Sigfunc *
signal_intr(int signo, Sigfunc *func)
{
struct sigaction
act, oact;
act.sa_handler = func;
sigemptyset(&act.sa_mask);
act.sa_flags = 0;
#ifdef SA_INTERRUPT
act.sa_flags |= SA_INTERRUPT;
#endif
if (sigaction(signo, &act, &oact) < 0)
return(SIG_ERR);
return(oact.sa_handler);
}

Чтобы повысить переносимость функции, мы используем флаг SA_INTERRUPT для
предотвращения перезапуска прерванных системных вызовов, если он определен
в системе.

10.15. Функции sigsetjmp и siglongjmp
В разделе 7.10 мы говорили о функциях setjmp и longjmp, которые используются
для выполнения дальних, или нелокальных, переходов. Функция longjmp достаточно часто используется в обработчиках сигналов, когда нужно вернуться в главный цикл программы, не выполняя возврат из обработчика. Мы продемонстрировали это в листингах 10.5 и 10.8.
Однако использование функции longjmp сопряжено с одной проблемой. Когда сигнал перехвачен, перед входом в функцию обработки производится автоматическое
добавление текущего сигнала к  маске сигналов процесса. Это препятствует прерыванию обработчика этим же сигналом. Как вы думаете, что произойдет с маской
сигналов, если выполнить дальний переход (longjmp) из функции-обработчика?
В FreeBSD 8.0 и Mac OS X 10.6.8 функции setjmp и longjmp сохраняют и восстанавливают
маску сигналов. Однако Linux 3.2.0 и Solaris 10 этого не делают, хотя Linux предоставляет
возможность поддержки поведения BSD-систем. FreeBSD и Mac OS X предоставляют
функции _setjmp и _longjmp, которые не сохраняют и не восстанавливают маску сигналов.

10.15. Функции sigsetjmp и siglongjmp   

425

Стандарт POSIX.1 не оговаривает воздействие функций setjmp и  longjmp на
маску сигналов  — вместо этого он определяет две новые функции, sigsetjmp
и siglongjmp. Для выхода из обработчика сигнала всегда должны использоваться
эти две функции.
#include <setjmp.h>
int sigsetjmp(sigjmp_buf env, int savemask);

Возвращает 0, если вызвана непосредственно, и ненулевое значение,
если возврат произошел в результате обращения к функции siglongjmp
void siglongjmp(sigjmp_buf env, int val);

Единственное их отличие от функций setjmp и  longjmp заключается в  том, что
функция sigsetjmp принимает один дополнительный аргумент. Если аргумент
savemask содержит ненулевое значение, sigsetjmp сохраняет текущую маску сигналов процесса в буфере env. При вызове siglongjmp, если аргумент env был сохранен в результате вызова sigsetjmp с ненулевым значением savemask, маска сигналов восстанавливается из сохраненного значения.

Пример
Программа в  листинге 10.14 демонстрирует, как производится автоматическое
включение сигнала в  маску сигналов при вызове функции-обработчика. Здесь
также показано использование функций sigsetjmp и siglongjmp.
Листинг 10.14. Пример работы с маской сигналов и функций sigsetjmp и siglongjmp
#include "apue.h"
#include <setjmp.h>
#include <time.h>
static
static
static
static

void
void
sigjmp_buf
volatile sig_atomic_t

int
main(void)
{
if (signal(SIGUSR1,
err_sys("ошибка
if (signal(SIGALRM,
err_sys("ошибка

sig_usr1(int);
sig_alrm(int);
jmpbuf;
canjump;

sig_usr1) == SIG_ERR)
вызова функции signal(SIGUSR1)");
sig_alrm) == SIG_ERR)
вызова функции signal(SIGALRM)");

pr_mask("в начале функции main: "); /* листинг 10.10 */
if (sigsetjmp(jmpbuf, 1)) {
pr_mask("в конце функции main: ");
exit(0);
}
canjump = 1; /* теперь можно выполнить переход */
for ( ; ; )

426    Глава 10. Сигналы

}

pause();

static void
sig_usr1(int signo)
{
time_t starttime;
if (canjump == 0)
return; /* получен неожиданный сигнал, игнорировать */
pr_mask("в начале функции sig_usr1: ");
alarm(3); /* запланировать SIGALRM через 3 секунды */
starttime = time(NULL);
for ( ; ; ) /* ждать 5 секунд */
if (time(NULL) > starttime + 5)
break;
pr_mask("в конце функции sig_usr1: ");

}

canjump = 0;
siglongjmp(jmpbuf, 1); /* переход в функцию main – не возврат */

static void
sig_alrm(int signo)
{
pr_mask("в функции sig_alrm: ");
}

Эта программа демонстрирует методику, которая должна применяться всякий
раз, когда планируется использовать функцию siglongjmp в  обработчике сигнала. Здесь переменная canjump устанавливается в  значение, отличное от нуля,
только после вызова функции sigsetjmp. Значение этой переменной проверяется
в  обработчике сигнала, и  функция siglongjmp вызывается, только когда значение переменной canjump отлично от нуля. Это предотвращает несвоевременный
вызов обработчика сигнала, когда буфер перехода еще не подготовлен функцией
sigsetjmp. (В этой достаточно простой программе все заканчивается практически
сразу же после вызова siglongjmp, но в больших программах обработчик сигнала
может оставаться установленным и после вызова siglongjmp.) Подобного рода защита обычно не требуется при использовании функции longjmp в обычных функциях языка C (в противоположность обработчикам сигналов). Однако учитывая,
что сигнал может быть сгенерирован в любой момент, мы вынуждены предусматривать меры предосторожности в обработчике сигналов.
Здесь мы использовали тип данных sig_atomic_t, который определен стандартом
ISO C для переменных, запись в  которые не может быть прервана. Это означает, например, что переменные этого типа не должны пересекать границы страниц
виртуальной памяти и  доступ к  ним должен осуществляться единственной машинной инструкцией. Кроме того, мы всегда используем спецификатор volatile
с этим типом данных, поскольку доступ к переменной возможен из двух различных потоков управления — из функции main и из обработчика асинхронного сигнала. На рис. 10.1 приводится временная диаграмма для этой программы. Этот
рисунок можно разделить на три части: левая часть соответствует функции main,

10.15. Функции sigsetjmp и siglongjmp   

427

центральная часть — функции sig_usr1 и правая часть — функции sig_alrm. Пока
выполнение процесса происходит в левой части, маска сигналов пуста (нет блокируемых сигналов). В  центральной части в  маске сигналов находится сигнал
SIGUSR1. В правой части в маске сигналов находятся сигналы SIGUSR1 и  SIGALRM.
main
signal()
signal()
pr_mask()
sigsetjmp()
pause()
доставлен сигнал SIGUSR1

sig_usr1
pr_mask()
alarm()
time()
time()
time()
доставлен сигнал SIGALRM

возврат из обработчика сигнала

sigsetjmp()
pr_mask()
exit()

sig_alrm
pr_mask()
return()

pr_mask()
siglongjmp()

Рис. 10.1. Временная диаграмма программы, обрабатывающей два сигнала

А теперь посмотрим, что выведет программа из листинга 10.14 после запуска:
$ ./a.out &
запуск процесса в фоновом режиме
в начале функции main:
[1]
531
командная оболочка вывела идентификатор процесса
$ kill -USR1 531
посылаем процессу сигнал SIGUSR1
в начале функции sig_usr1: SIGUSR1
$ в функции sig_alrm: SIGUSR1 SIGALRM
в конце функции sig_usr1: SIGUSR1
в конце функции main:
нажимаем ввод
[1] + Done
./a.out &

Как мы и ожидали, на входе в обработчик сигнала перехваченный сигнал добавляется в маску сигналов процесса. После выхода из обработчика маска сигналов
восстанавливается. Кроме того, функция siglongjmp восстанавливает маску сигналов, сохраненную вызовом функции sigsetjmp.
Если в программе из листинга 10.14 заменить функции sigsetjmp и siglongjmp на
setjmp и  longjmp в Linux (или _setjmp и  _longjmp в FreeBSD), последняя строка,
выведенная программой, будет такой
в конце функции main: SIGUSR1

428    Глава 10. Сигналы
Это означает, что после вызова longjmp функция main продолжит работу с заблокированным сигналом SIGUSR1, а это, скорее всего, не то, что нам нужно.

10.16. Функция sigsuspend
Мы рассмотрели порядок изменения маски сигналов процесса, с помощью которой можно заблокировать или разблокировать отдельные сигналы. Эту методику
можно также использовать для защиты критических участков программы, выполнение которых не должно прерываться сигналами. А если понадобится разблокировать сигнал и затем с помощью функции pause дождаться его доставки? Если
предположить, что ожидаемый сигнал — SIGINT, неправильная реализация могла
бы выглядеть так:
sigset_t newmask, oldmask;
sigemptyset(&newmask);
sigaddset(&newmask, SIGINT);
/* заблокировать SIGINT и сохранить текущую маску сигналов */
if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
err_sys("ошибка выполнения операции SIG_BLOCK");
/* критический участок программы */
/* восстановить прежнюю маску сигналов, в которой SIGINT не заблокирован */
if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
err_sys("ошибка выполнения операции SIG_SETMASK");
/* интервал времени, когда доставка сигнала станет проблемой */
pause(); /* дождаться доставки сигнала */
/* продолжить работу */

Если послать сигнал процессу, когда он еще заблокирован, доставка сигнала будет отложена до тех пор, пока процесс не разблокирует его. С точки зрения приложения это выглядит так, как если бы сигнал был сгенерирован между операцией разблокирования и вызовом функции pause (в зависимости от реализации
механизма сигналов в  ядре). Если все происходит именно так или если сигнал
действительно будет доставлен в промежутке между снятием блокировки и вызовом функции pause, возникнут определенные сложности. Сигнал, доставленный
в этот промежуток, приведет к тому, что функция pause может заблокировать процесс «навечно», если сигнал не будет сгенерирован еще хотя бы раз. Это еще одна
проблема, связанная с ранними ненадежными сигналами.
Чтобы преодолеть ее, необходим способ, с помощью которого можно было бы производить восстановление маски сигналов и приостанавливать процесс атомарно.
Такую возможность дает функция sigsuspend.
#include <signal.h>
int sigsuspend(const sigset_t *sigmask);

Возвращает –1 и записывает в переменную errno код ошибки EINTR

10.16. Функция sigsuspend   

429

Маска сигналов, передаваемая в аргументе sigmask, переносится в маску сигналов
процесса. Затем процесс приостанавливается, пока не будет перехвачен ожидаемый сигнал или какой-то другой сигнал не завершит процесс. Если сигнал был
перехвачен и функция-обработчик вернула управление, функция sigsuspend также вернет управление вызывающему процессу и при этом восстановит маску сигналов процесса в состояние, предшествовавшее ее вызову.
Обратите внимание, что эта функция всегда возвращает признак ошибки с кодом
EINTR в  переменной errno (который говорит о  том, что выполнение системного
вызова было прервано сигналом).

Пример
В листинге 10.15 демонстрируется корректный способ защиты критического
участка программы от конкретного сигнала.
Листинг 10.15. Защита критического участка программы от сигнала
#include "apue.h"
static void sig_int(int);
int
main(void)
{
sigset_t

newmask, oldmask, waitmask;

pr_mask("в начале программы: ");
if (signal(SIGINT, sig_int) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGINT)");
sigemptyset(&waitmask);
sigaddset(&waitmask, SIGUSR1);
sigemptyset(&newmask);
sigaddset(&newmask, SIGINT);
/*
* Заблокировать SIGINT и сохранить текущую маску сигналов.
*/
if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
err_sys("ошибка выполнения операции SIG_BLOCK");
/*
* Критический участок программы.
*/
pr_mask("внутри критического участка: ");
/*
* Промежуток времени, когда может быть доставлен любой сигнал,
* кроме SIGUSR1.
*/
if (sigsuspend(&waitmask) != -1)
err_sys("ошибка вызова функции sigsuspend");
pr_mask("после выхода из sigsuspend: ");
/*

430    Глава 10. Сигналы
* Восстановить прежнюю маску сигналов, которая разблокирует SIGINT.
*/
if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
err_sys("ошибка выполнения операции SIG_SETMASK");
/*
* И продолжить работу ...
*/
pr_mask("в конце программы: ");
}

exit(0);

static void
sig_int(int signo)
{
pr_mask("\nв функции sig_int: ");
}

Возвращая управление, функция sigsuspend восстанавливает маску сигналов
в  состояние, предшествовавшее ее вызову. В  данном примере к  моменту вызова
этой функции сигнал SIGINT был заблокирован. Поэтому мы восстанавливаем маску сигналов, записывая туда значение, сохраненное ранее (oldmask).
Запустив программу из листинга 10.15, мы получили
$ ./a.out
в начале программы:
внутри критического участка: SIGINT
^C
ввод символа прерывания
в функции sig_int: SIGUSR1
после выхода из sigsuspend: SIGINT
в конце программы:

Перед обращением к  функции sigsuspend в  существующую маску сигналов мы
добавили сигнал SIGUSR1. Затем внутри обработчика маска изменилась. Далее
видно, что когда sigsuspend возвращала управление, она восстановила маску сигналов.

Пример
Функция sigsuspend также используется для приостановки процесса, пока обработчик сигнала не установит глобальную переменную. Программа в  листинге 10.16 перехватывает два сигнала, SIGINT и  SIGQUIT, но при этом продолжение
работы возможно только после перехвата сигнала SIGQIUIT.
Листинг 10.16. Функция sigsuspend приостанавливает процесс, пока не будет
установлена глобальная переменная
#include "apue.h"
volatile sig_atomic_t quitflag; /* обработчик сигнала записывает сюда */
/* ненулевое значение */
static void
sig_int(int signo) /* единый обработчик для SIGINT и SIGQUIT */
{
if (signo == SIGINT)
printf("\nпрерывание\n");

10.16. Функция sigsuspend   

}

431

else if (signo == SIGQUIT)
quitflag = 1; /* установить флаг для главного цикла */

int
main(void)
{
sigset_t

newmask, oldmask, zeromask;

if (signal(SIGINT, sig_int) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGINT)");
if (signal(SIGQUIT, sig_int) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGQUIT)");
sigemptyset(&zeromask);
sigemptyset(&newmask);
sigaddset(&newmask, SIGQUIT);
/*
* Заблокировать SIGQUIT и сохранить текущую маску сигналов.
*/
if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
err_sys("ошибка выполнения операции SIG_BLOCK");
while (quitflag == 0)
sigsuspend(&zeromask);
/*
* Сигнал SIGQUIT был перехвачен и к настоящему моменту
* опять заблокирован.
*/
quitflag = 0;
/*
* Восстановить маску сигналов, в которой SIGQUIT разблокирован.
*/
if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
err_sys("ошибка выполнения операции SIG_SETMASK");
}

exit(0);

Примерный результат работы программы:
$ ./a.out
^С
прерывание
^С
прерывание
^C
прерывание
^\ $

ввод символа прерывания
ввод символа прерывания еще раз
и еще раз
а теперь ввод символа завершения

Для сохранения переносимости между POSIX-совместимыми системами и системами, несовместимыми со стандартом POSIX, но поддерживающими стандарт ISO C, необходимо
только одно: внутри обработчика сигнала присвоить некоторое значение переменной типа
sig_atomic_t. Стандарт POSIX.1 пошел дальше и определил список функций, которые можно
безопасно вызывать из обработчика сигнала (см. табл. 10.3), но в этом случае программа,
вероятно, не будет правильно работать в системах, не поддерживающих стандарт POSIX.

432    Глава 10. Сигналы

Пример
Следующий пример показывает, как с помощью сигналов синхронизировать работу родительского и дочернего процессов. В листинге 10.17 представлена реализация пяти процедур  — TELL_WAIT, TELL_PARENT, TELL_CHILD, WAIT_PARENT и  WAIT_
CHILD — из раздела 8.9.
Листинг 10.17. Процедуры для синхронизации родительского и дочернего процессов
#include "apue.h"
static volatile sig_atomic_t sigflag; /* устанавливается обработчиком */
/* в ненулевое значение */
static sigset_t newmask, oldmask, zeromask;
static void
sig_usr(int signo) /* единый обработчик для сигналов SIGUSR1 и SIGUSR2 */
{
sigflag = 1;
}
void
TELL_WAIT(void)
{
if (signal(SIGUSR1, sig_usr) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGUSR1)");
if (signal(SIGUSR2, sig_usr) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGUSR2)");
sigemptyset(&zeromask);
sigemptyset(&newmask);
sigaddset(&newmask, SIGUSR1);
sigaddset(&newmask, SIGUSR2);

}

/*
* Заблокировать сигналы SIGUSR1 и SIGUSR2,
* и сохранить текущую маску сигналов.
*/
if (sigprocmask(SIG_BLOCK, &newmask, &oldmask) < 0)
err_sys("ошибка выполнения операции SIG_BLOCK");

void
TELL_PARENT(pid_t pid)
{
kill(pid, SIGUSR2); /* сообщить родительскому процессу, что мы готовы */
}
void
WAIT_PARENT(void)
{
while (sigflag == 0)
sigsuspend(&zeromask); /* ждать ответа от родительского процесса */
sigflag = 0;
/*
* Восстановить маску сигналов в начальное состояние.
*/
if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
err_sys("ошибка выполнения операции SIG_SETMASK");

10.16. Функция sigsuspend   

433

}
void
TELL_CHILD(pid_t pid)
{
kill(pid, SIGUSR1); /* сообщить дочернему процессу, что мы готовы */
}
void
WAIT_CHILD(void)
{
while (sigflag == 0)
sigsuspend(&zeromask); /* дождаться ответа от дочернего процесса */
sigflag = 0;

}

/*
* Восстановить маску сигналов в начальное состояние.
*/
if (sigprocmask(SIG_SETMASK, &oldmask, NULL) < 0)
err_sys("ошибка выполнения операции SIG_SETMASK");

В этом примере мы использовали сигналы, определяемые пользователем: сигнал
SIGUSR1 передается от родительского процесса дочернему, а  SIGUSR2 — от дочернего родительскому. В листинге 15.3 мы покажем другую реализацию этих пяти
функций с использованием неименованных каналов.
Функция sigsuspend прекрасно подходит для случая, когда процесс должен приостановить работу, пока ему не будет доставлен сигнал (как это было в двух предыдущих примерах), но что, если нам необходимо во время ожидания сигнала обращаться к другим системным функциям? К сожалению, эта проблема не имеет
достаточно надежного решения, за исключением выполнения приложения в нескольких потоках, из которых один выделяется специально для обработки сигналов, о чем мы будем говорить в разделе 12.8.
Если отказаться от многопоточной модели, лучшее, что можно предложить, — это
записывать определенные значения в глобальные переменные во время обработки сигналов. Например, если мы выполняем перехват сигналов SIGINT и  SIGALRM
и устанавливаем обработчики сигналов с помощью функции signal_intr, доставка сигналов будет прерывать любые медленные системные вызовы. Чаще всего эти
сигналы будут доставляться во время работы функции read, ожидающей окончания операции ввода с медленного устройства. (Особенно это относится к сигналу
SIGALRM, который используется для прерывания затянувшихся операций ввода/
вывода.) Вот как мог бы выглядеть код, обслуживающий такую ситуацию:
if (intr_flag) /* флаг устанавливается обработчиком сигнала SIGINT */
handle_intr();
if (alrm_flag) /* флаг устанавливается обработчиком сигнала SIGALRM */
handle_alrm();
/* сигналы, появившиеся в этот момент времени, будут утеряны */
int n;
while ((n = read( ... )) < 0) {
if (errno == EINTR) {
if (alrm_flag)

434    Глава 10. Сигналы
handle_alrm();
else if (intr_flag)
handle_intr();
} else {
/* обработка других ошибок */
}

}
if (n == 0) {
/* конец файла */
} else {
/* обработать прочитанные данные */
}

Мы проверяем значения каждой глобальной переменной перед вызовом read
и всякий раз после того, как она возвращает ошибку прерывания системного вызова. Проблема возникает, когда происходит перехват сигнала между первыми
двумя условными операторами и последующим вызовом функции read. Сигналы,
доставленные в  этом промежутке времени, будут утеряны, что отмечено в  комментарии. Обработчики сигналов, разумеется, будут вызваны, и  они установят
соответствующие глобальные переменные, но read никогда не вернет управление
(если, конечно, какие-либо данные не будут готовы для чтения).
Нам требуется выполнить следующую последовательность действий.
1.	 Заблокировать сигналы SIGINT и SIGALRM.
2.	 Проверить значения двух глобальных переменных, чтобы проверить, был ли
доставлен какой-либо сигнал, и при необходимости выполнить соответствующие действия.
3.	 Вызвать read (или любой другой системный вызов) и разблокировать оба сигнала атомарно.
Функция sigsuspend может помочь, только если на шаге 3 используется операция
pause.

10.17. Функция abort
Ранее упоминалось, что вызов функции abort приводит к аварийному завершению процесса.
#include <stdlib.h>
void abort(void);

Эта функция никогда не возвращает управление
Эта функция посылает сигнал SIGABRT вызывающему процессу. (Процессы не
должны игнорировать этот сигнал.) Стандарт ISO C определяет, что функция
abort должна извещать операционную систему об аварийном завершении с помощью вызова raise(SIGABRT).

10.17. Функция abort   

435

Стандарт ISO C требует, чтобы функция abort никогда не возвращала управление, даже когда приложение перехватывает сигнал SIGABRT. Если сигнал перехватывается, единственный способ для обработчика не вернуть управление в вызывающий процесс  — вызвать одну из функций: exit, _exit, _Exit, longjmp или
siglongjmp. (Различия между longjmp и siglongjmp обсуждались в разделе 10.15.)
Помимо этого, стандарт POSIX.1 указывает, что функция abort должна выполняться даже в  том случае, если процесс заблокировал или игнорирует сигнал
SIGABRT.
Процессу позволено перехватывать сигнал SIGABRT, чтобы он мог выполнить необходимые действия перед завершением. Если процесс не завершается из обработчика сигнала, стандарт POSIX.1 указывает, что функция abort должна завершить процесс, когда обработчик сигнала вернет управление.
Стандарт ISO C оставляет на усмотрение реализации решение вопроса о сбросе
буферов ввода/вывода и  удалении временных файлов (раздел 5.13). Стандарт
POSIX.1 пошел гораздо дальше и  требует, чтобы функция abort, если она завершает процесс, воздействовала на открытые потоки ввода/вывода так же, как
функция fclose.
В ранних версиях System V функция abort генерировала сигнал SIGIOT. Кроме того, допускалась возможность игнорировать или перехватывать сигнал. В последнем случае, если
обработчик возвращал управление как обычно, то и функция abort возвращала управление
вызывающему процессу.
В 4.3BSD генерировался сигнал SIGILL, но перед этим функция abort снимала блокировку
с сигнала и сбрасывала его диспозицию в значение SIG_DFL (завершение с созданием файла
core). Это не позволяло процессам игнорировать сигнал или перехватывать его.
Традиционно различные реализации функции abort по-разному обслуживали потоки ввода/
вывода. Если необходимо, чтобы перед аварийным завершением все потоки ввода/вывода
сбрасывались должным образом, это нужно сделать перед вызовом функции abort. Именно
так делает наша функция err_dump (приложение B).
Поскольку в большинстве реализаций UNIX функция tmpfile сразу же вызывает unlink,
проблема удаления временных файлов, о которой предупреждает стандарт ISO C, отпадает сама собой.

Пример
В листинге 10.18 приводится реализация функции abort, соответствующая требованиям стандарта POSIX.1.
Листинг 10.18. Реализация функции abort, соответствующая требованиям
стандарта POSIX.1
#include
#include
#include
#include

<signal.h>
<stdio.h>
<stdlib.h>
<unistd.h>

void
abort(void) /* функция abort() в стиле POSIX */
{

436    Глава 10. Сигналы
sigset_t
struct sigaction

mask;
action;

/*
* Вызывающий процесс не может игнорировать SIGABRT,
* иначе – сбросить диспозицию сигнала в значение по умолчанию.
*/
sigaction(SIGABRT, NULL, &action);
if (action.sa_handler == SIG_IGN) {
action.sa_handler = SIG_DFL;
sigaction(SIGABRT, &action, NULL);
}
if (action.sa_handler == SIG_DFL)
fflush(NULL); /* сбросить все буферы потоков ввода-вывода */
/*
* Вызывающий процесс не может заблокировать SIGABRT;
* убедитесь, что он не заблокирован.
*/
sigfillset(&mask);
sigdelset(&mask, SIGABRT);
/* в маске разблокирован только SIGABRT */
sigprocmask(SIG_SETMASK, &mask, NULL);
kill(getpid(), SIGABRT);
/* послать сигнал */

}

/*
* Если мы вернулись сюда, значит, процесс обработал SIGABRT
* и вернул управление.
*/
fflush(NULL);
/* сбросить все буферы */
action.sa_handler = SIG_DFL;
sigaction(SIGABRT, &action, NULL); /* установить диспозицию сигнала */
/* в значение по умолчанию*/
sigprocmask(SIG_SETMASK, &mask, NULL); /* на всякий случай ... */
kill(getpid(), SIGABRT);
/* и еще раз */
exit(1);
/* этот вызов никогда не выполнится... */

Прежде всего мы проверяем, будет ли выполнено действие по умолчанию для сигнала, — если это так, сбрасываем все буферы стандартных потоков ввода/вывода. Это не равносильно вызову функции fclose (поскольку мы лишь сбрасываем
буферы, а  не закрываем потоки), но система сама закроет все открытые файлы,
когда процесс завершится. Если процесс перехватил сигнал и вернул управление,
мы опять сбрасываем все буферы ввода/вывода, поскольку процесс мог выводить
некоторые данные в  обработчике сигнала. Единственное, чего мы не сможем,  —
вызвать функцию _exit или _Exit из обработчика. В  этом случае все данные,
оставшиеся в  буферах ввода/вывода, будут утеряны. Но мы будем исходить из
предположения, что вызывающий процесс просто не пожелал сбрасывать содержимое буферов.
В разделе 10.9 мы говорили, что если вызов функции kill сгенерирует сигнал для
вызывающего процесса и этот сигнал не заблокирован (что гарантирует функция
из листинга 10.18), этот сигнал (или любой другой незаблокированный сигнал,
ожидающий обработки) будет доставлен процессу еще до выхода из функции
kill. В  данном случае мы блокируем доставку всех сигналов, за исключением
SIGABRT, поэтому мы наверняка знаем, что если вызов kill вернул управление,
значит, сигнал был перехвачен и обработан процессом.

10.18. Функция system   

437

10.18. Функция system
В разделе 8.13 мы приводили пример реализации функции system. Однако эта версия не обрабатывала сигналы. Стандарт POSIX.1 требует, чтобы функция system
игнорировала сигналы SIGINT и  SIGQUIT и  блокировала сигнал SIGCHLD. Прежде
чем продемонстрировать версию, которая обрабатывает сигналы, мы расскажем,
почему это необходимо.

Пример
Программа в листинге 10.19 использует версию функции system из раздела 8.13
для вызова редактора ed(1). (Этот редактор уже давно входит в состав UNIX. Мы
использовали его потому, что он перехватывает и  обрабатывает сигналы SIGINT
и  SIGQUIT. Если запустить редактор ed из командной оболочки и  ввести символ
прерывания, он перехватит его и выведет символ «?». Кроме того, программа ed
устанавливает диспозицию сигнала SIGQUIT в  значение SIG_IGN.) Программа из
листинга 10.19 перехватывает сигналы SIGINT и SIGCHLD. Запустив ее, мы получим
следующее:
$ ./a.out
a
включить режим добавления текста в буфер редактора
Это одна строка текста
.
точка на отдельной строке выключает режим добавления
1,$p
вывести строки из буфера с первой по последнюю,
чтобы увидеть его содержимое
Это одна строка текста
w temp.foo
записать буфер в файл
23
редактор сообщает, что записано 23 байта
q
выйти из редактора
перехвачен сигнал SIGCHLD

Когда редактор завершает работу, система посылает родительскому процессу
(a.out) сигнал SIGCHLD. Мы перехватываем его и возвращаем управление из обработчика сигнала. Родительский процесс должен это делать, если желает знать,
когда завершился дочерний процесс. Доставка этого сигнала родительскому процессу должна быть заблокирована на время работы функции system, как того
требует стандарт POSIX.1. Иначе процесс, запустивший функцию system, будет
думать, что завершился один из его собственных дочерних процессов. После доставки сигнала вызывающий процесс должен обратиться к одной из функций семейства wait, чтобы получить код завершения дочернего процесса.
Листинг 10.19. Вызов редактора ed с помощью функции system
#include "apue.h"
static void
sig_int(int signo)
{
printf("перехвачен сигнал SIGINT\n");
}
static void
sig_chld(int signo)

438    Глава 10. Сигналы
{
}

printf("перехвачен сигнал SIGCHLD\n");

int
main(void)
{
if (signal(SIGINT, sig_int) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGINT)");
if (signal(SIGCHLD, sig_chld) == SIG_ERR)
err_sys("ошибка вызова функции signal(SIGCHLD)");
if (system("/bin/ed") < 0)
err_sys("ошибка вызова функции system()");
exit(0);
}

Если запустить программу еще раз и отправить ей сигнал SIGINT, мы получим следующий результат:
$ ./a.out
a
привет, мир
.
1,$p

включить режим добавления текста в буфер редактора

привет, мир
w temp.foo
12
^C
?
перехвачен сигнал SIGINT
q
перехвачен сигнал SIGCHLD

точка на отдельной строке выключает режим добавления
вывести строки из буфера с первой по последнюю,
чтобы увидеть его содержимое
записать содержимое буфера в файл
редактор сообщает, что записано 12 байт
ввод символа прерывания
редактор перехватил сигнал и вывел знак вопроса
и то же самое сделал родительский процесс
выход из редактора

В разделе 9.6 уже говорилось, что ввод символа прерывания приводит к посылке
сигнала SIGINT всем процессам из группы процессов переднего плана. На рис. 10.2
показана схема процессов после запуска редактора.

Командная
оболочка входа

Группа фоновых процессов

fork
exec

a.out

fork
exec

/bin/sh

fork
exec

/bin/ed

Группа процессов переднего плана

Рис. 10.2. Группы процессов переднего плана и фонового режима

В данном примере сигнал SIGINT посылается всем трем процессам переднего плана. (Командная оболочка игнорирует его.) Как видно из вывода программы, оба
процесса, a.out и редактор, перехватывают сигнал. Но когда мы запускаем программу с  помощью функции system, у  нас не должно получаться так, что и  родительский и дочерний процессы перехватывают сигналы SIGINT и  SIGQUIT, сгенерированные терминалом. В действительности эти сигналы должны посылаться
только запущенной программе  — дочернему процессу. Программа, запускаемая
функцией system, может быть интерактивной (как программа ed в этом примере),

10.18. Функция system   

439

а  процесс, вызывающий функцию system, отдает управление другой программе,
ожидая ее завершения, поэтому он не должен принимать эти два сигнала, генерируемые терминалом. По этой причине стандарт POSIX.1 требует, чтобы функция
system игнорировала эти два сигнала, пока она ожидает завершения команды.

Пример
В листинге 10.20 приводится реализация функции system, которая предусматривает необходимую обработку сигналов.
Листинг 10.20. Корректная реализация функции system, соответствующая
стандарту POSIX.1
#include
#include
#include
#include

<sys/wait.h>
<errno.h>
<signal.h>
<unistd.h>

int
system(const char *cmdstring) /* предусматривает обработку сигналов */
{
pid_t
pid;
int
status;
struct sigaction
ignore, saveintr, savequit;
sigset_t
chldmask, savemask;
if (cmdstring == NULL)
return(1); /* UNIX всегда поддерживает командный процессор */
ignore.sa_handler = SIG_IGN; /* игнорировать SIGINT и SIGQUIT */
sigemptyset(&ignore.sa_mask);
ignore.sa_flags = 0;
if (sigaction(SIGINT, &ignore, &saveintr) < 0)
return(-1);
if (sigaction(SIGQUIT, &ignore, &savequit) < 0)
return(-1);
sigemptyset(&chldmask);
/* заблокировать SIGCHLD */
sigaddset(&chldmask, SIGCHLD);
if (sigprocmask(SIG_BLOCK, &chldmask, &savemask) < 0)
return(-1);
if ((pid = fork()) < 0) {
status = -1; /* вероятно, превышено максимальное */
/* количество процессов */
} else if (pid == 0) { /* дочерний процесс */
/* восстановить предыдущие действия сигналов и сбросить маску */
sigaction(SIGINT, &saveintr, NULL);
sigaction(SIGQUIT, &savequit, NULL);
sigprocmask(SIG_SETMASK, &savemask, NULL);
execl("/bin/sh", "sh", "-c", cmdstring, (char *)0);
_exit(127);
/* ошибка вызова функции exec */
} else {
/* родительский процесс */
while (waitpid(pid, &status, 0) < 0)
if (errno != EINTR) {
status = -1; /* получен код ошибки, отличный от EINTR */
break;

440    Глава 10. Сигналы

}

}

/* восстановить предыдущие действия сигналов и сбросить маску */
if (sigaction(SIGINT, &saveintr, NULL) < 0)
return(-1);
if (sigaction(SIGQUIT, &savequit, NULL) < 0)
return(-1);
if (sigprocmask(SIG_SETMASK, &savemask, NULL) < 0)
return(-1);
}

return(status);

Если собрать программу из листинга 10.19 с этой версией функции system, работа
программы претерпит следующие изменения.
1.	 Вызывающий процесс не будет получать сигналы SIGINT и SIGQUIT, сгенерированные терминалом.
2.	 По завершении редактора сигнал SIGCHLD не будет послан вызывающему процессу. Вместо этого он заблокируется, пока не будет разблокирован последним
вызовом функции sigprocmask уже после того, как функция waitpid получит
код завершения дочернего процесса.
Стандарт POSIX.1 указывает, что если функция wait или waitpid получает код завершения дочернего процесса, когда сигнал SIGCHLD находится в  ожидании обработки, то
сигнал SIGCHLD не должен доставляться процессу, если не существует неполученного кода
завершения другого дочернего процесса. FreeBSD 8.0, Mac OS X 10.6.8 и Solaris 10 реализуют эту семантику, а Linux 3.2.0 — нет. Вместо этого сигнал SIGCHLD остается ждать
обработки после того, как функция system вызовет waitpid. Когда блокировка сигнала
снимается, он доставляется вызывающему процессу. Вызвав функцию wait в  функции
sig_chld из листинга 10.19, мы получили бы признак ошибки с кодом ECHILD, поскольку
код завершения дочернего процесса уже был получен функцией system.

Во многих устаревших руководствах в качестве примера, как игнорировать сигналы SIGINT и SIGQUIT, приводится следующий код:
if ((pid = fork()) < 0) {
err_sys("ошибка вызова функции fork");
} else if (pid == 0) {
/* дочерний процесс */
execl(...);
_exit(127);
}
/* родительский процесс */
old_intr = signal(SIGINT, SIG_IGN);
old_quit = signal(SIGQUIT, SIG_IGN);
waitpid(pid, &status, 0)
signal(SIGINT, old_intr);
signal(SIGQUIT, old_quit);

Проблема этого кода заключается в том, что нельзя заранее точно сказать, какой
из процессов первым получит управление после вызова функции fork  — родительский или дочерний. Если первым начнет работу дочерний процесс, может

10.18. Функция system   

441

получиться так, что сигнал будет сгенерирован еще до того, как родительский
процесс получит возможность изменить его диспозицию. По этой причине в лис­
тинге 10.20 мы изменяем диспозиции сигналов еще до вызова fork.
Обратите внимание, что диспозиции этих сигналов в дочернем процессе необходимо переустановить до вызова execl. Это позволит функции execl изменить их
диспозиции на значения по умолчанию на основе диспозиций сигналов вызывающего процесса, как это было описано в разделе 8.10.

Возвращаемое значение функции system
Будьте осторожны с возвращаемым значением функции system. Это код завершения командной оболочки, который не всегда совпадает с кодом завершения самой
команды. В листинге 8.13 мы видели ряд примеров, когда результаты оказывались
вполне ожидаемыми: если выполнялась простая команда, такая как date, код завершения был равен 0. Команда exit 44 дала код завершения — 44. А что случится,
если команда во время выполнения получит сигнал?
Запустим программу из листинга 8.14 и попробуем посылать сигналы выполняемым командам:
$ tsys "sleep 30"
^Cнормальное завершение, код выхода = 130
$ tsys "sleep 30"
^\sh: 946 Quit
нормальное завершение, код выхода = 131

мы нажали клавишу
прерывания (Control-C)
мы нажали клавишу завершения

Когда мы прервали команду sleep сигналом SIGINT, функция pr_exit (листинг 8.3)
восприняла это как нормальное завершение. То же произошло, когда мы прервали
команду sleep сигналом SIGQUIT. Дело в том, что командная оболочка Bourne shell
имеет плохо документированную особенность — она возвращает 128 плюс номер
сигнала, если работа команды была прервана сигналом. Это можно наблюдать
и в интерактивном сеансе работы с командной оболочкой.
$ sh
$ sh -c "sleep 30"
^С
$ echo $?
130
$ sh -c "sleep 30"
^\sh: 962 Quit - core dumped
$ echo $?
131
$ exit

убедимся, что запущена Bourne shell
нажали клавишу прерывания
вывести код завершения последней команды
нажали клавишу завершения
вывести код завершения последней команды
выйти из Bourne shell

В системе, где сигнал SIGINT имеет номер 2, а сигнал SIGQUIT — номер 3, мы получили коды завершения 130 и 131 соответственно.
Теперь сделаем то же самое, но на этот раз пошлем сигналы самой командной оболочке и посмотрим, что возвращает функция system:
$ tsys "sleep 30" &
9257
$ ps -f

на этот раз запустим в фоновом режиме
посмотрим идентификаторы процессов

442    Глава 10. Сигналы
UID
PID
PPID
TTY
TIME CMD
sar 9260
949
pts/5
0:00 ps -f
sar 9258
9257
pts/5
0:00 sh -c sleep 30
sar
949
947
pts/5
0:01 /bin/sh
sar 9257
949
pts/5
0:00 tsys sleep 30
sar 9259
9258
pts/5
0:00 sleep 30
$ kill -KILL 9258
завершим саму командную оболочку
аварийное завершение, номер сигнала = 9

Значение, возвращаемое функцией system, свидетельствует об аварийном завершении, только когда сама командная оболочка завершается аварийно.
Другие оболочки ведут себя иначе при обработке сигналов, вызывающих завершение, таких
как SIGINT и  SIGQUIT. В оболочках bash и  dash, например, нажатие клавиши прерывания
или завершения приведет к возврату кода завершения, свидетельствующего об аварийном
завершении с соответствующим номером сигнала. Однако если послать сигнал процессу
непосредственно, когда он ожидает в вызове функции sleep, чтобы сигнал был доставлен
отдельному процессу, а не всей группе процессов переднего плана, обнаружится, что эти
оболочки действуют подобно Bourne и завершаются с нормальным кодом завершения —
128 плюс номер сигнала.

При использовании функции system в своих программах уделите особое внимание правильной интерпретации возвращаемого значения. Если вызывать непосредственно fork, exec и  wait, код завершения дочернего процесса не будет соответствовать возвращаемому значению функции system.

10.19. Функции sleep, nanosleep
и clock_nanosleep
Мы уже пользовались функцией sleep во многих примерах и даже продемонстрировали две ее реализации в листингах 10.4 и 10.5; впрочем, у них есть определенные недостатки.
#include <unistd.h>
unsigned int sleep(unsigned int seconds);

Возвращает 0 или количество секунд, оставшихся
до окончания приостановки
Эта функция приостанавливает выполнение вызывающего процесса, пока:
1.	 Не истечет установленный интервал времени.
2.	 Не будет получен сигнал и обработчик сигнала не вернет управление.
Как и в случае с функцией alarm, функция sleep может вернуть управление чуть
позже, чем было запрошено, в зависимости от загруженности системы.
В первом случае функция возвращает 0. Если выход из функции происходит раньше из-за того, что процессу был доставлен сигнал (второй случай), возвращаемое

10.19. Функции sleep, nanosleep и clock_nanosleep   

443

значение содержит количество секунд, оставшихся до истечения запрошенного
интервала времени (заданное количество секунд минус количество секунд, прошедших с момента вызова функции).
Функция sleep может быть реализована на базе функции alarm (раздел 10.10), но
это совсем не обязательно. Однако если в основе реализации функции sleep лежит функция alarm, могут возникнуть взаимовлияния этих двух функций. Стандарт POSIX.1 никак не оговаривает возможность взаимного влияния. Например,
что произойдет, если сначала вызвать alarm(10), а  затем, спустя 3 секунды, вызвать sleep(5)? Функция sleep вернет управление через 5 секунд (разумеется,
если процессом не был перехвачен какой-либо сигнал), но будет ли сгенерирован
сигнал SIGALRM через 2 секунды после этого? Решение этих вопросов остается за
реализацией.
FreeBSD 8.0, Linux 3.2.0, Mac OS X 10.6.8 и Solaris 10 реализуют функцию sleep на основе
функции nanosleep, устраняющей зависимость от сигналов и таймера, взводимого функцией alarm. Для сохранения переносимости приложений не следует делать какие-либо
предположения о  реализации функции sleep, но если понадобится смешивать вызовы
функции sleep с  любыми другими функциями, отмеряющими интервалы времени, вам
придется побеспокоиться о возможных взаимовлияниях этих функций.

Пример
В листинге 10.21 показана реализация POSIX.1-совместимой функции sleep.
Эта функция является модификацией функции из листинга 10.4, она надежно
обслуживает сигналы и избегает состояния гонки за ресурсами, которое наблюдалось в  предыдущей реализации. Однако она по-прежнему не учитывает, что
функция alarm могла предварительно установить таймер. (Как уже упоминалось, стандарт POSIX.1 не оговаривает явно возможность взаимного влияния
этих двух функций.)
Листинг 10.21. Надежная реализация функции sleep
#include "apue.h"
static void
sig_alrm(int signo)
{
/*
* ничего не делаем, просто возвращаем управление,
* чтобы выйти из функции sigsuspend()
*/
}
unsigned int
sleep(unsigned int seconds)
{
struct sigaction
newact, oldact;
sigset_t
newmask, oldmask, suspmask;
unsigned int
unslept;
/* установить свой обработчик, сохранив предыдущую информацию */
newact.sa_handler = sig_alrm;
sigemptyset(&newact.sa_mask);

444    Глава 10. Сигналы
newact.sa_flags = 0;
sigaction(SIGALRM, &newact, &oldact);
/* заблокировать сигнал SIGALRM и сохранить текущую маску сигналов */
sigemptyset(&newmask);
sigaddset(&newmask, SIGALRM);
sigprocmask(SIG_BLOCK, &newmask, &oldmask);
alarm(seconds);
suspmask = oldmask;
/* убедиться, что SIGALRM не заблокирован */
sigdelset(&suspmask, SIGALRM);
/* дождаться, пока не будет перехвачен какой-либо сигнал */
sigsuspend(&suspmask);
/* был перехвачен некоторый сигнал, сейчас SIGALRM заблокирован */
unslept = alarm(0);
/* восстановить предыдущее действие */
sigaction(SIGALRM, &oldact, NULL); /* восстановить предыдущее действие */

}

/* восстановить маску сигналов, в которой сигнал SIGALRM разблокирован */
sigprocmask(SIG_SETMASK, &oldmask, NULL);
return(unslept);

Чтобы создать более надежную реализацию, потребовался больший объем кода,
чем в листинге 10.4. Мы не используем функции дальних переходов (как это делалось в листинге 10.5, чтобы избежать гонки за ресурсами) и поэтому не оказываем
влияния на другие обработчики сигналов, которые могли выполняться в момент
доставки сигнала SIGALRM.
Функция nanosleep похожа на функцию sleep, но обеспечивает точность измерения времени до наносекунд.
#include <time.h>
int nanosleep(const struct timespec *reqtp, struct timespec *remtp);

Возвращает 0, если установленное время истекло,
или –1 — в случае ошибки
Эта функция приостанавливает вызывающий процесс, пока не истечет установленный интервал времени или выполнение функции не будет прервано сигналом.
Параметр reqtp определяет интервал времени в  секундах и  наносекундах. Если
выполнение функции будет прервано сигналом и процесс при этом не завершится, в структуре timespec, на которую указывает параметр remtp, будет возвращено
время, оставшееся до окончания приостановки. В этом параметре можно передать
NULL, если оставшееся время не представляет интереса.
Если система не поддерживает точность измерения времени до наносекунд, запрошенный интервал будет округлен. Поскольку функция nanosleep не опирает-

10.19. Функции sleep, nanosleep и clock_nanosleep   

445

ся на механизм сигналов, ее можно смело использовать, не беспокоясь о возможном влиянии других функций.
Функция nanosleep прежде определялась расширением Timers стандарта Single UNIX
Specification, но в версии SUSv4 была перемещена в раздел базовых спецификаций.

С введением поддержки множества системных часов (раздел 6.10) возникла необходимость иметь возможность приостанавливать вызывающий поток выполнения, определяя интервал времени относительно определенных часов. Такую возможность дает функция clock_nanosleep.
#include <time.h>
int clock_nanosleep(clockid_t clock_id, int flags,
const struct timespec *reqtp, struct timespec *remtp);

Возвращает 0, если установленное время истекло, или код ошибки —
в случае неудачи
Аргумент clock_id определяет часы, которые будут отмерять интервал приостановки. Идентификаторы часов перечислены в табл. 6.7. Аргумент flags определяет
тип задержки — относительная или абсолютная. Если в аргументе flags передать
0, время приостановки будет интерпретироваться как относительное (то есть продолжительность приостановки). Если передать значение TIMER_ABSTIME, время
приостановки будет интерпретироваться как абсолютное (то есть поток выполнения будет приостановлен до достижения указанного момента времени).
Другие аргументы, reqtp и  remtp, имеют то же назначение, что и  в  функции
nanosleep. Однако когда определяется абсолютное время, аргумент remtp не
используется, так как в  этом нет необходимости; мы можем вызывать clock_
nanosleep с одним и тем же значением reqtp, пока указанные часы не достигнут
установленного абсолютного значения времени.
Обратите внимание, что, кроме возвращаемого кода ошибки, вызов
clock_nanosleep(CLOCK_REALTIME, 0, reqtp, remtp);

эквивалентен вызову
nanosleep(reqtp, remtp);

Проблема с относительными интервалами времени состоит в том, что некоторым
приложениям требуется очень высокая точность измерения интервала приостановки, а при использовании относительного интервала процесс может быть приостановлен на более длительное время. Например, если приложению требуется
выполнять некоторую операцию через регулярные интервалы времени, в  нем
следует получить текущее время, прибавить продолжительность интервала до
следующего запуска операции и затем вызвать nanosleep. Между моментом получения текущего времени и вызовом nanosleep процесс может быть приостановлен
планировщиком, чтобы выделить квант времени другому процессу, что, в  свою
очередь, увеличит продолжительность приостановки при использовании относи-

446    Глава 10. Сигналы
тельного интервала. Использование абсолютного времени увеличивает точность,
даже при том, что планировщик процессов не дает гарантии, что процесс возобновит работу сразу после окончания установленного интервала.
В прежних версиях стандарта Single UNIX Specification функция clock_nanosleep определялась расширением Clock, но в версии SUSv4 была перемещена в раздел базовых спе­
цификаций.

10.20. Функция sigqueue
В разделе 10.8 говорилось, что большинство реализаций UNIX не ставят сигналы
в очередь. Однако, следуя требованиям расширений реального времени стандарта POSIX.1, некоторые системы стали добавлять поддержку очередей сигналов.
В версии SUSv4 поддержка очередей сигналов была перемещена из расширений
реального времени в раздел базовых спецификаций.
Вообще, сигнал несет единственный бит информации: сам факт сигнала. Помимо
поддержки очередей сигналов, эти расширения позволяют приложениям передавать вместе с сигналами дополнительную информацию (вспомните раздел 10.14).
Эта информация встраивается в структуру siginfo. Наряду с системной информацией приложения могут передать целое число или указатель на буфер с дополнительной информацией для обработчика сигнала.
Чтобы задействовать очереди сигналов, необходимо выполнить следующее.
1.	 Указать флаг SA_SIGINFO в  ходе установки обработчика сигналов вызовом
sigaction. Если этого не сделать, сигнал будет послан, но при этом реализация
сама решит, следует ли поместить его в очередь.
2.	 Передать обработчик сигнала в поле sa_sigaction структуры sigaction вместо
поля sa_handler. Реализации могут позволять использовать поле sa_handler,
но в этом случае обработчик не сможет получать дополнительную информацию, отправляемую с помощью функции sigqueue.
3.	 Посылать сигналы вызовом функции sigqueue.
#include <signal.h>
int sigqueue(pid_t pid, int signo, const union sigval value)

Возвращает 0 в случае успеха, –1 — в случае ошибки
Функция sigqueue напоминает функцию kill, кроме того, что позволяет посылать сигналы только одному процессу и использовать аргумент value для передачи
обработчику сигнала целого числа или указателя на буфер.
Сигналы не могут добавляться в  очередь до бесконечности. Вспомните предел
SIGQUEUE_MAX из табл. 2.9 и  2.11. По достижении этого предела sigqueue может
терпеть неудачу, возвращая признак ошибки с кодом EAGAIN.

10.21. Сигналы управления заданиями   

447

В расширениях реального времени вводится отдельный диапазон сигналов для
использования в приложениях: от SIGRTMIN по SIGRTMAX включительно. Не забывайте, что по умолчанию эти сигналы приводят к завершению процесса.
В табл. 10.7 перечислены отличия поддержки очередей сигналов между реализациями, описываемыми в этой книге.
Таблица 10.7. Поведение поддержки очередей сигналов в различных платформах
Поведение

Поддержка sigqueue

SUS

FreeBSD Linux
8.0
3.2.0





Возможность помещения в очередь
других сигналов, не из диапазона
SIGRTMIN .. SIGRTMAX

Не обязательно



Сигналы помещаются в очередь, даже без
использования флага SA_SIGINFO

Не обязательно



Mac OS X Solaris
10.6.8
10








ОС Mac OS X 10.6.8 не поддерживает ни функцию sigqueue, ни сигналы реального времени.
В Solaris 10 функция sigqueue находится в библиотеке реального времени librt.

10.21. Сигналы управления заданиями
Шесть сигналов из перечисленных в табл. 10.1 стандарт POSIX.1 рассматривает
как сигналы управления заданиями.
SIGCHLD  Дочерний процесс приостановлен или завершен.
SIGCONT  Возобновление работы приостановленного процесса.
SIGSTOP  Сигнал останова (не может быть проигнорирован).
SIGTSTP  Интерактивный сигнал приостановки.
SIGTTIN  Чтение из управляющего терминала процессом из группы процессов
фонового режима.
SIGTTOU  Запись в  управляющий терминал процессом из группы процессов фонового режима.
Большинство программ не обрабатывают эти сигналы, за исключением сигнала
SIGCHLD. Обычно все необходимые действия по их обработке принимают на себя
интерактивные командные оболочки. При вводе символа приостановки (обычно
Control-Z) всем процессам переднего плана передается сигнал SIGTSTP. Когда мы
даем команду возобновить работу фонового задания или задания переднего плана, командная оболочка посылает всем процессам в задании сигнал SIGCONT. Аналогично, когда процесс получает сигнал SIGTTIN или SIGTTOU, по умолчанию он
приостанавливается, а командная оболочка, распознав эту ситуацию, уведомляет
нас о ней.
Исключение составляют процессы, которые управляют терминалом, например
редактор vi(1). Такие программы должны знать, когда пользователь хочет при-

448    Глава 10. Сигналы
остановить их работу, чтобы восстановить состояние терминала, предшествовавшее запуску программы. Кроме того, программы, подобные редактору vi, при
возобновлении работы должны надлежащим образом перенастроить терминал
и перерисовать экран. Позднее мы увидим на примере, как программа, подобная
vi, выполняет все необходимые действия.
Сигналы управления заданиями оказывают определенное влияние друг на друга. Когда генерируется любой из четырех сигналов, вызывающих приостановку
процесса (SIGSTOP, SIGTSTP, SIGTTIN или SIGTTOU), система отменяет ожидающий
обработки сигнал SIGCONT для этого же процесса. Аналогично, когда генерируется сигнал SIGCONT, система отменяет все ожидающие обработки сигналы приостановки.
Обратите внимание, что по умолчанию сигнал SIGCONT возобновляет процесс,
если он был приостановлен, иначе сигнал игнорируется. Обычно при получении
этого сигнала ничего делать не нужно. Когда генерируется сигнал SIGCONT, приостановленный процесс возобновляет работу, даже если этот сигнал заблокирован
или игнорируется.

Пример
Программа в  листинге 10.22 демонстрирует обычную последовательность действий, выполняемую при обработке сигналов управления заданиями. Данная программа просто копирует данные со стандартного ввода в стандартный вывод; в тех
местах, где обычно осуществляется управление терминалом, даны соответствующие комментарии.
Листинг 10.22. Обработка сигнала SIGTSTP
#include "apue.h"
#define BUFFSIZE 1024
static void
sig_tstp(int signo) /* Обработчик сигнала SIGTSTP */
{
sigset_t
mask;
/* ...переместить курсор в левый нижний угол, установить режим терминала...
*/
/*
* Разблокировать SIGTSTP, так как он был заблокирован системой.
*/
sigemptyset(&mask);
sigaddset(&mask, SIGTSTP);
sigprocmask(SIG_UNBLOCK, &mask, NULL);
signal(SIGTSTP, SIG_DFL); /* установить диспозицию в значение SIG_DFL */
kill(getpid(), SIGTSTP);

/* и послать сигнал самому себе */

/*
* Функция kill не вернет управление,
* пока работа процесса не будет возобновлена.
*/

10.21. Сигналы управления заданиями   

449

signal(SIGTSTP, sig_tstp); /* переустановить обработчик сигнала */
}

/* ... переустановить режим терминала, перерисовать экран ... */

int
main(void)
{
int
char

n;
buf[BUFFSIZE];

/*
* Сигнал SIGTSTP следует перехватывать только в том случае,
* если командная оболочка поддерживает управление заданиями.
*/
if (signal(SIGTSTP, SIG_IGN) == SIG_DFL)
signal(SIGTSTP, sig_tstp);
while ((n = read(STDIN_FILENO, buf, BUFFSIZE)) > 0)
if (write(STDOUT_FILENO, buf, n) != n)
err_sys("ошибка вызова функции write");
if (n < 0)
err_sys("ошибка вызова функции read");
}

exit(0);

При запуске программа устанавливает обработчик сигнала SIGTSTP, только если
его диспозиция имеет значение SIG_DFL. Причина в том, что когда программа запускается из командной оболочки, не поддерживающей управление заданиями
(например, /bin/sh), диспозиция сигнала должна быть установлена в  значение
SIG_IGN. На самом деле командная оболочка явно не устанавливает диспозиции
трех сигналов (SIGTSTP, SIGTTIN и  SIGTTOU) в  значение SIG_IGN, изначально это
делает процесс init, после чего эти диспозиции наследуются всеми оболочками
входа. И только те оболочки, которые обладают возможностью управления заданиями, переустанавливают диспозиции этих трех сигналов в значение SIG_DFL.
Когда мы вводим символ приостановки, процесс получает сигнал SIGTSTP и вызывает обработчик сигнала. На этом этапе нужно выполнить все необходимые
действия, связанные с  терминалом: переместить курсор в  нижний левый угол,
восстановить режим работы терминала и  т. п. После этого процесс отправляет
самому себе этот же сигнал, предварительно разблокировав его и установив его
диспозицию в значение SIG_DFL. Разблокирование сигнала должно производиться
обязательно, так как в это самое время ведется обработка этого же сигнала и система автоматически заблокировала его в момент вызова обработчика. Здесь процесс приостанавливается системой. Он возобновит работу только при получении
сигнала SIGCONT (который обычно посылается в ответ на команду fg). Мы не перехватываем сигнал SIGCONT. По умолчанию он должен возобновить работу приостановленного процесса — когда это произойдет, программа продолжит выполнение,
как если бы функция kill вернула управление. В этот момент восстанавливается
диспозиция сигнала SIGTSTP и выполняются необходимые действия с терминалом
(например, перерисовка экрана).

450    Глава 10. Сигналы

10.22. Имена и номера сигналов
В этом разделе мы рассмотрим взаимосвязь между номерами и именами сигналов.
В некоторых системах имеется массив
extern char *sys_siglist[];

Этот массив индексируется номерами сигналов и содержит указатели на строки
с именами сигналов.
Этот массив существует в ОС FreeBSD 8.0, Linux 3.2.0 и Mac OS X 10.6.8. В Solaris 10
также имеется этот массив, но он носит имя _sys_siglist.

Для вывода переносимым способом строк символов, соответствующих номерам
сигналов, можно использовать функцию psignal.
#include <signal.h>
void psignal(int signo, const char *msg);

Она выводит в  стандартный поток вывода сообщений об ошибках строку msg
(обычно включающую имя программы), за которой следуют двоеточие, пробел,
описание сигнала и символ перевода строки. Если в аргументе msg передать пустой указатель NULL, будет выведено только описание сигнала. Эта функция очень
похожа на perror (раздел 1.7).
Если обработчику сигнала, установленному альтернативной функцией sigaction,
передается структура siginfo, информацию о  сигнале можно вывести вызовом
функции psiginfo.
#include <signal.h>
void psiginfo(const siginfo_t *info, const char *msg);

Она действует подобно функции psignal, но имеет доступ к дополнительной информации, а не только к номеру сигнала, Что именно выводится в виде дополнительной информации, зависит от платформы.
Если необходимо вывести лишь описание сигнала и  необязательно в  стандартный поток вывода сообщений об ошибках (например, в  файл журнала), можно
воспользоваться функцией strsignal. Она напоминает функцию strerror (раздел 1.7).
#include <string.h>
char *strsignal(int signo);

Возвращает указатель на строку с описанием сигнала
По заданному номеру сигнала возвращается строка с описанием. Эта строка может использоваться приложениями для формирования сообщений об ошибках
при получении сигналов.

10.23. Подведение итогов   

451

Все обсуждаемые в этой книге платформы поддерживают функции psignal и strsignal,
но в их реализациях имеются различия. В Solaris 10 функция strsignal возвращает пустой
указатель, если задан некорректный номер сигнала, тогда как в FreeBSD 8.0, Linux 3.2.0
и Mac OS X 10.6.8 возвращается указатель на строку с сообщением о том, что сигнал не
распознан.
Функция psiginfo поддерживается только в Linux 3.2.0 и Solaris 10.

Solaris предоставляет пару функций  — для отображения номеров сигналов в  их
имена и обратно.
#include <signal.h>
int sig2str(int signo, char *str);
int str2sig(const char *str, int *signop);

Обе возвращают 0 в случае успеха, –1 — в случае ошибки
Эти функции удобны при разработке интерактивных программ, которые должны
принимать и выводить номера сигналов и их имена.
Функция sig2str преобразует номер сигнала в  строку и  сохраняет результат
в  памяти по адресу, переданному в  аргументе str. Вызывающий процесс должен
предоставить буфер достаточного размера для хранения строки максимально возможной длины, с учетом завершающего нулевого символа. Для этих целей Solaris
предусматривает в заголовочном файле <signal.h> константу SIG2STR_MAX, которая представляет максимальный размер строки, возвращаемой функцией sig2str.
Возвращаемая строка содержит имя сигнала без префикса SIG. Например, если
функции передать номер сигнала SIGKILL, она вернет строку «KILL» в буфере, на
который указывает аргумент str.
Функция str2sig преобразует заданное имя сигнала в его номер. Номер сигнала
сохраняется в целочисленной переменной, на которую указывает аргумент signop.
В качестве имени сигнала можно передать имя без префикса SIG или строку с десятичным номером сигнала (например, «9»).
Обратите внимание, что функции sig2str и  str2sig отступают от общепринятой
практики и в случае неудачи не сохраняют код ошибки в переменной errno.

10.23. Подведение итогов
Сигналы широко используются в большинстве серьезных приложений. Понимание, как и зачем обрабатываются сигналы, является основой профессионального
подхода к программированию для системы UNIX. В этой главе представлен достаточно объемный и полный обзор сигналов UNIX. Мы начали с рассмотрения
недостатков, присущих ранним реализациям сигналов, и того, как они проявляются. Затем мы перешли к  обсуждению надежных сигналов POSIX.1 и  связанных с ними функций. Разобравшись со всеми тонкостями, мы смогли реализовать

452    Глава 10. Сигналы
свои версии функций abort, system и  sleep. И наконец, мы закончили главу рассмотрением сигналов управления заданиями и  способов преобразования между
именами сигналов и их номерами.

Упражнения
10.1	 В листинге 10.1 удалите оператор for(;;). Что произойдет и почему?
10.2	 Реализуйте функцию sig2str, описанную в разделе 10.22.
10.3	 Нарисуйте схему, которая показывает кадры стека программы из листинга 10.6.
10.4	 В листинге 10.8 мы продемонстрировали методику использования функций
setjmp и  longjmp, которая достаточно часто применяется для ограничения
времени выполнения продолжительных операций ввода/вывода. Можно
также представить следующий код:
signal(SIGALRM, sig_alrm);
alarm(60);
if (setjmp(env_alrm) != 0) {
/* обработать ситуацию выхода по тайм-ауту */
...
}
...

Скажите, что в нем неправильно.
10.5	 Используя единственный системный таймер (alarm или setitimer  — таймер с высоким разрешением), реализуйте набор функций, которые предоставляли бы в распоряжение процесса произвольное количество таймеров.
10.6	 Напишите программу, с  помощью которой можно было бы проверить
функции синхронизации родительского и дочернего процессов из листинга 10.17. Процесс должен создавать файл и записывать в него число 0. Затем вызывать функцию fork, после чего родительский и дочерний процессы
должны по очереди увеличивать число, прочитанное из файла. При каждом
увеличении счетчика процесс должен выводить информацию о  том, кто
произвел увеличение — родитель или потомок.
10.7	 В функции из листинга 10.18 предусмотрен сброс диспозиции сигнала
SIGABRT в значение по умолчанию и повторный вызов функции kill на случай, если обработчик сигнала вернет управление. Почему в этой ситуации
нельзя просто вызвать функцию _exit?
10.8	 Как вы думаете, почему структура siginfo (раздел 10.14) помещает в поле
si_uid реальный, а не эффективный идентификатор пользователя?
10.9	 Перепишите функцию из листинга 10.10 так, чтобы она могла обслуживать все сигналы из табл. 10.1. Функция должна выполнять одну итерацию цикла для каждого включенного в маску, а не для каждого возможного сигнала.

Упражнения   

453

10.10	 Напишите программу, которая вызывала бы sleep(60) в  бесконечном цикле. Каждые пять проходов цикла (то  есть каждые 5 минут) программа
должна получать текущее время суток и выводить содержимое поля tm_sec.
Запустите программу на ночь и  объясните полученные результаты. Подумайте, как может быть реализована программа, которая «просыпается»
каждую минуту, как демон cron?
10.11	 Измените программу из листинга 3.3 следующим образом: (а) константу
BUFFSIZE установите в  значение 100, (б) перехватите сигнал SIGXFSZ с  помощью функции signal_intr, выведите сообщение при выходе из обработчика сигнала и (в) выведите значение, полученное от функции write, если
она не смогла записать заданное количество байтов. Измените «мягкий»
предел RLIMIT_FSIZE (раздел 7.11), установив его в значение 1024, и с помощью измененной программы попробуйте скопировать файл, размер которого превышает 1024 байта. (Попробуйте установить новое значение предела
из командной оболочки. Если это не удастся, вызовите функцию setrlimit
прямо из программы.) Запустите эту программу в другой системе, которая
вам доступна. Что произошло и почему?
10.12	 Напишите программу, которая передает функции fwrite буфер гигантского размера (порядка нескольких сотен мегабайтов). Перед обращением
к  fwrite вызовите alarm, чтобы запланировать генерацию сигнала через
одну секунду. Ваш обработчик сигнала должен просто выводить сообщение,
что сигнал перехвачен, и возвращать управление. Успеет ли функция fwrite
завершить работу? Объясните, что произойдет?

11

Потоки

11.1. Введение
В предыдущих главах мы обсуждали процессы. Мы рассмотрели окружение процессов в UNIX, взаимоотношения между процессами и способы управления ими.
В этой главе мы продолжим изучение внутреннего устройства процессов и узнаем, как можно использовать несколько потоков выполнения (или просто потоков
(threads)) для решения нескольких задач в рамках единственного процесса. Все
потоки внутри процесса имеют доступ к одним и тем же компонентам процесса,
таким как файловые дескрипторы или переменные.
Всякий раз при попытке организовать одновременный доступ нескольких пользователей к одному и тому же ресурсу приходится сталкиваться с проблемой согласования доступа. В конце этой главы мы рассмотрим механизмы синхронизации
потоков, которые позволяют предотвратить доступ разных потоков к  разделяемым ресурсам, находящимся в несогласованном состоянии.

11.2. Понятие потоков
Типичный процесс в UNIX можно представить как имеющий единственный поток управления  — каждый процесс в  один момент времени решает только одну
задачу. При использовании нескольких потоков управления можно спроектировать приложение, которое будет решать одновременно несколько задач в рамках
единственного процесса, где каждый поток решает отдельную задачу. Такой подход имеет следующие преимущества.
 Можно значительно упростить код, обрабатывающий асинхронные события,
привязав каждый тип события к отдельному потоку. В результате каждый поток сможет обслуживать свое событие, используя для этого синхронную модель программирования, которая намного проще асинхронной.
 Чтобы организовать совместный доступ нескольких процессов к одним и тем
же ресурсам, таким как общая память или файловые дескрипторы, необходимо
использовать достаточно сложные механизмы синхронизации, предоставляемые операционной системой (об этом — в главах 15 и 17). Потоки же, в отличие
от процессов, автоматически получают доступ к одному и тому же адресному
пространству и файловым дескрипторам.

11.3. Идентификация потоков   

455

 Решение некоторых задач можно разбить на более мелкие подзадачи, что может дать прирост производительности программы. Однопоточный процесс,
выполняющий решение нескольких задач, неявно вынужден решать их последовательно, поскольку имеет только один поток управления. При наличии
нескольких потоков управления независимые друг от друга задачи могут решаться одновременно отдельными потоками. Две задачи могут решаться одновременно только при условии, что они не зависят друг от друга.
 Аналогично, интерактивные программы могут сократить время отклика на
действия пользователя, используя многопоточную модель, чтобы отделить обработку ввода/вывода пользователя от других частей программы.
У многих многопоточное программирование ассоциируется с  многопроцессорными системами. Однако преимущества многопоточной модели проявляют себя,
даже если программа работает в однопроцессорной системе. Независимо от количества процессоров, программу можно упростить благодаря многопоточной модели, поскольку количество процессоров не влияет на структуру программы. Кроме
того, в то время как однопоточный процесс вынужден периодически простаивать
при последовательном решении нескольких задач, многопоточный может повысить производительность и  в  однопроцессорной системе, так как часть потоков
могут продолжать работу, когда другие простаивают, ожидая наступления некоторых событий.
Поток содержит набор информации, необходимой для представления контекста выполнения внутри процесса. Сюда включаются идентификатор потока, отличающий
поток внутри процесса, набор значений в регистрах процессора, стек, приоритет, маска сигналов, переменная errno (раздел 1.7) и дополнительные данные, специфичные для потока (раздел 12.6). Все компоненты процесса, включая выполняемый код
программы, глобальные переменные и динамическую память, стеки и файловые дескрипторы, могут совместно использоваться различными потоками этого процесса.
Интерфейс потоков, о  котором мы будем говорить, определяется стандартом
POSIX.1-2001. Этот интерфейс, известный также как «pthreads» (от «POSIX
threads»), первоначально представлял собой дополнительную функциональную
возможность, включенную в  стандарт POSIX.1-2001, но в  версии SUSv4 был
перемещен в  раздел базовых спецификаций. Поддержку потоков POSIX можно
проверить с помощью макроопределения _POSIX_THREADS. Приложения могут выполнять проверку поддержки потоков во время компиляции, используя команду условной компиляции #ifdef, или во время выполнения, вызывая функцию
sysconf с аргументом _SC_THREADS. Системы, соответствующие стандарту SUSv4,
определяют символ _POSIX_THREADS со значением 200809L.

11.3. Идентификация потоков
Как любой процесс обладает идентификатором процесса, так и  каждый поток
имеет свой идентификатор потока. В отличие от процессов, идентификаторы которых являются уникальными в пределах системы, идентификатор потока имеет
смысл только в контексте процесса, которому он принадлежит.

456    Глава 11. Потоки
Мы уже говорили, что идентификатор процесса представлен типом pid_t и является целым неотрицательным числом. Идентификатор потока представлен типом
pthread_t. Реализациям разрешается использовать структуру для представления
типа pthread_t, поэтому, чтобы сохранить переносимость приложений, мы не
должны рассматривать этот тип как целое число. Следовательно, сравнение двух
идентификаторов потоков должно выполняться с помощью функции.
#include <pthread.h>
int pthread_equal(pthread_t tid1, pthread_t tid2);

Возвращает ненулевое значение, если идентификаторы равны,
0 — в противном случае
Для представления типа pthread_t Linux 3.2.0 использует тип long int, Solaris 10  —
unsigned int, а  FreeBSD 8.0 и  Mac OS X 10.6.8 в  качестве типа pthread_t используют
указатель на структуру pthread.

Поскольку тип pthread_t может быть структурой, не существует простого переносимого способа вывести его значение. Иногда в процессе отладки программы бывает удобно выводить идентификаторы потоков, но, как правило, в других случаях в этом нет необходимости. В самом худшем случае это приводит к написанию
непереносимого отладочного кода, поэтому данное ограничение можно считать
несущественным.
Поток может получить собственный идентификатор, обратившись к  функции
pthread_self.
#include <pthread.h>
pthread_t pthread_self(void);

Возвращает идентификатор вызывающего потока
Эта функция может использоваться совместно с  pthread_equal, если внутри потока возникнет необходимость самоидентификации. Например, главный поток
может размещать задания в некоторой очереди и сопровождать их идентификаторами потоков, чтобы каждый поток мог выполнять задания, предназначенные
конкретно для него. Эта методика показана на рис. 11.1. Главный поток помещает
новые задания в очередь, а три рабочих потока извлекают их из очереди. Вместо
того чтобы позволить произвольному потоку извлекать очередное задание из начала очереди, главный поток, используя идентификаторы потоков, назначает задания конкретным потокам. В  этом случае рабочий поток извлекает из очереди
только те задания, которые отмечены его идентификатором.

11.4. Создание потока   

457

Главный
поток
Поток
1

TID 1
Очередь
заданий

Поток
2

Задание

TID 3
Задание

TID 2

TID 3

Задание

Задание

Поток
3

Рис. 11.1. Пример очереди заданий

11.4. Создание потока
Традиционная модель процессов в UNIX поддерживает только один поток управления на процесс. Концептуально это то же, что и модель, основанная на потоках,
в случае, когда каждый процесс состоит из одного потока. При наличии поддержки pthread программа также запускается как процесс, состоящий из одного потока
управления. Поведение такой программы ничем не отличается от поведения традиционного процесса, пока она не создаст дополнительные потоки управления.
Создание дополнительных потоков производится с помощью функции pthread_
create.
#include <pthread.h>
int pthread_create(pthread_t *restrict tidp,
const pthread_attr_t *restrict attr,
void *(*start_rtn)(void *), void *restrict arg);

Возвращает 0 в случае успеха, код ошибки — в случае неудачи
Аргумент tidp — это указатель на область памяти, где будет размещен идентификатор созданного потока, если вызов функции pthread_create завершится успехом. Аргумент attr используется для настройки различных атрибутов потока. Об
атрибутах потока мы поговорим в  разделе 12.3, а  пока будем передавать в  этом
аргументе пустой указатель (NULL), что соответствует созданию потока со значениями атрибутов по умолчанию.

458    Глава 11. Потоки
Вновь созданный поток начинает выполнение с  функции start_rtn. Эта функция принимает единственный аргумент arg — нетипизированный указатель. Если
функции start_rtn потребуется передать значительный объем информации, ее
следует сохранить в виде структуры и передать в arg указатель на структуру.
При создании нового потока нельзя заранее предположить, кто первым получит
управление — вновь созданный поток или поток, вызвавший функцию pthread_
create. Новый поток имеет доступ к адресному пространству процесса и наследует от вызывающего потока среду окружения арифметического сопроцессора и маску сигналов, однако набор сигналов, ожидающих обработки, для нового потока
очищается.
Обратите внимание, что функции семейства pthread, как правило, возвращают
код ошибки в случае неудачи. Они не изменяют значение переменной errno подобно другим функциям POSIX. Экземпляр переменной errno для каждого потока предоставляется только для сохранения совместимости с  существующими
функциями, которые используют эту переменную. Вообще, при работе с потоками
принято возвращать код ошибки из функций, что дает возможность локализовать
ошибку, а  не полагаться на некоторую глобальную переменную, которая могла
быть изменена в результате побочного эффекта.

Пример
Несмотря на отсутствие переносимого способа вывода значений идентификаторов потоков, все же можно написать небольшую программу, которая делает это,
и  тем самым получить представление о  некоторых особенностях потоков. Программа в листинге 11.1 выводит идентификатор процесса и идентификаторы начального и вновь созданного потоков.
Листинг 11.1. Вывод идентификаторов потоков
#include "apue.h"
#include <pthread.h>
pthread_t ntid;
void
printids(const char *s)
{
pid_t
pid;
pthread_t
tid;

}

pid = getpid();
tid = pthread_self();
printf("%s pid %u tid %u (0x%x)\n", s, (unsigned int)pid,
(unsigned int)tid, (unsigned int)tid);

void *
thr_fn(void *arg)
{
printids("новый поток: ");
return((void *)0);
}

11.4. Создание потока   

int
main(void)
{
int

}

459

err;

err = pthread_create(&ntid, NULL, thr_fn, NULL);
if (err != 0)
err_exit(err, "невозможно создать поток");
printids("главный поток:");
sleep(1);
exit(0);

В этом примере есть два интересных момента, связанных с возможностью гонки
за ресурсами между основным и вновь созданным потоками. (Далее в этой же главе мы рассмотрим более правильные способы синхронизации потоков.) В первую
очередь необходимо приостановить основной поток. Если этого не сделать, основной поток может завершиться и тем самым завершить весь процесс еще до того,
как новый поток получит возможность начать работу. Такое поведение потоков
во многом зависит от реализации потоков в операционной системе и алгоритма
планирования.
Второй интересный момент заключается в  том, что новый поток получает свой
идентификатор с помощью функции pthread_self, а не берет его из глобальной
переменной или из аргумента запускающей функции. При описании функции
pthread_create мы уже говорили, что она возвращает идентификатор созданного
потока через аргумент tidp. В нашем примере основной поток сохраняет идентификатор в переменной ntid, но новый поток не может его использовать. Если новый поток получит управление первым, еще до того, как функция pthread_create
вернет управление в основной поток, вместо идентификатора новый поток обнаружит неинициализированное значение переменной ntid.
Запустив программу из листинга 11.1 в Solaris, мы получили следующие результаты:
$ ./a.out
главный поток: pid 20075 tid 1 (0x1)
новый поток:
pid 20075 tid 2 (0x2)

Как мы и ожидали, оба потока обладают одним и тем же идентификатором процесса, но разными идентификаторами потоков. Запуск программы из листинга 11.1 в FreeBSD дал следующие результаты:
$ ./a.out
главный поток: pid 37396 tid 673190208 (0x28201140)
новый поток:
pid 37396 tid 673280320 (0x28217140)

В этом случае потоки также имеют один и тот же идентификатор процесса. Если
рассматривать идентификаторы потоков как целые десятичные числа, они могут показаться достаточно странными, но если их рассматривать в шестнадцатеричном представлении, они приобретают некоторый смысл. Как уже отмечалось
выше, в качестве идентификатора потока FreeBSD использует указатель на структуру с данными потока.

460    Глава 11. Потоки
В Mac OS X можно было бы ожидать похожих результатов, однако идентификаторы главного потока и потока, созданного с помощью функции pthread_create,
принадлежат к разным диапазонам адресов.
$ ./a.out
главный поток: pid 31807 tid 140735073889440 (0x7fff70162ca0)
новый поток:
pid 31807 tid 4295716864 (0x1000b7000)

Запуск программы в Linux дал несколько иные результаты:
$ ./a.out
главный поток: pid 17874 tid 140693894424320 (0x7ff5d9996700)
новый поток:
pid 17874 tid 140693886129920 (0x7ff5d91ad700)

Идентификаторы потоков в Linux больше напоминают указатели, хотя в действительности являются целыми числами без знака.
Реализация потоков изменилась при переходе от версии Linux 2.4 к Linux 2.6. В Linux 2.4
подсистема LinuxThreads реализовала потоки как отдельные процессы. Это мешало реа­
лизации поведения потоков так, чтобы оно соответствовало требованиям стандарта
POSIX. В Linux 2.6 ядро и библиотека поддержки потоков были полностью переделаны
под новую реализацию потоков под названием Native POSIX Thread Library (NPTL). Она
поддерживает модель выполнения множества потоков в рамках единственного процесса
и упрощает поддержку семантики потоков в соответствии со стандартом POSIX.

11.5. Завершение потока
Если один из потоков вызовет функцию exit, _exit или _Exit, будет завершен
весь процесс. Аналогично, если потоку будет послан сигнал, действие которого
заключается в  завершении процесса, этот сигнал завершит весь процесс (более
подробно о взаимодействиях между сигналами и потоками мы поговорим в разделе 12.8).
Завершить работу единственного потока, то есть без завершения всего процесса,
можно тремя способами.
1.	 Поток может просто вернуть управление из запускающей процедуры. Возвращаемое значение этой процедуры — код завершения потока.
2.	 Поток можно принудительно завершить из другого потока в том же процессе.
3.	 Поток может вызвать функцию pthread_exit.
#include <pthread.h>
void pthread_exit(void *rval_ptr);

Аргумент rval_ptr  — это нетипизированный указатель, аналогичный аргументу,
передаваемому запускающей процедуре. Этот указатель смогут получить другие
потоки процесса, вызвавшие функцию pthread_join.

11.5. Завершение потока   

461

#include <pthread.h>
int pthread_join(pthread_t thread, void **rval_ptr);

Возвращает 0 в случае успеха, код ошибки — в случае неудачи
Вызывающий поток будет заблокирован, пока указанный поток не вызовет функцию pthread_exit, не вернет управление из запускающей процедуры или не будет принудительно завершен другим потоком. Если поток просто выйдет из запускающей процедуры, rval_ptr будет содержать возвращаемое значение. Если
поток был принудительно завершен, по адресу rval_ptr будет записано значение
PTHREAD_CANCELED.
Вызов функции pthread_join автоматически переводит поток в  обособленное
состояние (вскоре мы обсудим это), которое позволяет вернуть ресурсы потока
обратно. Если он уже находится в  обособленном состоянии, поток, вызвавший
pthread_join, получит код ошибки EINVAL.
Если нас не интересует возвращаемое значение потока, мы можем передать пустой указатель в аргументе rval_ptr. В этом случае обращение к функции pthread_
join позволит дождаться завершения указанного потока, но не вернет код его завершения.

Пример
В листинге 11.2 показано, как получить код выхода завершившегося потока.
Листинг 11.2. Получение кода выхода потока
#include "apue.h"
#include <pthread.h>
void *
thr_fn1(void *arg)
{
printf("поток 1: выход\n");
return((void *)1);
}
void *
thr_fn2(void *arg)
{
printf("поток 2: выход\n");
pthread_exit((void *)2);
}
int
main(void)
{
int
pthread_t
void

err;
tid1, tid2;
*tret;

err = pthread_create(&tid1, NULL, thr_fn1, NULL);

462    Глава 11. Потоки

}

if (err != 0)
err_exit(err, "невозможно создать поток 1");
err = pthread_create(&tid2, NULL, thr_fn2, NULL);
if (err != 0)
err_exit(err, "невозможно создать поток 2");
err = pthread_join(tid1, &tret);
if (err != 0)
err_exit(err, "невозможно присоединить поток 1");
printf("код выхода потока 1: %ld\n", (long)tret);
err = pthread_join(tid2, &tret);
if (err != 0)
err_exit(err, "невозможно присоединить поток 2");
printf("код выхода потока 2: %ld\n", (long)tret);
exit(0);

Запустив программу из листинга 11.2, мы получили:
$ ./a.out
поток 1: выход
поток 2: выход
код выхода потока 1: 1
код выхода потока 2: 2

Как видите, когда поток завершается вызовом функции pthread_exit или просто
возвращая управление из запускающей процедуры, другой поток может получить
код выхода вызовом pthread_join.
Нетипизированный указатель, передаваемый функциям pthread_create
и  pthread_exit, может использоваться для передачи более одного значения.
В этом указателе можно передать адрес структуры, содержащей большой объем
информации. Помните, что этот адрес должен оставаться действительным после
выхода из вызывающей функции. Если, к примеру, структура размещается на стеке вызывающей функции, ее содержимое может оказаться измененным к моменту,
когда она будет использована. Если поток размещает структуру на стеке и передает указатель на нее функции pthread_exit, стек этого потока может оказаться
разрушенным, а память, занимаемая им, может быть использована повторно для
других целей к моменту, когда поток, вызвавший pthread_join, попытается обратиться к ней.

Пример
Программа в листинге 11.3 демонстрирует проблему, связанную с использованием переменной с автоматическим классом размещения (на стеке) в качестве аргумента функции pthread_exit.
Листинг 11.3. Некорректное использование аргумента функции pthread_exit
#include "apue.h"
#include <pthread.h>
struct foo {
int a, b, c, d;
};
void

11.5. Завершение потока   

printfoo(const char *s, const struct foo *fp)
{
printf("%s", s);
printf(" структура по адресу 0x%lx\n", (unsigned long)fp);
printf(" foo.a = %d\n", fp->a);
printf(" foo.b = %d\n", fp->b);
printf(" foo.c = %d\n", fp->c);
printf(" foo.d = %d\n", fp->d);
}
void *
thr_fn1(void *arg)
{
struct foo foo = {1, 2, 3, 4};

}

printfoo("поток 1:\n", &foo);
pthread_exit((void *)&foo);

void *
thr_fn2(void *arg)
{
printf("поток 2: идентификатор - %lu\n", (unsigned long)pthread_self());
pthread_exit((void *)0);
}
int
main(void)
{
int
pthread_t
struct foo

}

err;
tid1, tid2;
*fp;

err = pthread_create(&tid1, NULL, thr_fn1, NULL);
if (err != 0)
err_exit(err, "невозможно создать поток 1");
err = pthread_join(tid1, (void *)&fp);
if (err != 0)
err_exit(err, "невозможно присоединить поток 1");
sleep(1);
printf("родительский процесс создает второй поток\n");
err = pthread_create(&tid2, NULL, thr_fn2, NULL);
if (err != 0)
err_exit(err, "невозможно создать поток 2");
sleep(1);
printfoo("родительский процесс:\n", fp);
exit(0);

Запустив эту программу в Linux, мы получили:
$ ./a.out
поток 1:
структура по адресу 0x7f2c83682ed0
foo.a = 1
foo.b = 2
foo.c = 3
foo.d = 4
родительский процесс создает второй поток
поток 2: идентификатор - 139829159933696

463

464    Глава 11. Потоки
родительский процесс:
структура по адресу 0x7f2c83682ed0
foo.a = -2090321472
foo.b = 32556
foo.c = 1
foo.d = 0

Разумеется, результаты зависят от архитектуры памяти, компилятора и реализации библиотеки функций для работы с потоками. В Solaris были получены похожие результаты:
$ ./a.out
поток 1:
структура по адресу 0xffffffff7f0fbf30
foo.a = 1
foo.b = 2
foo.c = 3
foo.d = 4
родительский процесс создает второй поток
поток 2: идентификатор - 3
родительский процесс:
структура по адресу 0xffffffff7f0fbf30
foo.a = -1
foo.b = 2136969048
foo.c = -1
foo.d = 2138049024

Как видите, содержимое структуры (размещенной на стеке потоком tid1) изменилось к тому моменту, когда главный поток получил к ней доступ. Обратите внимание, как стек второго потока (tid2) наложился на стек первого потока. Чтобы
решить эту проблему, можно либо использовать глобальную память, либо размещать структуру с помощью функции malloc.
В Mac OS X мы получили иные результаты:
$ ./a.out
поток 1:
структура по адресу 0x1000b6f00
foo.a = 1
foo.b = 2
foo.c = 3
foo.d = 4
родительский процесс создает второй поток
поток 2: идентификатор - 4295716864
родительский процесс:
структура по адресу 0x1000b6f00
Segmentation fault (core dumped)

В данном случае, когда родитель попытался получить доступ к структуре, переданной ему при выходе из первого потока, ее адрес оказался недействительным
и родителю был послан сигнал SIGSEGV.
В FreeBSD память не была затерта к  моменту, когда родитель обратился к  ней,
и мы получили:
поток 1:
структура по адресу 0xbf9fef88
foo.a = 1

11.5. Завершение потока   

465

foo.b = 2
foo.c = 3
foo.d = 4
родительский процесс создает второй поток
поток 2: идентификатор - 673279680
родительский процесс:
структура по адресу 0xbf9fef88
foo.a = 1
foo.b = 2
foo.c = 3
foo.d = 4

Но даже при том что после выхода из потока память оказалась не повреждена, мы
не должны полагать, что так будет всегда. Кроме того, на других платформах мы
наблюдаем как раз противоположное поведение.
Один поток может передать запрос на принудительное завершение другого потока в том же процессе, обратившись к функции pthread_cancel.
#include <pthread.h>
int pthread_cancel(pthread_t tid);

Возвращает 0 в случае успеха, код ошибки — в случае неудачи
По умолчанию вызов pthread_cancel заставляет указанный поток вести себя так,
словно он вызвал функцию pthread_exit с аргументом PTHREAD_CANCELED. Однако поток может отвергнуть запрос или как-то иначе отреагировать на него. Более
подробно мы обсудим эту тему в разделе 12.7. Обратите внимание, что функция
pthread_cancel не ждет завершения потока. Она просто посылает з­ апрос.
Поток может назначить некоторую функцию для вызова в момент его завершения
примерно так же, как это делается для процессов с помощью функции atexit (раздел 7.3), которая регистрирует функции, запускаемые при завершении процесса.
Эти функции называют функциями обработки выхода из потока. Поток может
зарегистрировать несколько таких функций обработки выхода. Обработчики заносятся в стек — это означает, что они будут вызываться в порядке, обратном порядку их регистрации.
#include <pthread.h>
void pthread_cleanup_push(void (*rtn)(void *), void *arg);
void pthread_cleanup_pop(int execute);

Функция pthread_cleanup_push регистрирует функцию rtn, которая будет вызвана с аргументом arg, когда поток выполнит одно из следующих действий:
 вызовет функцию pthread_exit;
 ответит на запрос о принудительном завершении;
 вызовет функцию pthread_cleanup_pop с ненулевым аргументом execute.

466    Глава 11. Потоки
Если аргумент execute имеет значение 0, функция обработки выхода из потока вызываться не будет. В  любом случае функция pthread_cleanup_pop удаляет
функцию-обработчик, зарегистрированную последним обращением к  функции
pthread_cleanup_push.
Ограничение, связанное с  этими функциями, заключается в  том, что они могут
быть реализованы в виде макроопределений, и тогда они должны использоваться
в паре, в пределах одной области видимости в потоке. Макроопределение функции pthread_cleanup_push может включать символ {, и тогда парная ей скобка }
будет находиться в макроопределении pthread_cleanup_pop.

Пример
В листинге 11.4 показан порядок использования функций обработки выхода из
потока. Это во многом надуманный пример, тем не менее он прозрачно иллюстрирует описываемую методику. Обратите внимание: хотя ненулевой аргумент не передается в функцию pthread_cleanup_pop, мы по-прежнему вынуждены вызывать
функции pthread_cleanup_push и  pthread_cleanup_pop в  паре, иначе программа
может не скомпилироваться.
Листинг 11.4. Обработчик выхода из потока
#include "apue.h"
#include <pthread.h>
void
cleanup(void *arg)
{
printf("выход: %s\n", (char *)arg);
}
void *
thr_fn1(void *arg)
{
printf("запуск потока 1\n");
pthread_cleanup_push(cleanup, "поток 1, первый обработчик");
pthread_cleanup_push(cleanup, "поток 1, второй обработчик");
printf("поток 1, регистрация обработчиков закончена\n");
if (arg)
return((void *)1);
pthread_cleanup_pop(0);
pthread_cleanup_pop(0);
return((void *)1);
}
void *
thr_fn2(void *arg)
{
printf("запуск потока 2\n");
pthread_cleanup_push(cleanup, "поток 2, первый обработчик");
pthread_cleanup_push(cleanup, "поток 2, второй обработчик");
printf("поток 1, регистрация обработчиков закончена\n");
if (arg)
pthread_exit((void *)2);
pthread_cleanup_pop(0);
pthread_cleanup_pop(0);

11.5. Завершение потока   

}

pthread_exit((void *)2);

int
main(void)
{
int
pthread_t
void

}

467

err;
tid1, tid2;
*tret;

err = pthread_create(&tid1, NULL, thr_fn1, (void *)1);
if (err != 0)
err_exit(err, "невозможно создать поток 1");
err = pthread_create(&tid2, NULL, thr_fn2, (void *)1);
if (err != 0)
err_exit(err, "невозможно создать поток 2");
err = pthread_join(tid1, &tret);
if (err != 0)
err_exit(err, "невозможно присоединить поток 1");
printf("код выхода потока 1: %ld\n", (long)tret);
err = pthread_join(tid2, &tret);
if (err != 0)
err_exit(err, "невозможно присоединить поток 2");
printf("код выхода потока 2: %ld\n", (long)tret);
exit(0);

Запуск программы из листинга 11.4 дал нам следующие результаты:
$ ./a.out
запуск потока 1
поток 1, регистрация обработчиков закончена
запуск потока 2
поток 2, регистрация обработчиков закончена
выход: поток 2, второй обработчик
выход: поток 2, первый обработчик
код выхода потока 1: 1
код выхода потока 2: 2

Из полученных результатов видно, что оба потока нормально запустились и корректно завершились, но функции обработки выхода были вызваны только для
второго потока. Отсюда можно сделать вывод, что функции обработки выхода из
потока не вызываются, если поток завершается простым возвратом из процедуры
запуска. Кроме того, обратите внимание, что функции обработки выхода запускаются в порядке, обратном порядку их регистрации.
Если запустить ту же программу в FreeBSD или Mac OS X, программа завершится
аварийно с сохранением файла core. Проблема в том, что в этих системах функция pthread_cleanup_push реализована как макрос, сохраняющий некоторые контекстные данные на стеке. Когда поток 1 возвращает управление между вызовами
pthread_cleanup_push и pthread_cleanup_pop, содержимое стека затирается и программа в этих системах использует уже поврежденный к этому моменту контекст,
когда пытается вызвать обработчики выхода из потока. Поведение системы при
возврате между соответствующими парными вызовами pthread_cleanup_push
и pthread_cleanup_pop не регламентируется стандартом Single UNIX Specification.

468    Глава 11. Потоки
Единственный переносимый способ выполнить возврат между вызовами этих
двух функций — обратиться к функции pthread_exit.
Сейчас вы уже должны обнаружить некоторые черты сходства между функциями
управления процессами и функциями управления потоками.
В табл. 11.1 приводится список аналогичных функций.
Таблица 11.1. Сравнение функций управления процессами и потоками
Процессы

Потоки

Описание

fork

pthread_create

Создает новый поток управления

exit

pthread_exit

Завершает существующий поток управления

waitpid

pthread_join

Возвращает код выхода из потока управления

atexit

pthread_cleanup_push

Регистрирует функцию обработки выхода из потока
управления

getpid

pthread_self

Возвращает идентификатор потока управления

abort

pthread_cancel

Запрашивает аварийное завершение потока управления

По умолчанию код завершения потока сохраняется, пока для этого потока не будет вызвана функция pthread_join. Основная память потока может быть немедленно освобождена по его завершении, если поток был обособлен. Когда поток
обособлен, функция pthread_join не может использоваться для получения его
кода завершения, потому что в этом случае ее поведение не определено. Обособить поток можно с помощью функции pthread_detach.
#include <pthread.h>
int pthread_detach(pthread_t tid);

Возвращает 0 в случае успеха, код ошибки — в случае неудачи
Как мы увидим в следующей главе, существует возможность создания потока изначально в обособленном состоянии, через изменение атрибутов потока, передаваемых функции pthread_create.

11.6. Синхронизация потоков
При наличии нескольких потоков управления, совместно использующих одни
и те же данные, необходимо гарантировать, что все потоки будут видеть стабильное представление этих данных. Если каждый из потоков использует переменные,
которые не модифицируются в других потоках, проблем не возникает. Аналогично, если переменная доступна одновременно нескольким потокам только для чтения, здесь также отсутствует проблема сохранения непротиворечивости.
Однако если один поток изменяет значение переменной, читать или изменять которое могут также другие потоки, необходимо синхронизировать доступ к пере-

11.6. Синхронизация потоков   

469

менной, чтобы гарантировать, что потоки не будут получать неверное значение
переменной при одновременном доступе к ней.
Когда поток изменяет значение переменной, существует потенциальная опасность, что другой поток прочитает еще не до конца записанное значение. На аппаратных платформах, где запись в память осуществляется более чем за один цикл,
может произойти так, что между двумя циклами записи вклинится цикл чтения.
Разумеется, такое поведение во многом зависит от аппаратной архитектуры, но
при написании переносимых программ мы не можем полагаться на то, что они
будут выполняться только на определенной платформе.
На рис. 11.2 приводится пример гипотетической ситуации, когда два потока одновременно выполняют запись и  чтение значения одной и  той же переменной.
В данном примере поток A читает значение переменной и затем записывает в нее
новое значение, но операция записи производится за два цикла. Если поток B прочитает значение этой же переменной между двумя циклами записи, он обнаружит
переменную в несогласованном состоянии.
Поток А

Поток B

Чтение

Время

Запись 1
Чтение
Запись 2

Рис. 11.2. Перемежение циклов доступа к памяти из двух потоков

Для решения этой проблемы потоки должны использовать блокировки, которые
позволят только одному потоку работать с  переменной в  один момент времени.
На рис. 11.3 показана подобная синхронизация. Если поток B должен прочитать
значение переменной, он устанавливает блокировку. Аналогично, когда поток A
изменяет значение переменной, он также устанавливает блокировку. Благодаря
такой организации поток B не сможет прочитать значение переменной, пока поток A не снимет блокировку.
Точно так же следует синхронизировать два или более потока, которые могут попытаться одновременно изменить значение переменной. Рассмотрим случай, когда выполняется увеличение значения переменной на 1 (рис. 11.4). Операцию увеличения (инкремента) обычно можно разбить на три шага.
1.	 Прочитать значение переменной из памяти в регистр процессора.
2.	 Увеличить значение в регистре.
3.	 Записать новое значение из регистра процессора в память.

470    Глава 11. Потоки
Поток A

Поток B
Чтение

Чтение

Время

Запись 1

Запись 2

Чтение

Рис. 11.3. Синхронизированный доступ к памяти из двух потоков

Если два потока попытаются одновременно увеличить значение одной и той же
переменной, не согласуя свои действия между собой, результаты могут получиться самые разные. В конечном итоге полученное значение может оказаться на 1 или
на 2 больше предыдущего в зависимости от того, какое значение получил второй
поток перед началом операции. Если второй поток выполнил шаг 1 до того, как
первый выполнил шаг 3, второй поток прочитает то же значение, что и первый поток, увеличит его на 1 и запишет обратно в память, фактически не оказав никакого
влияния на значение переменной.
Если изменение переменной производится атомарно, подобная гонка между потоками отсутствует. В  предыдущем примере, если увеличение производится за
одно обращение к памяти, состояние гонки между потоками не возникает. Если
данные постоянно находятся в непротиворечивом состоянии, нет необходимости
предусматривать дополнительную синхронизацию. Операции являются последовательно непротиворечивыми, если различные потоки не могут получить доступ к данным, когда они находятся в противоречивом состоянии. В современных
компьютерных системах доступ к памяти выполняется за несколько тактов шины,
а  в  многопроцессорных системах доступ к  шине вообще чередуется между несколькими процессорами, поэтому невозможно гарантировать непротиворечивое
состояние данных в любой произвольный момент времени.
В непротиворечивой среде изменения данных можно описать как последовательность операций, выполняемых потоками. Мы можем сказать: «Поток A увеличил
значение переменной, затем поток B увеличил значение переменной, в результате значение переменной было увеличено на 2» или: «Поток B увеличил значение
переменной, затем поток A увеличил значение переменной, в результате значение
переменной было увеличено на 2». Конечный результат не зависит от порядка выполнения потоков.

11.6. Синхронизация потоков   

Поток A

Поток B

Записать значение
переменной i в регистр
(регистр = 5)

471

Содержимое переменной i

5

Увеличить содержимое
регистра (регистр = 6)

Записать значение
переменной i в регистр
(регистр = 5)

5

Сохранить значение
регистра в переменную i
(регистр = 6)

Увеличить содержимое
регистра (регистр = 6)

6

Сохранить значение
регистра в переменную i
(регистр = 6)

6

Время

Рис. 11.4. Два несинхронизированных потока пытаются увеличить значение
одной и той же переменной

Помимо особенностей аппаратной архитектуры, состояние гонки может быть вызвано алгоритмом использования переменных в  программах. Например, мы можем увеличить значение переменной и затем, основываясь на полученном значении, принять решение о дальнейшем порядке выполнения операций. Комбинация
операций, состоящая из увеличения переменной и проверки полученного значения, не является атомарной, и, таким образом, появляется вероятность принятия
неверного решения.

11.6.1. Мьютексы
Мы можем защитить данные и ограничить доступ к ним одним потоком в один
момент времени с  помощью взаимоисключений (mutual-exclusion) интерфейса
pthreads. Мьютекс (mutex) — это фактически блокировка, которая устанавливается (запирается) перед обращением к разделяемому ресурсу и снимается (отпирается) после выполнения требуемой последовательности операций. Если мьютекс
заперт, любой другой поток, который попытается запереть его, будет заблокирован, пока мьютекс не будет отперт. Если в момент отпирания мьютекса сразу несколько потоков будут находиться в заблокированном состоянии, все они будут
запущены, и первый, кто успеет запереть мьютекс, продолжит работу. Все остальные потоки обнаружат запертый мьютекс и опять перейдут в режим ожидания. Таким образом, доступ к ресурсу сможет получить одновременно только один поток.

472    Глава 11. Потоки
Такой механизм взаимоисключений будет корректно работать только при условии, что все потоки приложения соблюдают одни и те же правила доступа к данным. Операционная система никак не упорядочивает доступ к данным. Если мы
позволим одному потоку производить действия с  общими данными, предварительно не ограничив доступ к ним, остальные потоки могут обнаружить эти данные в противоречивом состоянии, даже если перед обращением к ним будут устанавливать блокировку.
Переменные-мьютексы определяются с  типом pthread_mutex_t. Прежде чем использовать переменную-мьютекс, следует сначала инициализировать ее, записав
значение константы PTHREAD_MUTEX_INITIALIZER (только для статически размещаемых мьютексов) или вызвав функцию pthread_mutex_init. Если мьютекс размещается в динамической памяти (например, с помощью функции malloc), прежде
чем освободить занимаемую память, необходимо вызвать функцию pthread_
mutex_destroy.
#include <pthread.h>
int pthread_mutex_init(pthread_mutex_t *restrict mutex,
const pthread_mutexattr_t *restrict attr);
int pthread_mutex_destroy(pthread_mutex_t *mutex);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
Чтобы инициализировать мьютекс со значениями атрибутов по умолчанию, нужно передать NULL в аргументе attr. Конкретные значения атрибутов мьютексов мы
рассмотрим в разделе 12.4.
Запирается мьютекс вызовом функции pthread_mutex_lock. Если мьютекс уже
заперт, вызывающий поток будет заблокирован, пока мьютекс не будет отперт.
Мьютекс отпирается вызовом функции pthread_mutex_unlock.
#include <pthread.h>
int pthread_mutex_lock(pthread_mutex_t *mutex);
int pthread_mutex_trylock(pthread_mutex_t *mutex);
int pthread_mutex_unlock(pthread_mutex_t *mutex);

Все три возвращают 0 в случае успеха, код ошибки — в случае неудачи
Если поток не должен блокироваться при попытке запереть мьютекс, он может
воспользоваться функцией pthread_mutex_trylock. Если к моменту вызова этой
функции мьютекс будет отперт, функция запрет мьютекс и  вернет значение 0.
В противном случае pthread_mutex_trylock вернет код ошибки EBUSY.

Пример
Листинг 11.5 иллюстрирует использование мьютексов для защиты структуры
данных. Если более чем один поток работает с данными, размещаемыми динами-

11.6. Синхронизация потоков   

473

чески, мы можем предусмотреть в  структуре данных счетчик ссылок на объект,
чтобы освобождать память, только когда все потоки завершат работу с объектом.
Листинг 11.5. Использование мьютексов для защиты структур данных
#include <stdlib.h>
#include <pthread.h>
struct foo {
int
f_count;
pthread_mutex_t f_lock;
int
f_id
/* ... другие поля структуры ... */
};
struct foo *
foo_alloc(int id) /* размещает объект в динамической памяти */
{
struct foo *fp;

}

if ((fp = malloc(sizeof(struct foo))) != NULL) {
fp->f_count = 1;
fp->f_id = id;
if (pthread_mutex_init(&fp->f_lock, NULL) != 0) {
free(fp);
return(NULL);
}
/* ... продолжение инициализации ... */
}
return(fp);

void
foo_hold(struct foo *fp) /* наращивает счетчик ссылок на объект */
{
pthread_mutex_lock(&fp->f_lock);
fp->f_count++;
pthread_mutex_unlock(&fp->f_lock);
}
void
foo_rele(struct foo *fp) /* освобождает ссылку на объект */
{
pthread_mutex_lock(&fp->f_lock);
if (--fp->f_count == 0) { /* последняя ссылка */
pthread_mutex_unlock(&fp->f_lock);
pthread_mutex_destroy(&fp->f_lock);
free(fp);
} else {
pthread_mutex_unlock(&fp->f_lock);
}
}

Перед увеличением или уменьшением счетчика ссылок и перед его проверкой на
равенство нулю мьютекс запирается. При инициализации счетчика ссылок значением 1 в функции foo_alloc запирать мьютекс нет необходимости, поскольку
пока только поток, который размещает структуру, имеет к  ней доступ. Если бы
в этой точке структура включалась в некий список, она могла бы быть обнаружена
другими потоками, и тогда пришлось бы сначала запереть мьютекс.

474    Глава 11. Потоки
Прежде чем приступить к  работе с  объектом, поток должен увеличить счетчик
ссылок на него. По окончании работы с объектом поток должен удалить ссылку.
Когда удаляется последняя ссылка, память, занимаемая объектом, освобождается.
Данный пример игнорирует возможность обнаружения объектов другими потоками перед вызовом foo_hold. Даже если счетчик ссылок равен нулю, для foo_rele
было бы ошибкой пытаться освободить память, занимаемую объектом, так как
другой поток мог запереть мьютекс вызовом foo_hold. Этой проблемы можно избежать, если перед освобождением памяти убедиться, что объект не может быть
найден. Как это сделать, будет показано в примерах, следующих ниже.

11.6.2. Предотвращение тупиковых ситуаций
Поток может попасть в тупиковую ситуацию (deadlock), если попытается дважды
захватить один и тот же мьютекс, но есть и менее очевидные способы. Например,
тупиковая ситуация может возникнуть, когда в программе используется несколько мьютексов и один поток, удерживая первый мьютекс, пытается запереть второй, в то время как другой поток аналогично удерживает второй мьютекс и пытается запереть первый. В результате ни один из потоков не сможет продолжить
работу, поскольку каждый будет ждать освобождения ресурса, захваченного другим потоком. Возникнет тупиковая ситуация.
Тупиковых ситуаций можно избежать, жестко определив порядок захвата ресурсов. Приведем пример. Предположим, что есть два мьютекса, A и B, которые необходимо запереть одновременно. Если все потоки сначала будут запирать мьютекс A, а потом B, тупиковой ситуации с этими мьютексами никогда не возникнет.
Аналогично, если все потоки сначала будут запирать мьютекс B, а  потом A, тупиковой ситуации с  этими мьютексами также никогда не возникнет. Опасность
попадания в тупиковую ситуацию возникает, только когда разные потоки могут
попытаться запереть мьютексы в разном порядке.
Иногда архитектура приложения не позволяет заранее предопределить порядок
захвата мьютексов. Если программа использует достаточно много мьютексов
и структур данных, а доступные функции, которые работают с ними, не укладываются в достаточно простую иерархию, придется попробовать иной подход. Например, при невозможности запереть мьютекс можно отпереть захваченные мьютексы и повторить попытку немного позже. В этом случае во избежание блокировки
потока можно использовать функцию pthread_mutex_trylock. Если мьютекс удалось запереть с помощью pthread_mutex_trylock, можно продолжить работу. Если
мьютекс запереть не удалось, можно отпереть уже захваченные мьютексы, освободить занятые ресурсы и повторить попытку немного позже.

Пример
В этом примере приводится дополненная версия программы из листинга 11.5
с целью продемонстрировать работу с двумя мьютексами. Во избежание тупиковой ситуации, которая может возникнуть при попытке одновременного захвата
обоих ресурсов, во всех потоках используется один и тот же порядок запирания
мьютексов.

11.6. Синхронизация потоков   

475

Второй мьютекс защищает хеш-список структур foo. То есть мьютекс hashlock защищает хеш-таблицу fh и поле связи f_next в структуре foo. Доступ к остальным
полям структуры foo производится под защитой мьютекса f_lock.
Листинг 11.6. Использование двух мьютексов
#include <stdlib.h>
#include <pthread.h>
#define NHASH 29
#define HASH(id) (((unsigned long)id)%NHASH)
struct foo *fh[NHASH];
pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;
struct foo {
int
f_count;
pthread_mutex_t f_lock;
int
f_id;
struct foo
*f_next; /* защищается мьютексом hashlock */
/* ... другие поля структуры ... */
};
struct foo *
foo_alloc(void) /* размещает объект в динамической памяти */
{
struct foo *fp;
int
idx;

}

if ((fp = malloc(sizeof(struct foo))) != NULL) {
fp->f_count = 1;
fp->f_id = id;
if (pthread_mutex_init(&fp->f_lock, NULL) != 0) {
free(fp);
return(NULL);
}
idx = HASH(fp);
pthread_mutex_lock(&hashlock);
fp->f_next = fh[idx];
fh[idx] = fp->f_next;
pthread_mutex_lock(&fp->f_lock);
pthread_mutex_unlock(&hashlock);
/* ... продолжение инициализации ... */
pthread_mutex_unlock(&fp->f_lock);
}
return(fp);

void
foo_hold(struct foo *fp) /* добавляет ссылку на объект */
{
pthread_mutex_lock(&fp->f_lock);
fp->f_count++;
pthread_mutex_unlock(&fp->f_lock);
}
struct foo *
foo_find(int id) /* находит существующий объект */

476    Глава 11. Потоки
{

}

struct foo *fp;
pthread_mutex_lock(&hashlock);
for (fp = fh[HASH(id)]; fp != NULL; fp = fp->f_next) {
if (fp->f_id == id) {
foo_hold(fp);
break;
}
}
pthread_mutex_unlock(&hashlock);
return(fp);

void
foo_rele(struct foo *fp) /* освобождает ссылку на объект */
{
struct foo *tfp;
int
idx;

}

pthread_mutex_lock(&fp->f_lock);
if (fp->f_count == 1) { /* последняя ссылка */
pthread_mutex_unlock(&fp->f_lock);
pthread_mutex_lock(&hashlock);
pthread_mutex_lock(&fp->f_lock);
/* необходима повторная проверка условия */
if (fp->f_count != 1) {
fp->f_count--;
pthread_mutex_unlock(&fp->f_lock);
pthread_mutex_unlock(&hashlock);
return;
}
/* удалить из списка */
idx = HASH(fp->f_id);
tfp = fh[idx];
if (tfp == fp) {
fh[idx] = fp->f_next;
} else {
while (tfp->f_next != fp)
tfp = tfp->f_next;
tfp->f_next = fp->f_next;
}
pthread_mutex_unlock(&hashlock);
pthread_mutex_unlock(&fp->f_lock);
pthread_mutex_destroy(&fp->f_lock);
free(fp);
} else {
fp->f_count;
pthread_mutex_unlock(&fp->f_lock);
}

Сравнив листинги 11.6 и 11.5, можно заметить, что теперь функция размещения
объекта в динамической памяти блокирует доступ к хеш-таблице, добавляет в нее
новую структуру, а  перед снятием блокировки с  хеш-таблицы запирает новую
структуру. Поскольку новая структура размещается в глобальном списке, ее может обнаружить любой другой поток, и поэтому мы вынуждены запирать ее, пока
не будет закончена инициализация структуры.

11.6. Синхронизация потоков   

477

Функция foo_find запирает хеш-таблицу и  производит поиск запрошенной
структуры. Если таковая будет найдена, мы увеличиваем в  ней счетчик ссылок
и  возвращаем указатель на структуру. Обратите внимание, что здесь мы соблюдаем порядок захвата мьютексов, запирая мьютекс hashlock до того, как функция
foo_hold запрет мьютекс f_lock.
Теперь перейдем к функции foo_rele, алгоритм работы которой несколько сложнее. Если освобождается последняя ссылка на объект, необходимо отпереть мьютекс f_lock, чтобы запереть hashlock, поскольку нам необходимо удалить структуру из списка. После этого необходимо запереть мьютекс f_lock.
Учитывая, что поток мог быть заблокирован во время повторной попытки захватить мьютексы, мы вынуждены повторить проверку необходимости удаления
структуры. Если какой-либо другой поток нашел структуру и нарастил счетчик
ссылок в ней, в то время как данный поток был заблокирован в ожидании освобождения мьютекса, мы просто уменьшаем счетчик ссылок, отпираем оба мьютекса и возвращаем управление.
Алгоритм работы с мьютексами получился довольно сложным, поэтому пересмотрим его. Алгоритм заметно упростится, если мьютекс hashlock будет защищать
еще и счетчик ссылок. Мьютекс f_lock будет защищать все остальные поля структуры foo. Эти изменения отражены в листинге 11.7.
Листинг 11.7. Упрощенный вариант использования мьютексов
#include <stdlib.h>
#include <pthread.h>
#define NHASH 29
#define HASH(id) (((unsigned long)id)%NHASH)
struct foo *fh[NHASH];
pthread_mutex_t hashlock = PTHREAD_MUTEX_INITIALIZER;
struct foo {
int
f_count; /* защищается мьютексом hashlock */
pthread_mutex_t f_lock;
int
f_id;
struct foo
*f_next; /* защищается мьютексом hashlock */
/* ... другие поля структуры ... */
};
struct foo *
foo_alloc(int id) /* размещает объект в динамической памяти */
{
struct foo *fp;
int
idx;
if ((fp = malloc(sizeof(struct foo))) != NULL) {
fp->f_count = 1;
fp->f_id = id;
if (pthread_mutex_init(&fp->f_lock, NULL) != 0) {
free(fp);
return(NULL);
}
idx = HASH(id);

478    Глава 11. Потоки
pthread_mutex_lock(&hashlock);
fp->f_next = fh[idx];
fh[idx] = fp;
pthread_mutex_lock(&fp->f_lock);
pthread_mutex_unlock(&hashlock);
/* ... продолжение инициализации ... */
pthread_mutex_unlock(&fp->f_lock);

}

}
return(fp);

void
foo_hold(struct foo *fp) /* добавляет ссылку на объект */
{
pthread_mutex_lock(&hashlock);
fp->f_count++;
pthread_mutex_unlock(&hashlock);
}
struct foo *
foo_find(int id) /* находит существующий объект */
{
struct foo *fp;

}

pthread_mutex_lock(&hashlock);
for (fp = fh[HASH(id)]; fp != NULL; fp = fp->f_next) {
if (fp->f_id == id) {
fp->f_count++;
break;
}
}
pthread_mutex_unlock(&hashlock);
return(fp);

void
foo_rele(struct foo *fp) /* освобождает ссылку на объект */
{
struct foo *tfp;
int
idx;

}

pthread_mutex_lock(&hashlock);
if (--fp->f_count == 0) { /* последняя ссылка, удалить из списка */
idx = HASH(fp->f_id);
tfp = fh[idx];
if (tfp == fp) {
fh[idx] = fp->f_next;
} else {
while (tfp->f_next != fp)
tfp = tfp->f_next;
tfp->f_next = fp->f_next;
}
pthread_mutex_unlock(&hashlock);
pthread_mutex_destroy(&fp->f_lock);
free(fp);
} else {
pthread_mutex_unlock(&hashlock);
}

11.6. Синхронизация потоков   

479

Обратите внимание, насколько проще стала программа по сравнению с  листингом 11.6. Когда мы стали использовать один и тот же мьютекс для защиты хешсписка и счетчика ссылок, отпала проблема соблюдения порядка захвата мьютексов. При разработке многопоточных приложений достаточно часто приходится
идти на подобные компромиссы. Слишком грубая детализация блокировок в конечном итоге приведет к тому, что большинство потоков будут простаивать при
попытках запереть один и тот же мьютекс, а преимущества многопоточной архитектуры приложения будут сведены к минимуму. Если детализация блокировок
будет слишком мелкой, это существенно усложнит код, а  производительность
приложения снизится из-за избыточного количества мьютексов. Программист
должен найти правильный баланс между производительностью и сложностью алгоритма и при этом выполнить все требования, связанные с захватом ресурсов.

11.6.3. Функция pthread_mutex_timedlock
Один из дополнительных примитивов управления мьютексами позволяет ограничить время блокировки потока при попытке захватить мьютекс, запертый другим потоком. Функция pthread_mutex_timedlock эквивалентна функции pthread_
mutex_lock, но по истечении указанного тайм-аута pthread_mutex_timedlock
вернет код ошибки ETIMEDOUT, не запирая мьютекс.
#include <pthread.h>
#include <time.h>
int pthread_mutex_timedlock(pthread_mutex_t *restrict mutex,
const struct timespec *restrict tsptr);

Возвращает 0 в случае успеха, код ошибки — в случае неудачи
Под тайм-аутом здесь понимается абсолютное время (в противоположность относительному; то есть мы должны указать момент времени X, когда следует прекратить попытки приобрести блокировку, а не количество секунд Y, в течение которых следует ждать освобождения мьютекса, если он занят). Значение тайм-аута
определяется в  виде структуры timespec, хранящей время в  секундах и  наносекундах.

Пример
Листинг 11.8 демонстрирует, как использовать функцию pthread_mutex_timedlock,
чтобы избежать блокировки потока навечно.
Листинг 11.8. Использование функции pthread_mutex_timedlock
#include "apue.h"
#include <pthread.h>
int
main(void)
{
int err;
struct timespec tout;

480    Глава 11. Потоки
struct tm *tmp;
char buf[64];

}

pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_lock(&lock);
printf("мьютекс заперт\n");
clock_gettime(CLOCK_REALTIME, &tout);
tmp = localtime(&tout.tv_sec);
strftime(buf, sizeof(buf), "%r", tmp);
printf("текущее время: %s\n", buf);
tout.tv_sec += 10; /* 10 секунд, начиная от текущего времени */
/* внимание: это может привести к тупиковой ситуации */
err = pthread_mutex_timedlock(&lock, &tout);
clock_gettime(CLOCK_REALTIME, &tout);
tmp = localtime(&tout.tv_sec);
strftime(buf, sizeof(buf), "%r", tmp);
printf("текущее время: %s\n", buf);
if (err == 0)
printf("мьютекс снова заперт!\n");
else
printf("не получилось повторно запереть мьютекс: %s\n", strerror(err));
exit(0);

Ниже приводится вывод программы из листинга 11.8.
$ ./a.out
мьютекс заперт
текущее время: 11:41:58 AM
текущее время: 11:42:08 AM
не получилось повторно запереть мьютекс: Connection timed out

Эта программа преднамеренно пытается повторно запереть уже запертый мьютекс, чтобы продемонстрировать работу функции pthread_mutex_timedlock. Данную стратегию не рекомендуется использовать на практике, потому что она может
служить источником тупиковых ситуаций.
Обратите внимание, что протяженность интервала блокировки может варьироваться в некоторых пределах по следующим причинам: начальный момент времени может быть определен в  середине текущей секунды, разрешение системных часов может быть недостаточно точным для поддержки желаемой точности
тайм-аута, задержки в планировщике задач могут вызвать увеличение времени
ожидания.
Mac OS X 10.6.8 не поддерживает функцию pthread_mutex_timedlock, но FreeBSD 8.0,
Linux 3.2.0 и Solaris 10 поддерживают ее, однако в Solaris эта функция до сих пор находится в библиотеке реального времени, librt. В Solaris 10 имеется также альтернативная
функция, которой можно передать относительный тайм-аут.

11.6.4. Блокировки чтения-записи
Блокировки чтения-записи похожи на мьютексы, за исключением того, что они
допускают более высокую степень параллелизма. Мьютексы могут иметь всего
два состояния, закрытое и открытое, и только один поток может владеть мьютек-

11.6. Синхронизация потоков   

481

сом в каждый момент времени. Блокировки чтения-записи могут иметь три состояния: режим блокировки для чтения, режим блокировки для записи и отсутствие
блокировки. Режим блокировки для записи может установить только один поток,
но установка режима блокировки для чтения доступна нескольким потокам одновременно.
Если блокировка чтения-записи установлена в режиме для записи, все потоки, которые попытаются захватить ее, будут приостановлены, пока блокировка не будет
снята. Если блокировка чтения-записи установлена в режиме для чтения, все потоки, которые попытаются захватить ее для чтения, получат доступ к ресурсу, но
если какой-либо поток попытается установить режим блокировки для записи, он
будет приостановлен, пока не будет снята последняя блокировка для чтения. Разные реализации блокировок чтения-записи могут различаться существенно, но
обычно, если блокировка для чтения уже установлена и имеется поток, который
пытается установить блокировку для записи, остальные потоки, которые пытаются получить блокировку для чтения, будут приостановлены. Это предотвращает
возможность блокирования пишущих потоков непрекращающимися запросами
на получение блокировки для чтения.
Блокировки чтения-записи прекрасно подходят для ситуаций, когда чтение данных производится намного чаще, чем запись. Когда блокировка чтения-записи
установлена в  режиме для записи, можно безопасно выполнять модификацию
защищаемых ею данных, поскольку владеть блокировкой в  этом режиме может
только один поток. Когда блокировка чтения-записи установлена в  режиме для
чтения, защищаемые ею данные могут безопасно читать несколько потоков, сумевших получить блокировку для чтения.
Блокировки чтения-записи еще называют совместно-исключающими блокировками (shared-exclusive locks). Когда блокировка чтения-записи установлена в режиме для чтения, говорят, что блокировка находится в  режиме совместного использования. Когда блокировка чтения-записи установлена в режиме для записи,
говорят, что блокировка находится в режиме исключительного использования.
Как и  в  случае с  мьютексами, блокировки чтения-записи должны инициализироваться перед использованием и разрушаться перед освобождением занимаемой
ими памяти.
#include <pthread.h>
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,
const pthread_rwlockattr_t *restrict attr);
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
Функция pthread_rwlock_init инициализирует блокировку чтения-записи. Если
в аргументе attr передать пустой указатель, блокировка инициализируется с атрибутами по умолчанию. Атрибуты блокировок чтения-записи мы рассмотрим
в разделе 12.4.2.

482    Глава 11. Потоки
Стандарт Single UNIX Specification определяет константу PTHREAD_RWLOCK_
INITIALIZER как расширение XSI, которую можно использовать для инициализации статических блокировок чтения-записи, когда значений по умолчанию для
атрибутов вполне достаточно.
Перед освобождением памяти, занимаемой блокировкой чтения-записи, нужно
вызвать функцию pthread_rwlock_destroy, чтобы освободить все занимаемые
блокировкой ресурсы. Функция pthread_rwlock_init размещает все необходимые для блокировки ресурсы, а pthread_rwlock_destroy освобождает их. Если освободить память, занимаемую блокировкой чтения-записи без предварительного
обращения к функции pthread_rwlock_destroy, все ресурсы, занимаемые блокировкой, будут потеряны для системы.
Чтобы установить блокировку в режиме для чтения, необходимо вызвать функцию pthread_rwlock_rdlock. Чтобы установить блокировку в  режиме для записи, необходимо вызвать функцию pthread_rwlock_wrlock. Независимо от режима
блокировки чтения-записи, ее снятие выполняется функцией pthread_rwlock_
unlock.
#include <pthread.h>
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);

Все три возвращают 0 в случае успеха, код ошибки — в случае неудачи
Реализации могут ограничивать количество блокировок, установленных в режиме совместного использования, поэтому обязательно нужно проверять значение,
возвращаемое функцией pthread_rwlock_rdlock. Даже когда функции pthread_
rwlock_wrlock и  pthread_rwlock_unlock возвращают код ошибки, нет необходимости проверять возвращаемые значения этих функций, если схема наложения
блокировок разработана надлежащим образом. Эти функции могут вернуть код
ошибки, только когда блокировка не инициализирована или когда может возникнуть тупиковая ситуация при попытке повторно установить уже установленную
блокировку. Однако вы должны помнить, что некоторые реализации могут определять дополнительные коды ошибок.
Стандарт Single UNIX Specification определяет дополнительные версии примитивов для работы с блокировками, которые могут использоваться для проверки
состояния блокировки.
#include <pthread.h>
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи

11.6. Синхронизация потоков   

483

Если блокировка была успешно установлена, эти функции возвращают 0. Иначе
возвращается код ошибки EBUSY. Эти функции можно использовать, когда нельзя
заранее предопределить порядок установки блокировок, чтобы избежать тупиковых ситуаций, которые мы обсуждали ранее.

Пример
Программа в листинге 11.9 иллюстрирует применение блокировок чтения-записи. Очередь запросов на выполнение заданий защищается единственной блокировкой чтения-записи. Этот пример является одной из возможных реализаций
приложения, представленного на рис. 11.1, где множество потоков получают задания, назначаемые им главным потоком.
Листинг 11.9. Использование блокировки чтения-записи
#include <stdlib.h>
#include <pthread.h>
struct job {
struct job *j_next;
struct job *j_prev;
pthread_t
j_id; /* сообщает, какой поток выполняет это задание */
/* ... другие поля структуры ... */
};
struct queue {
struct job
*q_head;
struct job
*q_tail;
pthread_rwlock_t q_lock;
};
/*
* Инициализирует очередь.
*/
int
queue_init(struct queue *qp)
{
int
err;

}

qp->q_head = NULL;
qp->q_tail = NULL;
err = pthread_rwlock_init(&qp->q_lock, NULL);
if (err != 0)
return(err);
/* ... продолжение инициализации ... */
return(0);

/*
* Добавляет задание в начало очереди.
*/
void
job_insert(struct queue *qp, struct job *jp)
{
pthread_rwlock_wrlock(&qp->q_lock);
jp->j_next = qp->q_head;
jp->j_prev = NULL;

484    Глава 11. Потоки

}

if (qp->q_head != NULL)
qp->q_head->j_prev = jp;
else
qp->q_tail = jp; /* список был пуст */
qp->q_head = jp;
pthread_rwlock_unlock(&qp->q_lock);

/*
* Добавляет задание в конец очереди.
*/
void
job_append(struct queue *qp, struct job *jp)
{
pthread_rwlock_wrlock(&qp->q_lock);
jp->j_next = NULL;
jp->j_prev = qp->q_tail;
if (qp->q_tail != NULL)
qp->q_tail->j_next = jp;
else
qp->q_head = jp; /* список был пуст */
qp->q_tail = jp;
pthread_rwlock_unlock(&qp->q_lock);
}
/*
* Удаляет задание из очереди.
*/
void
job_remove(struct queue *qp, struct job *jp)
{
pthread_rwlock_wrlock(&qp->q_lock);
if (jp == qp->q_head) {
qp->q_head = jp->j_next;
if (qp->q_tail == jp)
qp->q_tail = NULL;
else
jp->j_next->j_prev = jp->j_prev;
} else if (jp == qp->q_tail) {
qp->q_tail = jp->j_prev;
jp->j_prev->j_next = jp->j_next;
} else {
jp->j_prev->j_next = jp->j_next;
jp->j_next->j_prev = jp->j_prev;
}
pthread_rwlock_unlock(&qp->q_lock);
}
/* Находит задание для потока с заданным идентификатором. */
struct job *
job_find(struct queue *qp, pthread_t id)
{
struct job *jp;
if (pthread_rwlock_rdlock(&qp->q_lock) != 0)
return(NULL);
for (jp = qp->q_head; jp != NULL; jp = jp->j_next)

11.6. Синхронизация потоков   

485

if (pthread_equal(jp->j_id, id))
break;

}

pthread_rwlock_unlock(&qp->q_lock);
return(jp);

В этом примере блокировка чтения-записи очереди устанавливается в режиме для
записи, только когда необходимо добавить новое или удалить имеющееся задание.
Когда нужно выполнить поиск задания в очереди, мы устанавливаем блокировку
в режиме для чтения, допуская возможность поиска заданий несколькими рабочими потоками одновременно. В данном случае использование блокировки чтения-записи дает прирост производительности, только если поиск заданий в очереди выполняется чаще, чем добавление или удаление.
Рабочие потоки извлекают из очереди только те задания, которые соответствуют
их идентификаторам. Поскольку сама структура с  заданием используется только одним потоком, для организации доступа к ней не требуется дополнительных
блокировок.

11.6.5. Блокировки чтения-записи с тайм-аутом
Как и в случае с мьютексами, стандарт Single UNIX Specification определяет функции для приобретения блокировок чтения-записи с тайм-аутом, не позволяющие
приложениям заблокироваться навечно при попытке приобрести блокировку. Это
функции pthread_rwlock_timedrdlock и pthread_rwlock_timedwrlock.
#include <pthread.h>
#include <time.h>
int pthread_rwlock_timedrdlock(pthread_rwlock_t *restrict rwlock,
const struct timespec *restrict tsptr);
int pthread_rwlock_timedwrlock(pthread_rwlock_t *restrict rwlock,
const struct timespec *restrict tsptr);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
Эти функции действуют подобно своим «неограниченным» эквивалентам. В аргументе tsptr они принимают указатель на структуру timespec, определяющую момент времени, когда следует прекратить попытки приобрести блокировку. Если
по истечении тайм-аута не удалось приобрести блокировку, эти функции возвращают код ошибки ETIMEDOUT. Как и в функции pthread_mutex_timedlock, тайм-аут
определяет абсолютный момент времени, а не интервал ожидания.

11.6.6. Переменные состояния
Переменные состояния (condition variables) — еще один механизм синхронизации
потоков. Переменные состояния предоставляют потокам своеобразное место встречи. При использовании вместе с мьютексами переменные состояния позволяют потокам ожидать наступления некоторого события, избегая состояния гонки.

486    Глава 11. Потоки
Сами переменные состояния защищаются мьютексами. Прежде чем изменить
значение такой переменной, поток должен захватить мьютекс. Другие потоки
не будут замечать изменений в переменной, пока не попытаются захватить этот
мьютекс, потому что для оценки переменной состояния необходимо запереть
мьютекс.
Переменная состояния, представленная типом pthread_cond_t, должна инициализироваться перед использованием. При статическом размещении переменной
ей можно присвоить значение константы PTHREAD_COND_INITIALIZER, но если переменная состояния размещается динамически, ее следует инициализировать вызовом pthread_cond_init.
Для уничтожения переменной состояния перед освобождением занимаемой ею
памяти используется функция pthread_cond_destroy.
#include <pthread.h>
int pthread_cond_init(pthread_cond_t *restrict cond,
const pthread_condattr_t *restrict attr);
int pthread_cond_destroy(pthread_cond_t *cond);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
Если в  аргументе attr передать пустой указатель, переменная состояния будет
инициализирована значениями атрибутов по умолчанию. Атрибуты переменных
состояния мы рассмотрим в разделе 12.4.3.
Функция pthread_cond_wait ждет, пока переменная перейдет в  истинное состояние. Чтобы ограничить время ожидания заданным интервалом, используется
функция pthread_cond_timedwait.
#include <pthread.h>
int pthread_cond_wait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex);
int pthread_cond_timedwait(pthread_cond_t *restrict cond,
pthread_mutex_t *restrict mutex,
const struct timespec *restrict tsptr);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
Мьютекс, передаваемый функции pthread_cond_wait, защищает доступ к  переменной состояния. Вызывающий поток передает его функции в запертом состоянии, а функция атомарно помещает вызывающий поток в список потоков, ожидающих изменения состояния переменной, и  отпирает мьютекс. Это исключает
вероятность, что переменная изменит состояние между моментом ее проверки
и моментом приостановки потока, благодаря чему поток не пропустит наступление ожидаемого события. Когда функция pthread_cond_wait возвращает управление, мьютекс снова запирается.
Функция pthread_cond_timedwait работает аналогично, но дополнительно дает
возможность ограничить время ожидания. Значение аргумента tpstr определяет,

11.6. Синхронизация потоков   

487

как долго поток будет ожидать наступления события. Время тайм-аута задается
структурой timespec.
Как было показано в листинге 11.8, в этой структуре следует указывать абсолютное время, а  не относительное. Например, если потребуется ограничить время
ожидания 3 минутами, мы должны сохранить в этой структуре не 3 минуты, а текущее время + 3 минуты.
Для этого можно воспользоваться функцией clock_gettime (раздел 6.10), возвращающей текущее время в виде структуры timespec. Однако эта функция поддерживается не всеми платформами. Вместо нее можно использовать функцию
gettimeofday, чтобы получить текущее время в виде структуры timeval, и затем
преобразовать ее в  структуру timespec. Чтобы получить абсолютное время для
аргумента tsptr, можно использовать следующую функцию (предполагается, что
продолжительность интервала времени измеряется в минутах):
#include <sys/time.h>
#include <stdlib.h>
void
maketimeout(struct timespec *tsp, long minutes)
{
struct timeval now;

}

/* получить текущее время */
gettimeofday(&now);
tsp->tv_sec = now.tv_sec;
tsp->tv_nsec = now.tv_usec * 1000; /* микросекунды в наносекунды */
/* добавить величину тайм-аута */
tsp->tv_sec += minutes * 60;

Если тайм-аут истечет до появления ожидаемого события, функция pthread_
cont_timedwait запрет мьютекс и  вернет код ошибки ETIMEDOUT. Когда функция
pthread_cont_wait или pthread_cont_timedwait завершится успехом, поток должен оценить значение переменной, поскольку к этому моменту другой поток мог
изменить его.
Для передачи сообщения о  наступлении события существуют две функции.
Функция pthread_cond_signal возобновит работу одного потока, ожидающего
наступления события, а  pthread_cond_broadcast — всех потоков, ожидающих наступления события.
Для упрощения реализации cтандарт POSIX допускает, чтобы функция pthread_cond_
signal возобновляла работу нескольких потоков.
#include <pthread.h>
int pthread_cond_signal(pthread_cond_t *cond);
int pthread_cond_broadcast(pthread_cond_t *cond);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи

488    Глава 11. Потоки
Когда вызывается функция pthread_cond_signal, говорят, что посылается сигнал
о наступлении события. Мы должны сделать все возможное, чтобы сигнал о наступлении события посылался только после изменения состояния переменной.

Пример
В листинге 11.10 приводится пример синхронизации потоков с  помощью переменных состояния и мьютексов.
Листинг 11.10. Пример использования переменных состояния
#include <pthread.h>
struct msg {
struct msg *m_next;
/* ... другие поля структуры ... */
};
struct msg *workq;
pthread_cond_t qready = PTHREAD_COND_INITIALIZER;
pthread_mutex_t qlock = PTHREAD_MUTEX_INITIALIZER;
void
process_msg(void)
{
struct msg *mp;

}

for (;;) {
pthread_mutex_lock(&qlock);
while (workq == NULL)
pthread_cond_wait(&qready, &qlock);
mp = workq;
workq = mp->m_next;
pthread_mutex_unlock(&qlock);
/* обработка сообщения mp */
}

void
enqueue_msg(struct msg *mp)
{
pthread_mutex_lock(&qlock);
mp->m_next = workq;
workq = mp;
pthread_mutex_unlock(&qlock);
pthread_cond_signal(&qready);
}

В данном случае переменная хранит состояние очереди сообщений. Переменная
состояния защищена мьютексом, а  определение изменения состояния производится в  цикле while. Чтобы поместить очередное сообщение в  очередь, необходимо запереть мьютекс, но чтобы послать сигнал ожидающим потокам, запирать
мьютекс не нужно. Такой вариант, когда сигнал посылается после отпирания мьютекса, будет прекрасно работать, даже если какой-либо поток успеет возобновить
работу до передачи сигнала. Поскольку наступление события проверяется в ци-

11.6. Синхронизация потоков   

489

кле, это не представляет проблемы: поток просто возобновит работу, убедится, что
очередь пуста, и опять перейдет в режим ожидания. Если логика программы не допускает подобной гонки, тогда необходимо сначала вызвать pthread_cond_signal,
а затем отпереть мьютекс.

11.6.7. Циклические блокировки
Циклическая блокировка (spin lock) подобна мьютексу, но блокируемый процесс не приостанавливается, а вращается (spinning) в цикле ожидания, пока не
приобретет блокировку. Циклическую блокировку можно использовать в ситуациях, когда блокировка нужна на очень короткий промежуток времени, а  накладные расходы на перепланирование потока выполнения выглядят непомерно
большими.
Циклические блокировки часто используются как низкоуровневые примитивы
для реализации блокировок других типов. В зависимости от архитектуры системы они могут быть реализованы с использованием инструкций «проверил и установил». Несмотря на высокую эффективность, они могут приводить к напрасной
трате вычислительных ресурсов: пока поток вращается в цикле, ожидая, процессор не может заняться чем-то другим. Именно поэтому циклические блокировки
должны приобретаться на очень короткие промежутки времени.
Циклические блокировки особенно полезны при использовании невытесняемого
ядра (nonpreemptive kernel): помимо поддержки механизма взаимоисключения
(mutual exclusion), они блокируют прерывания, поэтому исключается вероятность тупиковой ситуации, когда обработчик прерывания может попытаться приобрести уже запертую циклическую блокировку (прерывания в данном контексте
можно рассматривать как одну из разновидностей вытеснения). В  ядрах этого
типа обработчики прерываний не могут приостанавливаться, поэтому единственные примитивы синхронизации, которые они могут использовать, — это циклические блокировки.
Однако на уровне пользовательского приложения циклические блокировки не
так полезны, если только приложение не выполняется с  классом планирования
в  режиме реального времени, не допускающим вытеснения. Пользовательские
потоки, выполняющиеся с классом планирования в режиме разделения времени,
могут вытесняться после исчерпания выделенного кванта времени или при появлении готового к выполнению потока с более высоким приоритетом. В этих случаях поток, приобретший циклическую блокировку, будет приостановлен и другие
потоки, заблокированные на блокировке, продолжат вращаться в цикле ожидания
дольше, чем предполагалось.
Многие реализации мьютексов настолько эффективны, что производительность
приложений с  использованием мьютексов не уступает производительности тех
же приложений с циклическими блокировками. На практике некоторые реализации мьютексов вращаются ограниченное время в цикле ожидания, пытаясь приобрести мьютекс, и только когда счетчик циклов ожидания превысит пороговое
значение, приостанавливают поток. Такой подход в сочетании с возможностями
современных процессоров, позволяющими переключать контекст выполнения

490    Глава 11. Потоки
все быстрее и быстрее, делают циклические блокировки пригодными лишь в редких ситуациях.
Интерфейс циклических блокировок похож на интерфейс мьютексов, что позволяет легко заменять одни другими. Инициализация циклической блокировки
выполняется вызовом функции pthread_spin_init. Чтобы уничтожить циклическую блокировку, следует вызвать функцию pthread_spin_destroy.
#include <pthread.h>
int pthread_spin_init(pthread_spinlock_t *lock, int pshared);
int pthread_spin_destroy(pthread_spinlock_t *lock);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
При инициализации циклической блокировки можно указать лишь один атрибут,
который имеет смысл, только если платформа поддерживает расширение Thread
Process-Shared Synchronization (Синхронизация потоков между процессами,
в настоящее время это расширение перенесено в разряд базовых спецификаций
Single UNIX Specification; см. табл. 2.5). В аргументе pshared передается признак
совместного использования блокировки несколькими процессами (process-shared),
определяющий ее доступность. Если в  нем передать значение PTHREAD_PROCESS_
SHARED, циклическая блокировка будет доступна потокам выполнения, имеющим
доступ к памяти, где хранится блокировка, — даже потокам в других процессах.
Иначе аргумент pshared следует устанавливать в  значение PTHREAD_PROCESS_
PRIVATE, и в этом случае циклическая блокировка будет доступна только потокам
процесса, инициализировавшего ее.
Запереть циклическую блокировку можно с помощью pthread_spin_lock, которая
будет крутиться в цикле ожидания, пока не приобретет блокировку, или pthread_
spin_trylock, которая вернет код ошибки EBUSY, если блокировку нельзя приобрести немедленно. Обратите внимание, что pthread_spin_trylock не выполняет
цикл ожидания. Независимо от способа, каким была заперта блокировка, ее можно освободить вызовом pthread_spin_unlock.
#include <pthread.h>
int pthread_spin_lock(pthread_spinlock_t *lock);
int pthread_spin_trylock(pthread_spinlock_t *lock);
int pthread_spin_unlock(pthread_spinlock_t *lock);

Все возвращают 0 в случае успеха, код ошибки — в случае неудачи
Обратите внимание: если циклическая блокировка свободна, функция pthread_
spin_lock может запереть ее, не выполняя цикл ожидания. Стандарты не определяют, что должна делать реализация, если поток попытается приобрести блокировку, которой он уже владеет. В этом случае вызов pthread_spin_lock может

11.6. Синхронизация потоков   

491

вернуть код ошибки EDEADLK (или какой-то другой) или попасть в  бесконечный
цикл ожидания. Поведение зависит от реализации. Также стандарты не определяют, что должна делать реализация, если поток попытается освободить незапертую
блокировку.
Если pthread_spin_lock или pthread_spin_trylock вернула 0, следовательно,
циклическая блокировка была успешно заперта. Необходимо проявлять особую
осторожность, чтобы не вызвать какую-нибудь функцию, которая может приостановить поток, пока он удерживает циклическую блокировку. Иначе мы впустую
будем тратить процессорное время, увеличивая продолжительность времени, которое другие потоки потратят при попытке приобретения этой циклической блокировки.

11.6.8. Барьеры
Барьеры (barriers) — это механизм синхронизации, который можно использовать
для координации действий нескольких потоков, выполняющихся одновременно.
Барьер позволяет каждому потоку дождаться момента, когда все сотрудничающие
с ним потоки достигнут той же точки, и продолжить работу. Мы уже познакомились с  одной из разновидностей барьеров  — функцией pthread_join, действующей как барьер, позволяя одному потоку дождаться завершения другого.
Однако объекты барьеров более универсальны, чем эта функция. Они дают возможность любому количеству потоков дождаться, пока все потоки завершат обработку, но при этом потоки не обязаны завершаться. Они могут продолжить работу,
когда все потоки достигнут барьера.
Инициализировать барьер можно с  помощью функции pthread_barrier_init,
а уничтожить — с помощью функции pthread_barrier_destroy.
#include <pthread.h>
int pthread_barrier_init(pthread_barrier_t *restrict barrier,
const pthread_barrierattr_t *restrict attr,
unsigned int count);
int pthread_barrier_destroy(pthread_barrier_t *barrier);

Обе возвращают 0 в случае успеха, код ошибки — в случае неудачи
При инициализации барьера в  аргументе count передается количество потоков,
которые должны достигнуть барьера, прежде чем всем потокам будет позволено
продолжить работу. В аргументе attr передаются атрибуты объекта барьера, с которыми мы познакомимся в следующей главе. А пока достаточно знать, что если
передать в аргументе attr пустой указатель (NULL), барьер будет инициализирован
значениями атрибутов по умолчанию. Если функция pthread_barrier_init выделяет какие-либо ресурсы для барьера, эти ресурсы будут освобождены функцией
pthread_barrier_destroy.
Чтобы показать, что поток выполнил свое задание и готов ждать, когда другие потоки достигнут барьера, он должен вызвать функцию pthread_barrier_wait.

492    Глава 11. Потоки

#include <pthread.h>
int pthread_barrier_wait(pthread_barrier_t *barrier);

Возвращает 0 или PTHREAD_BARRIER_SERIAL_THREAD в случае
успеха, код ошибки — в случае неудачи
Поток, вызвавший pthread_barrier_wait, приостанавливается, если количество
ожидающих потоков не сравнялось со счетчиком барьера (устанавливается вызовом функции pthread_barrier_init). Если поток оказался последним достигшим барьера, вызов pthread_barrier_wait возобновит работу всех ожидающих
потоков.
В одном потоке (выбранном произвольно) pthread_barrier_wait вернет значение
PTHREAD_BARRIER_SERIAL_THREAD. В остальных она вернет 0. Это дает возможность
одному из потоков взять на себя руководящие функции и  заняться обработкой
результатов, произведенных всеми другими потоками.
Как только количество потоков достигнет счетчика в объекте барьера и все ожидающие потоки разблокируются, барьер можно использовать повторно. Однако
изменить счетчик барьера нельзя иначе, как вызвав функцию pthread_barrier_
destroy и за ней функцию pthread_barrier_init с другим значением счетчика.

Пример
Листинг 11.11 демонстрирует, как можно использовать барьер для синхронизации потоков, сотрудничающих над решением общей задачи.
Листинг 11.11. Использование барьера
#include
#include
#include
#include

"apue.h"
<pthread.h>
<limits.h>
<sys/time.h>

#define NTHR 8
/* количество потоков */
#define NUMNUM 8000000L
/* количество чисел для сортировки */
#define TNUM (NUMNUM/NTHR) /* количество чисел для одного потока */
long nums[NUMNUM];
long snums[NUMNUM];
pthread_barrier_t b;
#ifdef SOLARIS
#define heapsort qsort
#else
extern int heapsort(void *, size_t, size_t,
int (*)(const void *, const void *));
#endif
/*
* Сравнивает два длинных целых (вспомогательная функция для heapsort)
*/
int

11.6. Синхронизация потоков   

complong(const void *arg1, const void *arg2)
{
long l1 = *(long *)arg1;
long l2 = *(long *)arg2;
if (l1 == l2)
return 0;
else if (l1 < l2)
return -1;
else
return 1;
}
/*
* Рабочий поток, сортирующий фрагмент массива чисел.
*/
void *
thr_fn(void *arg)
{
long
idx = (long)arg;
heapsort(&nums[idx], TNUM, sizeof(long), complong);
pthread_barrier_wait(&b);

}

/*
* Выполнить дополнительные операции при необходимости ...
*/
return((void *)0);

/*
* Выполняет слияние результатов сортировки фрагментов.
*/
void
merge()
{
long
idx[NTHR];
long
i, minidx, sidx, num;

}

for (i = 0; i < NTHR; i++)
idx[i] = i * TNUM;
for (sidx = 0; sidx < NUMNUM; sidx++) {
num = LONG_MAX;
for (i = 0; i < NTHR; i++) {
if ((idx[i] < (i+1)*TNUM) && (nums[idx[i]] < num)) {
num = nums[idx[i]];
minidx = i;
}
}
snums[sidx] = nums[idx[minidx]];
idx[minidx]++;
}

int
main()
{
unsigned long
struct timeval
long long

i;
start, end;
startusec, endusec;

493

494    Глава 11. Потоки
double
int
pthread_t

elapsed;
err;
tid;

/*
* Создать начальный массив чисел для сортировки.
*/
srandom(1);
for (i = 0; i < NUMNUM; i++)
nums[i] = random();
/*
* Запустить 8 потоков для сортировки массива.
*/
gettimeofday(&start, NULL);
pthread_barrier_init(&b, NULL, NTHR+1);
for (i = 0; i < NTHR; i++) {
err = pthread_create(&tid, NULL, thr_fn, (void *)(i * TNUM));
if